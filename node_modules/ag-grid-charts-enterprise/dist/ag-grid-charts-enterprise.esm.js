/**
 * ag-grid-enterprise - AG Grid Enterprise Features * @version v31.1.1
 * @link https://www.ag-grid.com/
' * @license Commercial
 */

import { BeanStub, PreConstruct, Bean, Autowired, RefSelector, PostConstruct, Component, ModuleNames, Events, _, KeyCode, AgRichSelect, VirtualListDragFeature, DragSourceType, AgInputDateField, AgInputNumberField, AgInputTextField, TabGuardComp, TooltipFeature, DragAndDropService, VirtualList, AgDialog, AgAutocomplete, AutoScrollService, AgGroupComponent, AgCheckbox, AgRadioButton, AgToggleButton, AgSelect, AgAbstractLabel, AgSlider, AgPickerField, DEFAULT_CHART_GROUPS, TabbedLayout, AgPromise, CHART_TOOLBAR_ALLOW_LIST, CHART_TOOL_PANEL_ALLOW_LIST, CHART_TOOL_PANEL_MENU_OPTIONS, AgPanel, Optional, ModuleRegistry, CellRangeType, GROUP_AUTO_COLUMN_ID, PreDestroy, CellCtrl, SelectionHandleType, GroupInstanceIdCreator, ColumnGroup, ChangedPath, EventService, Column, ProvidedColumnGroup, AgMenuList, AgMenuItemComponent, CssClassApplier, TouchListener, RowNode, ManagedFocusFeature, PositionableFeature, ExcelFactoryMode, createGrid, ColumnApi, ProvidedFilter, AgMenuItemRenderer, PopupComponent, RowNodeBlock, NumberSequence, ServerSideTransactionResultStatus, RowNodeBlockLoader, ExpansionService, TextFilter } from 'ag-grid-community';
export { AbstractHeaderCellCtrl, AgAbstractField, AgAbstractLabel, AgAutocomplete, AgCheckbox, AgDialog, AgGroupComponent, AgInputDateField, AgInputNumberField, AgInputRange, AgInputTextArea, AgInputTextField, AgMenuItemComponent, AgMenuItemRenderer, AgMenuList, AgMenuPanel, AgPanel, AgPickerField, AgRadioButton, AgRichSelect, AgSelect, AgSlider, AgStackComponentsRegistry, AgToggleButton, AlignedGridsService, AnimateShowChangeCellRenderer, AnimateSlideCellRenderer, AnimationFrameService, AutoScrollService, AutoWidthCalculator, Autowired, BaseComponentWrapper, BaseCreator, BaseGridSerializingSession, Bean, BeanStub, Beans, BodyDropPivotTarget, BodyDropTarget, CellComp, CellCtrl, CellNavigationService, CellPositionUtils, CellRangeType, ChangedPath, CheckboxCellEditor, CheckboxCellRenderer, CheckboxSelectionComponent, ClientSideRowModelSteps, ColDefUtil, Column, ColumnApi, ColumnFactory, ColumnGroup, ColumnKeyCreator, ColumnModel, ColumnUtils, Component, ComponentUtil, Context, CssClassApplier, CssClassManager, CsvCreator, CsvExportModule, CtrlsService, CustomTooltipFeature, DataTypeService, DateCellEditor, DateFilter, DateStringCellEditor, DisplayedGroupCreator, Downloader, DragAndDropService, DragService, DragSourceType, Environment, EventService, Events, ExcelFactoryMode, ExpansionService, ExpressionService, FilterManager, FloatingFilterMapper, FocusService, GROUP_AUTO_COLUMN_ID, Grid, GridApi, GridBodyComp, GridBodyCtrl, GridComp, GridCoreCreator, GridCtrl, GridHeaderComp, GridHeaderCtrl, GridOptionsService, GridSerializer, GroupCellRenderer, GroupCellRendererCtrl, GroupInstanceIdCreator, HeaderCellCtrl, HeaderFilterCellComp, HeaderFilterCellCtrl, HeaderGroupCellCtrl, HeaderNavigationDirection, HeaderNavigationService, HeaderPositionUtils, HeaderRowComp, HeaderRowContainerComp, HeaderRowContainerCtrl, HeaderRowCtrl, HeaderRowType, HorizontalDirection, HorizontalResizeService, KeyCode, LargeTextCellEditor, LayoutCssClasses, LocaleService, Logger, LoggerFactory, ManagedFocusFeature, MenuService, ModuleNames, ModuleRegistry, MouseEventService, MoveColumnFeature, NavigationService, NumberCellEditor, NumberFilter, Optional, PaginationProxy, PinnedRowModel, PopupComponent, PopupEditorWrapper, PopupService, PositionableFeature, PostConstruct, PreConstruct, PreDestroy, PropertyKeys, ProvidedColumnGroup, ProvidedFilter, Qualifier, QuerySelector, RefSelector, ResizeObserverService, RowAnimationCssClasses, RowContainerComp, RowContainerCtrl, RowContainerName, RowContainerType, RowCtrl, RowHighlightPosition, RowNode, RowNodeBlock, RowNodeBlockLoader, RowNodeSorter, RowPositionUtils, RowRenderer, RowType, ScalarFilter, ScrollVisibleService, SelectCellEditor, SelectableService, SelectionHandleType, ServerSideTransactionResultStatus, SetLeftFeature, SimpleFilter, SortController, SortIndicatorComp, StandardMenuFactory, StylingService, TabGuardClassNames, TabGuardComp, TabGuardCtrl, TabbedLayout, TemplateService, TextCellEditor, TextFilter, TextFloatingFilter, TooltipFeature, TouchListener, UserComponentFactory, UserComponentRegistry, ValueCache, ValueFormatterService, ValueParserService, ValueService, VanillaFrameworkOverrides, VerticalDirection, VirtualList, VirtualListDragFeature, XmlFactory, ZipContainer, createGrid, getRowContainerTypeForName } from 'ag-grid-community';

class MD5 {
    constructor() {
        this.ieCompatibility = false;
    }
    init() {
        this.ieCompatibility = (this.md5('hello') != '5d41402abc4b2a76b9719d911017c592');
    }
    md5cycle(x, k) {
        let a = x[0], b = x[1], c = x[2], d = x[3];
        a = this.ff(a, b, c, d, k[0], 7, -680876936);
        d = this.ff(d, a, b, c, k[1], 12, -389564586);
        c = this.ff(c, d, a, b, k[2], 17, 606105819);
        b = this.ff(b, c, d, a, k[3], 22, -1044525330);
        a = this.ff(a, b, c, d, k[4], 7, -176418897);
        d = this.ff(d, a, b, c, k[5], 12, 1200080426);
        c = this.ff(c, d, a, b, k[6], 17, -1473231341);
        b = this.ff(b, c, d, a, k[7], 22, -45705983);
        a = this.ff(a, b, c, d, k[8], 7, 1770035416);
        d = this.ff(d, a, b, c, k[9], 12, -1958414417);
        c = this.ff(c, d, a, b, k[10], 17, -42063);
        b = this.ff(b, c, d, a, k[11], 22, -1990404162);
        a = this.ff(a, b, c, d, k[12], 7, 1804603682);
        d = this.ff(d, a, b, c, k[13], 12, -40341101);
        c = this.ff(c, d, a, b, k[14], 17, -1502002290);
        b = this.ff(b, c, d, a, k[15], 22, 1236535329);
        a = this.gg(a, b, c, d, k[1], 5, -165796510);
        d = this.gg(d, a, b, c, k[6], 9, -1069501632);
        c = this.gg(c, d, a, b, k[11], 14, 643717713);
        b = this.gg(b, c, d, a, k[0], 20, -373897302);
        a = this.gg(a, b, c, d, k[5], 5, -701558691);
        d = this.gg(d, a, b, c, k[10], 9, 38016083);
        c = this.gg(c, d, a, b, k[15], 14, -660478335);
        b = this.gg(b, c, d, a, k[4], 20, -405537848);
        a = this.gg(a, b, c, d, k[9], 5, 568446438);
        d = this.gg(d, a, b, c, k[14], 9, -1019803690);
        c = this.gg(c, d, a, b, k[3], 14, -187363961);
        b = this.gg(b, c, d, a, k[8], 20, 1163531501);
        a = this.gg(a, b, c, d, k[13], 5, -1444681467);
        d = this.gg(d, a, b, c, k[2], 9, -51403784);
        c = this.gg(c, d, a, b, k[7], 14, 1735328473);
        b = this.gg(b, c, d, a, k[12], 20, -1926607734);
        a = this.hh(a, b, c, d, k[5], 4, -378558);
        d = this.hh(d, a, b, c, k[8], 11, -2022574463);
        c = this.hh(c, d, a, b, k[11], 16, 1839030562);
        b = this.hh(b, c, d, a, k[14], 23, -35309556);
        a = this.hh(a, b, c, d, k[1], 4, -1530992060);
        d = this.hh(d, a, b, c, k[4], 11, 1272893353);
        c = this.hh(c, d, a, b, k[7], 16, -155497632);
        b = this.hh(b, c, d, a, k[10], 23, -1094730640);
        a = this.hh(a, b, c, d, k[13], 4, 681279174);
        d = this.hh(d, a, b, c, k[0], 11, -358537222);
        c = this.hh(c, d, a, b, k[3], 16, -722521979);
        b = this.hh(b, c, d, a, k[6], 23, 76029189);
        a = this.hh(a, b, c, d, k[9], 4, -640364487);
        d = this.hh(d, a, b, c, k[12], 11, -421815835);
        c = this.hh(c, d, a, b, k[15], 16, 530742520);
        b = this.hh(b, c, d, a, k[2], 23, -995338651);
        a = this.ii(a, b, c, d, k[0], 6, -198630844);
        d = this.ii(d, a, b, c, k[7], 10, 1126891415);
        c = this.ii(c, d, a, b, k[14], 15, -1416354905);
        b = this.ii(b, c, d, a, k[5], 21, -57434055);
        a = this.ii(a, b, c, d, k[12], 6, 1700485571);
        d = this.ii(d, a, b, c, k[3], 10, -1894986606);
        c = this.ii(c, d, a, b, k[10], 15, -1051523);
        b = this.ii(b, c, d, a, k[1], 21, -2054922799);
        a = this.ii(a, b, c, d, k[8], 6, 1873313359);
        d = this.ii(d, a, b, c, k[15], 10, -30611744);
        c = this.ii(c, d, a, b, k[6], 15, -1560198380);
        b = this.ii(b, c, d, a, k[13], 21, 1309151649);
        a = this.ii(a, b, c, d, k[4], 6, -145523070);
        d = this.ii(d, a, b, c, k[11], 10, -1120210379);
        c = this.ii(c, d, a, b, k[2], 15, 718787259);
        b = this.ii(b, c, d, a, k[9], 21, -343485551);
        x[0] = this.add32(a, x[0]);
        x[1] = this.add32(b, x[1]);
        x[2] = this.add32(c, x[2]);
        x[3] = this.add32(d, x[3]);
    }
    cmn(q, a, b, x, s, t) {
        a = this.add32(this.add32(a, q), this.add32(x, t));
        return this.add32((a << s) | (a >>> (32 - s)), b);
    }
    ff(a, b, c, d, x, s, t) {
        return this.cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    gg(a, b, c, d, x, s, t) {
        return this.cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    hh(a, b, c, d, x, s, t) {
        return this.cmn(b ^ c ^ d, a, b, x, s, t);
    }
    ii(a, b, c, d, x, s, t) {
        return this.cmn(c ^ (b | (~d)), a, b, x, s, t);
    }
    md51(s) {
        const n = s.length;
        const state = [1732584193, -271733879, -1732584194, 271733878];
        let i;
        for (i = 64; i <= s.length; i += 64) {
            this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < s.length; i++) {
            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
        }
        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
        if (i > 55) {
            this.md5cycle(state, tail);
            for (i = 0; i < 16; i++) {
                tail[i] = 0;
            }
        }
        tail[14] = n * 8;
        this.md5cycle(state, tail);
        return state;
    }
    /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
     * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
     * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
     * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
     * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
     * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
     * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
     */
    md5blk(s) {
        const md5blks = [];
        /* Andy King said do it this way. */
        for (let i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s.charCodeAt(i)
                + (s.charCodeAt(i + 1) << 8)
                + (s.charCodeAt(i + 2) << 16)
                + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
    }
    rhex(n) {
        const hex_chr = '0123456789abcdef'.split('');
        let s = '', j = 0;
        for (; j < 4; j++) {
            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F]
                + hex_chr[(n >> (j * 8)) & 0x0F];
        }
        return s;
    }
    hex(x) {
        for (let i = 0; i < x.length; i++) {
            x[i] = this.rhex(x[i]);
        }
        return x.join('');
    }
    md5(s) {
        return this.hex(this.md51(s));
    }
    add32(a, b) {
        return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);
    }
    /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
     need the idiotic second function, generated by an if clause.  */
    add32Std(a, b) {
        return (a + b) & 0xFFFFFFFF;
    }
    add32Compat(x, y) {
        const lsw = (x & 0xFFFF) + (y & 0xFFFF), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }
}

// move to general utils
function missingOrEmpty(value) {
    return value == null || value.length === 0;
}
const LICENSE_TYPES = {
    '01': 'GRID',
    '02': 'CHARTS',
    '0102': 'BOTH'
};
class LicenseManager {
    constructor(document) {
        this.watermarkMessage = undefined;
        this.totalMessageLength = 124;
        this.document = document;
        this.md5 = new MD5();
        this.md5.init();
    }
    validateLicense() {
        const licenseDetails = this.getLicenseDetails(LicenseManager.licenseKey);
        const currentLicenseName = `AG Grid ${licenseDetails.currentLicenseType === 'BOTH' ? 'and AG Charts ' : ''}Enterprise`;
        const suppliedLicenseName = licenseDetails.suppliedLicenseType === undefined ? '' : `AG ${licenseDetails.suppliedLicenseType === 'BOTH' ? 'Grid and AG Charts' : licenseDetails.suppliedLicenseType === 'GRID' ? 'Grid' : 'Charts'} Enterprise`;
        if (licenseDetails.missing) {
            if (!this.isWebsiteUrl() || this.isForceWatermark()) {
                this.outputMissingLicenseKey(currentLicenseName);
            }
        }
        else if (licenseDetails.expired) {
            const gridReleaseDate = LicenseManager.getGridReleaseDate();
            const formattedReleaseDate = LicenseManager.formatDate(gridReleaseDate);
            this.outputExpiredKey(licenseDetails.expiry, formattedReleaseDate, currentLicenseName, suppliedLicenseName);
        }
        else if (!licenseDetails.valid) {
            this.outputInvalidLicenseKey(!!licenseDetails.incorrectLicenseType, currentLicenseName, suppliedLicenseName);
        }
        else if (licenseDetails.isTrial && licenseDetails.trialExpired) {
            this.outputExpiredTrialKey(licenseDetails.expiry, currentLicenseName, suppliedLicenseName);
        }
    }
    static extractExpiry(license) {
        const restrictionHashed = license.substring(license.lastIndexOf('_') + 1, license.length);
        return new Date(parseInt(LicenseManager.decode(restrictionHashed), 10));
    }
    static extractLicenseComponents(licenseKey) {
        // when users copy the license key from a PDF extra zero width characters are sometimes copied too
        // carriage returns and line feeds are problematic too
        // all of which causes license key validation to fail - strip these out
        let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, '');
        cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, '');
        // the hash that follows the key is 32 chars long
        if (licenseKey.length <= 32) {
            return { md5: null, license: licenseKey, version: null, isTrial: null };
        }
        const hashStart = cleanedLicenseKey.length - 32;
        const md5 = cleanedLicenseKey.substring(hashStart);
        const license = cleanedLicenseKey.substring(0, hashStart);
        const [version, isTrial, type] = LicenseManager.extractBracketedInformation(cleanedLicenseKey);
        return { md5, license, version, isTrial, type };
    }
    getLicenseDetails(licenseKey) {
        const currentLicenseType = LicenseManager.chartsLicenseManager ? 'BOTH' : 'GRID';
        if (missingOrEmpty(licenseKey)) {
            return {
                licenseKey,
                valid: false,
                missing: true,
                currentLicenseType
            };
        }
        const gridReleaseDate = LicenseManager.getGridReleaseDate();
        const { md5, license, version, isTrial, type } = LicenseManager.extractLicenseComponents(licenseKey);
        let valid = (md5 === this.md5.md5(license)) && licenseKey.indexOf("For_Trialing_ag-Grid_Only") === -1;
        let trialExpired = undefined;
        let expired = undefined;
        let expiry = null;
        let incorrectLicenseType = false;
        let suppliedLicenseType = undefined;
        function handleTrial() {
            const now = new Date();
            trialExpired = (expiry < now);
            expired = undefined;
        }
        if (valid) {
            expiry = LicenseManager.extractExpiry(license);
            valid = !isNaN(expiry.getTime());
            if (valid) {
                expired = (gridReleaseDate > expiry);
                switch (version) {
                    case "legacy":
                    case "2": {
                        if (isTrial) {
                            handleTrial();
                        }
                        break;
                    }
                    case "3": {
                        if (missingOrEmpty(type)) {
                            valid = false;
                        }
                        else {
                            suppliedLicenseType = type;
                            if ((type !== LICENSE_TYPES['01'] && type !== LICENSE_TYPES['0102']) ||
                                (currentLicenseType === 'BOTH' && suppliedLicenseType !== 'BOTH')) {
                                valid = false;
                                incorrectLicenseType = true;
                            }
                            else if (isTrial) {
                                handleTrial();
                            }
                        }
                    }
                }
            }
        }
        if (!valid) {
            return {
                licenseKey,
                valid,
                incorrectLicenseType,
                currentLicenseType,
                suppliedLicenseType
            };
        }
        return {
            licenseKey,
            valid,
            expiry: LicenseManager.formatDate(expiry),
            expired,
            version,
            isTrial,
            trialExpired,
            incorrectLicenseType,
            currentLicenseType,
            suppliedLicenseType
        };
    }
    isDisplayWatermark() {
        return this.isForceWatermark() || (!this.isLocalhost() && !this.isWebsiteUrl() && !missingOrEmpty(this.watermarkMessage));
    }
    getWatermarkMessage() {
        return this.watermarkMessage || '';
    }
    getHostname() {
        const win = (this.document.defaultView || window);
        const loc = win.location;
        const { hostname = '' } = loc;
        return hostname;
    }
    isForceWatermark() {
        const win = (this.document.defaultView || window);
        const loc = win.location;
        const { pathname } = loc;
        return pathname ? pathname.indexOf('forceWatermark') !== -1 : false;
    }
    isWebsiteUrl() {
        const hostname = this.getHostname();
        return hostname.match(/^((?:\w+\.)?ag-grid\.com)$/) !== null;
    }
    isLocalhost() {
        const hostname = this.getHostname();
        return hostname.match(/^(?:127\.0\.0\.1|localhost)$/) !== null;
    }
    static formatDate(date) {
        const monthNames = [
            'January', 'February', 'March',
            'April', 'May', 'June', 'July',
            'August', 'September', 'October',
            'November', 'December'
        ];
        const day = date.getDate();
        const monthIndex = date.getMonth();
        const year = date.getFullYear();
        return day + ' ' + monthNames[monthIndex] + ' ' + year;
    }
    static getGridReleaseDate() {
        return new Date(parseInt(LicenseManager.decode(LicenseManager.RELEASE_INFORMATION), 10));
    }
    static decode(input) {
        const keystr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let t = '';
        let n, r, i;
        let s, o, u, a;
        let f = 0;
        const e = input.replace(/[^A-Za-z0-9+/=]/g, '');
        while (f < e.length) {
            s = keystr.indexOf(e.charAt(f++));
            o = keystr.indexOf(e.charAt(f++));
            u = keystr.indexOf(e.charAt(f++));
            a = keystr.indexOf(e.charAt(f++));
            n = s << 2 | o >> 4;
            r = (o & 15) << 4 | u >> 2;
            i = (u & 3) << 6 | a;
            t = t + String.fromCharCode(n);
            if (u != 64) {
                t = t + String.fromCharCode(r);
            }
            if (a != 64) {
                t = t + String.fromCharCode(i);
            }
        }
        t = LicenseManager.utf8_decode(t);
        return t;
    }
    static utf8_decode(input) {
        input = input.replace(/rn/g, 'n');
        let t = '';
        for (let n = 0; n < input.length; n++) {
            const r = input.charCodeAt(n);
            if (r < 128) {
                t += String.fromCharCode(r);
            }
            else if (r > 127 && r < 2048) {
                t += String.fromCharCode(r >> 6 | 192);
                t += String.fromCharCode(r & 63 | 128);
            }
            else {
                t += String.fromCharCode(r >> 12 | 224);
                t += String.fromCharCode(r >> 6 & 63 | 128);
                t += String.fromCharCode(r & 63 | 128);
            }
        }
        return t;
    }
    static setChartsLicenseManager(dependantLicenseManager) {
        this.chartsLicenseManager = dependantLicenseManager;
    }
    static setLicenseKey(licenseKey) {
        this.licenseKey = licenseKey;
        if (this.chartsLicenseManager) {
            this.chartsLicenseManager.setLicenseKey(licenseKey, true);
        }
    }
    static extractBracketedInformation(licenseKey) {
        // legacy no trial key
        if (!licenseKey.includes("[")) {
            return ["legacy", false, undefined];
        }
        const matches = licenseKey.match(/\[(.*?)\]/g).map(match => match.replace("[", "").replace("]", ""));
        if (!matches || matches.length === 0) {
            return ["legacy", false, undefined];
        }
        const isTrial = matches.filter(match => match === 'TRIAL').length === 1;
        const rawVersion = matches.filter(match => match.indexOf("v") === 0)[0];
        const version = rawVersion ? rawVersion.replace('v', '') : 'legacy';
        const type = LICENSE_TYPES[matches.filter(match => LICENSE_TYPES[match])[0]];
        return [version, isTrial, type];
    }
    centerPadAndOutput(input) {
        const paddingRequired = this.totalMessageLength - input.length;
        console.error(input.padStart(paddingRequired / 2 + input.length, '*').padEnd(this.totalMessageLength, '*'));
    }
    padAndOutput(input, padding = '*', terminateWithPadding = '') {
        console.error(input.padEnd(this.totalMessageLength - terminateWithPadding.length, padding) + terminateWithPadding);
    }
    outputInvalidLicenseKey(incorrectLicenseType, currentLicenseName, suppliedLicenseName) {
        if (incorrectLicenseType) {
            // TC4, TC5,TC10
            this.centerPadAndOutput('');
            this.centerPadAndOutput(` ${currentLicenseName} License `);
            this.centerPadAndOutput(' Incompatible License Key ');
            this.padAndOutput(`* Your license key is for ${suppliedLicenseName} only and does not cover you for ${currentLicenseName}.`, ' ', '*');
            this.padAndOutput('* Please contact info@ag-grid.com to obtain a combined license key.', ' ', '*');
            this.centerPadAndOutput('');
            this.centerPadAndOutput('');
        }
        else {
            // TC3, TC9
            this.centerPadAndOutput('');
            this.centerPadAndOutput(` ${currentLicenseName} License `);
            this.centerPadAndOutput(' Invalid License Key ');
            this.padAndOutput(`* Your license key is not valid - please contact info@ag-grid.com to obtain a valid license.`, ' ', '*');
            this.centerPadAndOutput('');
            this.centerPadAndOutput('');
        }
        this.watermarkMessage = "Invalid License";
    }
    outputExpiredTrialKey(formattedExpiryDate, currentLicenseName, suppliedLicenseName) {
        // TC14
        this.centerPadAndOutput('');
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(' Trial Period Expired. ');
        this.padAndOutput(`* Your trial only license for ${suppliedLicenseName} expired on ${formattedExpiryDate}.`, ' ', '*');
        this.padAndOutput('* Please email info@ag-grid.com to purchase a license.', ' ', '*');
        this.centerPadAndOutput('');
        this.centerPadAndOutput('');
        this.watermarkMessage = "Trial Period Expired";
    }
    outputMissingLicenseKey(currentLicenseName) {
        // TC6, TC12
        this.centerPadAndOutput('');
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(' License Key Not Found ');
        this.padAndOutput(`* All ${currentLicenseName} features are unlocked for trial.`, ' ', '*');
        this.padAndOutput('* If you want to hide the watermark please email info@ag-grid.com for a trial license key.', ' ', '*');
        this.centerPadAndOutput('');
        this.centerPadAndOutput('');
        this.watermarkMessage = "For Trial Use Only";
    }
    outputExpiredKey(formattedExpiryDate, formattedReleaseDate, currentLicenseName, suppliedLicenseName) {
        // TC2
        this.centerPadAndOutput('');
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(' Incompatible Software Version ');
        this.padAndOutput(`* Your license key works with versions of ${suppliedLicenseName} released before ${formattedExpiryDate}.`, ' ', '*');
        this.padAndOutput(`* The version you are trying to use was released on ${formattedReleaseDate}.`, ' ', '*');
        this.padAndOutput('* Please contact info@ag-grid.com to renew your license key.', ' ', '*');
        this.centerPadAndOutput('');
        this.centerPadAndOutput('');
        this.watermarkMessage = "License Expired";
    }
}
LicenseManager.RELEASE_INFORMATION = 'MTcwODI3NzkwNjI5Nw==';

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let GridLicenseManager = class GridLicenseManager extends BeanStub {
    validateLicense() {
        this.licenseManager = new LicenseManager(this.gridOptionsService.getDocument());
        this.licenseManager.validateLicense();
    }
    static getLicenseDetails(licenseKey) {
        return new LicenseManager(null).getLicenseDetails(licenseKey);
    }
    isDisplayWatermark() {
        return this.licenseManager.isDisplayWatermark();
    }
    getWatermarkMessage() {
        return this.licenseManager.getWatermarkMessage();
    }
    static setLicenseKey(licenseKey) {
        LicenseManager.setLicenseKey(licenseKey);
    }
    static setChartsLicenseManager(chartsLicenseManager) {
        LicenseManager.setChartsLicenseManager(chartsLicenseManager);
    }
};
__decorate([
    PreConstruct
], GridLicenseManager.prototype, "validateLicense", null);
GridLicenseManager = __decorate([
    Bean('licenseManager')
], GridLicenseManager);

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class WatermarkComp extends Component {
    constructor() {
        super(/* html*/ `<div class="ag-watermark">
                <div ref="eLicenseTextRef" class="ag-watermark-text"></div>
            </div>`);
    }
    postConstruct() {
        const show = this.shouldDisplayWatermark();
        this.setDisplayed(show);
        if (show) {
            this.eLicenseTextRef.innerText = this.licenseManager.getWatermarkMessage();
            window.setTimeout(() => this.addCssClass('ag-opacity-zero'), 0);
            window.setTimeout(() => this.setDisplayed(false), 5000);
        }
    }
    shouldDisplayWatermark() {
        return this.licenseManager.isDisplayWatermark();
    }
}
__decorate$1([
    Autowired('licenseManager')
], WatermarkComp.prototype, "licenseManager", void 0);
__decorate$1([
    RefSelector('eLicenseTextRef')
], WatermarkComp.prototype, "eLicenseTextRef", void 0);
__decorate$1([
    PostConstruct
], WatermarkComp.prototype, "postConstruct", null);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION = '31.1.1';

const EnterpriseCoreModule = {
    version: VERSION,
    moduleName: ModuleNames.EnterpriseCoreModule,
    beans: [GridLicenseManager],
    agStackComponents: [
        { componentName: 'AgWatermark', componentClass: WatermarkComp }
    ]
};

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AdvancedFilterHeaderComp extends Component {
    constructor(enabled) {
        super(/* html */ `
            <div class="ag-advanced-filter-header" role="row">
            </div>`);
        this.enabled = enabled;
    }
    postConstruct() {
        this.setupAdvancedFilter(this.enabled);
        this.addDestroyFunc(() => this.destroyBean(this.eAdvancedFilter));
        this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, () => this.onGridColumnsChanged());
        this.addGuiEventListener('keydown', (event) => this.onKeyDown(event));
        this.addGuiEventListener('focusout', (event) => {
            if (!this.getFocusableElement().contains(event.relatedTarget)) {
                this.focusService.clearAdvancedFilterColumn();
            }
        });
    }
    getFocusableElement() {
        var _a, _b;
        return (_b = (_a = this.eAdvancedFilter) === null || _a === void 0 ? void 0 : _a.getGui()) !== null && _b !== void 0 ? _b : this.getGui();
    }
    setEnabled(enabled) {
        if (enabled === this.enabled) {
            return;
        }
        this.setupAdvancedFilter(enabled);
    }
    refresh() {
        var _a;
        (_a = this.eAdvancedFilter) === null || _a === void 0 ? void 0 : _a.refresh();
    }
    getHeight() {
        return this.height;
    }
    setInputDisabled(disabled) {
        var _a;
        (_a = this.eAdvancedFilter) === null || _a === void 0 ? void 0 : _a.setInputDisabled(disabled);
    }
    setupAdvancedFilter(enabled) {
        const eGui = this.getGui();
        if (enabled) {
            // unmanaged as can be recreated
            this.eAdvancedFilter = this.createBean(new AdvancedFilterComp());
            const eAdvancedFilterGui = this.eAdvancedFilter.getGui();
            this.eAdvancedFilter.addCssClass('ag-advanced-filter-header-cell');
            this.height = this.columnModel.getFloatingFiltersHeight();
            const height = `${this.height}px`;
            eGui.style.height = height;
            eGui.style.minHeight = height;
            this.setAriaRowIndex();
            _.setAriaRole(eAdvancedFilterGui, 'gridcell');
            _.setAriaColIndex(eAdvancedFilterGui, 1);
            this.setAriaColumnCount(eAdvancedFilterGui);
            eGui.appendChild(eAdvancedFilterGui);
        }
        else {
            _.clearElement(eGui);
            this.destroyBean(this.eAdvancedFilter);
            this.height = 0;
        }
        _.setDisplayed(eGui, enabled);
        this.enabled = enabled;
    }
    setAriaColumnCount(eAdvancedFilterGui) {
        _.setAriaColSpan(eAdvancedFilterGui, this.columnModel.getAllGridColumns().length);
    }
    setAriaRowIndex() {
        _.setAriaRowIndex(this.getGui(), this.headerNavigationService.getHeaderRowCount());
    }
    onGridColumnsChanged() {
        if (!this.eAdvancedFilter) {
            return;
        }
        this.setAriaColumnCount(this.eAdvancedFilter.getGui());
        this.setAriaRowIndex();
    }
    onKeyDown(event) {
        switch (event.key) {
            case KeyCode.ENTER: {
                if (this.hasFocus()) {
                    if (this.focusService.focusInto(this.getFocusableElement())) {
                        event.preventDefault();
                    }
                }
                break;
            }
            case KeyCode.ESCAPE:
                if (!this.hasFocus()) {
                    this.getFocusableElement().focus();
                }
                break;
            case KeyCode.UP:
                this.navigateUpDown(true, event);
                break;
            case KeyCode.DOWN:
                this.navigateUpDown(false, event);
                break;
            case KeyCode.TAB:
                if (this.hasFocus()) {
                    this.navigateLeftRight(event);
                }
                else {
                    const nextFocusableEl = this.focusService.findNextFocusableElement(this.getFocusableElement(), null, event.shiftKey);
                    if (nextFocusableEl) {
                        event.preventDefault();
                        nextFocusableEl.focus();
                    }
                    else {
                        this.navigateLeftRight(event);
                    }
                }
                break;
        }
    }
    navigateUpDown(backwards, event) {
        if (this.hasFocus()) {
            if (this.focusService.focusNextFromAdvancedFilter(backwards)) {
                event.preventDefault();
            }
        }
    }
    navigateLeftRight(event) {
        if (event.shiftKey
            ? this.focusService.focusLastHeader()
            : this.focusService.focusNextFromAdvancedFilter(false, true)) {
            event.preventDefault();
        }
    }
    hasFocus() {
        const eDocument = this.gridOptionsService.getDocument();
        return eDocument.activeElement === this.getFocusableElement();
    }
}
__decorate$2([
    Autowired('columnModel')
], AdvancedFilterHeaderComp.prototype, "columnModel", void 0);
__decorate$2([
    Autowired('focusService')
], AdvancedFilterHeaderComp.prototype, "focusService", void 0);
__decorate$2([
    Autowired('headerNavigationService')
], AdvancedFilterHeaderComp.prototype, "headerNavigationService", void 0);
__decorate$2([
    PostConstruct
], AdvancedFilterHeaderComp.prototype, "postConstruct", null);

class AddDropdownComp extends AgRichSelect {
    constructor(params) {
        super(Object.assign(Object.assign({}, params), { template: /* html */ `
                <div class="ag-picker-field" role="presentation">
                    <div ref="eLabel"></div>
                    <div ref="eWrapper" class="ag-wrapper ag-picker-collapsed">
                        <div ref="eDisplayField" class="ag-picker-field-display"></div>
                        <ag-input-text-field ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
                        <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                    </div>
                </div>` }));
        this.params = params;
    }
    showPicker() {
        // avoid focus handling issues with multiple rich selects
        setTimeout(() => super.showPicker());
    }
    hidePicker() {
        // avoid focus handling issues with multiple rich selects
        setTimeout(() => super.hidePicker());
    }
    postConstruct() {
        super.postConstruct();
        const { wrapperClassName, ariaLabel } = this.params;
        _.setDisplayed(this.eDisplayField, false);
        if (wrapperClassName) {
            this.eWrapper.classList.add(wrapperClassName);
        }
        _.setAriaLabelledBy(this.eWrapper, '');
        _.setAriaLabel(this.eWrapper, ariaLabel);
    }
    onEnterKeyDown(event) {
        _.stopPropagationForAgGrid(event);
        if (this.isPickerDisplayed) {
            super.onEnterKeyDown(event);
        }
        else {
            event.preventDefault();
            this.showPicker();
        }
    }
}

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AdvancedFilterBuilderDragFeature extends BeanStub {
    constructor(comp, virtualList) {
        super();
        this.comp = comp;
        this.virtualList = virtualList;
    }
    postConstruct() {
        this.createManagedBean(new VirtualListDragFeature(this.comp, this.virtualList, {
            dragSourceType: DragSourceType.AdvancedFilterBuilder,
            listItemDragStartEvent: AdvancedFilterBuilderDragFeature.EVENT_DRAG_STARTED,
            listItemDragEndEvent: AdvancedFilterBuilderDragFeature.EVENT_DRAG_ENDED,
            eventSource: this,
            getCurrentDragValue: (listItemDragStartEvent) => this.getCurrentDragValue(listItemDragStartEvent),
            isMoveBlocked: () => false,
            getNumRows: (comp) => comp.getNumItems(),
            moveItem: (currentDragValue, lastHoveredListItem) => this.moveItem(currentDragValue, lastHoveredListItem)
        }));
    }
    getCurrentDragValue(listItemDragStartEvent) {
        return listItemDragStartEvent.item;
    }
    moveItem(currentDragValue, lastHoveredListItem) {
        this.comp.moveItem(currentDragValue, lastHoveredListItem);
    }
}
AdvancedFilterBuilderDragFeature.EVENT_DRAG_STARTED = 'advancedFilterBuilderDragStarted';
AdvancedFilterBuilderDragFeature.EVENT_DRAG_ENDED = 'advancedFilterBuilderDragEnded';
__decorate$3([
    PostConstruct
], AdvancedFilterBuilderDragFeature.prototype, "postConstruct", null);

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AdvancedFilterBuilderItemNavigationFeature extends BeanStub {
    constructor(eGui, focusWrapper, eFocusableComp) {
        super();
        this.eGui = eGui;
        this.focusWrapper = focusWrapper;
        this.eFocusableComp = eFocusableComp;
    }
    postConstruct() {
        this.addManagedListener(this.eGui, 'keydown', (event) => {
            switch (event.key) {
                case KeyCode.TAB:
                    if (!event.defaultPrevented) {
                        // tab guard handled the navigation. stop from reaching virtual list
                        _.stopPropagationForAgGrid(event);
                    }
                    break;
                case KeyCode.UP:
                case KeyCode.DOWN:
                    // if this hasn't been handled by an editor, prevent virtual list navigation
                    _.stopPropagationForAgGrid(event);
                    break;
                case KeyCode.ESCAPE:
                    if (_.isStopPropagationForAgGrid(event)) {
                        return;
                    }
                    const eDocument = this.gridOptionsService.getDocument();
                    if (this.eGui.contains(eDocument.activeElement)) {
                        event.preventDefault();
                        _.stopPropagationForAgGrid(event);
                        this.focusWrapper.focus();
                    }
                    break;
            }
        });
        this.addManagedListener(this.focusWrapper, 'keydown', (event) => {
            switch (event.key) {
                case KeyCode.ENTER:
                    if (_.isStopPropagationForAgGrid(event)) {
                        return;
                    }
                    const eDocument = this.gridOptionsService.getDocument();
                    if (eDocument.activeElement === this.focusWrapper) {
                        event.preventDefault();
                        _.stopPropagationForAgGrid(event);
                        this.eFocusableComp.getFocusableElement().focus();
                    }
                    break;
            }
        });
        this.addManagedListener(this.focusWrapper, 'focusin', () => {
            this.focusWrapper.classList.add('ag-advanced-filter-builder-virtual-list-item-highlight');
        });
        this.addManagedListener(this.focusWrapper, 'focusout', (event) => {
            if (!this.focusWrapper.contains(event.relatedTarget)) {
                this.focusWrapper.classList.remove('ag-advanced-filter-builder-virtual-list-item-highlight');
            }
        });
    }
}
__decorate$4([
    PostConstruct
], AdvancedFilterBuilderItemNavigationFeature.prototype, "postConstruct", null);

function getAdvancedFilterBuilderAddButtonParams(translate, maxPickerWidth) {
    return {
        pickerAriaLabelKey: 'ariaLabelAdvancedFilterBuilderAddField',
        pickerAriaLabelValue: 'Advanced Filter Builder Add Field',
        pickerType: 'ag-list',
        valueList: [{
                key: 'condition',
                displayValue: translate('advancedFilterBuilderAddCondition')
            }, {
                key: 'join',
                displayValue: translate('advancedFilterBuilderAddJoin')
            }],
        valueFormatter: (value) => { var _a; return value == null ? null : (_a = value.displayValue) !== null && _a !== void 0 ? _a : value.key; },
        pickerIcon: 'advancedFilterBuilderAdd',
        maxPickerWidth: `${maxPickerWidth !== null && maxPickerWidth !== void 0 ? maxPickerWidth : 120}px`,
        wrapperClassName: 'ag-advanced-filter-builder-item-button',
        ariaLabel: translate('advancedFilterBuilderAddButtonTooltip')
    };
}

class AdvancedFilterBuilderEvents {
}
AdvancedFilterBuilderEvents.EVENT_ADDED = 'advancedFilterBuilderAdded';
AdvancedFilterBuilderEvents.EVENT_MOVED = 'advancedFilterBuilderMoved';
AdvancedFilterBuilderEvents.EVENT_REMOVED = 'advancedFilterBuilderRemoved';
AdvancedFilterBuilderEvents.EVENT_VALUE_CHANGED = 'advancedFilterBuilderValueChanged';
AdvancedFilterBuilderEvents.EVENT_VALID_CHANGED = 'advancedFilterBuilderValidChanged';

var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ConditionPillWrapperComp extends Component {
    constructor() {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-item-condition" role="presentation"></div>
        `);
        this.validationMessage = null;
    }
    init(params) {
        const { item, createPill } = params;
        this.item = item;
        this.createPill = createPill;
        this.filterModel = item.filterModel;
        this.setupColumnCondition(this.filterModel);
        this.validate();
        this.addDestroyFunc(() => this.destroyBeans([this.eColumnPill, this.eOperatorPill, this.eOperandPill]));
    }
    getDragName() {
        return this.filterModel.colId
            ? this.advancedFilterExpressionService.parseColumnFilterModel(this.filterModel)
            : this.getDefaultColumnDisplayValue();
    }
    getAriaLabel() {
        return `${this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderFilterItem')} ${this.getDragName()}`;
    }
    getValidationMessage() {
        return this.validationMessage;
    }
    getFocusableElement() {
        return this.eColumnPill.getFocusableElement();
    }
    setupColumnCondition(filterModel) {
        var _a;
        const columnDetails = this.advancedFilterExpressionService.getColumnDetails(filterModel.colId);
        this.baseCellDataType = columnDetails.baseCellDataType;
        this.column = columnDetails.column;
        this.numOperands = this.getNumOperands(this.getOperatorKey());
        this.eColumnPill = this.createPill({
            key: this.getColumnKey(),
            displayValue: (_a = this.getColumnDisplayValue()) !== null && _a !== void 0 ? _a : this.getDefaultColumnDisplayValue(),
            cssClass: 'ag-advanced-filter-builder-column-pill',
            isSelect: true,
            getEditorParams: () => ({ values: this.advancedFilterExpressionService.getColumnAutocompleteEntries() }),
            update: (key) => this.setColumnKey(key),
            pickerAriaLabelKey: 'ariaLabelAdvancedFilterBuilderColumnSelectField',
            pickerAriaLabelValue: 'Advanced Filter Builder Column Select Field',
            ariaLabel: this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderColumn')
        });
        this.getGui().appendChild(this.eColumnPill.getGui());
        if (_.exists(this.getColumnKey())) {
            this.createOperatorPill();
            if (this.hasOperand()) {
                this.createOperandPill();
            }
        }
    }
    createOperatorPill() {
        var _a;
        this.eOperatorPill = this.createPill({
            key: this.getOperatorKey(),
            displayValue: (_a = this.getOperatorDisplayValue()) !== null && _a !== void 0 ? _a : this.getDefaultOptionSelectValue(),
            cssClass: 'ag-advanced-filter-builder-option-pill',
            isSelect: true,
            getEditorParams: () => ({ values: this.getOperatorAutocompleteEntries() }),
            update: (key) => this.setOperatorKey(key),
            pickerAriaLabelKey: 'ariaLabelAdvancedFilterBuilderOptionSelectField',
            pickerAriaLabelValue: 'Advanced Filter Builder Option Select Field',
            ariaLabel: this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderOption')
        });
        this.eColumnPill.getGui().insertAdjacentElement('afterend', this.eOperatorPill.getGui());
    }
    createOperandPill() {
        var _a;
        const key = (_a = this.getOperandDisplayValue()) !== null && _a !== void 0 ? _a : '';
        this.eOperandPill = this.createPill({
            key,
            displayValue: key,
            baseCellDataType: this.baseCellDataType,
            cssClass: 'ag-advanced-filter-builder-value-pill',
            isSelect: false,
            update: (key) => this.setOperand(key),
            ariaLabel: this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderValue')
        });
        this.getGui().appendChild(this.eOperandPill.getGui());
    }
    getColumnKey() {
        return this.filterModel.colId;
    }
    getColumnDisplayValue() {
        return this.advancedFilterExpressionService.getColumnDisplayValue(this.filterModel);
    }
    getOperatorKey() {
        return this.filterModel.type;
    }
    getOperatorDisplayValue() {
        return this.advancedFilterExpressionService.getOperatorDisplayValue(this.filterModel);
    }
    getOperandDisplayValue() {
        return this.advancedFilterExpressionService.getOperandDisplayValue(this.filterModel, true);
    }
    hasOperand() {
        return this.numOperands > 0;
    }
    getOperatorAutocompleteEntries() {
        return this.column
            ? this.advancedFilterExpressionService.getOperatorAutocompleteEntries(this.column, this.baseCellDataType)
            : [];
    }
    setColumnKey(colId) {
        if (!this.eOperatorPill) {
            this.createOperatorPill();
        }
        const newColumnDetails = this.advancedFilterExpressionService.getColumnDetails(colId);
        this.column = newColumnDetails.column;
        const newBaseCellDataType = newColumnDetails.baseCellDataType;
        if (this.baseCellDataType !== newBaseCellDataType) {
            this.baseCellDataType = newBaseCellDataType;
            this.setOperatorKey(undefined);
            if (this.eOperatorPill) {
                _.removeFromParent(this.eOperatorPill.getGui());
                this.destroyBean(this.eOperatorPill);
                this.createOperatorPill();
            }
            this.validate();
        }
        this.filterModel.colId = colId;
        this.filterModel.filterType = this.baseCellDataType;
    }
    setOperatorKey(operator) {
        const newNumOperands = this.getNumOperands(operator);
        if (newNumOperands !== this.numOperands) {
            this.numOperands = newNumOperands;
            if (newNumOperands === 0) {
                this.destroyOperandPill();
            }
            else {
                this.createOperandPill();
                if (this.baseCellDataType !== 'number') {
                    this.setOperand('');
                }
            }
        }
        this.filterModel.type = operator;
        this.validate();
    }
    setOperand(operand) {
        var _a;
        let parsedOperand = operand;
        if (this.column) {
            parsedOperand = (_a = this.advancedFilterExpressionService.getOperandModelValue(operand, this.baseCellDataType, this.column)) !== null && _a !== void 0 ? _a : '';
        }
        this.filterModel.filter = parsedOperand;
        this.validate();
    }
    getNumOperands(operator) {
        var _a, _b;
        return (_b = (_a = this.advancedFilterExpressionService.getExpressionOperator(this.baseCellDataType, operator)) === null || _a === void 0 ? void 0 : _a.numOperands) !== null && _b !== void 0 ? _b : 0;
    }
    destroyOperandPill() {
        delete this.filterModel.filter;
        this.getGui().removeChild(this.eOperandPill.getGui());
        this.destroyBean(this.eOperandPill);
        this.eOperandPill = undefined;
    }
    validate() {
        let validationMessage = null;
        if (!_.exists(this.getColumnKey())) {
            validationMessage = this.advancedFilterExpressionService.translate('advancedFilterBuilderValidationSelectColumn');
        }
        else if (!_.exists(this.getOperatorKey())) {
            validationMessage = this.advancedFilterExpressionService.translate('advancedFilterBuilderValidationSelectOption');
        }
        else if (this.numOperands > 0 && !_.exists(this.getOperandDisplayValue())) {
            validationMessage = this.advancedFilterExpressionService.translate('advancedFilterBuilderValidationEnterValue');
        }
        this.item.valid = !validationMessage;
        if (validationMessage !== this.validationMessage) {
            this.validationMessage = validationMessage;
            this.dispatchEvent({
                type: AdvancedFilterBuilderEvents.EVENT_VALID_CHANGED
            });
        }
    }
    getDefaultColumnDisplayValue() {
        return this.advancedFilterExpressionService.translate('advancedFilterBuilderSelectColumn');
    }
    getDefaultOptionSelectValue() {
        return this.advancedFilterExpressionService.translate('advancedFilterBuilderSelectOption');
    }
}
__decorate$5([
    Autowired('advancedFilterExpressionService')
], ConditionPillWrapperComp.prototype, "advancedFilterExpressionService", void 0);
__decorate$5([
    Autowired('valueParserService')
], ConditionPillWrapperComp.prototype, "valueParserService", void 0);

var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class InputPillComp extends Component {
    constructor(params) {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-pill-wrapper" role="presentation">
                <div ref="ePill" class="ag-advanced-filter-builder-pill" role="button">
                    <span ref="eLabel" class="ag-advanced-filter-builder-pill-display"></span>
                </div>
            </div>
        `);
        this.params = params;
        this.value = params.value;
    }
    postConstruct() {
        const { cssClass, ariaLabel } = this.params;
        this.ePill.classList.add(cssClass);
        this.activateTabIndex([this.ePill]);
        this.eLabel.id = `${this.getCompId()}`;
        _.setAriaDescribedBy(this.ePill, this.eLabel.id);
        _.setAriaLabel(this.ePill, ariaLabel);
        this.renderValue();
        this.addManagedListener(this.ePill, 'click', (event) => {
            event.preventDefault();
            this.showEditor();
        });
        this.addManagedListener(this.ePill, 'keydown', (event) => {
            switch (event.key) {
                case KeyCode.ENTER:
                    event.preventDefault();
                    _.stopPropagationForAgGrid(event);
                    this.showEditor();
                    break;
            }
        });
        this.addDestroyFunc(() => this.destroyBean(this.eEditor));
    }
    getFocusableElement() {
        return this.ePill;
    }
    showEditor() {
        if (this.eEditor) {
            return;
        }
        _.setDisplayed(this.ePill, false);
        this.eEditor = this.createEditorComp(this.params.type);
        this.eEditor.setValue(this.value);
        const eEditorGui = this.eEditor.getGui();
        this.eEditor.addManagedListener(eEditorGui, 'keydown', (event) => {
            switch (event.key) {
                case KeyCode.ENTER:
                    event.preventDefault();
                    _.stopPropagationForAgGrid(event);
                    this.updateValue(true);
                    break;
                case KeyCode.ESCAPE:
                    event.preventDefault();
                    _.stopPropagationForAgGrid(event);
                    this.hideEditor(true);
                    break;
            }
        });
        this.eEditor.addManagedListener(eEditorGui, 'focusout', () => {
            this.updateValue(false);
        });
        this.getGui().appendChild(eEditorGui);
        this.eEditor.getFocusableElement().focus();
    }
    createEditorComp(type) {
        let comp;
        switch (type) {
            case 'text':
                comp = new AgInputTextField();
                break;
            case 'number':
                comp = new AgInputNumberField();
                break;
            case 'date':
                comp = new AgInputDateField();
                break;
        }
        return this.createBean(comp);
    }
    hideEditor(keepFocus) {
        const { eEditor } = this;
        if (!eEditor) {
            return;
        }
        this.eEditor = undefined;
        this.getGui().removeChild(eEditor.getGui());
        this.destroyBean(eEditor);
        _.setDisplayed(this.ePill, true);
        if (keepFocus) {
            this.ePill.focus();
        }
    }
    renderValue() {
        let value;
        this.eLabel.classList.remove('ag-advanced-filter-builder-value-empty', 'ag-advanced-filter-builder-value-number', 'ag-advanced-filter-builder-value-text');
        if (!_.exists(this.value)) {
            value = this.advancedFilterExpressionService.translate('advancedFilterBuilderEnterValue');
            this.eLabel.classList.add('ag-advanced-filter-builder-value-empty');
        }
        else if (this.params.type === 'number') {
            value = this.value;
            this.eLabel.classList.add('ag-advanced-filter-builder-value-number');
        }
        else {
            value = `"${this.value}"`;
            this.eLabel.classList.add('ag-advanced-filter-builder-value-text');
        }
        this.eLabel.innerText = value;
    }
    updateValue(keepFocus) {
        var _a;
        if (!this.eEditor) {
            return;
        }
        const value = (_a = this.eEditor.getValue()) !== null && _a !== void 0 ? _a : '';
        this.dispatchEvent({
            type: Events.EVENT_FIELD_VALUE_CHANGED,
            value
        });
        this.value = value;
        this.renderValue();
        this.hideEditor(keepFocus);
    }
}
__decorate$6([
    RefSelector('ePill')
], InputPillComp.prototype, "ePill", void 0);
__decorate$6([
    RefSelector('eLabel')
], InputPillComp.prototype, "eLabel", void 0);
__decorate$6([
    Autowired('advancedFilterExpressionService')
], InputPillComp.prototype, "advancedFilterExpressionService", void 0);
__decorate$6([
    PostConstruct
], InputPillComp.prototype, "postConstruct", null);

var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class JoinPillWrapperComp extends Component {
    constructor() {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-item-condition" role="presentation"></div>
        `);
    }
    init(params) {
        const { item, createPill } = params;
        const filterModel = item.filterModel;
        this.filterModel = filterModel;
        this.ePill = createPill({
            key: filterModel.type,
            displayValue: this.advancedFilterExpressionService.parseJoinOperator(filterModel),
            cssClass: 'ag-advanced-filter-builder-join-pill',
            isSelect: true,
            getEditorParams: () => ({ values: this.advancedFilterExpressionService.getJoinOperatorAutocompleteEntries() }),
            update: (key) => filterModel.type = key,
            pickerAriaLabelKey: 'ariaLabelAdvancedFilterBuilderJoinSelectField',
            pickerAriaLabelValue: 'Advanced Filter Builder Join Operator Select Field',
            ariaLabel: this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderJoinOperator')
        });
        this.getGui().appendChild(this.ePill.getGui());
        this.addDestroyFunc(() => this.destroyBean(this.ePill));
    }
    getDragName() {
        return this.advancedFilterExpressionService.parseJoinOperator(this.filterModel);
    }
    getAriaLabel() {
        return `${this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderGroupItem')} ${this.getDragName()}`;
    }
    getValidationMessage() {
        return null;
    }
    getFocusableElement() {
        return this.ePill.getFocusableElement();
    }
}
__decorate$7([
    Autowired('advancedFilterExpressionService')
], JoinPillWrapperComp.prototype, "advancedFilterExpressionService", void 0);

class SelectPillComp extends AgRichSelect {
    constructor(params) {
        super(Object.assign(Object.assign({}, params), { template: /* html */ `
                <div class="ag-picker-field ag-advanced-filter-builder-pill-wrapper" role="presentation">
                    <div ref="eLabel"></div>
                    <div ref="eWrapper" class="ag-wrapper ag-advanced-filter-builder-pill ag-picker-collapsed">
                        <div ref="eDisplayField" class="ag-picker-field-display ag-advanced-filter-builder-pill-display"></div>
                        <ag-input-text-field ref="eInput" class="ag-rich-select-field-input"></ag-input-text-field>
                        <div ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                    </div>
                </div>` }));
        this.params = params;
    }
    getFocusableElement() {
        return this.eWrapper;
    }
    showPicker() {
        // avoid focus handling issues with multiple rich selects
        setTimeout(() => super.showPicker());
    }
    hidePicker() {
        // avoid focus handling issues with multiple rich selects
        setTimeout(() => super.hidePicker());
    }
    postConstruct() {
        super.postConstruct();
        const { wrapperClassName, ariaLabel } = this.params;
        this.eWrapper.classList.add(wrapperClassName);
        _.setAriaLabelledBy(this.eWrapper, '');
        _.setAriaLabel(this.eWrapper, ariaLabel);
    }
    createPickerComponent() {
        var _a;
        if (!this.values) {
            const { values } = this.params.getEditorParams();
            this.values = values;
            const key = this.value.key;
            const value = (_a = values.find(value => value.key === key)) !== null && _a !== void 0 ? _a : {
                key,
                displayValue: this.value.displayValue
            };
            this.value = value;
        }
        return super.createPickerComponent();
    }
    onEnterKeyDown(event) {
        _.stopPropagationForAgGrid(event);
        if (this.isPickerDisplayed) {
            super.onEnterKeyDown(event);
        }
        else {
            event.preventDefault();
            this.showPicker();
        }
    }
}

var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AdvancedFilterBuilderItemComp extends TabGuardComp {
    constructor(item, dragFeature, focusWrapper) {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-item-wrapper" role="presentation">
                <div ref="eItem" class="ag-advanced-filter-builder-item" role="presentation">
                    <div ref="eTreeLines" class="ag-advanced-filter-builder-item-tree-lines" aria-hidden="true"></div>
                    <span ref="eDragHandle" class="ag-drag-handle" aria-hidden="true"></span>
                    <span ref="eValidation" class="ag-advanced-filter-builder-item-button ag-advanced-filter-builder-invalid" aria-hidden="true"></span>
                </div>
                <div ref="eButtons" class="ag-advanced-filter-builder-item-buttons">
                    <span ref="eMoveUpButton" class="ag-advanced-filter-builder-item-button" role="button"></span>
                    <span ref="eMoveDownButton" class="ag-advanced-filter-builder-item-button" role="button"></span>
                    <div ref="eAddButton" role="presentation"></div>
                    <span ref="eRemoveButton" class="ag-advanced-filter-builder-item-button" role="button"></span>
                </div>
            </div>
        `);
        this.item = item;
        this.dragFeature = dragFeature;
        this.focusWrapper = focusWrapper;
        this.moveUpDisabled = false;
        this.moveDownDisabled = false;
    }
    postConstruct() {
        const { filterModel, level, showMove } = this.item;
        const isJoin = filterModel.filterType === 'join';
        this.ePillWrapper = this.createManagedBean(isJoin ? new JoinPillWrapperComp() : new ConditionPillWrapperComp());
        this.ePillWrapper.init({ item: this.item, createPill: (params) => this.createPill(params) });
        this.eDragHandle.insertAdjacentElement('afterend', this.ePillWrapper.getGui());
        if (level === 0) {
            const eTreeLine = document.createElement('div');
            eTreeLine.classList.add('ag-advanced-filter-builder-item-tree-line-vertical-bottom');
            eTreeLine.classList.add('ag-advanced-filter-builder-item-tree-line-root');
            this.eTreeLines.appendChild(eTreeLine);
            _.setDisplayed(this.eDragHandle, false);
            _.setDisplayed(this.eButtons, false);
            _.setAriaExpanded(this.focusWrapper, true);
        }
        else {
            this.setupTreeLines(level);
            this.eDragHandle.appendChild(_.createIconNoSpan('advancedFilterBuilderDrag', this.gridOptionsService));
            this.setupValidation();
            this.setupMoveButtons(showMove);
            this.setupAddButton();
            this.setupRemoveButton();
            this.setupDragging();
            this.updateAriaExpanded();
        }
        _.setAriaLevel(this.focusWrapper, level + 1);
        this.initialiseTabGuard({});
        this.createManagedBean(new AdvancedFilterBuilderItemNavigationFeature(this.getGui(), this.focusWrapper, this.ePillWrapper));
        this.updateAriaLabel();
        this.addManagedListener(this.ePillWrapper, AdvancedFilterBuilderEvents.EVENT_VALUE_CHANGED, () => this.dispatchEvent({
            type: AdvancedFilterBuilderEvents.EVENT_VALUE_CHANGED
        }));
        this.addManagedListener(this.ePillWrapper, AdvancedFilterBuilderEvents.EVENT_VALID_CHANGED, () => this.updateValidity());
    }
    setState(params) {
        const { level } = this.item;
        if (level === 0) {
            return;
        }
        const { showMove } = this.item;
        const { disableMoveUp, disableMoveDown, treeLines, showStartTreeLine } = params;
        this.updateTreeLines(treeLines, showStartTreeLine);
        this.updateAriaExpanded();
        if (showMove) {
            this.moveUpDisabled = !!disableMoveUp;
            this.moveDownDisabled = !!disableMoveDown;
            this.eMoveUpButton.classList.toggle('ag-advanced-filter-builder-item-button-disabled', disableMoveUp);
            this.eMoveDownButton.classList.toggle('ag-advanced-filter-builder-item-button-disabled', disableMoveDown);
            _.setAriaDisabled(this.eMoveUpButton, !!disableMoveUp);
            _.setAriaDisabled(this.eMoveDownButton, !!disableMoveDown);
            this.moveUpTooltipFeature.refreshToolTip();
            this.moveDownTooltipFeature.refreshToolTip();
        }
    }
    focusMoveButton(backwards) {
        (backwards ? this.eMoveUpButton : this.eMoveDownButton).focus();
    }
    afterAdd() {
        this.ePillWrapper.getFocusableElement().focus();
    }
    setupTreeLines(level) {
        for (let i = 0; i < level; i++) {
            const eTreeLine = document.createElement('div');
            this.eTreeLines.appendChild(eTreeLine);
        }
    }
    updateTreeLines(treeLines, showStartTreeLine) {
        const lastTreeLineIndex = treeLines.length - 1;
        const { children } = this.eTreeLines;
        for (let i = 0; i < lastTreeLineIndex; i++) {
            const eTreeLine = children.item(i);
            if (eTreeLine) {
                eTreeLine.classList.toggle('ag-advanced-filter-builder-item-tree-line-vertical', !treeLines[i]);
            }
        }
        const eTreeLine = children.item(lastTreeLineIndex);
        if (eTreeLine) {
            eTreeLine.classList.add('ag-advanced-filter-builder-item-tree-line-horizontal');
            const isLastChild = treeLines[lastTreeLineIndex];
            eTreeLine.classList.toggle('ag-advanced-filter-builder-item-tree-line-vertical-top', isLastChild);
            eTreeLine.classList.toggle('ag-advanced-filter-builder-item-tree-line-vertical', !isLastChild);
        }
        this.eDragHandle.classList.toggle('ag-advanced-filter-builder-item-tree-line-vertical-bottom', showStartTreeLine);
    }
    setupValidation() {
        this.eValidation.appendChild(_.createIconNoSpan('advancedFilterBuilderInvalid', this.gridOptionsService));
        this.validationTooltipFeature = this.createManagedBean(new TooltipFeature({
            getGui: () => this.eValidation,
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.ePillWrapper.getValidationMessage(),
            getTooltipShowDelayOverride: () => 1000
        }, this.beans));
        this.validationTooltipFeature.setComp(this.eValidation);
        this.updateValidity();
    }
    setupAddButton() {
        var _a;
        const addButtonParams = getAdvancedFilterBuilderAddButtonParams(key => this.advancedFilterExpressionService.translate(key), (_a = this.gridOptionsService.get('advancedFilterBuilderParams')) === null || _a === void 0 ? void 0 : _a.addSelectWidth);
        const eAddButton = this.createManagedBean(new AddDropdownComp(addButtonParams));
        this.addManagedListener(eAddButton, Events.EVENT_FIELD_PICKER_VALUE_SELECTED, ({ value }) => this.dispatchEvent({
            type: AdvancedFilterBuilderEvents.EVENT_ADDED,
            item: this.item,
            isJoin: value.key === 'join'
        }));
        this.eAddButton.appendChild(eAddButton.getGui());
        const tooltipFeature = this.createManagedBean(new TooltipFeature({
            getGui: () => this.eAddButton,
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.advancedFilterExpressionService.translate('advancedFilterBuilderAddButtonTooltip')
        }, this.beans));
        tooltipFeature.setComp(this.eAddButton);
    }
    setupRemoveButton() {
        this.eRemoveButton.appendChild(_.createIconNoSpan('advancedFilterBuilderRemove', this.gridOptionsService));
        this.addManagedListener(this.eRemoveButton, 'click', () => this.removeItem());
        this.addManagedListener(this.eRemoveButton, 'keydown', (event) => {
            switch (event.key) {
                case KeyCode.ENTER:
                    event.preventDefault();
                    _.stopPropagationForAgGrid(event);
                    this.removeItem();
                    break;
            }
        });
        const tooltipFeature = this.createManagedBean(new TooltipFeature({
            getGui: () => this.eRemoveButton,
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.advancedFilterExpressionService.translate('advancedFilterBuilderRemoveButtonTooltip')
        }, this.beans));
        tooltipFeature.setComp(this.eRemoveButton);
        _.setAriaLabel(this.eRemoveButton, this.advancedFilterExpressionService.translate('advancedFilterBuilderRemoveButtonTooltip'));
        this.activateTabIndex([this.eRemoveButton]);
    }
    setupMoveButtons(showMove) {
        if (showMove) {
            this.eMoveUpButton.appendChild(_.createIconNoSpan('advancedFilterBuilderMoveUp', this.gridOptionsService));
            this.addManagedListener(this.eMoveUpButton, 'click', () => this.moveItem(true));
            this.addManagedListener(this.eMoveUpButton, 'keydown', (event) => {
                switch (event.key) {
                    case KeyCode.ENTER:
                        event.preventDefault();
                        _.stopPropagationForAgGrid(event);
                        this.moveItem(true);
                        break;
                }
            });
            this.moveUpTooltipFeature = this.createManagedBean(new TooltipFeature({
                getGui: () => this.eMoveUpButton,
                getLocation: () => 'advancedFilter',
                getTooltipValue: () => this.moveUpDisabled
                    ? null
                    : this.advancedFilterExpressionService.translate('advancedFilterBuilderMoveUpButtonTooltip')
            }, this.beans));
            this.moveUpTooltipFeature.setComp(this.eMoveUpButton);
            _.setAriaLabel(this.eMoveUpButton, this.advancedFilterExpressionService.translate('advancedFilterBuilderMoveUpButtonTooltip'));
            this.eMoveDownButton.appendChild(_.createIconNoSpan('advancedFilterBuilderMoveDown', this.gridOptionsService));
            this.addManagedListener(this.eMoveDownButton, 'click', () => this.moveItem(false));
            this.addManagedListener(this.eMoveDownButton, 'keydown', (event) => {
                switch (event.key) {
                    case KeyCode.ENTER:
                        event.preventDefault();
                        _.stopPropagationForAgGrid(event);
                        this.moveItem(false);
                        break;
                }
            });
            this.moveDownTooltipFeature = this.createManagedBean(new TooltipFeature({
                getGui: () => this.eMoveDownButton,
                getLocation: () => 'advancedFilter',
                getTooltipValue: () => this.moveDownDisabled
                    ? null
                    : this.advancedFilterExpressionService.translate('advancedFilterBuilderMoveDownButtonTooltip')
            }, this.beans));
            this.moveDownTooltipFeature.setComp(this.eMoveDownButton);
            _.setAriaLabel(this.eMoveDownButton, this.advancedFilterExpressionService.translate('advancedFilterBuilderMoveDownButtonTooltip'));
            this.activateTabIndex([this.eMoveUpButton, this.eMoveDownButton]);
        }
        else {
            _.setDisplayed(this.eMoveUpButton, false);
            _.setDisplayed(this.eMoveDownButton, false);
        }
    }
    updateValidity() {
        _.setVisible(this.eValidation, !this.item.valid);
        this.validationTooltipFeature.refreshToolTip();
        this.updateAriaLabel();
    }
    createPill(params) {
        var _a, _b;
        const { key, displayValue, cssClass, update, ariaLabel } = params;
        const onUpdated = (key) => {
            if (key == null) {
                return;
            }
            update(key);
            this.dispatchEvent({
                type: AdvancedFilterBuilderEvents.EVENT_VALUE_CHANGED
            });
        };
        if (params.isSelect) {
            const { getEditorParams, pickerAriaLabelKey, pickerAriaLabelValue } = params;
            const advancedFilterBuilderParams = this.gridOptionsService.get('advancedFilterBuilderParams');
            const minPickerWidth = `${(_a = advancedFilterBuilderParams === null || advancedFilterBuilderParams === void 0 ? void 0 : advancedFilterBuilderParams.pillSelectMinWidth) !== null && _a !== void 0 ? _a : 140}px`;
            const maxPickerWidth = `${(_b = advancedFilterBuilderParams === null || advancedFilterBuilderParams === void 0 ? void 0 : advancedFilterBuilderParams.pillSelectMaxWidth) !== null && _b !== void 0 ? _b : 200}px`;
            const comp = this.createBean(new SelectPillComp({
                pickerAriaLabelKey,
                pickerAriaLabelValue,
                pickerType: 'ag-list',
                value: {
                    key,
                    displayValue
                },
                valueFormatter: (value) => { var _a; return value == null ? null : (_a = value.displayValue) !== null && _a !== void 0 ? _a : value.key; },
                variableWidth: true,
                minPickerWidth,
                maxPickerWidth,
                getEditorParams,
                wrapperClassName: cssClass,
                ariaLabel
            }));
            this.addManagedListener(comp, Events.EVENT_FIELD_PICKER_VALUE_SELECTED, ({ value }) => onUpdated(value === null || value === void 0 ? void 0 : value.key));
            return comp;
        }
        else {
            const comp = this.createBean(new InputPillComp({
                value: displayValue,
                cssClass,
                type: this.getInputType(params.baseCellDataType),
                ariaLabel
            }));
            this.addManagedListener(comp, Events.EVENT_FIELD_VALUE_CHANGED, ({ value }) => onUpdated(value));
            return comp;
        }
    }
    getInputType(baseCellDataType) {
        switch (baseCellDataType) {
            case 'text':
            case 'object':
            case 'boolean':
                return 'text';
            case 'number':
                return 'number';
            case 'date':
            case 'dateString':
                return 'date';
        }
    }
    setupDragging() {
        const dragSource = {
            type: DragSourceType.AdvancedFilterBuilder,
            eElement: this.eDragHandle,
            dragItemName: () => this.ePillWrapper.getDragName(),
            getDefaultIconName: () => DragAndDropService.ICON_NOT_ALLOWED,
            getDragItem: () => ({}),
            onDragStarted: () => this.dragFeature.dispatchEvent({
                type: AdvancedFilterBuilderDragFeature.EVENT_DRAG_STARTED,
                item: this.item
            }),
            onDragStopped: () => this.dragFeature.dispatchEvent({
                type: AdvancedFilterBuilderDragFeature.EVENT_DRAG_ENDED
            })
        };
        this.dragAndDropService.addDragSource(dragSource, true);
        this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(dragSource));
    }
    updateAriaLabel() {
        const wrapperLabel = this.ePillWrapper.getAriaLabel();
        const level = `${this.item.level + 1}`;
        const validationMessage = this.ePillWrapper.getValidationMessage();
        let ariaLabel;
        if (validationMessage) {
            ariaLabel = this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderItemValidation', [wrapperLabel, level, validationMessage]);
        }
        else {
            ariaLabel = this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderItem', [wrapperLabel, level]);
        }
        _.setAriaLabel(this.focusWrapper, ariaLabel);
    }
    updateAriaExpanded() {
        _.removeAriaExpanded(this.focusWrapper);
        const { filterModel } = this.item;
        if ((filterModel === null || filterModel === void 0 ? void 0 : filterModel.filterType) === 'join' && filterModel.conditions.length) {
            _.setAriaExpanded(this.focusWrapper, true);
        }
    }
    removeItem() {
        this.dispatchEvent({
            type: AdvancedFilterBuilderEvents.EVENT_REMOVED,
            item: this.item
        });
    }
    moveItem(backwards) {
        this.dispatchEvent({
            type: AdvancedFilterBuilderEvents.EVENT_MOVED,
            item: this.item,
            backwards
        });
    }
}
__decorate$8([
    RefSelector('eTreeLines')
], AdvancedFilterBuilderItemComp.prototype, "eTreeLines", void 0);
__decorate$8([
    RefSelector('eDragHandle')
], AdvancedFilterBuilderItemComp.prototype, "eDragHandle", void 0);
__decorate$8([
    RefSelector('eItem')
], AdvancedFilterBuilderItemComp.prototype, "eItem", void 0);
__decorate$8([
    RefSelector('eButtons')
], AdvancedFilterBuilderItemComp.prototype, "eButtons", void 0);
__decorate$8([
    RefSelector('eValidation')
], AdvancedFilterBuilderItemComp.prototype, "eValidation", void 0);
__decorate$8([
    RefSelector('eMoveUpButton')
], AdvancedFilterBuilderItemComp.prototype, "eMoveUpButton", void 0);
__decorate$8([
    RefSelector('eMoveDownButton')
], AdvancedFilterBuilderItemComp.prototype, "eMoveDownButton", void 0);
__decorate$8([
    RefSelector('eAddButton')
], AdvancedFilterBuilderItemComp.prototype, "eAddButton", void 0);
__decorate$8([
    RefSelector('eRemoveButton')
], AdvancedFilterBuilderItemComp.prototype, "eRemoveButton", void 0);
__decorate$8([
    Autowired('beans')
], AdvancedFilterBuilderItemComp.prototype, "beans", void 0);
__decorate$8([
    Autowired('dragAndDropService')
], AdvancedFilterBuilderItemComp.prototype, "dragAndDropService", void 0);
__decorate$8([
    Autowired('advancedFilterExpressionService')
], AdvancedFilterBuilderItemComp.prototype, "advancedFilterExpressionService", void 0);
__decorate$8([
    PostConstruct
], AdvancedFilterBuilderItemComp.prototype, "postConstruct", null);

var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AdvancedFilterBuilderItemAddComp extends Component {
    constructor(item, focusWrapper) {
        super(/* html */ `
            <div class="ag-advanced-filter-builder-item-wrapper" role="presentation">
                <div ref="eItem" class="ag-advanced-filter-builder-item" role="presentation">
                    <div class="ag-advanced-filter-builder-item-tree-lines" aria-hidden="true">
                        <div class="ag-advanced-filter-builder-item-tree-line-vertical-top ag-advanced-filter-builder-item-tree-line-horizontal"></div>
                    </div>
                </div>
            </div>
        `);
        this.item = item;
        this.focusWrapper = focusWrapper;
    }
    postConstruct() {
        var _a;
        _.setAriaLevel(this.focusWrapper, 2);
        const addButtonParams = getAdvancedFilterBuilderAddButtonParams(key => this.advancedFilterExpressionService.translate(key), (_a = this.gridOptionsService.get('advancedFilterBuilderParams')) === null || _a === void 0 ? void 0 : _a.addSelectWidth);
        const eAddButton = this.createManagedBean(new AddDropdownComp(addButtonParams));
        this.addManagedListener(eAddButton, Events.EVENT_FIELD_PICKER_VALUE_SELECTED, ({ value }) => {
            this.dispatchEvent({
                type: AdvancedFilterBuilderEvents.EVENT_ADDED,
                item: this.item,
                isJoin: value.key === 'join'
            });
        });
        this.eItem.appendChild(eAddButton.getGui());
        const tooltipFeature = this.createManagedBean(new TooltipFeature({
            getGui: () => eAddButton.getGui(),
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.advancedFilterExpressionService.translate('advancedFilterBuilderAddButtonTooltip')
        }, this.beans));
        tooltipFeature.setComp(eAddButton.getGui());
        this.createManagedBean(new AdvancedFilterBuilderItemNavigationFeature(this.getGui(), this.focusWrapper, eAddButton));
        _.setAriaLabel(this.focusWrapper, this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderItem', [
            this.advancedFilterExpressionService.translate('advancedFilterBuilderAddButtonTooltip'),
            `${this.item.level + 1}`
        ]));
    }
    afterAdd() {
        // do nothing
    }
}
__decorate$9([
    Autowired('beans')
], AdvancedFilterBuilderItemAddComp.prototype, "beans", void 0);
__decorate$9([
    Autowired('advancedFilterExpressionService')
], AdvancedFilterBuilderItemAddComp.prototype, "advancedFilterExpressionService", void 0);
__decorate$9([
    RefSelector('eItem')
], AdvancedFilterBuilderItemAddComp.prototype, "eItem", void 0);
__decorate$9([
    PostConstruct
], AdvancedFilterBuilderItemAddComp.prototype, "postConstruct", null);

var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AdvancedFilterBuilderComp extends Component {
    constructor() {
        super(/* html */ `
            <div role="presentation" class="ag-advanced-filter-builder" tabindex="-1">
                <div role="presentation" class="ag-advanced-filter-builder-list" ref="eList"></div>
                <div role="presentation" class="ag-advanced-filter-builder-button-panel">
                    <button class="ag-button ag-standard-button ag-advanced-filter-builder-apply-button" ref="eApplyFilterButton"></button>
                    <button class="ag-button ag-standard-button ag-advanced-filter-builder-cancel-button" ref="eCancelFilterButton"></button>
                </div>
            </div>`);
        this.validationMessage = null;
    }
    postConstruct() {
        var _a;
        const { showMoveButtons } = (_a = this.gridOptionsService.get('advancedFilterBuilderParams')) !== null && _a !== void 0 ? _a : {};
        this.showMove = !!showMoveButtons;
        this.addManagedPropertyListener('advancedFilterBuilderParams', ({ currentValue }) => {
            this.showMove = !!(currentValue === null || currentValue === void 0 ? void 0 : currentValue.showMoveButtons);
            this.refreshList(false);
        });
        this.filterModel = this.setupFilterModel();
        this.setupVirtualList();
        this.dragFeature = this.createManagedBean(new AdvancedFilterBuilderDragFeature(this, this.virtualList));
        this.setupButtons();
    }
    refresh() {
        let indexToFocus = this.virtualList.getLastFocusedRow();
        this.setupFilterModel();
        this.validateItems();
        this.refreshList(false);
        if (indexToFocus != null) {
            // last focused row is cleared on focus out, so if defined, we need to put the focus back
            if (!this.virtualList.getComponentAt(indexToFocus)) {
                indexToFocus = 0;
            }
            this.virtualList.focusRow(indexToFocus);
        }
    }
    getNumItems() {
        return this.items.length;
    }
    moveItem(item, destination) {
        if (!destination || !item) {
            return;
        }
        this.moveItemToIndex(item, destination.rowIndex, destination.position);
    }
    afterGuiAttached() {
        this.virtualList.focusRow(0);
    }
    setupVirtualList() {
        this.virtualList = this.createManagedBean(new VirtualList({
            cssIdentifier: 'advanced-filter-builder',
            ariaRole: 'tree',
            listName: this.advancedFilterExpressionService.translate('ariaAdvancedFilterBuilderList')
        }));
        this.virtualList.setComponentCreator(this.createItemComponent.bind(this));
        this.virtualList.setComponentUpdater(this.updateItemComponent.bind(this));
        this.virtualList.setRowHeight(40);
        this.eList.appendChild(this.virtualList.getGui());
        this.virtualList.setModel({
            getRowCount: () => this.items.length,
            getRow: (index) => this.items[index],
            areRowsEqual: (oldRow, newRow) => oldRow === newRow
        });
        this.buildList();
        this.virtualList.refresh();
    }
    setupButtons() {
        this.eApplyFilterButton.innerText = this.advancedFilterExpressionService.translate('advancedFilterBuilderApply');
        this.activateTabIndex([this.eApplyFilterButton]);
        this.addManagedListener(this.eApplyFilterButton, 'click', () => {
            this.advancedFilterService.setModel(this.filterModel);
            this.filterManager.onFilterChanged({ source: 'advancedFilter' });
            this.close();
        });
        this.validationTooltipFeature = this.createManagedBean(new TooltipFeature({
            getGui: () => this.eApplyFilterButton,
            getLocation: () => 'advancedFilter',
            getTooltipValue: () => this.validationMessage,
            getTooltipShowDelayOverride: () => 1000
        }, this.beans));
        this.validationTooltipFeature.setComp(this.eApplyFilterButton);
        this.validate();
        this.addManagedListener(this.eApplyFilterButton, 'mouseenter', () => this.addOrRemoveCssClass('ag-advanced-filter-builder-validation', true));
        this.addManagedListener(this.eApplyFilterButton, 'mouseleave', () => this.addOrRemoveCssClass('ag-advanced-filter-builder-validation', false));
        this.eCancelFilterButton.innerText = this.advancedFilterExpressionService.translate('advancedFilterBuilderCancel');
        this.activateTabIndex([this.eCancelFilterButton]);
        this.addManagedListener(this.eCancelFilterButton, 'click', () => this.close());
    }
    removeItemFromParent(item) {
        const sourceParentIndex = item.parent.conditions.indexOf(item.filterModel);
        item.parent.conditions.splice(sourceParentIndex, 1);
        return sourceParentIndex;
    }
    moveItemToIndex(item, destinationRowIndex, destinationPosition) {
        var _a;
        const destinationItem = this.items[destinationRowIndex];
        const destinationIsParent = ((_a = destinationItem.filterModel) === null || _a === void 0 ? void 0 : _a.filterType) === 'join' && destinationPosition === 'bottom';
        const destinationParent = destinationIsParent ? destinationItem.filterModel : destinationItem.parent;
        // trying to move before the root
        if (!destinationParent) {
            return;
        }
        // can't move into itself
        if (this.isChildOrSelf(destinationParent, item.filterModel) || destinationItem === item) {
            return;
        }
        this.removeItemFromParent(item);
        let destinationParentIndex;
        if (destinationIsParent) {
            destinationParentIndex = 0;
        }
        else {
            destinationParentIndex = destinationParent.conditions.indexOf(destinationItem.filterModel);
            if (destinationParentIndex === -1) {
                destinationParentIndex = destinationParent.conditions.length;
            }
            else if (destinationPosition === 'bottom') {
                destinationParentIndex += 1;
            }
        }
        destinationParent.conditions.splice(destinationParentIndex, 0, item.filterModel);
        this.refreshList(false);
    }
    isChildOrSelf(modelToCheck, potentialParentModel) {
        return modelToCheck === potentialParentModel || (potentialParentModel.filterType === 'join' &&
            potentialParentModel.conditions.some(condition => this.isChildOrSelf(modelToCheck, condition)));
    }
    setupFilterModel() {
        const filterModel = this.formatFilterModel(this.advancedFilterService.getModel());
        this.stringifiedModel = JSON.stringify(filterModel);
        return filterModel;
    }
    formatFilterModel(filterModel) {
        filterModel = filterModel !== null && filterModel !== void 0 ? filterModel : {
            filterType: 'join',
            type: 'AND',
            conditions: []
        };
        if (filterModel.filterType !== 'join') {
            filterModel = {
                filterType: 'join',
                type: 'AND',
                conditions: [filterModel]
            };
        }
        return filterModel;
    }
    buildList() {
        const parseFilterModel = (filterModel, items, level, parent) => {
            items.push({ filterModel, level, parent, valid: true, showMove: this.showMove });
            if (filterModel.filterType === 'join') {
                filterModel.conditions.forEach(childFilterModel => parseFilterModel(childFilterModel, items, level + 1, filterModel));
                if (level === 0) {
                    items.push({ filterModel: null, level: level + 1, parent: filterModel, valid: true });
                }
            }
        };
        this.items = [];
        parseFilterModel(this.filterModel, this.items, 0);
    }
    refreshList(softRefresh) {
        if (!softRefresh) {
            const invalidModels = [];
            this.items.forEach(item => {
                if (!item.valid) {
                    invalidModels.push(item.filterModel);
                }
            });
            this.buildList();
            if (invalidModels.length) {
                this.items.forEach(item => {
                    if (item.filterModel && invalidModels.includes(item.filterModel)) {
                        item.valid = false;
                    }
                });
            }
        }
        this.virtualList.refresh(softRefresh);
        this.validate();
    }
    updateItemComponent(item, comp) {
        const index = this.items.indexOf(item);
        const populateTreeLines = (filterModel, treeLines) => {
            const parentItem = this.items.find(itemToCheck => itemToCheck.filterModel === filterModel);
            const parentFilterModel = parentItem === null || parentItem === void 0 ? void 0 : parentItem.parent;
            if (parentFilterModel) {
                const { conditions } = parentFilterModel;
                // check parent
                populateTreeLines(parentFilterModel, treeLines);
                treeLines.push(conditions[conditions.length - 1] === filterModel);
            }
        };
        const treeLines = [];
        const { filterModel } = item;
        if (filterModel) {
            populateTreeLines(filterModel, treeLines);
            // the add item button is always last child
            treeLines[0] = false;
        }
        const showStartTreeLine = (filterModel === null || filterModel === void 0 ? void 0 : filterModel.filterType) === 'join' && !!filterModel.conditions.length;
        comp.setState({
            disableMoveUp: index === 1,
            disableMoveDown: !this.canMoveDown(item, index),
            treeLines,
            showStartTreeLine
        });
    }
    createItemComponent(item, focusWrapper) {
        const itemComp = this.createBean(item.filterModel
            ? new AdvancedFilterBuilderItemComp(item, this.dragFeature, focusWrapper)
            : new AdvancedFilterBuilderItemAddComp(item, focusWrapper));
        itemComp.addManagedListener(itemComp, AdvancedFilterBuilderEvents.EVENT_REMOVED, ({ item }) => this.removeItem(item));
        itemComp.addManagedListener(itemComp, AdvancedFilterBuilderEvents.EVENT_VALUE_CHANGED, () => this.validate());
        itemComp.addManagedListener(itemComp, AdvancedFilterBuilderEvents.EVENT_ADDED, ({ item, isJoin }) => this.addItem(item, isJoin));
        itemComp.addManagedListener(itemComp, AdvancedFilterBuilderEvents.EVENT_MOVED, ({ item, backwards }) => this.moveItemUpDown(item, backwards));
        if (itemComp instanceof AdvancedFilterBuilderItemComp) {
            this.updateItemComponent(item, itemComp);
        }
        return itemComp;
    }
    addItem(item, isJoin) {
        var _a;
        const { parent: itemParent, level, filterModel: itemFilterModel } = item;
        const itemIsJoin = (itemFilterModel === null || itemFilterModel === void 0 ? void 0 : itemFilterModel.filterType) === 'join';
        const filterModel = isJoin ? {
            filterType: 'join',
            type: 'AND',
            conditions: []
        } : {};
        const parent = (itemIsJoin ? itemFilterModel : itemParent);
        let insertIndex = itemIsJoin ? 0 : parent.conditions.indexOf(itemFilterModel);
        if (insertIndex >= 0) {
            if (!itemIsJoin) {
                insertIndex += 1;
            }
            parent.conditions.splice(insertIndex, 0, filterModel);
        }
        else {
            parent.conditions.push(filterModel);
        }
        let index = this.items.indexOf(item);
        const softRefresh = index >= 0;
        if (softRefresh) {
            if (item.filterModel) {
                index++;
            }
            const newItems = [{
                    filterModel,
                    level: itemIsJoin ? level + 1 : level,
                    parent,
                    valid: isJoin,
                    showMove: this.showMove
                }];
            this.items.splice(index, 0, ...newItems);
        }
        this.refreshList(softRefresh);
        if (softRefresh) {
            (_a = this.virtualList.getComponentAt(index)) === null || _a === void 0 ? void 0 : _a.afterAdd();
        }
    }
    removeItem(item) {
        var _a;
        const parent = item.parent;
        const { filterModel } = item;
        const parentIndex = parent.conditions.indexOf(filterModel);
        parent.conditions.splice(parentIndex, 1);
        const isJoin = ((_a = item.filterModel) === null || _a === void 0 ? void 0 : _a.filterType) === 'join';
        const index = this.items.indexOf(item);
        // if it's a join, we don't know how many children there are, so always rebuild
        const softRefresh = !isJoin && index >= 0;
        if (softRefresh) {
            this.items.splice(index, 1);
        }
        this.refreshList(softRefresh);
        if (index >= 0) {
            this.virtualList.focusRow(index);
        }
    }
    moveItemUpDown(item, backwards) {
        const itemIndex = this.items.indexOf(item);
        const destinationIndex = backwards ? itemIndex - 1 : itemIndex + 1;
        if (destinationIndex === 0 || (!backwards && !this.canMoveDown(item, itemIndex))) {
            return;
        }
        const destinationItem = this.items[destinationIndex];
        const indexInParent = this.removeItemFromParent(item);
        const { level, filterModel, parent } = item;
        const { level: destinationLevel, filterModel: destinationFilterModel, parent: destinationParent } = destinationItem;
        if (backwards) {
            if (destinationLevel === level && destinationFilterModel.filterType === 'join') {
                // destination is empty join. move to last child
                destinationFilterModel.conditions.push(filterModel);
            }
            else if (destinationLevel <= level) {
                // same parent or first child. move above destination in destination parent
                const destinationIndex = destinationParent.conditions.indexOf(destinationFilterModel);
                destinationParent.conditions.splice(destinationIndex, 0, filterModel);
            }
            else {
                // need to move up a level. move to end of previous item's children
                const newParentItem = parent.conditions[indexInParent - 1];
                newParentItem.conditions.push(filterModel);
            }
        }
        else {
            if (destinationLevel === level) {
                if (destinationFilterModel.filterType === 'join') {
                    // destination is join. move to first child
                    destinationFilterModel.conditions.splice(0, 0, filterModel);
                }
                else {
                    // switch positions
                    const destinationIndex = destinationParent.conditions.indexOf(destinationFilterModel);
                    destinationParent.conditions.splice(destinationIndex + 1, 0, filterModel);
                }
            }
            else {
                if (indexInParent < parent.conditions.length) {
                    // keep in parent, but swap with next child
                    parent.conditions.splice(indexInParent + 1, 0, filterModel);
                }
                else {
                    // need to move down a level. move after parent in its parent
                    const parentItem = this.items.find(itemToCheck => itemToCheck.filterModel === parent);
                    const destinationIndex = parentItem.parent.conditions.indexOf(parentItem.filterModel) + 1;
                    parentItem.parent.conditions.splice(destinationIndex, 0, filterModel);
                }
            }
        }
        this.refreshList(false);
        const newIndex = this.items.findIndex(({ filterModel: filterModelToCheck }) => filterModelToCheck === filterModel);
        if (newIndex >= 0) {
            const comp = this.virtualList.getComponentAt(newIndex);
            if (comp instanceof AdvancedFilterBuilderItemComp) {
                comp.focusMoveButton(backwards);
            }
        }
    }
    canMoveDown(item, index) {
        return !((item.level === 1 && index === this.items.length - 2) ||
            (item.level === 1 && item.parent.conditions[item.parent.conditions.length - 1] === item.filterModel));
    }
    close() {
        this.advancedFilterService.getCtrl().toggleFilterBuilder('ui');
    }
    validate() {
        let disableApply = !this.items.every(({ valid }) => valid);
        if (!disableApply) {
            disableApply = JSON.stringify(this.filterModel) === this.stringifiedModel;
            if (disableApply) {
                this.validationMessage = this.advancedFilterExpressionService.translate('advancedFilterBuilderValidationAlreadyApplied');
            }
            else {
                this.validationMessage = null;
            }
        }
        else {
            this.validationMessage = this.advancedFilterExpressionService.translate('advancedFilterBuilderValidationIncomplete');
        }
        _.setDisabled(this.eApplyFilterButton, disableApply);
        this.validationTooltipFeature.refreshToolTip();
    }
    validateItems() {
        const clearOperator = (filterModel) => {
            filterModel.type = undefined;
        };
        const clearOperand = (filterModel) => {
            delete filterModel.filter;
        };
        this.items.forEach(item => {
            if (!item.valid || !item.filterModel || item.filterModel.filterType === 'join') {
                return;
            }
            const { filterModel } = item;
            const { colId } = filterModel;
            const hasColumn = this.advancedFilterExpressionService.getColumnAutocompleteEntries().find(({ key }) => key === colId);
            const columnDetails = this.advancedFilterExpressionService.getColumnDetails(filterModel.colId);
            if (!hasColumn || !columnDetails.column) {
                item.valid = false;
                filterModel.colId = undefined;
                clearOperator(filterModel);
                clearOperand(filterModel);
                return;
            }
            const operatorForType = this.advancedFilterExpressionService.getDataTypeExpressionOperator(columnDetails.baseCellDataType);
            const operator = operatorForType.operators[filterModel.type];
            if (!operator) {
                item.valid = false;
                clearOperator(filterModel);
                clearOperand(filterModel);
                return;
            }
            if (operator.numOperands > 0 && !_.exists(filterModel.filter)) {
                item.valid = false;
                return;
            }
        });
    }
}
__decorate$a([
    RefSelector('eList')
], AdvancedFilterBuilderComp.prototype, "eList", void 0);
__decorate$a([
    RefSelector('eApplyFilterButton')
], AdvancedFilterBuilderComp.prototype, "eApplyFilterButton", void 0);
__decorate$a([
    RefSelector('eCancelFilterButton')
], AdvancedFilterBuilderComp.prototype, "eCancelFilterButton", void 0);
__decorate$a([
    Autowired('filterManager')
], AdvancedFilterBuilderComp.prototype, "filterManager", void 0);
__decorate$a([
    Autowired('advancedFilterService')
], AdvancedFilterBuilderComp.prototype, "advancedFilterService", void 0);
__decorate$a([
    Autowired('advancedFilterExpressionService')
], AdvancedFilterBuilderComp.prototype, "advancedFilterExpressionService", void 0);
__decorate$a([
    Autowired('beans')
], AdvancedFilterBuilderComp.prototype, "beans", void 0);
__decorate$a([
    PostConstruct
], AdvancedFilterBuilderComp.prototype, "postConstruct", null);

var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AdvancedFilterCtrl extends BeanStub {
    constructor(enabled) {
        super();
        this.enabled = enabled;
    }
    postConstruct() {
        this.hasAdvancedFilterParent = !!this.gridOptionsService.get('advancedFilterParent');
        this.ctrlsService.whenReady(() => this.setAdvancedFilterComp());
        this.addManagedListener(this.eventService, Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, ({ enabled }) => this.onEnabledChanged(enabled));
        this.addManagedPropertyListener('advancedFilterParent', () => this.updateComps());
        this.addDestroyFunc(() => {
            this.destroyAdvancedFilterComp();
            this.destroyBean(this.eBuilderComp);
            if (this.eBuilderDialog && this.eBuilderDialog.isAlive()) {
                this.destroyBean(this.eBuilderDialog);
            }
        });
    }
    setupHeaderComp(eCompToInsertBefore) {
        this.eHeaderComp = this.createManagedBean(new AdvancedFilterHeaderComp(this.enabled && !this.hasAdvancedFilterParent));
        eCompToInsertBefore.insertAdjacentElement('beforebegin', this.eHeaderComp.getGui());
    }
    focusHeaderComp() {
        if (this.eHeaderComp) {
            this.eHeaderComp.getFocusableElement().focus();
            return true;
        }
        return false;
    }
    refreshComp() {
        var _a, _b;
        (_a = this.eFilterComp) === null || _a === void 0 ? void 0 : _a.refresh();
        (_b = this.eHeaderComp) === null || _b === void 0 ? void 0 : _b.refresh();
    }
    refreshBuilderComp() {
        var _a;
        (_a = this.eBuilderComp) === null || _a === void 0 ? void 0 : _a.refresh();
    }
    getHeaderHeight() {
        var _a, _b;
        return (_b = (_a = this.eHeaderComp) === null || _a === void 0 ? void 0 : _a.getHeight()) !== null && _b !== void 0 ? _b : 0;
    }
    setInputDisabled(disabled) {
        var _a, _b;
        (_a = this.eFilterComp) === null || _a === void 0 ? void 0 : _a.setInputDisabled(disabled);
        (_b = this.eHeaderComp) === null || _b === void 0 ? void 0 : _b.setInputDisabled(disabled);
    }
    toggleFilterBuilder(source, force) {
        if ((force && this.eBuilderDialog) || (force === false && !this.eBuilderDialog)) {
            // state requested is already active
            return;
        }
        if (this.eBuilderDialog) {
            this.builderDestroySource = source;
            this.destroyBean(this.eBuilderDialog);
            return;
        }
        this.setInputDisabled(true);
        const { width, height, minWidth } = this.getBuilderDialogSize();
        this.eBuilderComp = this.createBean(new AdvancedFilterBuilderComp());
        this.eBuilderDialog = this.createBean(new AgDialog({
            title: this.advancedFilterExpressionService.translate('advancedFilterBuilderTitle'),
            component: this.eBuilderComp,
            width,
            height,
            resizable: true,
            movable: true,
            maximizable: true,
            centered: true,
            closable: true,
            minWidth,
            afterGuiAttached: () => { var _a; return (_a = this.eBuilderComp) === null || _a === void 0 ? void 0 : _a.afterGuiAttached(); }
        }));
        this.dispatchFilterBuilderVisibleChangedEvent(source, true);
        this.eBuilderDialog.addEventListener(AgDialog.EVENT_DESTROYED, () => {
            var _a;
            this.destroyBean(this.eBuilderComp);
            this.eBuilderComp = undefined;
            this.eBuilderDialog = undefined;
            this.setInputDisabled(false);
            this.dispatchEvent({
                type: AdvancedFilterCtrl.EVENT_BUILDER_CLOSED
            });
            this.dispatchFilterBuilderVisibleChangedEvent((_a = this.builderDestroySource) !== null && _a !== void 0 ? _a : 'ui', false);
            this.builderDestroySource = undefined;
        });
    }
    dispatchFilterBuilderVisibleChangedEvent(source, visible) {
        const event = {
            type: Events.EVENT_ADVANCED_FILTER_BUILDER_VISIBLE_CHANGED,
            source,
            visible
        };
        this.eventService.dispatchEvent(event);
    }
    getBuilderDialogSize() {
        var _a, _b;
        const minWidth = (_b = (_a = this.gridOptionsService.get('advancedFilterBuilderParams')) === null || _a === void 0 ? void 0 : _a.minWidth) !== null && _b !== void 0 ? _b : 500;
        const popupParent = this.popupService.getPopupParent();
        const maxWidth = Math.round(_.getAbsoluteWidth(popupParent)) - 2; // assume 1 pixel border
        const maxHeight = Math.round(_.getAbsoluteHeight(popupParent) * 0.75) - 2;
        const width = Math.min(Math.max(600, minWidth), maxWidth);
        const height = Math.min(600, maxHeight);
        return { width, height, minWidth };
    }
    onEnabledChanged(enabled) {
        this.enabled = enabled;
        this.updateComps();
    }
    updateComps() {
        this.setAdvancedFilterComp();
        this.setHeaderCompEnabled();
        this.eventService.dispatchEvent({
            type: Events.EVENT_HEADER_HEIGHT_CHANGED
        });
    }
    setAdvancedFilterComp() {
        this.destroyAdvancedFilterComp();
        if (!this.enabled) {
            return;
        }
        const advancedFilterParent = this.gridOptionsService.get('advancedFilterParent');
        this.hasAdvancedFilterParent = !!advancedFilterParent;
        if (advancedFilterParent) {
            // unmanaged as can be recreated
            const eAdvancedFilterComp = this.createBean(new AdvancedFilterComp());
            const eAdvancedFilterCompGui = eAdvancedFilterComp.getGui();
            const { allThemes } = this.environment.getTheme();
            if (allThemes.length) {
                eAdvancedFilterCompGui.classList.add(...allThemes);
            }
            eAdvancedFilterCompGui.classList.add(this.gridOptionsService.get('enableRtl') ? 'ag-rtl' : 'ag-ltr');
            advancedFilterParent.appendChild(eAdvancedFilterCompGui);
            this.eFilterComp = eAdvancedFilterComp;
        }
    }
    setHeaderCompEnabled() {
        var _a;
        (_a = this.eHeaderComp) === null || _a === void 0 ? void 0 : _a.setEnabled(this.enabled && !this.hasAdvancedFilterParent);
    }
    destroyAdvancedFilterComp() {
        if (this.eFilterComp) {
            _.removeFromParent(this.eFilterComp.getGui());
            this.destroyBean(this.eFilterComp);
        }
    }
}
AdvancedFilterCtrl.EVENT_BUILDER_CLOSED = 'advancedFilterBuilderClosed';
__decorate$b([
    Autowired('focusService')
], AdvancedFilterCtrl.prototype, "focusService", void 0);
__decorate$b([
    Autowired('ctrlsService')
], AdvancedFilterCtrl.prototype, "ctrlsService", void 0);
__decorate$b([
    Autowired('popupService')
], AdvancedFilterCtrl.prototype, "popupService", void 0);
__decorate$b([
    Autowired('advancedFilterExpressionService')
], AdvancedFilterCtrl.prototype, "advancedFilterExpressionService", void 0);
__decorate$b([
    PostConstruct
], AdvancedFilterCtrl.prototype, "postConstruct", null);

var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AdvancedFilterComp extends Component {
    constructor() {
        super(/* html */ `
            <div class="ag-advanced-filter" role="presentation" tabindex="-1">
                <ag-autocomplete ref="eAutocomplete"></ag-autocomplete>
                <button class="ag-button ag-standard-button ag-advanced-filter-apply-button" ref="eApplyFilterButton"></button>
                <button class="ag-advanced-filter-builder-button" ref="eBuilderFilterButton">
                    <span ref="eBuilderFilterButtonIcon" aria-hidden="true"></span>
                    <span class="ag-advanced-filter-builder-button-label" ref="eBuilderFilterButtonLabel"></span>
                </button>
            </div>`);
        this.expressionParser = null;
        this.isApplyDisabled = true;
        this.builderOpen = false;
    }
    postConstruct() {
        this.eAutocomplete
            .setListGenerator((_value, position) => this.generateAutocompleteListParams(position))
            .setValidator(() => this.validateValue())
            .setForceLastSelection((lastSelection, searchString) => this.forceLastSelection(lastSelection, searchString))
            .setInputAriaLabel(this.advancedFilterExpressionService.translate('ariaAdvancedFilterInput'))
            .setListAriaLabel(this.advancedFilterExpressionService.translate('ariaLabelAdvancedFilterAutocomplete'));
        this.refresh();
        this.addManagedListener(this.eAutocomplete, AgAutocomplete.EVENT_VALUE_CHANGED, ({ value }) => this.onValueChanged(value));
        this.addManagedListener(this.eAutocomplete, AgAutocomplete.EVENT_VALUE_CONFIRMED, ({ isValid }) => this.onValueConfirmed(isValid));
        this.addManagedListener(this.eAutocomplete, AgAutocomplete.EVENT_OPTION_SELECTED, ({ position, updateEntry, autocompleteType }) => this.onOptionSelected(position, updateEntry, autocompleteType));
        this.addManagedListener(this.eAutocomplete, AgAutocomplete.EVENT_VALID_CHANGED, ({ isValid, validationMessage }) => this.onValidChanged(isValid, validationMessage));
        this.setupApplyButton();
        this.setupBuilderButton();
    }
    refresh() {
        const expression = this.advancedFilterService.getExpressionDisplayValue();
        this.eAutocomplete.setValue({ value: expression !== null && expression !== void 0 ? expression : '', position: expression === null || expression === void 0 ? void 0 : expression.length, updateListOnlyIfOpen: true });
    }
    setInputDisabled(disabled) {
        this.eAutocomplete.setInputDisabled(disabled);
        _.setDisabled(this.eApplyFilterButton, disabled || this.isApplyDisabled);
    }
    getTooltipParams() {
        const res = super.getTooltipParams();
        res.location = 'advancedFilter';
        return res;
    }
    setupApplyButton() {
        this.eApplyFilterButton.innerText = this.advancedFilterExpressionService.translate('advancedFilterApply');
        this.activateTabIndex([this.eApplyFilterButton]);
        this.addManagedListener(this.eApplyFilterButton, 'click', () => this.onValueConfirmed(this.eAutocomplete.isValid()));
        _.setDisabled(this.eApplyFilterButton, this.isApplyDisabled);
    }
    setupBuilderButton() {
        this.eBuilderFilterButtonIcon.appendChild(_.createIconNoSpan('advancedFilterBuilder', this.gridOptionsService));
        this.eBuilderFilterButtonLabel.innerText = this.advancedFilterExpressionService.translate('advancedFilterBuilder');
        this.activateTabIndex([this.eBuilderFilterButton]);
        this.addManagedListener(this.eBuilderFilterButton, 'click', () => this.openBuilder());
        this.addManagedListener(this.advancedFilterService.getCtrl(), AdvancedFilterCtrl.EVENT_BUILDER_CLOSED, () => this.closeBuilder());
    }
    onValueChanged(value) {
        var _a;
        value = _.makeNull(value);
        this.advancedFilterService.setExpressionDisplayValue(value);
        this.expressionParser = this.advancedFilterService.createExpressionParser(value);
        const updatedExpression = (_a = this.expressionParser) === null || _a === void 0 ? void 0 : _a.parseExpression();
        if (updatedExpression && updatedExpression !== value) {
            this.eAutocomplete.setValue({ value: updatedExpression, silent: true, restoreFocus: true });
        }
    }
    onValueConfirmed(isValid) {
        if (!isValid || this.isApplyDisabled) {
            return;
        }
        _.setDisabled(this.eApplyFilterButton, true);
        this.advancedFilterService.applyExpression();
        this.filterManager.onFilterChanged({ source: 'advancedFilter' });
    }
    onOptionSelected(position, updateEntry, type) {
        const { updatedValue, updatedPosition, hideAutocomplete } = this.updateExpression(position, updateEntry, type);
        this.eAutocomplete.setValue({
            value: updatedValue,
            position: updatedPosition,
            updateListOnlyIfOpen: hideAutocomplete,
            restoreFocus: true
        });
    }
    validateValue() {
        var _a, _b, _c;
        return ((_a = this.expressionParser) === null || _a === void 0 ? void 0 : _a.isValid()) ? null : ((_c = (_b = this.expressionParser) === null || _b === void 0 ? void 0 : _b.getValidationMessage()) !== null && _c !== void 0 ? _c : null);
    }
    onValidChanged(isValid, validationMessage) {
        this.isApplyDisabled = !isValid || this.advancedFilterService.isCurrentExpressionApplied();
        _.setDisabled(this.eApplyFilterButton, this.isApplyDisabled);
        this.setTooltip(validationMessage, 1000);
    }
    generateAutocompleteListParams(position) {
        return this.expressionParser
            ? this.expressionParser.getAutocompleteListParams(position)
            : this.advancedFilterExpressionService.getDefaultAutocompleteListParams('');
    }
    updateExpression(position, updateEntry, type) {
        var _a, _b;
        this.advancedFilterExpressionService.updateAutocompleteCache(updateEntry, type);
        return (_b = (_a = this.expressionParser) === null || _a === void 0 ? void 0 : _a.updateExpression(position, updateEntry, type)) !== null && _b !== void 0 ? _b : this.advancedFilterService.getDefaultExpression(updateEntry);
    }
    forceLastSelection({ key, displayValue }, searchString) {
        return !!searchString.toLocaleLowerCase().match(`^${(displayValue !== null && displayValue !== void 0 ? displayValue : key).toLocaleLowerCase()}\\s*$`);
    }
    openBuilder() {
        if (this.builderOpen) {
            return;
        }
        this.builderOpen = true;
        _.setDisabled(this.eBuilderFilterButton, true);
        this.advancedFilterService.getCtrl().toggleFilterBuilder('ui');
    }
    closeBuilder() {
        if (!this.builderOpen) {
            return;
        }
        this.builderOpen = false;
        _.setDisabled(this.eBuilderFilterButton, false);
        this.eBuilderFilterButton.focus();
    }
}
__decorate$c([
    RefSelector('eAutocomplete')
], AdvancedFilterComp.prototype, "eAutocomplete", void 0);
__decorate$c([
    RefSelector('eApplyFilterButton')
], AdvancedFilterComp.prototype, "eApplyFilterButton", void 0);
__decorate$c([
    RefSelector('eBuilderFilterButton')
], AdvancedFilterComp.prototype, "eBuilderFilterButton", void 0);
__decorate$c([
    RefSelector('eBuilderFilterButtonIcon')
], AdvancedFilterComp.prototype, "eBuilderFilterButtonIcon", void 0);
__decorate$c([
    RefSelector('eBuilderFilterButtonLabel')
], AdvancedFilterComp.prototype, "eBuilderFilterButtonLabel", void 0);
__decorate$c([
    Autowired('advancedFilterService')
], AdvancedFilterComp.prototype, "advancedFilterService", void 0);
__decorate$c([
    Autowired('advancedFilterExpressionService')
], AdvancedFilterComp.prototype, "advancedFilterExpressionService", void 0);
__decorate$c([
    Autowired('filterManager')
], AdvancedFilterComp.prototype, "filterManager", void 0);
__decorate$c([
    PostConstruct
], AdvancedFilterComp.prototype, "postConstruct", null);

const ADVANCED_FILTER_LOCALE_TEXT = {
    ariaAdvancedFilterBuilderItem: (variableValues) => `${variableValues[0]}. Level ${variableValues[1]}. Press ENTER to edit.`,
    ariaAdvancedFilterBuilderItemValidation: (variableValues) => `${variableValues[0]}. Level ${variableValues[1]}. ${variableValues[2]} Press ENTER to edit.`,
    ariaAdvancedFilterBuilderList: 'Advanced Filter Builder List',
    ariaAdvancedFilterBuilderFilterItem: 'Filter Condition',
    ariaAdvancedFilterBuilderGroupItem: 'Filter Group',
    ariaAdvancedFilterBuilderColumn: 'Column',
    ariaAdvancedFilterBuilderOption: 'Option',
    ariaAdvancedFilterBuilderValue: 'Value',
    ariaAdvancedFilterBuilderJoinOperator: 'Join Operator',
    ariaAdvancedFilterInput: 'Advanced Filter Input',
    ariaLabelAdvancedFilterAutocomplete: 'Advanced Filter Autocomplete',
    advancedFilterContains: 'contains',
    advancedFilterNotContains: 'does not contain',
    advancedFilterTextEquals: 'equals',
    advancedFilterTextNotEqual: 'does not equal',
    advancedFilterStartsWith: 'begins with',
    advancedFilterEndsWith: 'ends with',
    advancedFilterBlank: 'is blank',
    advancedFilterNotBlank: 'is not blank',
    advancedFilterEquals: '=',
    advancedFilterNotEqual: '!=',
    advancedFilterGreaterThan: '>',
    advancedFilterGreaterThanOrEqual: '>=',
    advancedFilterLessThan: '<',
    advancedFilterLessThanOrEqual: '<=',
    advancedFilterTrue: 'is true',
    advancedFilterFalse: 'is false',
    advancedFilterAnd: 'AND',
    advancedFilterOr: 'OR',
    advancedFilterApply: 'Apply',
    advancedFilterBuilder: 'Builder',
    advancedFilterValidationMissingColumn: 'Column is missing',
    advancedFilterValidationMissingOption: 'Option is missing',
    advancedFilterValidationMissingValue: 'Value is missing',
    advancedFilterValidationInvalidColumn: 'Column not found',
    advancedFilterValidationInvalidOption: 'Option not found',
    advancedFilterValidationMissingQuote: 'Value is missing an end quote',
    advancedFilterValidationNotANumber: 'Value is not a number',
    advancedFilterValidationInvalidDate: 'Value is not a valid date',
    advancedFilterValidationMissingCondition: 'Condition is missing',
    advancedFilterValidationJoinOperatorMismatch: 'Join operators within a condition must be the same',
    advancedFilterValidationInvalidJoinOperator: 'Join operator not found',
    advancedFilterValidationMissingEndBracket: 'Missing end bracket',
    advancedFilterValidationExtraEndBracket: 'Too many end brackets',
    advancedFilterValidationMessage: (variableValues) => `Expression has an error. ${variableValues[0]} - ${variableValues[1]}.`,
    advancedFilterValidationMessageAtEnd: (variableValues) => `Expression has an error. ${variableValues[0]} at end of expression.`,
    advancedFilterBuilderTitle: 'Advanced Filter',
    advancedFilterBuilderApply: 'Apply',
    advancedFilterBuilderCancel: 'Cancel',
    advancedFilterBuilderAddButtonTooltip: 'Add Filter or Group',
    advancedFilterBuilderRemoveButtonTooltip: 'Remove',
    advancedFilterBuilderMoveUpButtonTooltip: 'Move Up',
    advancedFilterBuilderMoveDownButtonTooltip: 'Move Down',
    advancedFilterBuilderAddJoin: 'Add Group',
    advancedFilterBuilderAddCondition: 'Add Filter',
    advancedFilterBuilderSelectColumn: 'Select a column',
    advancedFilterBuilderSelectOption: 'Select an option',
    advancedFilterBuilderEnterValue: 'Enter a value...',
    advancedFilterBuilderValidationAlreadyApplied: 'Current filter already applied.',
    advancedFilterBuilderValidationIncomplete: 'Not all conditions are complete.',
    advancedFilterBuilderValidationSelectColumn: 'Must select a column.',
    advancedFilterBuilderValidationSelectOption: 'Must select an option.',
    advancedFilterBuilderValidationEnterValue: 'Must enter a value.',
};

function getSearchString(value, position, endPosition) {
    if (!value) {
        return '';
    }
    const numChars = endPosition - position;
    return numChars ? value.slice(0, value.length - numChars) : value;
}
function updateExpression(expression, startPosition, endPosition, updatedValuePart, appendSpace, appendQuote, empty) {
    const secondPartStartPosition = endPosition + (!expression.length || empty ? 0 : 1);
    let positionOffset = 0;
    if (appendSpace) {
        if (expression[secondPartStartPosition] === ' ') {
            // already a space, just move the position
            positionOffset = 1;
        }
        else {
            updatedValuePart += ' ';
            if (appendQuote) {
                updatedValuePart += `"`;
            }
        }
    }
    const updatedValue = expression.slice(0, startPosition) + updatedValuePart + expression.slice(secondPartStartPosition);
    return { updatedValue, updatedPosition: startPosition + updatedValuePart.length + positionOffset };
}
function findStartPosition(expression, position, endPosition) {
    let startPosition = position;
    while (startPosition < endPosition) {
        const char = expression[startPosition];
        if (char !== ' ') {
            break;
        }
        startPosition++;
    }
    return startPosition;
}
function findEndPosition(expression, position, includeCloseBracket, isStartPositionUnknown) {
    let endPosition = position;
    let isEmpty = false;
    while (endPosition < expression.length) {
        const char = expression[endPosition];
        if (char === '(') {
            if (isStartPositionUnknown && expression[endPosition - 1] === ' ') {
                isEmpty = true;
            }
            else {
                endPosition = endPosition - 1;
            }
            break;
        }
        else if (char === ' ' || (includeCloseBracket && char === ')')) {
            endPosition = endPosition - 1;
            break;
        }
        endPosition++;
    }
    return { endPosition, isEmpty };
}
function checkAndUpdateExpression(params, userValue, displayValue, endPosition) {
    if (displayValue !== userValue) {
        params.expression = updateExpression(params.expression, endPosition - userValue.length + 1, endPosition, displayValue).updatedValue;
    }
}
function escapeQuotes(value) {
    return value.replace(/(['"])/, '\\$1');
}

class ColumnParser {
    constructor(params, startPosition) {
        this.params = params;
        this.startPosition = startPosition;
        this.type = 'column';
        this.valid = true;
        this.hasStartChar = false;
        this.hasEndChar = false;
        this.colName = '';
    }
    parse(char, position) {
        if (char === ColFilterExpressionParser.COL_START_CHAR && !this.colName) {
            this.hasStartChar = true;
        }
        else if (char === ColFilterExpressionParser.COL_END_CHAR && this.hasStartChar) {
            const isMatch = this.parseColumn(false, position);
            if (isMatch) {
                this.hasEndChar = true;
                return false;
            }
            else {
                this.colName += char;
            }
        }
        else {
            this.colName += char;
        }
        return undefined;
    }
    getDisplayValue() {
        return (this.hasStartChar ? ColFilterExpressionParser.COL_START_CHAR : '') +
            this.colName +
            (this.hasEndChar ? ColFilterExpressionParser.COL_END_CHAR : '');
    }
    getColId() {
        return this.colId;
    }
    complete(position) {
        this.parseColumn(true, position);
    }
    getValidationError() {
        var _a;
        return this.valid ? null : {
            message: this.params.advancedFilterExpressionService.translate('advancedFilterValidationInvalidColumn'),
            startPosition: this.startPosition,
            endPosition: (_a = this.endPosition) !== null && _a !== void 0 ? _a : this.params.expression.length - 1
        };
    }
    parseColumn(fromComplete, endPosition) {
        var _a;
        this.endPosition = endPosition;
        const colValue = this.params.advancedFilterExpressionService.getColId(this.colName);
        if (colValue && this.hasStartChar) {
            this.colId = colValue.colId;
            checkAndUpdateExpression(this.params, this.colName, colValue.columnName, endPosition - 1);
            this.colName = colValue.columnName;
            this.column = this.params.columnModel.getPrimaryColumn(this.colId);
            if (this.column) {
                this.baseCellDataType = (_a = this.params.dataTypeService.getBaseDataType(this.column)) !== null && _a !== void 0 ? _a : 'text';
                return true;
            }
        }
        if (fromComplete) {
            this.valid = false;
        }
        this.baseCellDataType = 'text';
        return false;
    }
}
class OperatorParser {
    constructor(params, startPosition, baseCellDataType) {
        this.params = params;
        this.startPosition = startPosition;
        this.baseCellDataType = baseCellDataType;
        this.type = 'operator';
        this.valid = true;
        this.expectedNumOperands = 0;
        this.operator = '';
    }
    parse(char, position) {
        if (char === ' ' || char === ')') {
            const isMatch = this.parseOperator(false, position - 1);
            if (isMatch) {
                return true;
            }
            else {
                this.operator += char;
            }
        }
        else {
            this.operator += char;
        }
        return undefined;
    }
    complete(position) {
        this.parseOperator(true, position);
    }
    getValidationError() {
        var _a;
        return this.valid ? null : {
            message: this.params.advancedFilterExpressionService.translate('advancedFilterValidationInvalidOption'),
            startPosition: this.startPosition,
            endPosition: (_a = this.endPosition) !== null && _a !== void 0 ? _a : this.params.expression.length - 1
        };
    }
    getDisplayValue() {
        return this.operator;
    }
    getOperatorKey() {
        return this.parsedOperator;
    }
    parseOperator(fromComplete, endPosition) {
        const operatorForType = this.params.advancedFilterExpressionService.getDataTypeExpressionOperator(this.baseCellDataType);
        const parsedOperator = operatorForType.findOperator(this.operator);
        this.endPosition = endPosition;
        if (parsedOperator) {
            this.parsedOperator = parsedOperator;
            const operator = operatorForType.operators[parsedOperator];
            this.expectedNumOperands = operator.numOperands;
            const operatorDisplayValue = operator.displayValue;
            checkAndUpdateExpression(this.params, this.operator, operatorDisplayValue, endPosition);
            this.operator = operatorDisplayValue;
            return true;
        }
        const isPartialMatch = parsedOperator === null;
        if (fromComplete || !isPartialMatch) {
            this.valid = false;
        }
        return false;
    }
}
class OperandParser {
    constructor(params, startPosition, baseCellDataType, column) {
        this.params = params;
        this.startPosition = startPosition;
        this.baseCellDataType = baseCellDataType;
        this.column = column;
        this.type = 'operand';
        this.valid = true;
        this.operand = '';
        this.validationMessage = null;
    }
    parse(char, position) {
        if (char === ' ') {
            if (this.quotes) {
                this.operand += char;
            }
            else {
                this.parseOperand(false, position);
                return true;
            }
        }
        else if (char === ')') {
            if (this.baseCellDataType === 'number' || !this.quotes) {
                this.parseOperand(false, position - 1);
                return true;
            }
            else {
                this.operand += char;
            }
        }
        else if (!this.operand && !this.quotes && (char === `'` || char === `"`)) {
            this.quotes = char;
        }
        else if (this.quotes && char === this.quotes) {
            this.parseOperand(false, position);
            return false;
        }
        else {
            this.operand += char;
        }
        return undefined;
    }
    complete(position) {
        this.parseOperand(true, position);
    }
    getValidationError() {
        var _a;
        return this.validationMessage ? {
            message: this.validationMessage,
            startPosition: this.startPosition,
            endPosition: (_a = this.endPosition) !== null && _a !== void 0 ? _a : this.params.expression.length - 1
        } : null;
    }
    getRawValue() {
        return this.operand;
    }
    getModelValue() {
        return this.modelValue;
    }
    parseOperand(fromComplete, position) {
        const { advancedFilterExpressionService } = this.params;
        this.endPosition = position;
        this.modelValue = this.operand;
        if (fromComplete && this.quotes) {
            // missing end quote
            this.valid = false;
            this.validationMessage = advancedFilterExpressionService.translate('advancedFilterValidationMissingQuote');
        }
        else if (this.modelValue === '') {
            this.valid = false;
            this.validationMessage = advancedFilterExpressionService.translate('advancedFilterValidationMissingValue');
        }
        else {
            const modelValue = advancedFilterExpressionService.getOperandModelValue(this.operand, this.baseCellDataType, this.column);
            if (modelValue != null) {
                this.modelValue = modelValue;
            }
            switch (this.baseCellDataType) {
                case 'number':
                    if (this.quotes || isNaN(this.modelValue)) {
                        this.valid = false;
                        this.validationMessage = advancedFilterExpressionService.translate('advancedFilterValidationNotANumber');
                    }
                    break;
                case 'date':
                case 'dateString':
                    if (modelValue == null) {
                        this.valid = false;
                        this.validationMessage = advancedFilterExpressionService.translate('advancedFilterValidationInvalidDate');
                    }
                    break;
            }
        }
    }
}
class ColFilterExpressionParser {
    constructor(params, startPosition) {
        this.params = params;
        this.startPosition = startPosition;
        this.isAwaiting = true;
    }
    parseExpression() {
        var _a, _b;
        let i = this.startPosition;
        const { expression } = this.params;
        while (i < expression.length) {
            const char = expression[i];
            if (char === ' ' && this.isAwaiting) ;
            else {
                this.isAwaiting = false;
                if (!this.parser) {
                    let parser;
                    if (!this.columnParser) {
                        this.columnParser = new ColumnParser(this.params, i);
                        parser = this.columnParser;
                    }
                    else if (!this.operatorParser) {
                        this.operatorParser = new OperatorParser(this.params, i, this.columnParser.baseCellDataType);
                        parser = this.operatorParser;
                    }
                    else {
                        this.operandParser = new OperandParser(this.params, i, this.columnParser.baseCellDataType, this.columnParser.column);
                        parser = this.operandParser;
                    }
                    this.parser = parser;
                }
                const hasCompletedOnPrevChar = this.parser.parse(char, i);
                if (hasCompletedOnPrevChar != null) {
                    if (this.isComplete()) {
                        return this.returnEndPosition(hasCompletedOnPrevChar ? i - 1 : i, true);
                    }
                    this.parser = undefined;
                    this.isAwaiting = true;
                }
            }
            i++;
        }
        (_b = (_a = this.parser) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a, i - 1);
        return this.returnEndPosition(i);
    }
    isValid() {
        return this.isComplete() && this.columnParser.valid && this.operatorParser.valid && (!this.operandParser || this.operandParser.valid);
    }
    getValidationError() {
        var _a, _b, _c, _d, _e;
        const validationError = (_d = (_b = (_a = this.columnParser) === null || _a === void 0 ? void 0 : _a.getValidationError()) !== null && _b !== void 0 ? _b : (_c = this.operatorParser) === null || _c === void 0 ? void 0 : _c.getValidationError()) !== null && _d !== void 0 ? _d : (_e = this.operandParser) === null || _e === void 0 ? void 0 : _e.getValidationError();
        if (validationError) {
            return validationError;
        }
        const endPosition = this.params.expression.length;
        let translateKey;
        if (!this.columnParser) {
            translateKey = 'advancedFilterValidationMissingColumn';
        }
        else if (!this.operatorParser) {
            translateKey = 'advancedFilterValidationMissingOption';
        }
        else if (this.operatorParser.expectedNumOperands && !this.operandParser) {
            translateKey = 'advancedFilterValidationMissingValue';
        }
        if (translateKey) {
            return {
                message: this.params.advancedFilterExpressionService.translate(translateKey),
                startPosition: endPosition,
                endPosition
            };
        }
        return null;
    }
    getFunction(params) {
        var _a, _b;
        const colId = this.columnParser.getColId();
        const escapedColId = escapeQuotes(colId);
        const operator = (_a = this.operatorParser) === null || _a === void 0 ? void 0 : _a.getOperatorKey();
        const { operators, evaluatorParams, operands } = params;
        const operatorForColumn = this.params.advancedFilterExpressionService.getExpressionOperator(this.columnParser.baseCellDataType, operator);
        const operatorIndex = this.addToListAndGetIndex(operators, operatorForColumn);
        const evaluatorParamsForColumn = this.params.advancedFilterExpressionService.getExpressionEvaluatorParams(colId);
        const evaluatorParamsIndex = this.addToListAndGetIndex(evaluatorParams, evaluatorParamsForColumn);
        let operand;
        if (((_b = this.operatorParser) === null || _b === void 0 ? void 0 : _b.expectedNumOperands) === 0) {
            operand = '';
        }
        else {
            const operandIndex = this.addToListAndGetIndex(operands, this.getOperandValue());
            operand = `, params.operands[${operandIndex}]`;
        }
        return `params.operators[${operatorIndex}].evaluator(expressionProxy.getValue('${escapedColId}', node), node, params.evaluatorParams[${evaluatorParamsIndex}]${operand})`;
    }
    getAutocompleteListParams(position) {
        if (this.isColumnPosition(position)) {
            return this.getColumnAutocompleteListParams(position);
        }
        if (this.isOperatorPosition(position)) {
            return this.getOperatorAutocompleteListParams(position);
        }
        if (this.isBeyondEndPosition(position)) {
            return undefined;
        }
        return { enabled: false };
    }
    updateExpression(position, updateEntry, type) {
        var _a, _b, _c, _d, _e;
        const { expression } = this.params;
        if (this.isColumnPosition(position)) {
            return updateExpression(this.params.expression, this.startPosition, ((_a = this.columnParser) === null || _a === void 0 ? void 0 : _a.getColId()) ? this.columnParser.endPosition : findEndPosition(expression, position).endPosition, this.params.advancedFilterExpressionService.getColumnValue(updateEntry), true);
        }
        else if (this.isOperatorPosition(position)) {
            const baseCellDataType = this.getBaseCellDataTypeFromOperatorAutocompleteType(type);
            const hasOperand = this.hasOperand(baseCellDataType, updateEntry.key);
            const doesOperandNeedQuotes = hasOperand && this.doesOperandNeedQuotes(baseCellDataType);
            let update;
            if (((_b = this.operatorParser) === null || _b === void 0 ? void 0 : _b.startPosition) != null && position < this.operatorParser.startPosition) {
                // in between multiple spaces, just insert direct
                update = updateExpression(expression, position, position, (_c = updateEntry.displayValue) !== null && _c !== void 0 ? _c : updateEntry.key, hasOperand, doesOperandNeedQuotes);
            }
            else {
                let endPosition;
                let empty = false;
                if ((_d = this.operatorParser) === null || _d === void 0 ? void 0 : _d.getOperatorKey()) {
                    endPosition = this.operatorParser.endPosition;
                }
                else {
                    const { endPosition: calculatedEndPosition, isEmpty } = findEndPosition(expression, position, true, true);
                    endPosition = calculatedEndPosition;
                    empty = isEmpty;
                }
                update = updateExpression(expression, findStartPosition(expression, this.columnParser.endPosition + 1, endPosition), endPosition, (_e = updateEntry.displayValue) !== null && _e !== void 0 ? _e : updateEntry.key, hasOperand, doesOperandNeedQuotes, empty);
            }
            return Object.assign(Object.assign({}, update), { hideAutocomplete: !hasOperand });
        }
        return null;
    }
    getModel() {
        const colId = this.columnParser.getColId();
        const model = {
            filterType: this.columnParser.baseCellDataType,
            colId,
            type: this.operatorParser.getOperatorKey(),
        };
        if (this.operatorParser.expectedNumOperands) {
            model.filter = this.operandParser.getModelValue();
        }
        return model;
    }
    getOperandValue() {
        let operand = this.operandParser.getRawValue();
        const { baseCellDataType, column } = this.columnParser;
        switch (baseCellDataType) {
            case 'number':
                operand = Number(operand);
                break;
            case 'date':
            case 'dateString':
                operand = this.params.valueParserService.parseValue(column, null, operand, undefined);
                break;
        }
        if (baseCellDataType === 'dateString') {
            return this.params.dataTypeService.getDateParserFunction(column)(operand);
        }
        return operand;
    }
    isComplete() {
        return !!(this.operatorParser && (!this.operatorParser.expectedNumOperands || (this.operatorParser.expectedNumOperands && this.operandParser)));
    }
    isColumnPosition(position) {
        return !this.columnParser || this.columnParser.endPosition == null || position <= this.columnParser.endPosition + 1;
    }
    isOperatorPosition(position) {
        return !this.operatorParser || this.operatorParser.endPosition == null || position <= this.operatorParser.endPosition + 1;
    }
    isBeyondEndPosition(position) {
        return this.isComplete() && this.endPosition != null && position > this.endPosition + 1 && this.endPosition + 1 < this.params.expression.length;
    }
    returnEndPosition(returnPosition, treatAsEnd) {
        this.endPosition = treatAsEnd ? returnPosition : returnPosition - 1;
        return returnPosition;
    }
    getColumnAutocompleteListParams(position) {
        return this.params.advancedFilterExpressionService.generateAutocompleteListParams(this.params.advancedFilterExpressionService.getColumnAutocompleteEntries(), 'column', this.getColumnSearchString(position));
    }
    getColumnSearchString(position) {
        var _a, _b, _c, _d, _e;
        const columnName = (_b = (_a = this.columnParser) === null || _a === void 0 ? void 0 : _a.getDisplayValue()) !== null && _b !== void 0 ? _b : '';
        const searchString = getSearchString(columnName, position, ((_c = this.columnParser) === null || _c === void 0 ? void 0 : _c.endPosition) == null
            ? this.params.expression.length
            : (this.columnParser.endPosition + 1));
        const containsStartChar = ((_d = this.columnParser) === null || _d === void 0 ? void 0 : _d.hasStartChar) && searchString.length > 0;
        const containsEndChar = ((_e = this.columnParser) === null || _e === void 0 ? void 0 : _e.hasEndChar) && searchString.length === columnName.length + 2;
        if (containsStartChar) {
            return searchString.slice(1, containsEndChar ? -1 : undefined);
        }
        return searchString;
    }
    getOperatorAutocompleteListParams(position) {
        var _a, _b, _c, _d, _e;
        const column = (_a = this.columnParser) === null || _a === void 0 ? void 0 : _a.column;
        if (!column) {
            return { enabled: false };
        }
        const baseCellDataType = this.columnParser.baseCellDataType;
        const searchString = ((_b = this.operatorParser) === null || _b === void 0 ? void 0 : _b.startPosition) != null && position < this.operatorParser.startPosition ? '' : getSearchString((_d = (_c = this.operatorParser) === null || _c === void 0 ? void 0 : _c.getDisplayValue()) !== null && _d !== void 0 ? _d : '', position, ((_e = this.operatorParser) === null || _e === void 0 ? void 0 : _e.endPosition) == null ? this.params.expression.length : (this.operatorParser.endPosition + 1));
        return this.params.advancedFilterExpressionService.generateAutocompleteListParams(this.params.advancedFilterExpressionService.getOperatorAutocompleteEntries(column, baseCellDataType), `operator-${baseCellDataType}`, searchString);
    }
    getBaseCellDataTypeFromOperatorAutocompleteType(type) {
        return type === null || type === void 0 ? void 0 : type.replace('operator-', '');
    }
    hasOperand(baseCellDataType, operator) {
        var _a, _b;
        return !baseCellDataType ||
            !operator ||
            ((_b = (_a = this.params.advancedFilterExpressionService.getExpressionOperator(baseCellDataType, operator)) === null || _a === void 0 ? void 0 : _a.numOperands) !== null && _b !== void 0 ? _b : 0) > 0;
    }
    doesOperandNeedQuotes(baseCellDataType) {
        return baseCellDataType !== 'number';
    }
    addToListAndGetIndex(list, value) {
        const index = list.length;
        list.push(value);
        return index;
    }
}
ColFilterExpressionParser.COL_START_CHAR = '[';
ColFilterExpressionParser.COL_END_CHAR = ']';

// null = partial match, undefined = no match
function findMatch(searchValue, values, getDisplayValue) {
    let partialMatch = false;
    const searchValueLowerCase = searchValue.toLocaleLowerCase();
    const partialSearchValue = searchValueLowerCase + ' ';
    const parsedValue = Object.entries(values).find(([_key, value]) => {
        const displayValueLowerCase = getDisplayValue(value).toLocaleLowerCase();
        if (displayValueLowerCase.startsWith(partialSearchValue)) {
            partialMatch = true;
        }
        return displayValueLowerCase === searchValueLowerCase;
    });
    if (parsedValue) {
        return parsedValue[0];
    }
    else if (partialMatch) {
        return null;
    }
    else {
        return undefined;
    }
}
function getEntries(operators, activeOperatorKeys) {
    const keys = activeOperatorKeys !== null && activeOperatorKeys !== void 0 ? activeOperatorKeys : Object.keys(operators);
    return keys.map(key => ({
        key,
        displayValue: operators[key].displayValue
    }));
}
class TextFilterExpressionOperators {
    constructor(params) {
        this.params = params;
        this.initOperators();
    }
    getEntries(activeOperators) {
        return getEntries(this.operators, activeOperators);
    }
    findOperator(displayValue) {
        return findMatch(displayValue, this.operators, ({ displayValue }) => displayValue);
    }
    initOperators() {
        const { translate } = this.params;
        this.operators = {
            contains: {
                displayValue: translate('advancedFilterContains'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, false, (v, o) => v.includes(o)),
                numOperands: 1
            },
            notContains: {
                displayValue: translate('advancedFilterNotContains'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, true, (v, o) => !v.includes(o)),
                numOperands: 1
            },
            equals: {
                displayValue: translate('advancedFilterTextEquals'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, false, (v, o) => v === o),
                numOperands: 1
            },
            notEqual: {
                displayValue: translate('advancedFilterTextNotEqual'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, true, (v, o) => v != o),
                numOperands: 1
            },
            startsWith: {
                displayValue: translate('advancedFilterStartsWith'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, false, (v, o) => v.startsWith(o)),
                numOperands: 1
            },
            endsWith: {
                displayValue: translate('advancedFilterEndsWith'),
                evaluator: (value, node, params, operand1) => this.evaluateExpression(value, node, params, operand1, false, (v, o) => v.endsWith(o)),
                numOperands: 1
            },
            blank: {
                displayValue: translate('advancedFilterBlank'),
                evaluator: (value) => value == null || (typeof value === 'string' && value.trim().length === 0),
                numOperands: 0
            },
            notBlank: {
                displayValue: translate('advancedFilterNotBlank'),
                evaluator: (value) => value != null && (typeof value !== 'string' || value.trim().length > 0),
                numOperands: 0
            },
        };
    }
    evaluateExpression(value, node, params, operand, nullsMatch, expression) {
        if (value == null) {
            return nullsMatch;
        }
        return params.caseSensitive
            ? expression(params.valueConverter(value, node), operand)
            : expression(params.valueConverter(value, node).toLocaleLowerCase(), operand.toLocaleLowerCase());
    }
}
class ScalarFilterExpressionOperators {
    constructor(params) {
        this.params = params;
        this.initOperators();
    }
    getEntries(activeOperators) {
        return getEntries(this.operators, activeOperators);
    }
    findOperator(displayValue) {
        return findMatch(displayValue, this.operators, ({ displayValue }) => displayValue);
    }
    initOperators() {
        const { translate, equals } = this.params;
        this.operators = {
            equals: {
                displayValue: translate('advancedFilterEquals'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInEquals, equals),
                numOperands: 1
            },
            notEqual: {
                displayValue: translate('advancedFilterNotEqual'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInEquals, (v, o) => !equals(v, o)),
                numOperands: 1
            },
            greaterThan: {
                displayValue: translate('advancedFilterGreaterThan'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInGreaterThan, (v, o) => v > o),
                numOperands: 1
            },
            greaterThanOrEqual: {
                displayValue: translate('advancedFilterGreaterThanOrEqual'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInGreaterThan, (v, o) => v >= o),
                numOperands: 1
            },
            lessThan: {
                displayValue: translate('advancedFilterLessThan'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInLessThan, (v, o) => v < o),
                numOperands: 1
            },
            lessThanOrEqual: {
                displayValue: translate('advancedFilterLessThanOrEqual'),
                evaluator: (value, node, params, operand1) => this.evaluateSingleOperandExpression(value, node, params, operand1, !!params.includeBlanksInLessThan, (v, o) => v <= o),
                numOperands: 1
            },
            blank: {
                displayValue: translate('advancedFilterBlank'),
                evaluator: (value) => value == null,
                numOperands: 0
            },
            notBlank: {
                displayValue: translate('advancedFilterNotBlank'),
                evaluator: (value) => value != null,
                numOperands: 0
            }
        };
    }
    evaluateSingleOperandExpression(value, node, params, operand, nullsMatch, expression) {
        if (value == null) {
            return nullsMatch;
        }
        return expression(params.valueConverter(value, node), operand);
    }
}
class BooleanFilterExpressionOperators {
    constructor(params) {
        this.params = params;
        this.initOperators();
    }
    getEntries(activeOperators) {
        return getEntries(this.operators, activeOperators);
    }
    findOperator(displayValue) {
        return findMatch(displayValue, this.operators, ({ displayValue }) => displayValue);
    }
    initOperators() {
        const { translate } = this.params;
        this.operators = {
            true: {
                displayValue: translate('advancedFilterTrue'),
                evaluator: (value) => !!value,
                numOperands: 0
            },
            false: {
                displayValue: translate('advancedFilterFalse'),
                evaluator: (value) => value === false,
                numOperands: 0
            },
            blank: {
                displayValue: translate('advancedFilterBlank'),
                evaluator: (value) => value == null,
                numOperands: 0
            },
            notBlank: {
                displayValue: translate('advancedFilterNotBlank'),
                evaluator: (value) => value != null,
                numOperands: 0
            }
        };
    }
}

var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let AdvancedFilterExpressionService = class AdvancedFilterExpressionService extends BeanStub {
    constructor() {
        super(...arguments);
        this.columnNameToIdMap = {};
        this.columnAutocompleteEntries = null;
        this.expressionEvaluatorParams = {};
    }
    postConstruct() {
        this.expressionJoinOperators = this.generateExpressionJoinOperators();
        this.expressionOperators = this.generateExpressionOperators();
    }
    parseJoinOperator(model) {
        var _a;
        const { type } = model;
        return (_a = this.expressionJoinOperators[type]) !== null && _a !== void 0 ? _a : type;
    }
    getColumnDisplayValue(model) {
        const { colId } = model;
        const columnEntries = this.getColumnAutocompleteEntries();
        const columnEntry = columnEntries.find(({ key }) => key === colId);
        let columnName;
        if (columnEntry) {
            columnName = columnEntry.displayValue;
            this.columnNameToIdMap[columnName.toLocaleUpperCase()] = { colId, columnName };
        }
        else {
            columnName = colId;
        }
        return columnName;
    }
    getOperatorDisplayValue(model) {
        var _a, _b;
        return (_b = (_a = this.getExpressionOperator(model.filterType, model.type)) === null || _a === void 0 ? void 0 : _a.displayValue) !== null && _b !== void 0 ? _b : model.type;
    }
    getOperandModelValue(operand, baseCellDataType, column) {
        var _a;
        switch (baseCellDataType) {
            case 'number':
                return _.exists(operand) ? Number(operand) : null;
            case 'date':
                return _.serialiseDate(this.valueParserService.parseValue(column, null, operand, undefined), false);
            case 'dateString':
                // displayed string format may be different from data string format, so parse before converting to date
                const parsedDateString = this.valueParserService.parseValue(column, null, operand, undefined);
                return _.serialiseDate((_a = this.dataTypeService.getDateParserFunction(column)(parsedDateString)) !== null && _a !== void 0 ? _a : null, false);
        }
        return operand;
    }
    getOperandDisplayValue(model, skipFormatting) {
        var _a, _b;
        const { colId, filter } = model;
        const column = this.columnModel.getPrimaryColumn(colId);
        let operand = '';
        if (filter != null) {
            let operand1;
            switch (model.filterType) {
                case 'number':
                    operand1 = (_a = _.toStringOrNull(filter)) !== null && _a !== void 0 ? _a : '';
                    break;
                case 'date':
                    const dateValue = _.parseDateTimeFromString(filter);
                    operand1 = column ? this.valueFormatterService.formatValue(column, null, dateValue) : null;
                    break;
                case 'dateString':
                    // need to convert from ISO date string to Date to data string format to formatted string format
                    const dateStringDateValue = _.parseDateTimeFromString(filter);
                    const dateStringStringValue = column
                        ? this.dataTypeService.getDateFormatterFunction(column)(dateStringDateValue !== null && dateStringDateValue !== void 0 ? dateStringDateValue : undefined)
                        : null;
                    operand1 = column ? this.valueFormatterService.formatValue(column, null, dateStringStringValue) : null;
                    break;
            }
            if (model.filterType !== 'number') {
                operand1 = (_b = operand1 !== null && operand1 !== void 0 ? operand1 : _.toStringOrNull(filter)) !== null && _b !== void 0 ? _b : '';
                if (!skipFormatting) {
                    operand1 = `"${operand1}"`;
                }
            }
            operand = skipFormatting ? operand1 : ` ${operand1}`;
        }
        return operand;
    }
    parseColumnFilterModel(model) {
        var _a, _b;
        const columnName = (_a = this.getColumnDisplayValue(model)) !== null && _a !== void 0 ? _a : '';
        const operator = (_b = this.getOperatorDisplayValue(model)) !== null && _b !== void 0 ? _b : '';
        const operands = this.getOperandDisplayValue(model);
        return `[${columnName}] ${operator}${operands}`;
    }
    updateAutocompleteCache(updateEntry, type) {
        if (type === 'column') {
            const { key: colId, displayValue } = updateEntry;
            this.columnNameToIdMap[updateEntry.displayValue.toLocaleUpperCase()] = { colId, columnName: displayValue };
        }
    }
    translate(key, variableValues) {
        let defaultValue = ADVANCED_FILTER_LOCALE_TEXT[key];
        if (typeof defaultValue === 'function') {
            defaultValue = defaultValue(variableValues);
        }
        return this.localeService.getLocaleTextFunc()(key, defaultValue, variableValues);
    }
    generateAutocompleteListParams(entries, type, searchString) {
        return {
            enabled: true,
            type,
            searchString,
            entries
        };
    }
    getColumnAutocompleteEntries() {
        var _a;
        if (this.columnAutocompleteEntries) {
            return this.columnAutocompleteEntries;
        }
        const columns = (_a = this.columnModel.getAllPrimaryColumns()) !== null && _a !== void 0 ? _a : [];
        const entries = [];
        const includeHiddenColumns = this.gridOptionsService.get('includeHiddenColumnsInAdvancedFilter');
        columns.forEach(column => {
            if (column.getColDef().filter && (includeHiddenColumns || column.isVisible() || column.isRowGroupActive())) {
                entries.push({
                    key: column.getColId(),
                    displayValue: this.columnModel.getDisplayNameForColumn(column, 'advancedFilter')
                });
            }
        });
        entries.sort((a, b) => {
            var _a, _b;
            const aValue = (_a = a.displayValue) !== null && _a !== void 0 ? _a : '';
            const bValue = (_b = b.displayValue) !== null && _b !== void 0 ? _b : '';
            if (aValue < bValue) {
                return -1;
            }
            else if (bValue > aValue) {
                return 1;
            }
            return 0;
        });
        return entries;
    }
    getOperatorAutocompleteEntries(column, baseCellDataType) {
        const activeOperators = this.getActiveOperators(column);
        return this.getDataTypeExpressionOperator(baseCellDataType).getEntries(activeOperators);
    }
    getJoinOperatorAutocompleteEntries() {
        return Object.entries(this.expressionJoinOperators).map(([key, displayValue]) => ({ key, displayValue }));
    }
    getDefaultAutocompleteListParams(searchString) {
        return this.generateAutocompleteListParams(this.getColumnAutocompleteEntries(), 'column', searchString);
    }
    getDataTypeExpressionOperator(baseCellDataType) {
        return this.expressionOperators[baseCellDataType];
    }
    getExpressionOperator(baseCellDataType, operator) {
        var _a, _b;
        return (_b = (_a = this.getDataTypeExpressionOperator(baseCellDataType)) === null || _a === void 0 ? void 0 : _a.operators) === null || _b === void 0 ? void 0 : _b[operator];
    }
    getExpressionJoinOperators() {
        return this.expressionJoinOperators;
    }
    getColId(columnName) {
        const upperCaseColumnName = columnName.toLocaleUpperCase();
        const cachedColId = this.columnNameToIdMap[upperCaseColumnName];
        if (cachedColId) {
            return cachedColId;
        }
        const columnAutocompleteEntries = this.getColumnAutocompleteEntries();
        const colEntry = columnAutocompleteEntries.find(({ displayValue }) => displayValue.toLocaleUpperCase() === upperCaseColumnName);
        if (colEntry) {
            const { key: colId, displayValue } = colEntry;
            const colValue = { colId, columnName: displayValue };
            // cache for faster lookup
            this.columnNameToIdMap[upperCaseColumnName] = colValue;
            return colValue;
        }
        return null;
    }
    getExpressionEvaluatorParams(colId) {
        let params = this.expressionEvaluatorParams[colId];
        if (params) {
            return params;
        }
        const column = this.columnModel.getPrimaryColumn(colId);
        if (!column) {
            return { valueConverter: (v) => v };
        }
        const baseCellDataType = this.dataTypeService.getBaseDataType(column);
        switch (baseCellDataType) {
            case 'dateString':
                params = {
                    valueConverter: this.dataTypeService.getDateParserFunction(column)
                };
                break;
            case 'object':
                // If there's a filter value getter, assume the value is already a string. Otherwise we need to format it.
                if (column.getColDef().filterValueGetter) {
                    params = { valueConverter: (v) => v };
                }
                else {
                    params = {
                        valueConverter: (value, node) => {
                            var _a;
                            return (_a = this.valueFormatterService.formatValue(column, node, value)) !== null && _a !== void 0 ? _a : (typeof value.toString === 'function' ? value.toString() : '');
                        }
                    };
                }
                break;
            case 'text':
            case undefined:
                params = { valueConverter: (v) => _.toStringOrNull(v) };
                break;
            default:
                params = { valueConverter: (v) => v };
                break;
        }
        const { filterParams } = column.getColDef();
        if (filterParams) {
            [
                'caseSensitive', 'includeBlanksInEquals', 'includeBlanksInLessThan', 'includeBlanksInGreaterThan'
            ].forEach((param) => {
                const paramValue = filterParams[param];
                if (paramValue) {
                    params[param] = paramValue;
                }
            });
        }
        this.expressionEvaluatorParams[colId] = params;
        return params;
    }
    getColumnDetails(colId) {
        var _a, _b;
        const column = (_a = this.columnModel.getPrimaryColumn(colId)) !== null && _a !== void 0 ? _a : undefined;
        const baseCellDataType = (_b = (column ? this.dataTypeService.getBaseDataType(column) : undefined)) !== null && _b !== void 0 ? _b : 'text';
        return { column, baseCellDataType };
    }
    generateExpressionOperators() {
        const translate = (key, variableValues) => this.translate(key, variableValues);
        return {
            text: new TextFilterExpressionOperators({ translate }),
            boolean: new BooleanFilterExpressionOperators({ translate }),
            object: new TextFilterExpressionOperators({ translate }),
            number: new ScalarFilterExpressionOperators({ translate, equals: (v, o) => v === o }),
            date: new ScalarFilterExpressionOperators({ translate, equals: (v, o) => v.getTime() === o.getTime() }),
            dateString: new ScalarFilterExpressionOperators({ translate, equals: (v, o) => v.getTime() === o.getTime() })
        };
    }
    getColumnValue({ displayValue }) {
        return `${ColFilterExpressionParser.COL_START_CHAR}${displayValue}${ColFilterExpressionParser.COL_END_CHAR}`;
    }
    generateExpressionJoinOperators() {
        return {
            AND: this.translate('advancedFilterAnd'),
            OR: this.translate('advancedFilterOr')
        };
    }
    getActiveOperators(column) {
        var _a;
        const filterOptions = (_a = column.getColDef().filterParams) === null || _a === void 0 ? void 0 : _a.filterOptions;
        if (!filterOptions) {
            return undefined;
        }
        const isValid = filterOptions.every((filterOption) => typeof filterOption === 'string');
        return isValid ? filterOptions : undefined;
    }
    resetColumnCaches() {
        this.columnAutocompleteEntries = null;
        this.columnNameToIdMap = {};
        this.expressionEvaluatorParams = {};
    }
};
__decorate$d([
    Autowired('valueFormatterService')
], AdvancedFilterExpressionService.prototype, "valueFormatterService", void 0);
__decorate$d([
    Autowired('valueParserService')
], AdvancedFilterExpressionService.prototype, "valueParserService", void 0);
__decorate$d([
    Autowired('columnModel')
], AdvancedFilterExpressionService.prototype, "columnModel", void 0);
__decorate$d([
    Autowired('dataTypeService')
], AdvancedFilterExpressionService.prototype, "dataTypeService", void 0);
__decorate$d([
    PostConstruct
], AdvancedFilterExpressionService.prototype, "postConstruct", null);
AdvancedFilterExpressionService = __decorate$d([
    Bean('advancedFilterExpressionService')
], AdvancedFilterExpressionService);

class OperatorParser$1 {
    constructor(params) {
        this.params = params;
        this.operators = [];
        this.operatorStartPositions = [];
        this.operatorEndPositions = [];
        this.activeOperator = 0;
        this.validationError = null;
    }
    parseExpression(i) {
        this.operators.push('');
        this.operatorStartPositions.push(i);
        this.operatorEndPositions.push(undefined);
        const { expression } = this.params;
        while (i < expression.length) {
            const char = expression[i];
            if (char === ' ') {
                const isComplete = this.parseOperator(i - 1);
                if (isComplete) {
                    this.activeOperator++;
                    return i - 1;
                }
                else {
                    this.operators[this.activeOperator] += char;
                }
            }
            else {
                this.operators[this.activeOperator] += char;
            }
            i++;
        }
        this.parseOperator(i - 1);
        return i;
    }
    isValid() {
        return !this.validationError && (!this.operators.length || !!this.parsedOperator);
    }
    getValidationError() {
        return this.validationError;
    }
    getFunction() {
        return this.parsedOperator === 'OR' ? '||' : '&&';
    }
    getModel() {
        return this.parsedOperator === 'OR' ? 'OR' : 'AND';
    }
    getAutocompleteListParams(position, operatorIndex) {
        let searchString;
        if (operatorIndex == null) {
            searchString = '';
        }
        else {
            const operator = this.operators[operatorIndex];
            const operatorEndPosition = this.operatorEndPositions[operatorIndex];
            searchString = getSearchString(operator, position, operatorEndPosition == null ? this.params.expression.length : (operatorEndPosition + 1));
        }
        let entries = this.params.advancedFilterExpressionService.getJoinOperatorAutocompleteEntries();
        if (operatorIndex || (operatorIndex == null && this.activeOperator)) {
            // if operator already chosen, don't allow other operators
            entries = entries.filter(({ key }) => key === this.parsedOperator);
        }
        return this.params.advancedFilterExpressionService.generateAutocompleteListParams(entries, 'join', searchString);
    }
    updateExpression(position, updateEntry, operatorIndex) {
        var _a, _b;
        let { expression } = this.params;
        const updatedValuePart = (_a = updateEntry.displayValue) !== null && _a !== void 0 ? _a : updateEntry.key;
        if (operatorIndex === 0) {
            // need to update all others
            for (let i = this.operatorEndPositions.length - 1; i > 0; i--) {
                const operatorEndPosition = this.operatorEndPositions[i];
                if (operatorEndPosition == null) {
                    continue;
                }
                expression = updateExpression(expression, this.operatorStartPositions[i], operatorEndPosition, updatedValuePart).updatedValue;
            }
        }
        // if we don't have a start position, haven't typed anything yet, so use current position
        const startPosition = this.operatorStartPositions.length > operatorIndex ? this.operatorStartPositions[operatorIndex] : position;
        const endPosition = (_b = (this.operatorEndPositions.length > operatorIndex ? this.operatorEndPositions[operatorIndex] : undefined)) !== null && _b !== void 0 ? _b : findEndPosition(expression, position, true).endPosition;
        return updateExpression(expression, startPosition, endPosition, updatedValuePart, true);
    }
    getNumOperators() {
        return this.operators.length;
    }
    getLastOperatorEndPosition() {
        return this.operatorEndPositions[this.operatorEndPositions.length - 1];
    }
    parseOperator(endPosition) {
        const operator = this.operators.length > this.activeOperator ? this.operators[this.activeOperator] : '';
        const joinOperators = this.params.advancedFilterExpressionService.getExpressionJoinOperators();
        const parsedValue = findMatch(operator, joinOperators, v => v);
        if (parsedValue) {
            // exact match
            this.operatorEndPositions[this.activeOperator] = endPosition;
            const displayValue = joinOperators[parsedValue];
            if (this.activeOperator) {
                if (parsedValue !== this.parsedOperator) {
                    if (!this.validationError) {
                        this.validationError = {
                            message: this.params.advancedFilterExpressionService.translate('advancedFilterValidationJoinOperatorMismatch'),
                            startPosition: endPosition - operator.length + 1,
                            endPosition
                        };
                    }
                    return false;
                }
            }
            else {
                this.parsedOperator = parsedValue;
            }
            if (operator !== displayValue) {
                checkAndUpdateExpression(this.params, operator, displayValue, endPosition);
                this.operators[this.activeOperator] = displayValue;
            }
            return true;
        }
        else if (parsedValue === null) {
            // partial match
            return false;
        }
        else {
            // no match
            if (!this.validationError) {
                this.validationError = {
                    message: this.params.advancedFilterExpressionService.translate('advancedFilterValidationInvalidJoinOperator'),
                    startPosition: endPosition - operator.length + 1,
                    endPosition
                };
            }
            return true;
        }
    }
}
class JoinFilterExpressionParser {
    constructor(params, startPosition) {
        this.params = params;
        this.startPosition = startPosition;
        this.expectingExpression = true;
        this.expectingOperator = false;
        this.expressionParsers = [];
        this.operatorParser = new OperatorParser$1(this.params);
        this.missingEndBracket = false;
        this.extraEndBracket = false;
    }
    parseExpression() {
        let i = this.startPosition;
        const { expression } = this.params;
        while (i < expression.length) {
            const char = expression[i];
            if (char === '(' && !this.expectingOperator) {
                const nestedParser = new JoinFilterExpressionParser(this.params, i + 1);
                i = nestedParser.parseExpression();
                this.expressionParsers.push(nestedParser);
                this.expectingExpression = false;
                this.expectingOperator = true;
            }
            else if (char === ')') {
                this.endPosition = i - 1;
                if (this.startPosition === 0) {
                    this.extraEndBracket = true;
                }
                return i;
            }
            else if (char === ' ') ;
            else if (this.expectingExpression) {
                const nestedParser = new ColFilterExpressionParser(this.params, i);
                i = nestedParser.parseExpression();
                this.expressionParsers.push(nestedParser);
                this.expectingExpression = false;
                this.expectingOperator = true;
            }
            else if (this.expectingOperator) {
                i = this.operatorParser.parseExpression(i);
                this.expectingOperator = false;
                this.expectingExpression = true;
            }
            i++;
        }
        if (this.startPosition > 0) {
            this.missingEndBracket = true;
        }
        return i;
    }
    isValid() {
        return !this.missingEndBracket &&
            !this.extraEndBracket &&
            this.expressionParsers.length === this.operatorParser.getNumOperators() + 1 &&
            this.operatorParser.isValid() &&
            this.expressionParsers.every(expressionParser => expressionParser.isValid());
    }
    getValidationError() {
        const operatorError = this.operatorParser.getValidationError();
        for (let i = 0; i < this.expressionParsers.length; i++) {
            const expressionError = this.expressionParsers[i].getValidationError();
            if (expressionError) {
                return operatorError && operatorError.startPosition < expressionError.startPosition
                    ? operatorError
                    : expressionError;
            }
        }
        if (operatorError) {
            return operatorError;
        }
        if (this.extraEndBracket) {
            return {
                message: this.params.advancedFilterExpressionService.translate('advancedFilterValidationExtraEndBracket'),
                startPosition: this.endPosition + 1,
                endPosition: this.endPosition + 1
            };
        }
        let translateKey;
        if (this.expressionParsers.length === this.operatorParser.getNumOperators()) {
            translateKey = 'advancedFilterValidationMissingCondition';
        }
        else if (this.missingEndBracket) {
            translateKey = 'advancedFilterValidationMissingEndBracket';
        }
        if (translateKey) {
            return {
                message: this.params.advancedFilterExpressionService.translate(translateKey),
                startPosition: this.params.expression.length,
                endPosition: this.params.expression.length
            };
        }
        return null;
    }
    getFunction(params) {
        const hasMultipleExpressions = this.expressionParsers.length > 1;
        const expression = this.expressionParsers.map(expressionParser => expressionParser.getFunction(params)).join(` ${this.operatorParser.getFunction()} `);
        return hasMultipleExpressions ? `(${expression})` : expression;
    }
    getAutocompleteListParams(position) {
        if (this.endPosition != null && position > this.endPosition + 1) {
            return undefined;
        }
        if (!this.expressionParsers.length) {
            return this.getColumnAutocompleteListParams();
        }
        const expressionParserIndex = this.getExpressionParserIndex(position);
        if (expressionParserIndex == null) {
            if (this.params.expression[position] === '(') {
                return { enabled: false };
            }
            // positioned before the expression, so new expression
            return this.getColumnAutocompleteListParams();
        }
        const expressionParser = this.expressionParsers[expressionParserIndex];
        const autocompleteType = expressionParser.getAutocompleteListParams(position);
        if (!autocompleteType) {
            // beyond the end of the expression
            if (expressionParserIndex < this.expressionParsers.length - 1) {
                // in the middle of two expressions
                return this.operatorParser.getAutocompleteListParams(position, expressionParserIndex);
            }
            if (this.expressionParsers.length === this.operatorParser.getNumOperators()) {
                const operatorEndPosition = this.operatorParser.getLastOperatorEndPosition();
                return operatorEndPosition == null || position <= operatorEndPosition + 1
                    ? this.operatorParser.getAutocompleteListParams(position, this.operatorParser.getNumOperators() - 1)
                    : this.getColumnAutocompleteListParams();
            }
            if (this.params.expression[position - 1] === ')') {
                return { enabled: false };
            }
            return this.operatorParser.getAutocompleteListParams(position);
        }
        return autocompleteType;
    }
    updateExpression(position, updateEntry, type) {
        var _a;
        const expression = this.params.expression;
        const expressionParserIndex = this.getExpressionParserIndex(position);
        if (expressionParserIndex == null) {
            // positioned before the expression
            const updatedValuePart = type === 'column'
                ? this.params.advancedFilterExpressionService.getColumnValue(updateEntry)
                : (_a = updateEntry.displayValue) !== null && _a !== void 0 ? _a : updateEntry.key;
            return updateExpression(expression, this.startPosition, this.startPosition, updatedValuePart, true);
        }
        const expressionParser = this.expressionParsers[expressionParserIndex];
        const updatedExpression = expressionParser.updateExpression(position, updateEntry, type);
        if (updatedExpression == null) {
            if (type === 'column') {
                // beyond the end of the expression, just do simple update
                return updateExpression(expression, position, expression.length - 1, this.params.advancedFilterExpressionService.getColumnValue(updateEntry), true);
            }
            else if (this.endPosition != null && position > this.endPosition + 1) {
                return null;
            }
            else {
                return this.operatorParser.updateExpression(position, updateEntry, expressionParserIndex);
            }
        }
        return updatedExpression;
    }
    getModel() {
        if (this.expressionParsers.length > 1) {
            return {
                filterType: 'join',
                type: this.operatorParser.getModel(),
                conditions: this.expressionParsers.map(parser => parser.getModel())
            };
        }
        else {
            return this.expressionParsers[0].getModel();
        }
    }
    getColumnAutocompleteListParams() {
        return this.params.advancedFilterExpressionService.generateAutocompleteListParams(this.params.advancedFilterExpressionService.getColumnAutocompleteEntries(), 'column', '');
    }
    getExpressionParserIndex(position) {
        let expressionParserIndex;
        for (let i = 0; i < this.expressionParsers.length; i++) {
            const expressionParserToCheck = this.expressionParsers[i];
            if (expressionParserToCheck.startPosition > position) {
                break;
            }
            expressionParserIndex = i;
        }
        return expressionParserIndex;
    }
}

class FilterExpressionParser {
    constructor(params) {
        this.params = params;
        this.valid = false;
    }
    parseExpression() {
        this.joinExpressionParser = new JoinFilterExpressionParser(this.params, 0);
        const i = this.joinExpressionParser.parseExpression();
        this.valid = i >= this.params.expression.length - 1 && this.joinExpressionParser.isValid();
        return this.params.expression;
    }
    isValid() {
        return this.valid;
    }
    getValidationMessage() {
        const error = this.joinExpressionParser.getValidationError();
        if (!error) {
            return null;
        }
        const { message, startPosition, endPosition } = error;
        return startPosition < this.params.expression.length
            ? this.params.advancedFilterExpressionService.translate('advancedFilterValidationMessage', [
                message, this.params.expression.slice(startPosition, endPosition + 1).trim()
            ])
            : this.params.advancedFilterExpressionService.translate('advancedFilterValidationMessageAtEnd', [message]);
    }
    getFunction() {
        const params = {
            operands: [],
            operators: [],
            evaluatorParams: []
        };
        const functionBody = `return ${this.joinExpressionParser.getFunction(params)};`;
        return {
            functionBody,
            params
        };
    }
    getAutocompleteListParams(position) {
        var _a;
        return (_a = this.joinExpressionParser.getAutocompleteListParams(position)) !== null && _a !== void 0 ? _a : { enabled: false };
    }
    updateExpression(position, updateEntry, type) {
        return this.joinExpressionParser.updateExpression(position, updateEntry, type);
    }
    getModel() {
        return this.isValid() ? this.joinExpressionParser.getModel() : null;
    }
}

var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let AdvancedFilterService = class AdvancedFilterService extends BeanStub {
    constructor() {
        super(...arguments);
        this.appliedExpression = null;
        /** The value displayed in the input, which may be invalid */
        this.expression = null;
        this.isValid = true;
    }
    postConstruct() {
        this.setEnabled(this.gridOptionsService.get('enableAdvancedFilter'), true);
        this.ctrl = this.createManagedBean(new AdvancedFilterCtrl(this.enabled));
        this.expressionProxy = {
            getValue: (colId, node) => {
                const column = this.columnModel.getPrimaryColumn(colId);
                return column ? this.valueService.getValue(column, node, true) : undefined;
            },
        };
        this.addManagedPropertyListener('enableAdvancedFilter', (event) => this.setEnabled(!!event.currentValue));
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, (event) => this.onNewColumnsLoaded(event));
        this.addManagedPropertyListener('includeHiddenColumnsInAdvancedFilter', () => this.updateValidity());
    }
    isEnabled() {
        return this.enabled;
    }
    isFilterPresent() {
        return !!this.expressionFunction;
    }
    doesFilterPass(node) {
        return this.expressionFunction(this.expressionProxy, node, this.expressionParams);
    }
    getModel() {
        var _a;
        const expressionParser = this.createExpressionParser(this.appliedExpression);
        expressionParser === null || expressionParser === void 0 ? void 0 : expressionParser.parseExpression();
        return (_a = expressionParser === null || expressionParser === void 0 ? void 0 : expressionParser.getModel()) !== null && _a !== void 0 ? _a : null;
    }
    setModel(model) {
        const parseModel = (model, isFirstParent) => {
            if (model.filterType === 'join') {
                const operator = this.advancedFilterExpressionService.parseJoinOperator(model);
                const expression = model.conditions.map(condition => parseModel(condition))
                    .filter(condition => _.exists(condition))
                    .join(` ${operator} `);
                return isFirstParent || model.conditions.length <= 1 ? expression : `(${expression})`;
            }
            else {
                return this.advancedFilterExpressionService.parseColumnFilterModel(model);
            }
        };
        const expression = model ? parseModel(model, true) : null;
        this.setExpressionDisplayValue(expression);
        this.applyExpression();
        this.ctrl.refreshComp();
        this.ctrl.refreshBuilderComp();
    }
    getExpressionDisplayValue() {
        return this.expression;
    }
    setExpressionDisplayValue(expression) {
        this.expression = expression;
    }
    isCurrentExpressionApplied() {
        return this.appliedExpression === this.expression;
    }
    createExpressionParser(expression) {
        if (!expression) {
            return null;
        }
        return new FilterExpressionParser({
            expression,
            columnModel: this.columnModel,
            dataTypeService: this.dataTypeService,
            valueParserService: this.valueParserService,
            advancedFilterExpressionService: this.advancedFilterExpressionService,
        });
    }
    getDefaultExpression(updateEntry) {
        const updatedValue = this.advancedFilterExpressionService.getColumnValue(updateEntry) + ' ';
        return {
            updatedValue,
            updatedPosition: updatedValue.length
        };
    }
    isHeaderActive() {
        return !this.gridOptionsService.get('advancedFilterParent');
    }
    getCtrl() {
        return this.ctrl;
    }
    setEnabled(enabled, silent) {
        const previousValue = this.enabled;
        const rowModelType = this.rowModel.getType();
        const isValidRowModel = rowModelType === 'clientSide' || rowModelType === 'serverSide';
        if (enabled && !rowModelType) {
            _.warnOnce('Advanced Filter is only supported with the Client-Side Row Model or Server-Side Row Model.');
        }
        this.enabled = enabled && isValidRowModel;
        if (!silent && this.enabled !== previousValue) {
            const event = {
                type: Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED,
                enabled: this.enabled
            };
            this.eventService.dispatchEvent(event);
        }
    }
    applyExpression() {
        const expressionParser = this.createExpressionParser(this.expression);
        expressionParser === null || expressionParser === void 0 ? void 0 : expressionParser.parseExpression();
        this.applyExpressionFromParser(expressionParser);
    }
    applyExpressionFromParser(expressionParser) {
        this.isValid = !expressionParser || expressionParser.isValid();
        if (!expressionParser || !this.isValid) {
            this.expressionFunction = null;
            this.expressionParams = null;
            this.appliedExpression = null;
            return;
        }
        const { functionBody, params } = expressionParser.getFunction();
        this.expressionFunction = new Function('expressionProxy', 'node', 'params', functionBody);
        this.expressionParams = params;
        this.appliedExpression = this.expression;
    }
    updateValidity() {
        this.advancedFilterExpressionService.resetColumnCaches();
        const expressionParser = this.createExpressionParser(this.expression);
        expressionParser === null || expressionParser === void 0 ? void 0 : expressionParser.parseExpression();
        const isValid = !expressionParser || expressionParser.isValid();
        const updatedValidity = isValid !== this.isValid;
        this.applyExpressionFromParser(expressionParser);
        this.ctrl.refreshComp();
        this.ctrl.refreshBuilderComp();
        return updatedValidity;
    }
    onNewColumnsLoaded(event) {
        if (event.source !== 'gridInitializing' || !this.dataTypeService.isPendingInference()) {
            return;
        }
        this.ctrl.setInputDisabled(true);
        const destroyFunc = this.addManagedListener(this.eventService, Events.EVENT_DATA_TYPES_INFERRED, () => {
            destroyFunc === null || destroyFunc === void 0 ? void 0 : destroyFunc();
            this.ctrl.setInputDisabled(false);
        });
    }
};
__decorate$e([
    Autowired('valueService')
], AdvancedFilterService.prototype, "valueService", void 0);
__decorate$e([
    Autowired('columnModel')
], AdvancedFilterService.prototype, "columnModel", void 0);
__decorate$e([
    Autowired('dataTypeService')
], AdvancedFilterService.prototype, "dataTypeService", void 0);
__decorate$e([
    Autowired('valueParserService')
], AdvancedFilterService.prototype, "valueParserService", void 0);
__decorate$e([
    Autowired('rowModel')
], AdvancedFilterService.prototype, "rowModel", void 0);
__decorate$e([
    Autowired('advancedFilterExpressionService')
], AdvancedFilterService.prototype, "advancedFilterExpressionService", void 0);
__decorate$e([
    PostConstruct
], AdvancedFilterService.prototype, "postConstruct", null);
AdvancedFilterService = __decorate$e([
    Bean('advancedFilterService')
], AdvancedFilterService);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$1 = '31.1.1';

const AdvancedFilterModule = {
    version: VERSION$1,
    moduleName: ModuleNames.AdvancedFilterModule,
    beans: [AdvancedFilterService, AdvancedFilterExpressionService],
    agStackComponents: [
        { componentName: 'agAdvancedFilter', componentClass: AdvancedFilterComp }
    ],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

// packages/ag-charts-community/src/options/chart/errorBarOptions.ts
var AgErrorBarSupportedSeriesTypes = ["bar", "line", "scatter"];

// packages/ag-charts-community/src/options/chart/tooltipOptions.ts
var AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {
  AgTooltipPositionType2["POINTER"] = "pointer";
  AgTooltipPositionType2["NODE"] = "node";
  return AgTooltipPositionType2;
})(AgTooltipPositionType || {});

// packages/ag-charts-community/src/options/agChartOptions.ts
var __FORCE_MODULE_DETECTION = 0;

// packages/ag-charts-community/src/util/time/index.ts
var time_exports = {};
__export(time_exports, {
  day: () => day,
  friday: () => friday,
  hour: () => hour,
  millisecond: () => millisecond,
  minute: () => minute,
  monday: () => monday,
  month: () => month,
  saturday: () => saturday,
  second: () => second,
  sunday: () => sunday,
  thursday: () => thursday,
  tuesday: () => tuesday,
  utcDay: () => utcDay,
  utcHour: () => utcHour,
  utcMinute: () => utcMinute,
  utcMonth: () => utcMonth,
  utcYear: () => utcYear,
  wednesday: () => wednesday,
  year: () => year
});

// packages/ag-charts-community/src/util/function.ts
var doOnceState = /* @__PURE__ */ new Map();
function doOnce(func, key) {
  if (doOnceState.has(key))
    return;
  doOnceState.set(key, true);
  func();
}
doOnce.clear = () => doOnceState.clear();
function identity(x) {
  return x;
}
function debounce(callback, waitMs = 0, options) {
  const { leading = false, trailing = true, maxWait = Infinity } = options != null ? options : {};
  let timerId;
  let startTime;
  if (maxWait < waitMs) {
    throw new Error("Value of maxWait cannot be lower than waitMs.");
  }
  function debounceCallback(...args) {
    if (leading && !startTime) {
      startTime = Date.now();
      timerId = setTimeout(() => startTime = null, waitMs);
      callback(...args);
      return;
    }
    let adjustedWaitMs = waitMs;
    if (maxWait !== Infinity && startTime) {
      const elapsedTime = Date.now() - startTime;
      if (waitMs > maxWait - elapsedTime) {
        adjustedWaitMs = maxWait - elapsedTime;
      }
    }
    clearTimeout(timerId);
    startTime != null ? startTime : startTime = Date.now();
    timerId = setTimeout(() => {
      startTime = null;
      if (trailing) {
        callback(...args);
      }
    }, adjustedWaitMs);
  }
  return Object.assign(debounceCallback, {
    cancel() {
      clearTimeout(timerId);
      startTime = null;
    }
  });
}
function throttle(callback, waitMs = 0, options) {
  const { leading = true, trailing = true } = options != null ? options : {};
  let timerId;
  let lastArgs;
  let shouldWait = false;
  function timeoutHandler() {
    if (trailing && lastArgs) {
      timerId = setTimeout(timeoutHandler, waitMs);
      callback(...lastArgs);
    } else {
      shouldWait = false;
    }
    lastArgs = null;
  }
  function throttleCallback(...args) {
    if (shouldWait) {
      lastArgs = args;
    } else {
      shouldWait = true;
      timerId = setTimeout(timeoutHandler, waitMs);
      if (leading) {
        callback(...args);
      } else {
        lastArgs = args;
      }
    }
  }
  return Object.assign(throttleCallback, {
    cancel() {
      clearTimeout(timerId);
      shouldWait = false;
      lastArgs = null;
    }
  });
}

// packages/ag-charts-community/src/util/logger.ts
var Logger = {
  log(...logContent) {
    console.log(...logContent);
  },
  warn(message, ...logContent) {
    console.warn(`AG Charts - ${message}`, ...logContent);
  },
  error(message, ...logContent) {
    if (typeof message === "object") {
      console.error(`AG Charts error`, message, ...logContent);
    } else {
      console.error(`AG Charts - ${message}`, ...logContent);
    }
  },
  table(...logContent) {
    console.table(...logContent);
  },
  warnOnce(message, ...logContent) {
    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);
  },
  errorOnce(message, ...logContent) {
    doOnce(() => Logger.error(message, ...logContent), `Logger.error: ${message}`);
  }
};

// packages/ag-charts-community/src/util/time/interval.ts
var TimeInterval = class {
  constructor(_encode, _decode, _rangeCallback) {
    this._encode = _encode;
    this._decode = _decode;
    this._rangeCallback = _rangeCallback;
  }
  /**
   * Returns a new date representing the latest interval boundary date before or equal to date.
   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.
   * @param date
   */
  floor(date) {
    const d = new Date(date);
    const e = this._encode(d);
    return this._decode(e);
  }
  /**
   * Returns a new date representing the earliest interval boundary date after or equal to date.
   * @param date
   */
  ceil(date) {
    const d = new Date(Number(date) - 1);
    const e = this._encode(d);
    return this._decode(e + 1);
  }
  /**
   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).
   * @param start Range start.
   * @param stop Range end.
   * @param extend If specified, the requested range will be extended to the closest "nice" values.
   */
  range(start, stop, extend) {
    var _a;
    const rangeCallback = (_a = this._rangeCallback) == null ? void 0 : _a.call(this, start, stop);
    const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));
    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));
    if (e1 < e0) {
      return [];
    }
    const range3 = [];
    for (let e = e0; e <= e1; e++) {
      const d = this._decode(e);
      range3.push(d);
    }
    rangeCallback == null ? void 0 : rangeCallback();
    return range3;
  }
};
var CountableTimeInterval = class extends TimeInterval {
  getOffset(snapTo, step) {
    const s = typeof snapTo === "number" || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;
    return Math.floor(s) % step;
  }
  /**
   * Returns a filtered view of this interval representing every step'th date.
   * It can be a number of minutes, hours, days etc.
   * Must be a positive integer.
   * @param step
   */
  every(step, options) {
    let offset4 = 0;
    let rangeCallback;
    const unsafeStep = step;
    step = Math.max(1, Math.round(step));
    if (unsafeStep !== step) {
      Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);
    }
    const { snapTo = "start" } = options != null ? options : {};
    if (typeof snapTo === "string") {
      const initialOffset = offset4;
      rangeCallback = (start, stop) => {
        const s = snapTo === "start" ? start : stop;
        offset4 = this.getOffset(s, step);
        return () => offset4 = initialOffset;
      };
    } else if (typeof snapTo === "number") {
      offset4 = this.getOffset(new Date(snapTo), step);
    } else if (snapTo instanceof Date) {
      offset4 = this.getOffset(snapTo, step);
    }
    const encode13 = (date) => {
      const e = this._encode(date);
      return Math.floor((e - offset4) / step);
    };
    const decode13 = (encoded) => {
      return this._decode(encoded * step + offset4);
    };
    return new TimeInterval(encode13, decode13, rangeCallback);
  }
};

// packages/ag-charts-community/src/util/time/millisecond.ts
function encode(date) {
  return date.getTime();
}
function decode(encoded) {
  return new Date(encoded);
}
var millisecond = new CountableTimeInterval(encode, decode);
var millisecond_default = millisecond;

// packages/ag-charts-community/src/util/time/duration.ts
var epochYear = (/* @__PURE__ */ new Date(0)).getFullYear();
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// packages/ag-charts-community/src/util/time/second.ts
var offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
function encode2(date) {
  return Math.floor((date.getTime() - offset) / durationSecond);
}
function decode2(encoded) {
  return new Date(offset + encoded * durationSecond);
}
var second = new CountableTimeInterval(encode2, decode2);
var second_default = second;

// packages/ag-charts-community/src/util/time/minute.ts
var offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
function encode3(date) {
  return Math.floor((date.getTime() - offset2) / durationMinute);
}
function decode3(encoded) {
  return new Date(offset2 + encoded * durationMinute);
}
var minute = new CountableTimeInterval(encode3, decode3);
var minute_default = minute;

// packages/ag-charts-community/src/util/time/hour.ts
var offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
function encode4(date) {
  return Math.floor((date.getTime() - offset3) / durationHour);
}
function decode4(encoded) {
  return new Date(offset3 + encoded * durationHour);
}
var hour = new CountableTimeInterval(encode4, decode4);
var hour_default = hour;

// packages/ag-charts-community/src/util/time/day.ts
function encode5(date) {
  const tzOffsetMs = date.getTimezoneOffset() * durationMinute;
  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);
}
function decode5(encoded) {
  const d = new Date(1970, 0, 1);
  d.setDate(d.getDate() + encoded);
  return d;
}
var day = new CountableTimeInterval(encode5, decode5);
var day_default = day;

// packages/ag-charts-community/src/util/time/week.ts
function weekday(weekStart) {
  const thursday2 = 4;
  const dayShift = (7 + weekStart - thursday2) % 7;
  function encode13(date) {
    const tzOffsetMs = date.getTimezoneOffset() * durationMinute;
    return Math.floor((date.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);
  }
  function decode13(encoded) {
    const d = new Date(1970, 0, 1);
    d.setDate(d.getDate() + encoded * 7 + dayShift);
    return d;
  }
  return new CountableTimeInterval(encode13, decode13);
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var week_default = sunday;

// packages/ag-charts-community/src/util/time/month.ts
function encode6(date) {
  return date.getFullYear() * 12 + date.getMonth();
}
function decode6(encoded) {
  const year2 = Math.floor(encoded / 12);
  const month2 = encoded - year2 * 12;
  return new Date(year2, month2, 1);
}
var month = new CountableTimeInterval(encode6, decode6);
var month_default = month;

// packages/ag-charts-community/src/util/time/year.ts
function encode7(date) {
  return date.getFullYear();
}
function decode7(encoded) {
  const d = /* @__PURE__ */ new Date();
  d.setFullYear(encoded);
  d.setMonth(0, 1);
  d.setHours(0, 0, 0, 0);
  return d;
}
var year = new CountableTimeInterval(encode7, decode7);
var year_default = year;

// packages/ag-charts-community/src/util/time/utcMinute.ts
function encode8(date) {
  return Math.floor(date.getTime() / durationMinute);
}
function decode8(encoded) {
  return new Date(encoded * durationMinute);
}
var utcMinute = new CountableTimeInterval(encode8, decode8);

// packages/ag-charts-community/src/util/time/utcHour.ts
function encode9(date) {
  return Math.floor(date.getTime() / durationHour);
}
function decode9(encoded) {
  return new Date(encoded * durationHour);
}
var utcHour = new CountableTimeInterval(encode9, decode9);

// packages/ag-charts-community/src/util/time/utcDay.ts
function encode10(date) {
  return Math.floor(date.getTime() / durationDay);
}
function decode10(encoded) {
  const d = /* @__PURE__ */ new Date(0);
  d.setUTCDate(d.getUTCDate() + encoded);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
var utcDay = new CountableTimeInterval(encode10, decode10);

// packages/ag-charts-community/src/util/time/utcMonth.ts
function encode11(date) {
  return date.getUTCFullYear() * 12 + date.getUTCMonth();
}
function decode11(encoded) {
  const year2 = Math.floor(encoded / 12);
  const month2 = encoded - year2 * 12;
  return new Date(Date.UTC(year2, month2, 1));
}
var utcMonth = new CountableTimeInterval(encode11, decode11);

// packages/ag-charts-community/src/util/time/utcYear.ts
function encode12(date) {
  return date.getUTCFullYear();
}
function decode12(encoded) {
  const d = /* @__PURE__ */ new Date();
  d.setUTCFullYear(encoded);
  d.setUTCMonth(0, 1);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
var utcYear = new CountableTimeInterval(encode12, decode12);

// packages/ag-charts-community/src/module/enterpriseModule.ts
var enterpriseModule = {
  isEnterprise: false
};

// packages/ag-charts-community/src/module/module.ts
var BaseModuleInstance = class {
  constructor() {
    this.destroyFns = [];
  }
  destroy() {
    for (const destroyFn of this.destroyFns) {
      destroyFn();
    }
  }
};
var REGISTERED_MODULES = [];
function registerModule(module) {
  const otherModule = REGISTERED_MODULES.find((other) => {
    return module.type === other.type && module.optionsKey === other.optionsKey && module.identifier === other.identifier;
  });
  if (otherModule) {
    if (module.packageType === "enterprise" && otherModule.packageType === "community") {
      const index = REGISTERED_MODULES.indexOf(otherModule);
      REGISTERED_MODULES.splice(index, 1, module);
    }
  } else {
    REGISTERED_MODULES.push(module);
  }
}
function hasRegisteredEnterpriseModules() {
  return REGISTERED_MODULES.some((m) => m.packageType === "enterprise");
}

// packages/ag-charts-community/src/chart/factory/axisTypes.ts
var AXIS_CONSTRUCTORS = {};
function registerAxis(axisType, ctor) {
  AXIS_CONSTRUCTORS[axisType] = ctor;
}
function getAxis(axisType, moduleCtx) {
  const axisConstructor = AXIS_CONSTRUCTORS[axisType];
  if (axisConstructor) {
    return new axisConstructor(moduleCtx);
  }
  throw new Error(`AG Charts - unknown axis type: ${axisType}`);
}
var AXIS_TYPES = {
  has(axisType) {
    return Object.hasOwn(AXIS_CONSTRUCTORS, axisType);
  },
  get axesTypes() {
    return Object.keys(AXIS_CONSTRUCTORS);
  }
};
var AXIS_THEME_TEMPLATES = {};
function registerAxisThemeTemplate(axisType, theme) {
  AXIS_THEME_TEMPLATES[axisType] = theme;
}
function getAxisThemeTemplate(axisType) {
  var _a;
  return (_a = AXIS_THEME_TEMPLATES[axisType]) != null ? _a : {};
}

// packages/ag-charts-community/src/util/decorator.ts
var BREAK_TRANSFORM_CHAIN = Symbol("BREAK");
var CONFIG_KEY = "__decorator_config";
function initialiseConfig(target, propertyKeyOrSymbol) {
  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {
    Object.defineProperty(target, CONFIG_KEY, { value: {} });
  }
  const config = target[CONFIG_KEY];
  const propertyKey = propertyKeyOrSymbol.toString();
  if (typeof config[propertyKey] !== "undefined") {
    return config[propertyKey];
  }
  const valuesMap = /* @__PURE__ */ new WeakMap();
  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };
  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);
  const prevSet = descriptor == null ? void 0 : descriptor.set;
  const prevGet = descriptor == null ? void 0 : descriptor.get;
  const getter = function() {
    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);
    for (const transformFn of config[propertyKey].getters) {
      value = transformFn(this, propertyKeyOrSymbol, value);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    return value;
  };
  const setter = function(value) {
    const { setters, observers } = config[propertyKey];
    let oldValue;
    if (setters.some((f) => f.length > 2)) {
      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);
    }
    for (const transformFn of setters) {
      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    if (prevSet) {
      prevSet.call(this, value);
    } else {
      valuesMap.set(this, value);
    }
    for (const observerFn of observers) {
      observerFn(this, value, oldValue);
    }
  };
  Object.defineProperty(target, propertyKeyOrSymbol, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: false
  });
  return config[propertyKey];
}
function addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {
  return (target, propertyKeyOrSymbol) => {
    const config = initialiseConfig(target, propertyKeyOrSymbol);
    config.setters.push(setTransform);
    if (getTransform) {
      config.getters.unshift(getTransform);
    }
    if (configMetadata) {
      Object.assign(config, configMetadata);
    }
  };
}
function addObserverToInstanceProperty(setObserver) {
  return (target, propertyKeyOrSymbol) => {
    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);
  };
}
function isDecoratedObject(target) {
  return typeof target !== "undefined" && CONFIG_KEY in target;
}
function listDecoratedProperties(target) {
  const targets = /* @__PURE__ */ new Set();
  while (isDecoratedObject(target)) {
    targets.add(target == null ? void 0 : target[CONFIG_KEY]);
    target = Object.getPrototypeOf(target);
  }
  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));
}
function extractDecoratedProperties(target) {
  return listDecoratedProperties(target).reduce((result, key) => {
    var _a;
    result[key] = (_a = target[key]) != null ? _a : null;
    return result;
  }, {});
}
function extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {
  const propertyKey = propertyKeyOrSymbol.toString();
  while (isDecoratedObject(target)) {
    const config = target[CONFIG_KEY];
    if (Object.hasOwn(config, propertyKey)) {
      return config[propertyKey];
    }
    target = Object.getPrototypeOf(target);
  }
}

// packages/ag-charts-community/src/util/type-guards.ts
function isDefined(val) {
  return val != null;
}
function isArray(value) {
  return Array.isArray(value);
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isDate(value) {
  return value instanceof Date;
}
function isValidDate(value) {
  return isDate(value) && !isNaN(Number(value));
}
function isRegExp(value) {
  return value instanceof RegExp;
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return typeof value === "object" && value !== null && !isArray(value);
}
function isObjectLike(value) {
  return isArray(value) || isPlainObject(value);
}
function isPlainObject(value) {
  return typeof value === "object" && value !== null && value.constructor === Object;
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isFiniteNumber(value) {
  return isNumber(value) && Number.isFinite(value);
}
function isHtmlElement(value) {
  return typeof window !== "undefined" && value instanceof HTMLElement;
}
function isEnumKey(enumObject, enumKey) {
  return isString(enumKey) && Object.keys(enumObject).includes(enumKey);
}
function isEnumValue(enumObject, enumValue) {
  return Object.values(enumObject).includes(enumValue);
}
function isSymbol(value) {
  return typeof value === "symbol";
}

// packages/ag-charts-community/src/util/object.ts
function deepMerge(...sources) {
  return mergeDefaults(...sources.reverse());
}
function mergeDefaults(...sources) {
  var _a;
  const target = {};
  for (const source of sources) {
    if (!isObject(source))
      continue;
    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
    for (const key of keys) {
      if (isPlainObject(target[key]) && isPlainObject(source[key])) {
        target[key] = mergeDefaults(target[key], source[key]);
      } else {
        (_a = target[key]) != null ? _a : target[key] = source[key];
      }
    }
  }
  return target;
}
function mergeArrayDefaults(dataArray, ...itemDefaults) {
  if (itemDefaults && isArray(dataArray)) {
    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));
  }
  return dataArray;
}
function mapValues(object, mapper) {
  return Object.entries(object).reduce(
    (result, [key, value]) => {
      result[key] = mapper(value, key, object);
      return result;
    },
    {}
  );
}
function getPath(object, path) {
  const pathArray = isArray(path) ? path : path.split(".");
  return pathArray.reduce((value, pathKey) => value[pathKey], object);
}
function setPath(object, path, newValue) {
  const pathArray = isArray(path) ? path.slice() : path.split(".");
  const lastKey = pathArray.pop();
  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object);
  lastObject[lastKey] = newValue;
}
function partialAssign(keysToCopy, target, source) {
  if (source === void 0) {
    return target;
  }
  for (const key of keysToCopy) {
    const value = source[key];
    if (value !== void 0) {
      target[key] = value;
    }
  }
  return target;
}

// packages/ag-charts-community/src/chart/factory/chartTypes.ts
var TYPES = {};
var DEFAULTS = {};
var CHART_TYPES = {
  has(seriesType) {
    return Object.hasOwn(TYPES, seriesType);
  },
  isCartesian(seriesType) {
    return TYPES[seriesType] === "cartesian";
  },
  isPolar(seriesType) {
    return TYPES[seriesType] === "polar";
  },
  isHierarchy(seriesType) {
    return TYPES[seriesType] === "hierarchy";
  },
  get seriesTypes() {
    return Object.keys(TYPES);
  },
  get cartesianTypes() {
    return this.seriesTypes.filter((t) => this.isCartesian(t));
  },
  get polarTypes() {
    return this.seriesTypes.filter((t) => this.isPolar(t));
  },
  get hierarchyTypes() {
    return this.seriesTypes.filter((t) => this.isHierarchy(t));
  }
};
function registerChartSeriesType(seriesType, chartType2) {
  TYPES[seriesType] = chartType2;
}
function registerChartDefaults(chartType2, defaults) {
  DEFAULTS[chartType2] = mergeDefaults(defaults, DEFAULTS[chartType2]);
}
function getChartDefaults(chartType2) {
  var _a;
  return (_a = DEFAULTS[chartType2]) != null ? _a : {};
}
function getChartType(seriesType) {
  var _a;
  return (_a = TYPES[seriesType]) != null ? _a : "unknown";
}

// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts
var EXPECTED_ENTERPRISE_MODULES = [
  { type: "root", optionsKey: "animation", chartTypes: ["cartesian", "polar", "hierarchy"] },
  {
    type: "root",
    optionsKey: "background",
    chartTypes: ["cartesian", "polar", "hierarchy"],
    optionsInnerKey: "image"
  },
  { type: "root", optionsKey: "contextMenu", chartTypes: ["cartesian", "polar", "hierarchy"] },
  { type: "root", optionsKey: "dataSource", chartTypes: ["cartesian", "polar", "hierarchy"] },
  { type: "root", optionsKey: "sync", chartTypes: ["cartesian"] },
  { type: "root", optionsKey: "zoom", chartTypes: ["cartesian"] },
  {
    type: "legend",
    optionsKey: "gradientLegend",
    chartTypes: ["cartesian", "polar", "hierarchy"],
    identifier: "gradient"
  },
  { type: "root", optionsKey: "navigator", chartTypes: ["cartesian"], optionsInnerKey: "miniChart" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-number" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-number" },
  { type: "axis-option", optionsKey: "crosshair", chartTypes: ["cartesian"] },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "box-plot" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "bullet" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "heatmap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "nightingale" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-line" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-column" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["hierarchy"], identifier: "sunburst" },
  { type: "series", optionsKey: "series[]", chartTypes: ["hierarchy"], identifier: "treemap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "waterfall" },
  { type: "series-option", optionsKey: "errorBar", chartTypes: ["cartesian"], identifier: "error-bars" }
];
function isEnterpriseSeriesType(type) {
  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === "series" && s.identifier === type);
}
function getEnterpriseSeriesChartTypes(type) {
  var _a;
  return (_a = EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === "series" && s.identifier === type)) == null ? void 0 : _a.chartTypes;
}
function isEnterpriseSeriesTypeLoaded(type) {
  var _a, _b;
  return ((_b = (_a = EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === "series" && s.identifier === type)) == null ? void 0 : _a.useCount) != null ? _b : 0) > 0;
}
function isEnterpriseCartesian(seriesType) {
  var _a;
  const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) == null ? void 0 : _a.find((v) => v === "cartesian");
  return type === "cartesian";
}
function isEnterprisePolar(seriesType) {
  var _a;
  const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) == null ? void 0 : _a.find((v) => v === "polar");
  return type === "polar";
}
function isEnterpriseHierarchy(seriesType) {
  var _a;
  const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) == null ? void 0 : _a.find((v) => v === "hierarchy");
  return type === "hierarchy";
}
function isEnterpriseModule(module) {
  return module.packageType === "enterprise";
}
function verifyIfModuleExpected(module) {
  var _a;
  if (!isEnterpriseModule(module)) {
    throw new Error("AG Charts - internal configuration error, only enterprise modules need verification.");
  }
  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {
    return s.type === module.type && s.optionsKey === module.optionsKey && s.identifier === module.identifier && module.chartTypes.every((t) => s.chartTypes.includes(t));
  });
  if (stub) {
    (_a = stub.useCount) != null ? _a : stub.useCount = 0;
    stub.useCount++;
  }
  return stub != null;
}
function getUnusedExpectedModules() {
  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);
}

// packages/ag-charts-community/src/chart/mapping/types.ts
function optionsType(input) {
  var _a, _b, _c;
  return (_c = (_b = (_a = input.series) == null ? void 0 : _a[0]) == null ? void 0 : _b.type) != null ? _c : "line";
}
function isAgCartesianChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return true;
  }
  if (specifiedType === "cartesian") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return CHART_TYPES.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);
}
function isAgHierarchyChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "hierarchy") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return CHART_TYPES.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);
}
function isAgPolarChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "polar") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return CHART_TYPES.isPolar(specifiedType) || isEnterprisePolar(specifiedType);
}
function isAgPolarChartOptionsWithSeriesBasedLegend(input) {
  const specifiedType = optionsType(input);
  return isAgPolarChartOptions(input) && specifiedType !== "pie" && specifiedType !== "donut";
}
function isSeriesOptionType(input) {
  if (input == null) {
    return false;
  }
  return CHART_TYPES.has(input);
}
function isAxisOptionType(input) {
  if (input == null) {
    return false;
  }
  return AXIS_TYPES.has(input);
}

// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts
function removeUsedEnterpriseOptions(options) {
  var _a, _b, _c, _d;
  const usedOptions = [];
  const optionsChartType = getChartType(optionsType(options));
  for (const { type, chartTypes, optionsKey, optionsInnerKey, identifier } of EXPECTED_ENTERPRISE_MODULES) {
    if (optionsChartType !== "unknown" && !chartTypes.includes(optionsChartType))
      continue;
    if (type === "root" || type === "legend") {
      const optionValue = options[optionsKey];
      if (optionValue == null)
        continue;
      if (!optionsInnerKey) {
        usedOptions.push(optionsKey);
        delete options[optionsKey];
      } else if (optionValue[optionsInnerKey]) {
        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);
        delete optionValue[optionsInnerKey];
      }
    } else if (type === "axis") {
      if (!("axes" in options) || !((_a = options.axes) == null ? void 0 : _a.some((axis) => axis.type === identifier)))
        continue;
      usedOptions.push(`axis[type=${identifier}]`);
      options.axes = options.axes.filter((axis) => axis.type !== identifier);
    } else if (type === "axis-option") {
      if (!("axes" in options) || !((_b = options.axes) == null ? void 0 : _b.some((axis) => axis[optionsKey])))
        continue;
      usedOptions.push(`axis.${optionsKey}`);
      options.axes.forEach((axis) => {
        if (axis[optionsKey]) {
          delete axis[optionsKey];
        }
      });
    } else if (type === "series") {
      if (!((_c = options.series) == null ? void 0 : _c.some((series) => series.type === identifier)))
        continue;
      usedOptions.push(`series[type=${identifier}]`);
      options.series = options.series.filter((series) => series.type !== identifier);
    } else if (type === "series-option") {
      if (!((_d = options.series) == null ? void 0 : _d.some((series) => series[optionsKey])))
        continue;
      usedOptions.push(`series.${optionsKey}`);
      options.series.forEach((series) => {
        if (series[optionsKey]) {
          delete series[optionsKey];
        }
      });
    }
  }
  if (usedOptions.length) {
    Logger.warnOnce(
      [
        `unable to use these enterprise features as 'ag-charts-enterprise' has not been loaded:
`,
        "",
        ...usedOptions,
        "",
        "See: https://charts.ag-grid.com/javascript/installation/"
      ].join("\n")
    );
  }
}

// packages/ag-charts-community/src/util/properties.ts
var BaseProperties = class {
  constructor(className) {
    this.className = className;
  }
  set(properties) {
    const keys = new Set(Object.keys(properties));
    for (const propertyKey of listDecoratedProperties(this)) {
      if (keys.has(propertyKey)) {
        const value = properties[propertyKey];
        const self = this;
        if (isProperties(self[propertyKey])) {
          self[propertyKey] = self[propertyKey] instanceof PropertiesArray ? self[propertyKey].reset(value) : self[propertyKey].set(value);
        } else {
          self[propertyKey] = value;
        }
        keys.delete(propertyKey);
      }
    }
    for (const unknownKey of keys) {
      const { className = this.constructor.name } = this.constructor;
      Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);
    }
    return this;
  }
  isValid() {
    return listDecoratedProperties(this).every((propertyKey) => {
      const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);
      return optional || typeof this[propertyKey] !== "undefined";
    });
  }
  toJson() {
    return listDecoratedProperties(this).reduce((object, propertyKey) => {
      const propertyValue = this[propertyKey];
      object[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;
      return object;
    }, {});
  }
};
var PropertiesArray = class _PropertiesArray extends Array {
  constructor(itemFactory, ...properties) {
    super(properties.length);
    Object.defineProperty(this, "itemFactory", { value: itemFactory, enumerable: false, configurable: false });
    this.set(properties);
  }
  set(properties) {
    if (isArray(properties)) {
      this.length = properties.length;
      for (let i = 0; i < properties.length; i++) {
        this[i] = new this.itemFactory().set(properties[i]);
      }
    }
    return this;
  }
  reset(properties) {
    return new _PropertiesArray(this.itemFactory, ...properties);
  }
  toJson() {
    return this.slice();
  }
};
function isProperties(value) {
  return value instanceof BaseProperties || value instanceof PropertiesArray;
}

// packages/ag-charts-community/src/util/json.ts
var CLASS_INSTANCE_TYPE = "class-instance";
function jsonDiff(source, target) {
  if (isArray(target)) {
    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {
      return target;
    }
  } else if (isPlainObject(target)) {
    if (!isPlainObject(source)) {
      return target;
    }
    const result = {};
    const allKeys = /* @__PURE__ */ new Set([
      ...Object.keys(source),
      ...Object.keys(target)
    ]);
    for (const key of allKeys) {
      if (source[key] === target[key]) {
        continue;
      }
      if (typeof source[key] !== typeof target[key]) {
        result[key] = target[key];
      } else {
        const diff2 = jsonDiff(source[key], target[key]);
        if (diff2 !== null) {
          result[key] = diff2;
        }
      }
    }
    return Object.keys(result).length ? result : null;
  } else if (source !== target) {
    return target;
  }
  return null;
}
function deepClone(source, options) {
  if (isArray(source)) {
    return source.map((item) => deepClone(item, options));
  }
  if (isPlainObject(source)) {
    return Object.entries(source).reduce((result, [key, value]) => {
      var _a;
      result[key] = ((_a = options == null ? void 0 : options.shallow) == null ? void 0 : _a.includes(key)) ? shallowClone(value) : deepClone(value, options);
      return result;
    }, {});
  }
  return shallowClone(source);
}
function shallowClone(source) {
  if (isArray(source)) {
    return [...source];
  }
  if (isPlainObject(source)) {
    return __spreadValues({}, source);
  }
  if (isDate(source)) {
    return new Date(source);
  }
  if (isRegExp(source)) {
    return new RegExp(source.source, source.flags);
  }
  return source;
}
function jsonWalk(json, visit, opts, ...jsons) {
  var _a;
  if (isArray(json)) {
    visit(json, ...jsons);
    json.forEach((node, index) => {
      jsonWalk(node, visit, opts, ...keyMapper(jsons, index));
    });
  } else if (isPlainObject(json)) {
    visit(json, ...jsons);
    for (const key of Object.keys(json)) {
      if ((_a = opts == null ? void 0 : opts.skip) == null ? void 0 : _a.includes(key)) {
        continue;
      }
      const value = json[key];
      if (isArray(value) || isPlainObject(value)) {
        jsonWalk(value, visit, opts, ...keyMapper(jsons, key));
      }
    }
  }
}
function jsonApply(target, source, params = {}) {
  var _a, _b, _c;
  const {
    path,
    matcherPath = path ? path.replace(/(\[[0-9+]+])/i, "[]") : void 0,
    skip = [],
    constructors = {},
    constructedArrays = /* @__PURE__ */ new WeakMap(),
    allowedTypes = {},
    idx
  } = params;
  if (target == null) {
    throw new Error(`AG Charts - target is uninitialised: ${path != null ? path : "<root>"}`);
  }
  if (source == null) {
    return target;
  }
  if (isProperties(target)) {
    return target.set(source);
  }
  const targetAny = target;
  if (idx != null && "_declarationOrder" in targetAny) {
    targetAny["_declarationOrder"] = idx;
  }
  const targetType = classify(target);
  for (const property in source) {
    const propertyMatcherPath = `${matcherPath ? matcherPath + "." : ""}${property}`;
    if (skip.indexOf(propertyMatcherPath) >= 0) {
      continue;
    }
    const newValue = source[property];
    const propertyPath = `${path ? path + "." : ""}${property}`;
    const targetClass = targetAny.constructor;
    const currentValue = targetAny[property];
    let ctr = (_a = constructors[propertyMatcherPath]) != null ? _a : constructors[property];
    try {
      const currentValueType = classify(currentValue);
      const newValueType = classify(newValue);
      if (targetType === CLASS_INSTANCE_TYPE && !(property in target || Object.hasOwn(targetAny, property))) {
        Logger.warn(`unable to set [${propertyPath}] in ${targetClass == null ? void 0 : targetClass.name} - property is unknown`);
        continue;
      }
      const allowableTypes = (_b = allowedTypes[propertyMatcherPath]) != null ? _b : [currentValueType];
      if (currentValueType === CLASS_INSTANCE_TYPE && newValueType === "object") {
      } else if (currentValueType != null && newValueType != null && !allowableTypes.includes(newValueType)) {
        Logger.warn(
          `unable to set [${propertyPath}] in ${targetClass == null ? void 0 : targetClass.name} - can't apply type of [${newValueType}], allowed types are: [${allowableTypes}]`
        );
        continue;
      }
      if (newValueType === "array") {
        ctr = (_c = ctr != null ? ctr : constructedArrays.get(currentValue)) != null ? _c : constructors[`${propertyMatcherPath}[]`];
        if (isProperties(targetAny[property])) {
          targetAny[property].set(newValue);
        } else if (ctr != null) {
          const newValueArray = newValue;
          targetAny[property] = newValueArray.map(
            (v, idx2) => jsonApply(new ctr(), v, __spreadProps(__spreadValues({}, params), {
              path: propertyPath,
              matcherPath: propertyMatcherPath + "[]",
              idx: idx2
            }))
          );
        } else {
          targetAny[property] = newValue;
        }
      } else if (newValueType === CLASS_INSTANCE_TYPE) {
        targetAny[property] = newValue;
      } else if (newValueType === "object") {
        if (isProperties(currentValue)) {
          targetAny[property].set(newValue);
        } else if (currentValue != null) {
          jsonApply(currentValue, newValue, __spreadProps(__spreadValues({}, params), {
            path: propertyPath,
            matcherPath: propertyMatcherPath,
            idx: void 0
          }));
        } else if (ctr != null) {
          const obj = new ctr();
          if (isProperties(obj)) {
            targetAny[property] = obj.set(newValue);
          } else {
            targetAny[property] = jsonApply(obj, newValue, __spreadProps(__spreadValues({}, params), {
              path: propertyPath,
              matcherPath: propertyMatcherPath,
              idx: void 0
            }));
          }
        } else {
          targetAny[property] = newValue;
        }
      } else if (isProperties(targetAny[property])) {
        targetAny[property].set(newValue);
      } else {
        targetAny[property] = newValue;
      }
    } catch (error) {
      Logger.warn(`unable to set [${propertyPath}] in [${targetClass == null ? void 0 : targetClass.name}]; nested error is: ${error.message}`);
    }
  }
  return target;
}
function keyMapper(data, key) {
  return data.map((dataObject) => dataObject == null ? void 0 : dataObject[key]);
}
function classify(value) {
  if (value == null) {
    return null;
  }
  if (isHtmlElement(value) || isDate(value)) {
    return "primitive";
  }
  if (isArray(value)) {
    return "array";
  }
  if (isObject(value)) {
    return isPlainObject(value) ? "object" : CLASS_INSTANCE_TYPE;
  }
  if (isFunction(value)) {
    return "function";
  }
  return "primitive";
}

// packages/ag-charts-community/src/chart/factory/seriesTypes.ts
var SERIES_FACTORIES = {};
var SERIES_DEFAULTS = {};
var SERIES_THEME_TEMPLATES = {};
var ENTERPRISE_SERIES_THEME_TEMPLATES = {};
var SERIES_PALETTE_FACTORIES = {};
var SOLO_SERIES_TYPES = /* @__PURE__ */ new Set();
var STACKABLE_SERIES_TYPES = /* @__PURE__ */ new Set();
var GROUPABLE_SERIES_TYPES = /* @__PURE__ */ new Set();
var STACKED_BY_DEFAULT_SERIES_TYPES = /* @__PURE__ */ new Set();
var SWAP_DEFAULT_AXES_CONDITIONS = {};
function registerSeries({
  identifier: seriesType,
  chartTypes: [chartType2],
  instanceConstructor,
  seriesDefaults,
  themeTemplate,
  enterpriseThemeTemplate,
  paletteFactory,
  solo,
  stackable,
  groupable,
  stackedByDefault,
  swapDefaultAxesCondition
}) {
  SERIES_FACTORIES[seriesType] = instanceConstructor;
  SERIES_DEFAULTS[seriesType] = seriesDefaults;
  registerSeriesThemeTemplate(seriesType, themeTemplate, enterpriseThemeTemplate);
  if (paletteFactory) {
    addSeriesPaletteFactory(seriesType, paletteFactory);
  }
  if (solo) {
    addSoloSeriesType(seriesType);
  }
  if (stackable) {
    addStackableSeriesType(seriesType);
  }
  if (groupable) {
    addGroupableSeriesType(seriesType);
  }
  if (stackedByDefault) {
    addStackedByDefaultSeriesType(seriesType);
  }
  if (swapDefaultAxesCondition) {
    addSwapDefaultAxesCondition(seriesType, swapDefaultAxesCondition);
  }
  registerChartSeriesType(seriesType, chartType2);
}
function registerSeriesThemeTemplate(seriesType, themeTemplate, enterpriseThemeTemplate = {}) {
  const existingTemplate = SERIES_THEME_TEMPLATES[seriesType];
  SERIES_THEME_TEMPLATES[seriesType] = mergeDefaults(themeTemplate, existingTemplate);
  ENTERPRISE_SERIES_THEME_TEMPLATES[seriesType] = mergeDefaults(
    enterpriseThemeTemplate,
    themeTemplate,
    existingTemplate
  );
}
function createSeries(seriesType, moduleCtx) {
  const seriesConstructor = SERIES_FACTORIES[seriesType];
  if (seriesConstructor) {
    return new seriesConstructor(moduleCtx);
  }
  throw new Error(`AG Charts - unknown series type: ${seriesType}`);
}
function getSeriesDefaults(chartType2) {
  var _a;
  return deepClone((_a = SERIES_DEFAULTS[chartType2]) != null ? _a : {});
}
function getSeriesThemeTemplate(chartType2) {
  if (enterpriseModule.isEnterprise) {
    return ENTERPRISE_SERIES_THEME_TEMPLATES[chartType2];
  }
  return SERIES_THEME_TEMPLATES[chartType2];
}
function addSeriesPaletteFactory(seriesType, factory) {
  SERIES_PALETTE_FACTORIES[seriesType] = factory;
}
function getSeriesPaletteFactory(seriesType) {
  return SERIES_PALETTE_FACTORIES[seriesType];
}
function isSoloSeries(seriesType) {
  return SOLO_SERIES_TYPES.has(seriesType);
}
function isStackableSeries(seriesType) {
  return STACKABLE_SERIES_TYPES.has(seriesType);
}
function isGroupableSeries(seriesType) {
  return GROUPABLE_SERIES_TYPES.has(seriesType);
}
function isSeriesStackedByDefault(seriesType) {
  return STACKED_BY_DEFAULT_SERIES_TYPES.has(seriesType);
}
function addGroupableSeriesType(seriesType) {
  GROUPABLE_SERIES_TYPES.add(seriesType);
}
function addSoloSeriesType(seriesType) {
  SOLO_SERIES_TYPES.add(seriesType);
}
function addStackableSeriesType(seriesType) {
  STACKABLE_SERIES_TYPES.add(seriesType);
}
function addStackedByDefaultSeriesType(seriesType) {
  STACKED_BY_DEFAULT_SERIES_TYPES.add(seriesType);
}
function addSwapDefaultAxesCondition(seriesType, predicate) {
  SWAP_DEFAULT_AXES_CONDITIONS[seriesType] = predicate;
}
function isDefaultAxisSwapNeeded(opts) {
  var _a, _b;
  let result;
  for (const series of (_a = opts.series) != null ? _a : []) {
    const { type = "line" } = series;
    const isDefaultAxisSwapped = (_b = SWAP_DEFAULT_AXES_CONDITIONS[type]) == null ? void 0 : _b.call(SWAP_DEFAULT_AXES_CONDITIONS, series);
    if (isDefaultAxisSwapped != null) {
      if (result != null && result != isDefaultAxisSwapped) {
        throw new Error("AG Charts - The provided series have incompatible directions");
      }
      result = isDefaultAxisSwapped;
    }
  }
  return result;
}
var LEGEND_KEYS = {};
function registerLegend(type, key, ctr, theme) {
  LEGEND_KEYS[type] = key;
  LEGEND_THEME_TEMPLATES[key] = theme;
}
var LEGEND_THEME_TEMPLATES = {};
function getLegendThemeTemplates() {
  return LEGEND_THEME_TEMPLATES;
}
function getLegendKeys() {
  return LEGEND_KEYS;
}

// packages/ag-charts-community/src/chart/themes/constants.ts
var FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2) => {
  FONT_SIZE2[FONT_SIZE2["SMALL"] = 12] = "SMALL";
  FONT_SIZE2[FONT_SIZE2["MEDIUM"] = 13] = "MEDIUM";
  FONT_SIZE2[FONT_SIZE2["LARGE"] = 17] = "LARGE";
  return FONT_SIZE2;
})(FONT_SIZE || {});
var FONT_WEIGHT = /* @__PURE__ */ ((FONT_WEIGHT3) => {
  FONT_WEIGHT3["NORMAL"] = "normal";
  FONT_WEIGHT3["BOLD"] = "bold";
  FONT_WEIGHT3["BOLDER"] = "bolder";
  FONT_WEIGHT3["LIGHTER"] = "lighter";
  return FONT_WEIGHT3;
})(FONT_WEIGHT || {});
var POSITION = /* @__PURE__ */ ((POSITION3) => {
  POSITION3["TOP"] = "top";
  POSITION3["RIGHT"] = "right";
  POSITION3["BOTTOM"] = "bottom";
  POSITION3["LEFT"] = "left";
  return POSITION3;
})(POSITION || {});
var CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2) => {
  CARTESIAN_AXIS_TYPE2["CATEGORY"] = "category";
  CARTESIAN_AXIS_TYPE2["NUMBER"] = "number";
  CARTESIAN_AXIS_TYPE2["TIME"] = "time";
  CARTESIAN_AXIS_TYPE2["LOG"] = "log";
  return CARTESIAN_AXIS_TYPE2;
})(CARTESIAN_AXIS_TYPE || {});
var POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2) => {
  POLAR_AXIS_TYPE2["ANGLE_CATEGORY"] = "angle-category";
  POLAR_AXIS_TYPE2["ANGLE_NUMBER"] = "angle-number";
  POLAR_AXIS_TYPE2["RADIUS_CATEGORY"] = "radius-category";
  POLAR_AXIS_TYPE2["RADIUS_NUMBER"] = "radius-number";
  return POLAR_AXIS_TYPE2;
})(POLAR_AXIS_TYPE || {});
var POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2) => {
  POLAR_AXIS_SHAPE2["CIRCLE"] = "circle";
  POLAR_AXIS_SHAPE2["POLYGON"] = "polygon";
  return POLAR_AXIS_SHAPE2;
})(POLAR_AXIS_SHAPE || {});

// packages/ag-charts-community/src/chart/themes/defaultColors.ts
var DEFAULT_FILLS = {
  BLUE: "#5090dc",
  ORANGE: "#ffa03a",
  GREEN: "#459d55",
  CYAN: "#34bfe1",
  YELLOW: "#e1cc00",
  VIOLET: "#9669cb",
  GRAY: "#b5b5b5",
  MAGENTA: "#bd5aa7",
  BROWN: "#8a6224",
  RED: "#ef5452"
};
var DEFAULT_STROKES = {
  BLUE: "#2b5c95",
  ORANGE: "#cc6f10",
  GREEN: "#1e652e",
  CYAN: "#18859e",
  YELLOW: "#a69400",
  VIOLET: "#603c88",
  GRAY: "#575757",
  MAGENTA: "#7d2f6d",
  BROWN: "#4f3508",
  RED: "#a82529"
};

// packages/ag-charts-community/src/chart/themes/symbols.ts
var IS_DARK_THEME = Symbol("is-dark-theme");
var EXTENDS_CHART_DEFAULTS = Symbol("extends-chart-defaults");
var EXTENDS_LEGEND_DEFAULTS = Symbol("extends-legend-defaults");
var EXTENDS_LEGEND_ITEM_DEFAULTS = Symbol("extends-legend-item-defaults");
var EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS = Symbol("extends-legend-item-marker-defaults");
var EXTENDS_AXES_DEFAULTS = Symbol("extends-axes-defaults");
var EXTENDS_AXES_LABEL_DEFAULTS = Symbol("extends-axes-label-defaults");
var EXTENDS_AXES_LINE_DEFAULTS = Symbol("extends-axes-line-defaults");
var EXTENDS_AXES_TICK_DEFAULTS = Symbol("extends-axes-tick-defaults");
var EXTENDS_AXES_GRID_LINE_DEFAULTS = Symbol("extends-axes-grid-line-defaults");
var EXTENDS_SERIES_DEFAULTS = Symbol("extends-series-defaults");
var EXTENDS_CARTESIAN_MARKER_DEFAULTS = Symbol("extends-cartesian-marker-defaults");
var OVERRIDE_SERIES_LABEL_DEFAULTS = Symbol("override-series-label-defaults");
var DEFAULT_FONT_FAMILY = Symbol("default-font");
var DEFAULT_LABEL_COLOUR = Symbol("default-label-colour");
var DEFAULT_INVERTED_LABEL_COLOUR = Symbol("default-inverted-label-colour");
var DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol("default-inside-series-label-colour");
var DEFAULT_MUTED_LABEL_COLOUR = Symbol("default-muted-label-colour");
var DEFAULT_AXIS_GRID_COLOUR = Symbol("default-axis-grid-colour");
var DEFAULT_AXIS_LINE_COLOUR = Symbol("default-axis-line-colour");
var DEFAULT_CROSS_LINES_COLOUR = Symbol("default-cross-lines-colour");
var DEFAULT_BACKGROUND_COLOUR = Symbol("default-background-colour");
var DEFAULT_SHADOW_COLOUR = Symbol("default-shadow-colour");
var DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS = Symbol(
  "default-waterfall-series-positive-colors"
);
var DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS = Symbol(
  "default-waterfall-series-negative-colors"
);
var DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS = Symbol(
  "default-waterfall-series-total-colors"
);
var DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE = Symbol(
  "default-waterfall-series-connector-line-stroke"
);
var DEFAULT_POLAR_SERIES_STROKE = Symbol("default-polar-series-stroke");
var DEFAULT_DIVERGING_SERIES_COLOUR_RANGE = Symbol(
  "default-diverging-series-colour-range"
);
var DEFAULT_HIERARCHY_FILLS = Symbol("default-hierarchy-fills");
var DEFAULT_HIERARCHY_STROKES = Symbol("default-hierarchy-strokes");

// packages/ag-charts-community/src/chart/themes/chartTheme.ts
var DEFAULT_BACKGROUND_FILL = "white";
var palette = {
  fills: Object.values(DEFAULT_FILLS),
  strokes: Object.values(DEFAULT_STROKES)
};
var CHART_TYPE_CONFIG = {
  get cartesian() {
    return { seriesTypes: CHART_TYPES.cartesianTypes, commonOptions: ["zoom", "navigator"] };
  },
  get polar() {
    return { seriesTypes: CHART_TYPES.polarTypes, commonOptions: [] };
  },
  get hierarchy() {
    return { seriesTypes: CHART_TYPES.hierarchyTypes, commonOptions: [] };
  }
};
var CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => [...r, ...commonOptions], []);
function resolvePartialPalette(partialPalette, basePalette) {
  var _a, _b;
  if (partialPalette == null)
    return null;
  return {
    fills: (_a = partialPalette.fills) != null ? _a : basePalette.fills,
    strokes: (_b = partialPalette.strokes) != null ? _b : basePalette.strokes
  };
}
var _ChartTheme = class _ChartTheme {
  getPalette() {
    return palette;
  }
  static getAxisDefaults(overrideDefaults) {
    return mergeDefaults(overrideDefaults, {
      top: {},
      right: {},
      bottom: {},
      left: {},
      title: {
        enabled: false,
        text: "Axis Title",
        spacing: 25,
        fontWeight: "normal" /* NORMAL */,
        fontSize: 13 /* MEDIUM */,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR
      },
      label: {
        fontSize: 12 /* SMALL */,
        fontFamily: DEFAULT_FONT_FAMILY,
        padding: 5,
        color: DEFAULT_LABEL_COLOUR,
        avoidCollisions: true
      },
      line: {
        enabled: true,
        width: 1,
        color: DEFAULT_AXIS_LINE_COLOUR
      },
      tick: {
        enabled: false,
        width: 1,
        color: DEFAULT_AXIS_LINE_COLOUR
      },
      gridLine: {
        enabled: true,
        style: [
          {
            stroke: DEFAULT_AXIS_GRID_COLOUR,
            lineDash: []
          }
        ]
      },
      crossLines: {
        enabled: false,
        fill: DEFAULT_CROSS_LINES_COLOUR,
        stroke: DEFAULT_CROSS_LINES_COLOUR,
        fillOpacity: 0.1,
        strokeWidth: 1,
        label: {
          enabled: false,
          fontSize: 12 /* SMALL */,
          fontFamily: DEFAULT_FONT_FAMILY,
          padding: 5,
          color: DEFAULT_LABEL_COLOUR
        }
      }
    });
  }
  static getSeriesDefaults() {
    return {
      tooltip: {
        enabled: true
      },
      visible: true,
      showInLegend: true,
      highlightStyle: {
        item: {
          fill: "rgba(255,255,255, 0.33)",
          stroke: `rgba(0, 0, 0, 0.4)`,
          strokeWidth: 2
        },
        series: {
          dimOpacity: 1
        },
        text: {
          color: "black"
        }
      },
      nodeClickRange: "exact"
    };
  }
  static getCartesianSeriesMarkerDefaults() {
    return {
      enabled: true,
      shape: "circle",
      size: 7,
      strokeWidth: 1
    };
  }
  static getLegendItemMarkerDefaults() {
    return {
      size: 15,
      padding: 8
    };
  }
  static getCaptionWrappingDefaults() {
    return "hyphenate";
  }
  static getChartDefaults() {
    return {
      background: {
        visible: true,
        fill: DEFAULT_BACKGROUND_COLOUR
      },
      padding: {
        top: 20,
        right: 20,
        bottom: 20,
        left: 20
      },
      title: {
        enabled: false,
        text: "Title",
        fontWeight: "normal" /* NORMAL */,
        fontSize: 17 /* LARGE */,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR,
        wrapping: _ChartTheme.getCaptionWrappingDefaults()
      },
      subtitle: {
        enabled: false,
        text: "Subtitle",
        spacing: 20,
        fontSize: 13 /* MEDIUM */,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_MUTED_LABEL_COLOUR,
        wrapping: _ChartTheme.getCaptionWrappingDefaults()
      },
      footnote: {
        enabled: false,
        text: "Footnote",
        spacing: 20,
        fontSize: 13 /* MEDIUM */,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: "rgb(140, 140, 140)",
        wrapping: _ChartTheme.getCaptionWrappingDefaults()
      },
      legend: {
        position: "bottom" /* BOTTOM */,
        spacing: 30,
        listeners: {},
        item: {
          paddingX: 16,
          paddingY: 8,
          marker: _ChartTheme.getLegendItemMarkerDefaults(),
          toggleSeriesVisible: true,
          label: {
            color: DEFAULT_LABEL_COLOUR,
            fontSize: 12 /* SMALL */,
            fontFamily: DEFAULT_FONT_FAMILY
          }
        },
        reverseOrder: false,
        pagination: {
          marker: {
            size: 12
          },
          activeStyle: {
            fill: DEFAULT_LABEL_COLOUR
          },
          inactiveStyle: {
            fill: DEFAULT_MUTED_LABEL_COLOUR
          },
          highlightStyle: {
            fill: DEFAULT_LABEL_COLOUR
          },
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        }
      },
      tooltip: {
        enabled: true,
        darkTheme: IS_DARK_THEME,
        range: "nearest",
        delay: 0
      },
      overlays: {
        loading: {
          darkTheme: IS_DARK_THEME
        },
        noData: {
          darkTheme: IS_DARK_THEME
        },
        noVisibleSeries: {
          darkTheme: IS_DARK_THEME
        }
      },
      listeners: {}
    };
  }
  constructor(options) {
    var _a;
    options = deepClone(options != null ? options : {});
    const { overrides = null, palette: palette11 = null } = options;
    const defaults = this.createChartConfigPerChartType(this.getDefaults());
    if (overrides) {
      const { common } = overrides;
      const applyOverrides = (seriesTypes, overrideOpts) => {
        if (!overrideOpts)
          return;
        for (const s of seriesTypes) {
          const seriesType = s;
          defaults[seriesType] = mergeDefaults(overrideOpts, defaults[seriesType]);
        }
      };
      for (const [, { seriesTypes, commonOptions }] of Object.entries(CHART_TYPE_CONFIG)) {
        const cleanedCommon = __spreadValues({}, common);
        for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {
          if (!commonOptions.includes(commonKey)) {
            delete cleanedCommon[commonKey];
          }
        }
        applyOverrides(seriesTypes, cleanedCommon);
      }
      CHART_TYPES.seriesTypes.forEach((s) => {
        const seriesType = s;
        if (overrides[seriesType]) {
          defaults[seriesType] = mergeDefaults(overrides[seriesType], defaults[seriesType]);
        }
      });
    }
    const basePalette = this.getPalette();
    this.palette = (_a = resolvePartialPalette(palette11, basePalette)) != null ? _a : basePalette;
    this.config = Object.freeze(this.templateTheme(defaults));
  }
  createChartConfigPerChartType(config) {
    Object.entries(CHART_TYPE_CONFIG).forEach(([nextType, { seriesTypes }]) => {
      const typeDefaults = getChartDefaults(nextType);
      seriesTypes.forEach((seriesType) => {
        const alias = seriesType;
        config[alias] || (config[alias] = deepClone(typeDefaults));
      });
    });
    return config;
  }
  getDefaults() {
    const getChartTypeDefaults = (chartType2) => {
      return __spreadValues(__spreadValues(__spreadValues({
        axes: {}
      }, getLegendThemeTemplates()), _ChartTheme.getChartDefaults()), getChartDefaults(chartType2));
    };
    const getOverridesByType = (chartType2, seriesTypes) => {
      var _a;
      const chartDefaults = getChartTypeDefaults(chartType2);
      const result = {};
      for (const seriesType of seriesTypes) {
        result[seriesType] = mergeDefaults(
          getSeriesThemeTemplate(seriesType),
          (_a = result[seriesType]) != null ? _a : deepClone(chartDefaults)
        );
        const { axes } = result[seriesType];
        for (const axisType of AXIS_TYPES.axesTypes) {
          axes[axisType] = mergeDefaults(
            axes[axisType],
            getAxisThemeTemplate(axisType),
            chartType2 === "cartesian" && _ChartTheme.cartesianAxisDefault[axisType]
          );
        }
      }
      return result;
    };
    return mergeDefaults(
      getOverridesByType("cartesian", CHART_TYPES.cartesianTypes),
      getOverridesByType("polar", CHART_TYPES.polarTypes),
      getOverridesByType("hierarchy", CHART_TYPES.hierarchyTypes)
    );
  }
  templateTheme(themeTemplate) {
    const themeInstance = deepClone(themeTemplate);
    const { extensions, properties } = this.getTemplateParameters();
    jsonWalk(themeInstance, (node) => {
      if (node["__extends__"]) {
        const key = node["__extends__"];
        const source = extensions.get(key);
        if (source == null) {
          throw new Error(`AG Charts - no template variable provided for: ${key}`);
        }
        Object.keys(source).forEach((key2) => {
          if (!(key2 in node)) {
            node[key2] = source[key2];
          } else if (isObject(node[key2])) {
            node[key2] = mergeDefaults(node[key2], source[key2]);
          }
        });
        delete node["__extends__"];
      }
      if (node["__overrides__"]) {
        const key = node["__overrides__"];
        const source = extensions.get(key);
        if (source == null) {
          throw new Error(`AG Charts - no template variable provided for: ${key}`);
        }
        Object.assign(node, source);
        delete node["__overrides__"];
      }
      if (isArray(node)) {
        for (let i = 0; i < node.length; i++) {
          const symbol = node[i];
          if (properties.has(symbol)) {
            node[i] = properties.get(symbol);
          }
        }
      } else {
        for (const [name, value] of Object.entries(node)) {
          if (properties.has(value)) {
            node[name] = properties.get(value);
          }
        }
      }
    });
    return deepClone(themeInstance);
  }
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: DEFAULT_FILLS.BLUE,
      stroke: DEFAULT_STROKES.BLUE,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: DEFAULT_FILLS.ORANGE,
      stroke: DEFAULT_STROKES.ORANGE,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: DEFAULT_FILLS.GRAY,
      stroke: DEFAULT_STROKES.GRAY,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  getTemplateParameters() {
    const extensions = /* @__PURE__ */ new Map();
    extensions.set(EXTENDS_CHART_DEFAULTS, _ChartTheme.getChartDefaults());
    extensions.set(EXTENDS_AXES_DEFAULTS, _ChartTheme.getAxisDefaults());
    extensions.set(EXTENDS_LEGEND_DEFAULTS, _ChartTheme.getChartDefaults().legend);
    extensions.set(EXTENDS_LEGEND_ITEM_DEFAULTS, _ChartTheme.getChartDefaults().legend.item);
    extensions.set(EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS, _ChartTheme.getLegendItemMarkerDefaults());
    extensions.set(EXTENDS_AXES_LABEL_DEFAULTS, _ChartTheme.getAxisDefaults().label);
    extensions.set(EXTENDS_AXES_LINE_DEFAULTS, _ChartTheme.getAxisDefaults().line);
    extensions.set(EXTENDS_AXES_TICK_DEFAULTS, _ChartTheme.getAxisDefaults().tick);
    extensions.set(EXTENDS_AXES_GRID_LINE_DEFAULTS, _ChartTheme.getAxisDefaults().gridLine);
    extensions.set(EXTENDS_SERIES_DEFAULTS, _ChartTheme.getSeriesDefaults());
    extensions.set(OVERRIDE_SERIES_LABEL_DEFAULTS, {});
    extensions.set(EXTENDS_CARTESIAN_MARKER_DEFAULTS, _ChartTheme.getCartesianSeriesMarkerDefaults());
    const properties = /* @__PURE__ */ new Map();
    properties.set(IS_DARK_THEME, false);
    properties.set(DEFAULT_FONT_FAMILY, "Verdana, sans-serif");
    properties.set(DEFAULT_LABEL_COLOUR, "rgb(70, 70, 70)");
    properties.set(DEFAULT_INVERTED_LABEL_COLOUR, "white");
    properties.set(DEFAULT_MUTED_LABEL_COLOUR, "rgb(140, 140, 140)");
    properties.set(DEFAULT_AXIS_GRID_COLOUR, "rgb(224,234,241)");
    properties.set(DEFAULT_AXIS_LINE_COLOUR, "rgb(195, 195, 195)");
    properties.set(DEFAULT_CROSS_LINES_COLOUR, "rgb(70, 70, 70)");
    properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);
    properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);
    properties.set(DEFAULT_SHADOW_COLOUR, "rgba(0, 0, 0, 0.5)");
    properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      DEFAULT_FILLS.ORANGE,
      DEFAULT_FILLS.YELLOW,
      DEFAULT_FILLS.GREEN
    ]);
    properties.set(DEFAULT_HIERARCHY_FILLS, ["#ffffff", "#e0e5ea", "#c1ccd5", "#a3b4c1", "#859cad"]);
    properties.set(DEFAULT_HIERARCHY_STROKES, ["#ffffff", "#c5cbd1", "#a4b1bd", "#8498a9", "#648096"]);
    properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);
    properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, _ChartTheme.getWaterfallSeriesDefaultPositiveColors());
    properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, _ChartTheme.getWaterfallSeriesDefaultNegativeColors());
    properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, _ChartTheme.getWaterfallSeriesDefaultTotalColors());
    properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _ChartTheme.getWaterfallSeriesDefaultTotalColors().stroke
    );
    return {
      extensions,
      properties
    };
  }
};
_ChartTheme.cartesianAxisDefault = {
  ["number" /* NUMBER */]: _ChartTheme.getAxisDefaults({
    line: {
      enabled: false
    }
  }),
  ["log" /* LOG */]: _ChartTheme.getAxisDefaults({
    base: 10,
    line: {
      enabled: false
    }
  }),
  ["category" /* CATEGORY */]: _ChartTheme.getAxisDefaults({
    groupPaddingInner: 0.1,
    label: {
      autoRotate: true
    },
    gridLine: {
      enabled: false
    }
  }),
  ["time" /* TIME */]: _ChartTheme.getAxisDefaults({
    gridLine: {
      enabled: false
    }
  }),
  "grouped-category": _ChartTheme.getAxisDefaults()
};
var ChartTheme = _ChartTheme;

// packages/ag-charts-community/src/chart/themes/darkTheme.ts
var DEFAULT_DARK_BACKGROUND_FILL = "#192232";
var DEFAULT_DARK_FILLS = {
  BLUE: "#5090dc",
  ORANGE: "#ffa03a",
  GREEN: "#459d55",
  CYAN: "#34bfe1",
  YELLOW: "#e1cc00",
  VIOLET: "#9669cb",
  GRAY: "#b5b5b5",
  MAGENTA: "#bd5aa7",
  BROWN: "#8a6224",
  RED: "#ef5452"
};
var DEFAULT_DARK_STROKES = {
  BLUE: "#74a8e6",
  ORANGE: "#ffbe70",
  GREEN: "#6cb176",
  CYAN: "#75d4ef",
  YELLOW: "#f6e559",
  VIOLET: "#aa86d8",
  GRAY: "#a1a1a1",
  MAGENTA: "#ce7ab9",
  BROWN: "#997b52",
  RED: "#ff7872"
};
var palette2 = {
  fills: Object.values(DEFAULT_DARK_FILLS),
  strokes: Object.values(DEFAULT_DARK_STROKES)
};
var DarkTheme = class _DarkTheme extends ChartTheme {
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: DEFAULT_DARK_FILLS.BLUE,
      stroke: DEFAULT_DARK_STROKES.BLUE,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: DEFAULT_DARK_FILLS.ORANGE,
      stroke: DEFAULT_DARK_STROKES.ORANGE,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: DEFAULT_DARK_FILLS.GRAY,
      stroke: DEFAULT_DARK_STROKES.GRAY,
      label: {
        color: "white"
      }
    };
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.properties.set(IS_DARK_THEME, true);
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
      _DarkTheme.getWaterfallSeriesDefaultPositiveColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
      _DarkTheme.getWaterfallSeriesDefaultNegativeColors()
    );
    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, _DarkTheme.getWaterfallSeriesDefaultTotalColors());
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _DarkTheme.getWaterfallSeriesDefaultTotalColors().stroke
    );
    result.properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);
    result.properties.set(DEFAULT_LABEL_COLOUR, "white");
    result.properties.set(DEFAULT_MUTED_LABEL_COLOUR, "#7D91A0");
    result.properties.set(DEFAULT_AXIS_GRID_COLOUR, "#545A6E");
    result.properties.set(DEFAULT_CROSS_LINES_COLOUR, "white");
    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      DEFAULT_DARK_FILLS.ORANGE,
      DEFAULT_DARK_FILLS.YELLOW,
      DEFAULT_DARK_FILLS.GREEN
    ]);
    result.properties.set(DEFAULT_HIERARCHY_FILLS, ["#192834", "#253746", "#324859", "#3f596c", "#4d6a80"]);
    result.properties.set(DEFAULT_HIERARCHY_STROKES, ["#192834", "#3b5164", "#496275", "#577287", "#668399"]);
    result.properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);
    result.properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);
    return result;
  }
  getPalette() {
    return palette2;
  }
  constructor(options) {
    super(options);
  }
};

// packages/ag-charts-community/src/chart/themes/materialDark.ts
var MATERIAL_DARK_FILLS = {
  BLUE: "#2196F3",
  ORANGE: "#FF9800",
  GREEN: "#4CAF50",
  CYAN: "#00BCD4",
  YELLOW: "#FFEB3B",
  VIOLET: "#7E57C2",
  GRAY: "#9E9E9E",
  MAGENTA: "#F06292",
  BROWN: "#795548",
  RED: "#F44336"
};
var MATERIAL_DARK_STROKES = {
  BLUE: "#90CAF9",
  ORANGE: "#FFCC80",
  GREEN: "#A5D6A7",
  CYAN: "#80DEEA",
  YELLOW: "#FFF9C4",
  VIOLET: "#B39DDB",
  GRAY: "#E0E0E0",
  MAGENTA: "#F48FB1",
  BROWN: "#A1887F",
  RED: "#EF9A9A"
};
var palette3 = {
  fills: Object.values(MATERIAL_DARK_FILLS),
  strokes: Object.values(MATERIAL_DARK_STROKES)
};
var MaterialDark = class _MaterialDark extends DarkTheme {
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: MATERIAL_DARK_FILLS.BLUE,
      stroke: MATERIAL_DARK_STROKES.BLUE,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: MATERIAL_DARK_FILLS.RED,
      stroke: MATERIAL_DARK_STROKES.RED,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: MATERIAL_DARK_FILLS.GRAY,
      stroke: MATERIAL_DARK_STROKES.GRAY,
      label: {
        color: "white"
      }
    };
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
      _MaterialDark.getWaterfallSeriesDefaultPositiveColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
      _MaterialDark.getWaterfallSeriesDefaultNegativeColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
      _MaterialDark.getWaterfallSeriesDefaultTotalColors()
    );
    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      MATERIAL_DARK_FILLS.ORANGE,
      MATERIAL_DARK_FILLS.YELLOW,
      MATERIAL_DARK_FILLS.GREEN
    ]);
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _MaterialDark.getWaterfallSeriesDefaultTotalColors().stroke
    );
    return result;
  }
  getPalette() {
    return palette3;
  }
};

// packages/ag-charts-community/src/chart/themes/materialLight.ts
var MATERIAL_LIGHT_FILLS = {
  BLUE: "#2196F3",
  ORANGE: "#FF9800",
  GREEN: "#4CAF50",
  CYAN: "#00BCD4",
  YELLOW: "#FFEB3B",
  VIOLET: "#7E57C2",
  GRAY: "#9E9E9E",
  MAGENTA: "#F06292",
  BROWN: "#795548",
  RED: "#F44336"
};
var MATERIAL_LIGHT_STROKES = {
  BLUE: "#1565C0",
  ORANGE: "#E65100",
  GREEN: "#2E7D32",
  CYAN: "#00838F",
  YELLOW: "#F9A825",
  VIOLET: "#4527A0",
  GRAY: "#616161",
  MAGENTA: "#C2185B",
  BROWN: "#4E342E",
  RED: "#B71C1C"
};
var palette4 = {
  fills: Object.values(MATERIAL_LIGHT_FILLS),
  strokes: Object.values(MATERIAL_LIGHT_STROKES)
};
var MaterialLight = class _MaterialLight extends ChartTheme {
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: MATERIAL_LIGHT_FILLS.BLUE,
      stroke: MATERIAL_LIGHT_STROKES.BLUE,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: MATERIAL_LIGHT_FILLS.RED,
      stroke: MATERIAL_LIGHT_STROKES.RED,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: MATERIAL_LIGHT_FILLS.GRAY,
      stroke: MATERIAL_LIGHT_STROKES.GRAY,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
      _MaterialLight.getWaterfallSeriesDefaultPositiveColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
      _MaterialLight.getWaterfallSeriesDefaultNegativeColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
      _MaterialLight.getWaterfallSeriesDefaultTotalColors()
    );
    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      MATERIAL_LIGHT_FILLS.ORANGE,
      MATERIAL_LIGHT_FILLS.YELLOW,
      MATERIAL_LIGHT_FILLS.GREEN
    ]);
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _MaterialLight.getWaterfallSeriesDefaultTotalColors().stroke
    );
    return result;
  }
  getPalette() {
    return palette4;
  }
};

// packages/ag-charts-community/src/chart/themes/polychromaDark.ts
var POLYCHROMA_DARK_FILLS = {
  BLUE: "#436ff4",
  PURPLE: "#9a7bff",
  MAGENTA: "#d165d2",
  PINK: "#f0598b",
  RED: "#f47348",
  ORANGE: "#f2a602",
  YELLOW: "#e9e201",
  GREEN: "#21b448",
  CYAN: "#00b9a2",
  MODERATE_BLUE: "#00aee4"
};
var POLYCHROMA_DARK_STROKES = {
  BLUE: "#6698ff",
  PURPLE: "#c0a3ff",
  MAGENTA: "#fc8dfc",
  PINK: "#ff82b1",
  RED: "#ff9b70",
  ORANGE: "#ffcf4e",
  YELLOW: "#ffff58",
  GREEN: "#58dd70",
  CYAN: "#51e2c9",
  MODERATE_BLUE: "#4fd7ff"
};
var POLYCHROMA_DARK_FILL_GRAY = "#bbbbbb";
var POLYCHROMA_DARK_STROKE_GRAY = "#eeeeee";
var palette5 = {
  fills: Object.values(POLYCHROMA_DARK_FILLS),
  strokes: Object.values(POLYCHROMA_DARK_STROKES)
};
var PolychromaDark = class _PolychromaDark extends DarkTheme {
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: POLYCHROMA_DARK_FILLS.BLUE,
      stroke: POLYCHROMA_DARK_STROKES.BLUE,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: POLYCHROMA_DARK_FILLS.RED,
      stroke: POLYCHROMA_DARK_STROKES.RED,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: POLYCHROMA_DARK_FILL_GRAY,
      stroke: POLYCHROMA_DARK_STROKE_GRAY,
      label: {
        color: "white"
      }
    };
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
      _PolychromaDark.getWaterfallSeriesDefaultPositiveColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
      _PolychromaDark.getWaterfallSeriesDefaultNegativeColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
      _PolychromaDark.getWaterfallSeriesDefaultTotalColors()
    );
    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      POLYCHROMA_DARK_FILLS.BLUE,
      POLYCHROMA_DARK_FILLS.RED
    ]);
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _PolychromaDark.getWaterfallSeriesDefaultTotalColors().stroke
    );
    return result;
  }
  getPalette() {
    return palette5;
  }
};

// packages/ag-charts-community/src/chart/themes/polychromaLight.ts
var POLYCHROMA_LIGHT_FILLS = {
  BLUE: "#436ff4",
  PURPLE: "#9a7bff",
  MAGENTA: "#d165d2",
  PINK: "#f0598b",
  RED: "#f47348",
  ORANGE: "#f2a602",
  YELLOW: "#e9e201",
  GREEN: "#21b448",
  CYAN: "#00b9a2",
  MODERATE_BLUE: "#00aee4"
};
var POLYCHROMA_LIGHT_STROKES = {
  BLUE: "#2346c9",
  PURPLE: "#7653d4",
  MAGENTA: "#a73da9",
  PINK: "#c32d66",
  RED: "#c84b1c",
  ORANGE: "#c87f00",
  YELLOW: "#c1b900",
  GREEN: "#008c1c",
  CYAN: "#00927c",
  MODERATE_BLUE: "#0087bb"
};
var POLYCHROMA_LIGHT_FILL_GRAY = "#bbbbbb";
var POLYCHROMA_LIGHT_STROKE_GRAY = "#888888";
var palette6 = {
  fills: Object.values(POLYCHROMA_LIGHT_FILLS),
  strokes: Object.values(POLYCHROMA_LIGHT_STROKES)
};
var PolychromaLight = class _PolychromaLight extends ChartTheme {
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: POLYCHROMA_LIGHT_FILLS.BLUE,
      stroke: POLYCHROMA_LIGHT_STROKES.BLUE,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: POLYCHROMA_LIGHT_FILLS.RED,
      stroke: POLYCHROMA_LIGHT_STROKES.RED,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: POLYCHROMA_LIGHT_FILL_GRAY,
      stroke: POLYCHROMA_LIGHT_STROKE_GRAY,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
      _PolychromaLight.getWaterfallSeriesDefaultPositiveColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
      _PolychromaLight.getWaterfallSeriesDefaultNegativeColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
      _PolychromaLight.getWaterfallSeriesDefaultTotalColors()
    );
    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      POLYCHROMA_LIGHT_FILLS.BLUE,
      POLYCHROMA_LIGHT_FILLS.RED
    ]);
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _PolychromaLight.getWaterfallSeriesDefaultTotalColors().stroke
    );
    return result;
  }
  getPalette() {
    return palette6;
  }
};

// packages/ag-charts-community/src/chart/themes/sheetsDark.ts
var SHEETS_DARK_FILLS = {
  BLUE: "#4472C4",
  ORANGE: "#ED7D31",
  GRAY: "#A5A5A5",
  YELLOW: "#FFC000",
  MODERATE_BLUE: "#5B9BD5",
  GREEN: "#70AD47",
  DARK_GRAY: "#7B7B7B",
  DARK_BLUE: "#264478",
  VERY_DARK_GRAY: "#636363",
  DARK_YELLOW: "#997300"
};
var SHEETS_DARK_STROKES = {
  BLUE: "#6899ee",
  ORANGE: "#ffa55d",
  GRAY: "#cdcdcd",
  YELLOW: "#ffea53",
  MODERATE_BLUE: "#82c3ff",
  GREEN: "#96d56f",
  DARK_GRAY: "#a1a1a1",
  DARK_BLUE: "#47689f",
  VERY_DARK_GRAY: "#878787",
  DARK_YELLOW: "#c0993d"
};
var palette7 = {
  fills: Object.values(SHEETS_DARK_FILLS),
  strokes: Object.values(SHEETS_DARK_STROKES)
};
var SheetsDark = class _SheetsDark extends DarkTheme {
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: SHEETS_DARK_FILLS.BLUE,
      stroke: SHEETS_DARK_STROKES.BLUE,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: SHEETS_DARK_FILLS.ORANGE,
      stroke: SHEETS_DARK_STROKES.ORANGE,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: SHEETS_DARK_FILLS.GRAY,
      stroke: SHEETS_DARK_STROKES.GRAY,
      label: {
        color: "white"
      }
    };
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
      _SheetsDark.getWaterfallSeriesDefaultPositiveColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
      _SheetsDark.getWaterfallSeriesDefaultNegativeColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
      _SheetsDark.getWaterfallSeriesDefaultTotalColors()
    );
    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      SHEETS_DARK_FILLS.ORANGE,
      SHEETS_DARK_FILLS.YELLOW,
      SHEETS_DARK_FILLS.GREEN
    ]);
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _SheetsDark.getWaterfallSeriesDefaultTotalColors().stroke
    );
    return result;
  }
  getPalette() {
    return palette7;
  }
};

// packages/ag-charts-community/src/chart/themes/sheetsLight.ts
var SHEETS_LIGHT_FILLS = {
  BLUE: "#5281d5",
  ORANGE: "#ff8d44",
  GRAY: "#b5b5b5",
  YELLOW: "#ffd02f",
  MODERATE_BLUE: "#6aabe6",
  GREEN: "#7fbd57",
  DARK_GRAY: "#8a8a8a",
  DARK_BLUE: "#335287",
  VERY_DARK_GRAY: "#717171",
  DARK_YELLOW: "#a98220"
};
var SHEETS_LIGHT_STROKES = {
  BLUE: "#214d9b",
  ORANGE: "#c25600",
  GRAY: "#7f7f7f",
  YELLOW: "#d59800",
  MODERATE_BLUE: "#3575ac",
  GREEN: "#4b861a",
  DARK_GRAY: "#575757",
  DARK_BLUE: "#062253",
  VERY_DARK_GRAY: "#414141",
  DARK_YELLOW: "#734f00"
};
var palette8 = {
  fills: Object.values(SHEETS_LIGHT_FILLS),
  strokes: Object.values(SHEETS_LIGHT_STROKES)
};
var SheetsLight = class _SheetsLight extends ChartTheme {
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: SHEETS_LIGHT_FILLS.BLUE,
      stroke: SHEETS_LIGHT_STROKES.BLUE,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: SHEETS_LIGHT_FILLS.ORANGE,
      stroke: SHEETS_LIGHT_STROKES.ORANGE,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: SHEETS_LIGHT_FILLS.GRAY,
      stroke: SHEETS_LIGHT_STROKES.GRAY,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
      _SheetsLight.getWaterfallSeriesDefaultPositiveColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
      _SheetsLight.getWaterfallSeriesDefaultNegativeColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
      _SheetsLight.getWaterfallSeriesDefaultTotalColors()
    );
    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      SHEETS_LIGHT_FILLS.ORANGE,
      SHEETS_LIGHT_FILLS.YELLOW,
      SHEETS_LIGHT_FILLS.GREEN
    ]);
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _SheetsLight.getWaterfallSeriesDefaultTotalColors().stroke
    );
    return result;
  }
  getPalette() {
    return palette8;
  }
};

// packages/ag-charts-community/src/chart/themes/vividDark.ts
var VIVID_DARK_FILLS = {
  BLUE: "#0083ff",
  ORANGE: "#ff6600",
  GREEN: "#00af00",
  CYAN: "#00ccff",
  YELLOW: "#f7c700",
  VIOLET: "#ac26ff",
  GRAY: "#a7a7b7",
  MAGENTA: "#e800c5",
  BROWN: "#b54300",
  RED: "#ff0000"
};
var VIVID_DARK_STROKES = {
  BLUE: "#67b7ff",
  ORANGE: "#ffc24d",
  GREEN: "#5cc86f",
  CYAN: "#54ebff",
  VIOLET: "#c18aff",
  YELLOW: "#fff653",
  GRAY: "#aeaeae",
  MAGENTA: "#f078d4",
  BROWN: "#ba8438",
  RED: "#ff726e"
};
var palette9 = {
  fills: Object.values(VIVID_DARK_FILLS),
  strokes: Object.values(VIVID_DARK_STROKES)
};
var VividDark = class _VividDark extends DarkTheme {
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: VIVID_DARK_FILLS.BLUE,
      stroke: VIVID_DARK_STROKES.BLUE,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: VIVID_DARK_FILLS.ORANGE,
      stroke: VIVID_DARK_STROKES.ORANGE,
      label: {
        color: "white"
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: VIVID_DARK_FILLS.GRAY,
      stroke: VIVID_DARK_STROKES.GRAY,
      label: {
        color: "white"
      }
    };
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
      _VividDark.getWaterfallSeriesDefaultPositiveColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
      _VividDark.getWaterfallSeriesDefaultNegativeColors()
    );
    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, _VividDark.getWaterfallSeriesDefaultTotalColors());
    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      VIVID_DARK_FILLS.ORANGE,
      VIVID_DARK_FILLS.YELLOW,
      VIVID_DARK_FILLS.GREEN
    ]);
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _VividDark.getWaterfallSeriesDefaultTotalColors().stroke
    );
    return result;
  }
  getPalette() {
    return palette9;
  }
};

// packages/ag-charts-community/src/chart/themes/vividLight.ts
var VIVID_FILLS = {
  BLUE: "#0083ff",
  ORANGE: "#ff6600",
  GREEN: "#00af00",
  CYAN: "#00ccff",
  YELLOW: "#f7c700",
  VIOLET: "#ac26ff",
  GRAY: "#a7a7b7",
  MAGENTA: "#e800c5",
  BROWN: "#b54300",
  RED: "#ff0000"
};
var VIVID_STROKES = {
  BLUE: "#0f68c0",
  ORANGE: "#d47100",
  GREEN: "#007922",
  CYAN: "#009ac2",
  VIOLET: "#bca400",
  YELLOW: "#753cac",
  GRAY: "#646464",
  MAGENTA: "#9b2685",
  BROWN: "#6c3b00",
  RED: "#cb0021"
};
var palette10 = {
  fills: Object.values(VIVID_FILLS),
  strokes: Object.values(VIVID_STROKES)
};
var VividLight = class _VividLight extends ChartTheme {
  static getWaterfallSeriesDefaultPositiveColors() {
    return {
      fill: VIVID_FILLS.BLUE,
      stroke: VIVID_STROKES.BLUE,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultNegativeColors() {
    return {
      fill: VIVID_FILLS.ORANGE,
      stroke: VIVID_STROKES.ORANGE,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  static getWaterfallSeriesDefaultTotalColors() {
    return {
      fill: VIVID_FILLS.GRAY,
      stroke: VIVID_STROKES.GRAY,
      label: {
        color: DEFAULT_LABEL_COLOUR
      }
    };
  }
  getTemplateParameters() {
    const result = super.getTemplateParameters();
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
      _VividLight.getWaterfallSeriesDefaultPositiveColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
      _VividLight.getWaterfallSeriesDefaultNegativeColors()
    );
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
      _VividLight.getWaterfallSeriesDefaultTotalColors()
    );
    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
      VIVID_FILLS.ORANGE,
      VIVID_FILLS.YELLOW,
      VIVID_FILLS.GREEN
    ]);
    result.properties.set(
      DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      _VividLight.getWaterfallSeriesDefaultTotalColors().stroke
    );
    return result;
  }
  getPalette() {
    return palette10;
  }
};

// packages/ag-charts-community/src/chart/mapping/themes.ts
var lightTheme = () => new ChartTheme();
var darkTheme = () => new DarkTheme();
var lightThemes = {
  undefined: lightTheme,
  null: lightTheme,
  "ag-default": lightTheme,
  "ag-sheets": () => new SheetsLight(),
  "ag-polychroma": () => new PolychromaLight(),
  "ag-vivid": () => new VividLight(),
  "ag-material": () => new MaterialLight()
};
var darkThemes = {
  undefined: darkTheme,
  null: darkTheme,
  "ag-default-dark": darkTheme,
  "ag-sheets-dark": () => new SheetsDark(),
  "ag-polychroma-dark": () => new PolychromaDark(),
  "ag-vivid-dark": () => new VividDark(),
  "ag-material-dark": () => new MaterialDark()
};
var themes = __spreadValues(__spreadValues({}, darkThemes), lightThemes);
function validateChartThemeObject(unknownObject) {
  if (unknownObject === null) {
    return;
  }
  let valid = true;
  const { baseTheme, palette: palette11, overrides } = unknownObject;
  if (baseTheme !== void 0 && typeof baseTheme !== "string" && typeof baseTheme !== "object") {
    Logger.warn(`invalid theme.baseTheme type ${typeof baseTheme}, expected (string | object).`);
    valid = false;
  }
  if (overrides !== void 0 && typeof overrides !== "object") {
    Logger.warn(`invalid theme.overrides type ${typeof overrides}, expected object.`);
    valid = false;
  }
  if (typeof palette11 === "object") {
    if (palette11 !== null) {
      const { fills, strokes } = palette11;
      if (fills !== void 0 && !Array.isArray(fills)) {
        Logger.warn(`theme.overrides.fills must be undefined or an array`);
        valid = false;
      }
      if (strokes !== void 0 && !Array.isArray(strokes)) {
        Logger.warn(`theme.overrides.strokes must be undefined or an array`);
        valid = false;
      }
    }
  } else if (palette11 !== void 0) {
    Logger.warn(`invalid theme.palette type ${typeof palette11}, expected object.`);
    valid = false;
  }
  if (valid) {
    return unknownObject;
  }
}
function validateChartTheme(value) {
  if (value === void 0 || typeof value === "string" || value instanceof ChartTheme) {
    return value;
  }
  if (typeof value === "object") {
    return validateChartThemeObject(value);
  }
  Logger.warn(`invalid theme value type ${typeof value}, expected object or string.`);
  return void 0;
}
function getChartTheme(unvalidatedValue) {
  let value = validateChartTheme(unvalidatedValue);
  if (value instanceof ChartTheme) {
    return value;
  }
  if (value === void 0 || typeof value === "string") {
    const stockTheme = themes[value];
    if (stockTheme) {
      return stockTheme();
    }
    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);
    return lightTheme();
  }
  const overrides = [];
  let palette11;
  while (typeof value === "object") {
    overrides.push(value.overrides);
    palette11 != null ? palette11 : palette11 = value.palette;
    value = value.baseTheme;
  }
  const flattenedTheme = {
    baseTheme: value,
    overrides: mergeDefaults(...overrides),
    palette: palette11
  };
  const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();
  return new baseTheme.constructor(flattenedTheme);
}

// packages/ag-charts-community/src/util/array.ts
function extent(values) {
  if (values.length === 0) {
    return;
  }
  let min = Infinity;
  let max = -Infinity;
  for (let v of values) {
    if (v instanceof Date) {
      v = v.getTime();
    }
    if (typeof v !== "number") {
      continue;
    }
    if (v < min) {
      min = v;
    }
    if (v > max) {
      max = v;
    }
  }
  const extent2 = [min, max];
  if (extent2.every(isFinite)) {
    return extent2;
  }
}
function normalisedExtent(d, min, max) {
  return normalisedExtentWithMetadata(d, min, max).extent;
}
function normalisedExtentWithMetadata(d, min, max) {
  var _a;
  let clipped = false;
  if (d.length > 2) {
    d = (_a = extent(d)) != null ? _a : [NaN, NaN];
  }
  if (!isNaN(min)) {
    clipped || (clipped = min > d[0]);
    d = [min, d[1]];
  }
  if (!isNaN(max)) {
    clipped || (clipped = max < d[1]);
    d = [d[0], max];
  }
  if (d[0] > d[1]) {
    d = [];
  }
  return { extent: d, clipped };
}
function arraysEqual(a, b) {
  if (a == null || b == null || a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (Array.isArray(a[i]) && Array.isArray(b[i])) {
      if (!arraysEqual(a[i], b[i])) {
        return false;
      }
    } else if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function toArray(value) {
  if (typeof value === "undefined") {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function unique(array) {
  return Array.from(new Set(array));
}
function groupBy(array, iteratee) {
  return array.reduce((result, item) => {
    var _a;
    const groupKey = iteratee(item);
    (_a = result[groupKey]) != null ? _a : result[groupKey] = [];
    result[groupKey].push(item);
    return result;
  }, {});
}
function circularSliceArray(data, size, offset4 = 0) {
  if (data.length === 0) {
    return [];
  }
  const result = [];
  for (let i = 0; i < size; i++) {
    result.push(data.at((i + offset4) % data.length));
  }
  return result;
}

// packages/ag-charts-community/src/util/window.ts
function windowValue(name) {
  const WINDOW = typeof window !== "undefined" ? window : (
    // typeof global !== 'undefined' ? (global as any) :
    void 0
  );
  return WINDOW == null ? void 0 : WINDOW[name];
}

// packages/ag-charts-community/src/util/debug.ts
var LONG_TIME_PERIOD_THRESHOLD = 2e3;
var timeOfLastLog = Date.now();
var logTimeGap = () => {
  const timeSinceLastLog = Date.now() - timeOfLastLog;
  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {
    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);
    Logger.log(`**** ${prettyDuration}s since last log message ****`);
  }
  timeOfLastLog = Date.now();
};
var Debug = {
  create(...debugSelectors) {
    const resultFn = (...logContent) => {
      if (Debug.check(...debugSelectors)) {
        if (typeof logContent[0] === "function") {
          logContent = toArray(logContent[0]());
        }
        logTimeGap();
        Logger.log(...logContent);
      }
    };
    return Object.assign(resultFn, { check: () => Debug.check(...debugSelectors) });
  },
  check(...debugSelectors) {
    if (debugSelectors.length === 0) {
      debugSelectors.push(true);
    }
    const chartDebug = toArray(windowValue("agChartsDebug"));
    return chartDebug.some((selector) => debugSelectors.includes(selector));
  }
};

// packages/ag-charts-community/src/module/optionsModule.ts
var ChartOptions = class {
  constructor(userOptions, specialOverrides) {
    var _b, _c, _d;
    const cloneOptions = { shallow: ["data"] };
    const options = deepClone(userOptions, cloneOptions);
    const chartType2 = this.optionsType(options);
    this.sanityCheckAndCleanup(options);
    this.userOptions = options;
    this.activeTheme = getChartTheme(options.theme);
    this.seriesDefaults = this.getOptionsDefaults(options);
    this.specialOverrides = this.specialOverridesDefaults(__spreadValues({}, specialOverrides));
    const _a = this.getSeriesThemeConfig(chartType2), { axes: axesThemes = {}, series: seriesThemes } = _a, themeDefaults = __objRest(_a, ["axes", "series"]);
    this.processedOptions = deepClone(
      mergeDefaults(this.userOptions, themeDefaults, this.seriesDefaults),
      cloneOptions
    );
    this.processAxesOptions(this.processedOptions, axesThemes);
    this.processSeriesOptions(this.processedOptions);
    if ((isAgCartesianChartOptions(this.processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(this.processedOptions)) && ((_b = this.processedOptions.legend) == null ? void 0 : _b.enabled) == null) {
      (_d = (_c = this.processedOptions).legend) != null ? _d : _c.legend = {};
      this.processedOptions.legend.enabled = this.processedOptions.series.length > 1;
    }
    this.enableConfiguredOptions(this.processedOptions);
    if (!enterpriseModule.isEnterprise) {
      removeUsedEnterpriseOptions(this.processedOptions);
    }
  }
  getOptions() {
    var _a;
    return (_a = this.processedOptions) != null ? _a : {};
  }
  diffOptions(options) {
    return jsonDiff(options, this.processedOptions);
  }
  getSeriesThemeConfig(seriesType) {
    var _a, _b;
    return deepClone((_b = (_a = this.activeTheme) == null ? void 0 : _a.config[seriesType]) != null ? _b : {});
  }
  getOptionsDefaults(options) {
    const optionsType2 = this.optionsType(options);
    const seriesDefaults = getSeriesDefaults(optionsType2);
    if (isDefaultAxisSwapNeeded(options)) {
      this.swapAxesPosition(seriesDefaults);
    }
    return seriesDefaults;
  }
  optionsType(options) {
    var _a, _b, _c;
    return (_c = (_b = (_a = options.series) == null ? void 0 : _a[0]) == null ? void 0 : _b.type) != null ? _c : "line";
  }
  sanityCheckAndCleanup(options) {
    var _a;
    this.deprecationWarnings(options);
    this.axesTypeIntegrity(options);
    this.seriesTypeIntegrity(options);
    this.soloSeriesIntegrity(options);
    this.removeDisabledOptions(options);
    this.removeLeftoverSymbols(options);
    if (((_a = options.series) == null ? void 0 : _a.some((s) => s.type === "bullet")) && options.sync != null && options.sync.enabled !== false) {
      Logger.warnOnce("bullet series cannot be synced, disabling synchronization.");
      delete options.sync;
    }
  }
  swapAxesPosition(options) {
    var _a;
    if (isAgCartesianChartOptions(options)) {
      const [axis0, axis1] = (_a = options.axes) != null ? _a : [];
      options.axes = [
        __spreadProps(__spreadValues({}, axis0), { position: axis1.position }),
        __spreadProps(__spreadValues({}, axis1), { position: axis0.position })
      ];
    }
  }
  processAxesOptions(options, axesThemes) {
    if (!("axes" in options))
      return;
    options.axes = options.axes.map((axis) => {
      var _a, _b, _d, _e;
      const _c = mergeDefaults(
        (_a = this.seriesDefaults.axes) == null ? void 0 : _a.find(({ type }) => type === axis.type),
        (_b = axesThemes[axis.type]) == null ? void 0 : _b[axis.position],
        axesThemes[axis.type]
      ), { crossLines: crossLinesTheme } = _c, axisTheme = __objRest(_c, ["crossLines"]);
      if (axis.crossLines) {
        axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);
      }
      const gridLineStyle = (_d = axisTheme.gridLine) == null ? void 0 : _d.style;
      if (((_e = axis.gridLine) == null ? void 0 : _e.style) && (gridLineStyle == null ? void 0 : gridLineStyle.length)) {
        axis.gridLine.style = axis.gridLine.style.map(
          (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style
        );
      }
      const _f = mergeDefaults(axis, axisTheme), axisOptions = __objRest(_f, ["top", "right", "bottom", "left"]);
      return axisOptions;
    });
  }
  processSeriesOptions(options) {
    const defaultSeriesType = this.getDefaultSeriesType(options);
    const defaultTooltipPosition = this.getTooltipPositionDefaults(options);
    const paletteOptions = {
      colourIndex: 0,
      userPalette: Boolean(isObject(options.theme) && options.theme.palette)
    };
    const series = options.series.map((series2) => {
      var _a, _b;
      (_a = series2.type) != null ? _a : series2.type = defaultSeriesType;
      const _c = (_b = this.getSeriesThemeConfig(series2.type).series) != null ? _b : {}, { innerLabels: innerLabelsTheme } = _c, seriesTheme = __objRest(_c, ["innerLabels"]);
      const seriesOptions = mergeDefaults(
        this.getSeriesGroupingOptions(series2),
        series2,
        defaultTooltipPosition,
        seriesTheme,
        this.getSeriesPalette(series2.type, paletteOptions)
      );
      if (seriesOptions.innerLabels) {
        seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);
      }
      return this.activeTheme.templateTheme(seriesOptions);
    });
    options.series = this.setSeriesGroupingOptions(series);
  }
  getSeriesPalette(seriesType, options) {
    const paletteFactory = getSeriesPaletteFactory(seriesType);
    const { colourIndex: colourOffset, userPalette } = options;
    const { fills = [], strokes = [] } = this.activeTheme.palette;
    return paletteFactory == null ? void 0 : paletteFactory({
      userPalette,
      colorsCount: Math.max(fills.length, strokes.length),
      themeTemplateParameters: this.activeTheme.getTemplateParameters(),
      takeColors(count2) {
        options.colourIndex += count2;
        return {
          fills: circularSliceArray(fills, count2, colourOffset),
          strokes: circularSliceArray(strokes, count2, colourOffset)
        };
      }
    });
  }
  getSeriesGroupingOptions(series) {
    const groupable = isGroupableSeries(series.type);
    const stackable = isStackableSeries(series.type);
    const stackedByDefault = isSeriesStackedByDefault(series.type);
    if (series.grouped && !groupable) {
      Logger.warnOnce(`unsupported grouping of series type "${series.type}".`);
    }
    if ((series.stacked || series.stackGroup) && !stackable) {
      Logger.warnOnce(`unsupported stacking of series type "${series.type}".`);
    }
    let { grouped, stacked } = series;
    stacked != null ? stacked : stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped);
    grouped != null ? grouped : grouped = true;
    return {
      stacked: stackable && stacked,
      grouped: groupable && grouped && !(stackable && stacked)
    };
  }
  setSeriesGroupingOptions(series) {
    const seriesGroups = this.getSeriesGrouping(series);
    Debug.create(true, "opts")("setSeriesGroupingOptions() - series grouping: ", seriesGroups);
    const groupIdx = {};
    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {
      var _a, _b;
      if (seriesGroup.groupType === "default" /* DEFAULT */) {
        return countMap;
      }
      (_b = countMap[_a = seriesGroup.seriesType]) != null ? _b : countMap[_a] = 0;
      countMap[seriesGroup.seriesType] += seriesGroup.groupType === "stack" /* STACK */ ? 1 : seriesGroup.series.length;
      return countMap;
    }, {});
    return seriesGroups.flatMap((seriesGroup) => {
      var _a, _b;
      (_b = groupIdx[_a = seriesGroup.seriesType]) != null ? _b : groupIdx[_a] = 0;
      switch (seriesGroup.groupType) {
        case "stack" /* STACK */:
          const groupIndex = groupIdx[seriesGroup.seriesType]++;
          return seriesGroup.series.map(
            (series2, stackIndex) => Object.assign(series2, {
              seriesGrouping: {
                groupIndex,
                groupCount: groupCount2[seriesGroup.seriesType],
                stackIndex,
                stackCount: seriesGroup.series.length
              }
            })
          );
        case "group" /* GROUP */:
          return seriesGroup.series.map(
            (series2) => Object.assign(series2, {
              seriesGrouping: {
                groupIndex: groupIdx[seriesGroup.seriesType]++,
                groupCount: groupCount2[seriesGroup.seriesType],
                stackIndex: 0,
                stackCount: 0
              }
            })
          );
      }
      return seriesGroup.series;
    }).map((_a) => {
      var _b = _a, seriesOptions = __objRest(_b, ["stacked", "grouped"]);
      return seriesOptions;
    });
  }
  getSeriesGroupId(series) {
    var _a;
    if (!series.stacked && !series.grouped) {
      return "default-ag-charts-group";
    }
    return [series.type, series.xKey, series.stacked ? (_a = series.stackGroup) != null ? _a : "stacked" : "grouped"].filter(Boolean).join("-");
  }
  getSeriesGrouping(series) {
    const groupMap = /* @__PURE__ */ new Map();
    return series.reduce((result, series2) => {
      const seriesType = series2.type;
      if (!series2.stacked && !series2.grouped) {
        result.push({ groupType: "default" /* DEFAULT */, seriesType, series: [series2] });
      } else {
        const groupId = this.getSeriesGroupId(series2);
        if (!groupMap.has(groupId)) {
          const groupType = series2.stacked ? "stack" /* STACK */ : "group" /* GROUP */;
          const record = { groupType, seriesType, series: [] };
          groupMap.set(groupId, record);
          result.push(record);
        }
        groupMap.get(groupId).series.push(series2);
      }
      return result;
    }, []);
  }
  getDefaultSeriesType(options) {
    if (isAgCartesianChartOptions(options)) {
      return "line";
    } else if (isAgHierarchyChartOptions(options)) {
      return "treemap";
    } else if (isAgPolarChartOptions(options)) {
      return "pie";
    }
    throw new Error("Invalid chart options type detected.");
  }
  getTooltipPositionDefaults(options) {
    var _a;
    const position = (_a = options.tooltip) == null ? void 0 : _a.position;
    if (!isPlainObject(position)) {
      return;
    }
    const { type, xOffset, yOffset } = position;
    const result = {};
    if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {
      result.type = type;
    }
    if (isFiniteNumber(xOffset)) {
      result.xOffset = xOffset;
    }
    if (isFiniteNumber(yOffset)) {
      result.yOffset = yOffset;
    }
    return { tooltip: { position: result } };
  }
  deprecationWarnings(options) {
    const deprecatedArrayProps = { yKeys: "yKey", yNames: "yName" };
    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {
      var _a;
      if ((_a = options.series) == null ? void 0 : _a.some((s) => s[oldProp] != null)) {
        Logger.warnOnce(
          `Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`
        );
      }
    });
  }
  axesTypeIntegrity(options) {
    var _a;
    if ("axes" in options) {
      const axes = (_a = options.axes) != null ? _a : [];
      for (const { type } of axes) {
        if (!isAxisOptionType(type)) {
          delete options.axes;
          Logger.warnOnce(
            `unknown axis type: ${type}; expected one of: ${AXIS_TYPES.axesTypes.join(", ")}, ignoring.`
          );
        }
      }
    }
  }
  seriesTypeIntegrity(options) {
    var _a;
    const series = (_a = options.series) != null ? _a : [];
    options.series = series.filter(({ type }) => {
      if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {
        return true;
      }
      Logger.warnOnce(`unknown series type: ${type}; expected one of: ${CHART_TYPES.seriesTypes.join(", ")}`);
    });
  }
  soloSeriesIntegrity(options) {
    const series = options.series;
    if (series && series.length > 1 && series.some((series2) => isSoloSeries(series2.type))) {
      const mainSeriesType = this.optionsType(options);
      if (isSoloSeries(mainSeriesType)) {
        Logger.warn(
          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`
        );
        options.series = series.slice(0, 1);
      } else {
        const { solo, nonSolo } = groupBy(series, (s) => isSoloSeries(s.type) ? "solo" : "nonSolo");
        const rejects = unique(solo.map((s) => s.type)).join(", ");
        Logger.warn(`Unable to mix these series types with the lead series type: ${rejects}`);
        options.series = nonSolo;
      }
    }
  }
  enableConfiguredOptions(options) {
    jsonWalk(
      this.userOptions,
      (visitingUserOpts, visitingMergedOpts) => {
        if (visitingMergedOpts && "enabled" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {
          visitingMergedOpts.enabled = true;
        }
      },
      { skip: ["data", "theme"] },
      options
    );
    jsonWalk(
      options,
      (visitingMergedOpts) => {
        if (visitingMergedOpts._enabledFromTheme != null) {
          delete visitingMergedOpts._enabledFromTheme;
        }
      },
      { skip: ["data", "theme"] }
    );
  }
  removeDisabledOptions(options) {
    jsonWalk(
      options,
      (optionsNode) => {
        if ("enabled" in optionsNode && optionsNode.enabled === false) {
          Object.keys(optionsNode).forEach((key) => {
            if (key === "enabled")
              return;
            delete optionsNode[key];
          });
        }
      },
      { skip: ["data", "theme"] }
    );
  }
  removeLeftoverSymbols(options) {
    jsonWalk(
      options,
      (optionsNode) => {
        if (!optionsNode || !isObject(optionsNode))
          return;
        for (const [key, value] of Object.entries(optionsNode)) {
          if (isSymbol(value)) {
            delete optionsNode[key];
          }
        }
      },
      { skip: ["data"] }
    );
  }
  specialOverridesDefaults(options) {
    if (options.window == null) {
      if (typeof window !== "undefined") {
        options.window = window;
      } else if (typeof global !== "undefined") {
        options.window = global.window;
      } else {
        throw new Error("AG Charts - unable to resolve global window");
      }
    }
    if (options.document == null) {
      if (typeof document !== "undefined") {
        options.document = document;
      } else if (typeof global !== "undefined") {
        options.document = global.document;
      } else {
        throw new Error("AG Charts - unable to resolve global document");
      }
    }
    return options;
  }
};

// packages/ag-charts-community/src/util/deprecation.ts
function createDeprecationWarning() {
  return (key, message) => {
    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(" ");
    Logger.warnOnce(msg);
  };
}
function Deprecated(message, opts) {
  const warnDeprecated = createDeprecationWarning();
  const def = opts == null ? void 0 : opts.default;
  return addTransformToInstanceProperty((_, key, value) => {
    if (value !== def) {
      warnDeprecated(key.toString(), message);
    }
    return value;
  });
}
function DeprecatedAndRenamedTo(newPropName, mapValue) {
  const warnDeprecated = createDeprecationWarning();
  return addTransformToInstanceProperty(
    (target, key, value) => {
      if (value !== target[newPropName]) {
        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);
        target[newPropName] = mapValue ? mapValue(value) : value;
      }
      return BREAK_TRANSFORM_CHAIN;
    },
    (target, key) => {
      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);
      return target[newPropName];
    }
  );
}

// packages/ag-charts-community/src/motion/fromToMotion.ts
var fromToMotion_exports = {};
__export(fromToMotion_exports, {
  NODE_UPDATE_PHASES: () => NODE_UPDATE_PHASES,
  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,
  fromToMotion: () => fromToMotion,
  staticFromToMotion: () => staticFromToMotion
});

// packages/ag-charts-community/src/util/zip.ts
function zipObject(keys, values) {
  const zipped = {};
  if (Array.isArray(values)) {
    for (let i = 0; i < keys.length; i++) {
      zipped[`${keys[i]}`] = values[i];
    }
  } else {
    for (let i = 0; i < keys.length; i++) {
      zipped[`${keys[i]}`] = values;
    }
  }
  return zipped;
}

// packages/ag-charts-community/src/util/id.ts
var ID_MAP = /* @__PURE__ */ new Map();
function resetIds() {
  ID_MAP.clear();
}
function createId(instance) {
  var _a;
  const constructor = instance.constructor;
  const className = Object.hasOwn(constructor, "className") ? constructor.className : constructor.name;
  if (!className) {
    throw new Error(`The ${constructor} is missing the 'className' property.`);
  }
  const nextId = ((_a = ID_MAP.get(className)) != null ? _a : 0) + 1;
  ID_MAP.set(className, nextId);
  return `${className}-${nextId}`;
}

// packages/ag-charts-community/src/scene/changeDetectable.ts
var RedrawType = /* @__PURE__ */ ((RedrawType2) => {
  RedrawType2[RedrawType2["NONE"] = 0] = "NONE";
  RedrawType2[RedrawType2["TRIVIAL"] = 1] = "TRIVIAL";
  RedrawType2[RedrawType2["MINOR"] = 2] = "MINOR";
  RedrawType2[RedrawType2["MAJOR"] = 3] = "MAJOR";
  return RedrawType2;
})(RedrawType || {});
function functionConstructorAvailable() {
  try {
    new Function("return true");
    return true;
  } catch (e) {
    return false;
  }
}
var STRING_FUNCTION_USEABLE = functionConstructorAvailable();
function SceneChangeDetection(opts) {
  const { changeCb, convertor } = opts != null ? opts : {};
  return function(target, key) {
    const privateKey = `__${key}`;
    if (target[key]) {
      return;
    }
    if (STRING_FUNCTION_USEABLE && changeCb == null && convertor == null) {
      prepareFastGetSet(target, key, privateKey, opts);
    } else {
      prepareSlowGetSet(target, key, privateKey, opts);
    }
  };
}
function prepareFastGetSet(target, key, privateKey, opts) {
  const { redraw = 1 /* TRIVIAL */, type = "normal", checkDirtyOnAssignment = false } = opts != null ? opts : {};
  const setterJs = new Function(
    "value",
    `
        const oldValue = this.${privateKey};
        if (value !== oldValue) {
            this.${privateKey} = value;
            ${type === "normal" ? `this.markDirty(this, ${redraw});` : ""}
            ${type === "transform" ? `this.markDirtyTransform(${redraw});` : ""}
            ${type === "path" ? `if (!this._dirtyPath) { this._dirtyPath = true; this.markDirty(this, ${redraw}); }` : ""}
            ${type === "font" ? `if (!this._dirtyFont) { this._dirtyFont = true; this.markDirty(this, ${redraw}); }` : ""}
        }
        ${checkDirtyOnAssignment ? `if (value != null && value._dirty > ${0 /* NONE */}) { this.markDirty(value, value._dirty); }` : ""}
`
  );
  const getterJs = new Function(`return this.${privateKey};`);
  Object.defineProperty(target, key, {
    set: setterJs,
    get: getterJs,
    enumerable: true,
    configurable: true
  });
}
function prepareSlowGetSet(target, key, privateKey, opts) {
  const {
    redraw = 1 /* TRIVIAL */,
    type = "normal",
    changeCb,
    convertor,
    checkDirtyOnAssignment = false
  } = opts != null ? opts : {};
  const setter = function(value) {
    const oldValue = this[privateKey];
    value = convertor ? convertor(value) : value;
    if (value !== oldValue) {
      this[privateKey] = value;
      if (type === "normal")
        this.markDirty(this, redraw);
      if (type === "transform")
        this.markDirtyTransform(redraw);
      if (type === "path" && !this._dirtyPath) {
        this._dirtyPath = true;
        this.markDirty(this, redraw);
      }
      if (type === "font" && !this._dirtyFont) {
        this._dirtyFont = true;
        this.markDirty(this, redraw);
      }
      if (changeCb)
        changeCb(this);
    }
    if (checkDirtyOnAssignment && value != null && value._dirty > 0 /* NONE */)
      this.markDirty(value, value._dirty);
  };
  const getter = function() {
    return this[privateKey];
  };
  Object.defineProperty(target, key, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: true
  });
}
var ChangeDetectable = class {
  constructor() {
    this._dirty = 3 /* MAJOR */;
  }
  markDirty(_source, type = 1 /* TRIVIAL */) {
    if (this._dirty < type) {
      this._dirty = type;
    }
  }
  markClean(_opts) {
    this._dirty = 0 /* NONE */;
  }
  isDirty() {
    return this._dirty > 0 /* NONE */;
  }
};

// packages/ag-charts-community/src/util/number.ts
function clamp(min, value, max) {
  return Math.min(max, Math.max(min, value));
}
function clampArray(value, array) {
  const [min, max] = findMinMax(array);
  return clamp(min, value, max);
}
function findMinMax(array) {
  return array.length ? [Math.min(...array), Math.max(...array)] : [];
}
function findRangeExtent(array) {
  const [min, max] = findMinMax(array);
  return max - min;
}
function isEqual(a, b, epsilon2 = 1e-10) {
  return Math.abs(a - b) < epsilon2;
}
function isNegative(value) {
  return Math.sign(value) === -1 || Object.is(value, -0);
}
function round(value, decimals = 2) {
  const base = __pow(10, decimals);
  return Math.round(value * base) / base;
}
function toFixed(value, fractionOrSignificantDigits = 2) {
  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);
  if (power >= 0 || !isFinite(power)) {
    return value.toFixed(fractionOrSignificantDigits);
  }
  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits);
}
function mod(n, m) {
  return Math.floor(n % m + (n < 0 ? m : 0));
}
function countFractionDigits(value, maximumFractionDigits = 10) {
  const [, decimal = ""] = (Math.abs(value) % 1).toLocaleString("en-GB", { minimumFractionDigits: 0, maximumFractionDigits }).split(".");
  return decimal.length;
}

// packages/ag-charts-community/src/scene/nearest.ts
function nearestSquared(point, objects, maxDistanceSquared = Infinity) {
  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };
  for (const obj of objects) {
    const thisDistance = obj.distanceSquared(point);
    if (thisDistance === 0) {
      return { nearest: obj, distanceSquared: 0 };
    } else if (thisDistance < result.distanceSquared) {
      result.nearest = obj;
      result.distanceSquared = thisDistance;
    }
  }
  return result;
}
function nearestSquaredInContainer(point, container, maxDistanceSquared = Infinity) {
  const tpoint = container.transformPoint(point.x, point.y);
  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };
  for (const child of container.children) {
    const { nearest, distanceSquared: distanceSquared2 } = child.nearestSquared(tpoint, result.distanceSquared);
    if (distanceSquared2 === 0) {
      return { nearest, distanceSquared: distanceSquared2 };
    } else if (distanceSquared2 < result.distanceSquared) {
      result.nearest = nearest;
      result.distanceSquared = distanceSquared2;
    }
  }
  return result;
}

// packages/ag-charts-community/src/scene/bbox.ts
var _BBox = class _BBox {
  constructor(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  clone() {
    const { x, y, width, height } = this;
    return new _BBox(x, y, width, height);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
  }
  containsPoint(x, y) {
    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;
  }
  collidesBBox(other) {
    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;
  }
  isInfinite() {
    return Math.abs(this.x) === Infinity || Math.abs(this.y) === Infinity || Math.abs(this.width) === Infinity || Math.abs(this.height) === Infinity;
  }
  distanceSquared(point) {
    if (this.containsPoint(point.x, point.y)) {
      return 0;
    }
    const dx = point.x - clamp(this.x, point.x, this.x + this.width);
    const dy = point.y - clamp(this.y, point.y, this.y + this.height);
    return dx * dx + dy * dy;
  }
  static nearestBox(point, boxes) {
    return nearestSquared(point, boxes);
  }
  shrink(amount, position) {
    const apply = (pos, amt) => {
      switch (pos) {
        case "top":
          this.y += amt;
        case "bottom":
          this.height -= amt;
          break;
        case "left":
          this.x += amt;
        case "right":
          this.width -= amt;
          break;
        case "vertical":
          this.y += amt;
          this.height -= amt * 2;
          break;
        case "horizontal":
          this.x += amt;
          this.width -= amt * 2;
          break;
        case void 0:
          this.x += amt;
          this.width -= amt * 2;
          this.y += amt;
          this.height -= amt * 2;
          break;
      }
    };
    if (typeof amount === "number") {
      apply(position, amount);
    } else if (typeof amount === "object") {
      Object.entries(amount).forEach(([pos, amt]) => apply(pos, amt));
    }
    return this;
  }
  grow(amount, position) {
    if (typeof amount === "number") {
      this.shrink(-amount, position);
    } else {
      const paddingCopy = __spreadValues({}, amount);
      for (const key in paddingCopy) {
        paddingCopy[key] *= -1;
      }
      this.shrink(paddingCopy);
    }
    return this;
  }
  static merge(boxes) {
    let left = Infinity;
    let top = Infinity;
    let right = -Infinity;
    let bottom = -Infinity;
    boxes.forEach((box) => {
      if (box.x < left) {
        left = box.x;
      }
      if (box.y < top) {
        top = box.y;
      }
      if (box.x + box.width > right) {
        right = box.x + box.width;
      }
      if (box.y + box.height > bottom) {
        bottom = box.y + box.height;
      }
    });
    return new _BBox(left, top, right - left, bottom - top);
  }
};
_BBox.zero = new _BBox(0, 0, 0, 0);
var BBox = _BBox;

// packages/ag-charts-community/src/scene/matrix.ts
var _Matrix = class _Matrix {
  get e() {
    return [...this.elements];
  }
  constructor(elements = [1, 0, 0, 1, 0, 0]) {
    this.elements = elements;
  }
  setElements(elements) {
    const e = this.elements;
    e[0] = elements[0];
    e[1] = elements[1];
    e[2] = elements[2];
    e[3] = elements[3];
    e[4] = elements[4];
    e[5] = elements[5];
    return this;
  }
  get identity() {
    const e = this.elements;
    return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;
  }
  /**
   * Performs the AxB matrix multiplication and saves the result
   * to `C`, if given, or to `A` otherwise.
   */
  AxB(A, B, C) {
    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];
    C = C != null ? C : A;
    C[0] = a;
    C[1] = b;
    C[2] = c;
    C[3] = d;
    C[4] = e;
    C[5] = f;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns the current matrix.
   * @param other
   */
  multiplySelf(other) {
    this.AxB(this.elements, other.elements);
    return this;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns a new matrix.
   * @param other
   */
  multiply(other) {
    const elements = new Array(6);
    this.AxB(this.elements, other.elements, elements);
    return new _Matrix(elements);
  }
  preMultiplySelf(other) {
    this.AxB(other.elements, this.elements, this.elements);
    return this;
  }
  /**
   * Returns the inverse of this matrix as a new matrix.
   */
  inverse() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);
  }
  /**
   * Save the inverse of this matrix to the given matrix.
   */
  inverseTo(other) {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);
    return this;
  }
  invertSelf() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    el[0] = d;
    el[1] = -b;
    el[2] = -c;
    el[3] = a;
    el[4] = c * f - d * e;
    el[5] = b * e - a * f;
    return this;
  }
  transformPoint(x, y) {
    const e = this.elements;
    return {
      x: x * e[0] + y * e[2] + e[4],
      y: x * e[1] + y * e[3] + e[5]
    };
  }
  transformBBox(bbox, target) {
    const elements = this.elements;
    const xx = elements[0];
    const xy = elements[1];
    const yx = elements[2];
    const yy = elements[3];
    const h_w = bbox.width * 0.5;
    const h_h = bbox.height * 0.5;
    const cx = bbox.x + h_w;
    const cy = bbox.y + h_h;
    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);
    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);
    if (!target) {
      target = new BBox(0, 0, 0, 0);
    }
    target.x = cx * xx + cy * yx + elements[4] - w;
    target.y = cx * xy + cy * yy + elements[5] - h;
    target.width = w + w;
    target.height = h + h;
    return target;
  }
  toContext(ctx) {
    if (this.identity) {
      return;
    }
    const e = this.elements;
    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
  }
  static flyweight(sourceMatrix) {
    return _Matrix.instance.setElements(sourceMatrix.elements);
  }
  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {
    const [bbcx, bbcy] = [0, 0];
    const sx = scalingX;
    const sy = scalingY;
    let scx;
    let scy;
    if (sx === 1 && sy === 1) {
      scx = 0;
      scy = 0;
    } else {
      scx = (opts == null ? void 0 : opts.scalingCenterX) == null ? bbcx : opts == null ? void 0 : opts.scalingCenterX;
      scy = (opts == null ? void 0 : opts.scalingCenterY) == null ? bbcy : opts == null ? void 0 : opts.scalingCenterY;
    }
    const r = rotation;
    const cos = Math.cos(r);
    const sin = Math.sin(r);
    let rcx;
    let rcy;
    if (r === 0) {
      rcx = 0;
      rcy = 0;
    } else {
      rcx = (opts == null ? void 0 : opts.rotationCenterX) == null ? bbcx : opts == null ? void 0 : opts.rotationCenterX;
      rcy = (opts == null ? void 0 : opts.rotationCenterY) == null ? bbcy : opts == null ? void 0 : opts.rotationCenterY;
    }
    const tx = translationX;
    const ty = translationY;
    const tx4 = scx * (1 - sx) - rcx;
    const ty4 = scy * (1 - sy) - rcy;
    matrix.setElements([
      cos * sx,
      sin * sx,
      -sin * sy,
      cos * sy,
      cos * tx4 - sin * ty4 + rcx + tx,
      sin * tx4 + cos * ty4 + rcy + ty
    ]);
    return matrix;
  }
  static fromContext(ctx) {
    const domMatrix = ctx.getTransform();
    return new _Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);
  }
};
_Matrix.instance = new _Matrix();
var Matrix = _Matrix;

// packages/ag-charts-community/src/scene/node.ts
var PointerEvents = /* @__PURE__ */ ((PointerEvents2) => {
  PointerEvents2[PointerEvents2["All"] = 0] = "All";
  PointerEvents2[PointerEvents2["None"] = 1] = "None";
  return PointerEvents2;
})(PointerEvents || {});
var zIndexChangedCallback = (o) => {
  if (o.parent) {
    o.parent.dirtyZIndex = true;
  }
  o.zIndexChanged();
};
var _Node = class _Node extends ChangeDetectable {
  constructor({ isVirtual, tag } = {}) {
    super();
    /** Unique number to allow creation order to be easily determined. */
    this.serialNumber = _Node._nextSerialNumber++;
    /**
     * Unique node ID in the form `ClassName-NaturalNumber`.
     */
    this.id = createId(this);
    /**
     * To simplify the type system (especially in Selections) we don't have the `Parent` node
     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.
     * But we still need to distinguish regular leaf nodes from container leafs somehow.
     */
    this.isContainerNode = false;
    this._virtualChildren = [];
    this._children = [];
    // Used to check for duplicate nodes.
    this.childSet = {};
    // These matrices may need to have package level visibility
    // for performance optimization purposes.
    this.matrix = new Matrix();
    this.inverseMatrix = new Matrix();
    this.dirtyTransform = false;
    this.scalingX = 1;
    this.scalingY = 1;
    this.scalingCenterX = null;
    this.scalingCenterY = null;
    this.rotationCenterX = null;
    this.rotationCenterY = null;
    this.rotation = 0;
    this.translationX = 0;
    this.translationY = 0;
    this.visible = true;
    this.dirtyZIndex = false;
    this.zIndex = 0;
    /** Discriminators for render order within a zIndex. */
    this.zIndexSubOrder = void 0;
    this.pointerEvents = 0 /* All */;
    this.isVirtual = isVirtual != null ? isVirtual : false;
    this.tag = tag != null ? tag : NaN;
  }
  /**
   * Some arbitrary data bound to the node.
   */
  get datum() {
    var _a, _b;
    return (_b = this._datum) != null ? _b : (_a = this._parent) == null ? void 0 : _a.datum;
  }
  get previousDatum() {
    return this._previousDatum;
  }
  set datum(datum) {
    if (this._datum !== datum)
      this._previousDatum = this._datum;
    this._datum = datum;
  }
  _setLayerManager(value) {
    this._layerManager = value;
    this._debug = value == null ? void 0 : value.debug;
    for (const child of this._children) {
      child._setLayerManager(value);
    }
    for (const child of this._virtualChildren) {
      child._setLayerManager(value);
    }
  }
  get layerManager() {
    return this._layerManager;
  }
  get parent() {
    return this._parent;
  }
  get children() {
    if (this._virtualChildren.length === 0)
      return this._children;
    const result = [...this._children];
    for (const next of this._virtualChildren) {
      result.push(...next.children);
    }
    return result;
  }
  get virtualChildren() {
    return this._virtualChildren;
  }
  hasVirtualChildren() {
    return this._virtualChildren.length > 0;
  }
  // new Set<Node>()
  setProperties(styles, pickKeys) {
    const keys = pickKeys != null ? pickKeys : Object.keys(styles);
    for (const key of keys) {
      this[key] = styles[key];
    }
    return this;
  }
  /**
   * Appends one or more new node instances to this parent.
   * If one needs to:
   * - move a child to the end of the list of children
   * - move a child from one parent to another (including parents in other scenes)
   * one should use the {@link insertBefore} method instead.
   * @param nodes A node or nodes to append.
   */
  append(nodes) {
    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }
    for (const node of nodes) {
      if (node.parent) {
        throw new Error(`${node} already belongs to another parent: ${node.parent}.`);
      }
      if (node.layerManager) {
        throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);
      }
      if (this.childSet[node.id]) {
        throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);
      }
      if (node.isVirtual) {
        this._virtualChildren.push(node);
      } else {
        this._children.push(node);
      }
      this.childSet[node.id] = true;
      node._parent = this;
      node._setLayerManager(this.layerManager);
    }
    this.dirtyZIndex = true;
    this.markDirty(this, 3 /* MAJOR */);
  }
  appendChild(node) {
    this.append(node);
    return node;
  }
  removeChild(node) {
    const error = () => {
      throw new Error(`The node to be removed is not a child of this node.`);
    };
    if (node.parent !== this) {
      error();
    }
    if (node.isVirtual) {
      const i = this._virtualChildren.indexOf(node);
      if (i < 0)
        error();
      this._virtualChildren.splice(i, 1);
    } else {
      const i = this._children.indexOf(node);
      if (i < 0)
        error();
      this._children.splice(i, 1);
    }
    delete this.childSet[node.id];
    node._parent = void 0;
    node._setLayerManager();
    this.dirtyZIndex = true;
    this.markDirty(node, 3 /* MAJOR */);
    return node;
  }
  calculateCumulativeMatrix() {
    this.computeTransformMatrix();
    const matrix = Matrix.flyweight(this.matrix);
    let parent = this.parent;
    while (parent) {
      parent.computeTransformMatrix();
      matrix.preMultiplySelf(parent.matrix);
      parent = parent.parent;
    }
    return matrix;
  }
  transformPoint(x, y) {
    const matrix = this.calculateCumulativeMatrix();
    return matrix.invertSelf().transformPoint(x, y);
  }
  inverseTransformPoint(x, y) {
    const matrix = this.calculateCumulativeMatrix();
    return matrix.transformPoint(x, y);
  }
  transformBBox(bbox) {
    const matrix = this.calculateCumulativeMatrix();
    return matrix.invertSelf().transformBBox(bbox);
  }
  inverseTransformBBox(bbox) {
    const matrix = this.calculateCumulativeMatrix();
    return matrix.transformBBox(bbox);
  }
  markDirtyTransform() {
    this.dirtyTransform = true;
    this.markDirty(this, 3 /* MAJOR */);
  }
  containsPoint(_x, _y) {
    return false;
  }
  /**
   * Hit testing method.
   * Recursively checks if the given point is inside this node or any of its children.
   * Returns the first matching node or `undefined`.
   * Nodes that render later (show on top) are hit tested first.
   */
  pickNode(x, y) {
    var _a;
    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {
      return;
    }
    const children = this.children;
    if (children.length > 1e3) {
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const containsPoint = (_a = child.computeTransformedBBox()) == null ? void 0 : _a.containsPoint(x, y);
        const hit = containsPoint ? child.pickNode(x, y) : void 0;
        if (hit) {
          return hit;
        }
      }
    } else if (children.length) {
      for (let i = children.length - 1; i >= 0; i--) {
        const hit = children[i].pickNode(x, y);
        if (hit) {
          return hit;
        }
      }
    } else if (!this.isContainerNode) {
      return this;
    }
  }
  findNodes(predicate) {
    const result = predicate(this) ? [this] : [];
    for (const child of this.children) {
      const childResult = child.findNodes(predicate);
      if (childResult) {
        result.push(...childResult);
      }
    }
    return result;
  }
  computeBBox() {
    return;
  }
  computeTransformedBBox() {
    const bbox = this.computeBBox();
    if (!bbox) {
      return void 0;
    }
    this.computeTransformMatrix();
    const matrix = Matrix.flyweight(this.matrix);
    let parent = this.parent;
    while (parent) {
      parent.computeTransformMatrix();
      matrix.preMultiplySelf(parent.matrix);
      parent = parent.parent;
    }
    matrix.transformBBox(bbox, bbox);
    return bbox;
  }
  computeTransformMatrix() {
    if (!this.dirtyTransform) {
      return;
    }
    const {
      matrix,
      scalingX,
      scalingY,
      rotation,
      translationX,
      translationY,
      scalingCenterX,
      scalingCenterY,
      rotationCenterX,
      rotationCenterY
    } = this;
    Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {
      scalingCenterX,
      scalingCenterY,
      rotationCenterX,
      rotationCenterY
    });
    matrix.inverseTo(this.inverseMatrix);
    this.dirtyTransform = false;
  }
  render(renderCtx) {
    const { stats } = renderCtx;
    this._dirty = 0 /* NONE */;
    if (stats)
      stats.nodesRendered++;
  }
  clearBBox(ctx) {
    const bbox = this.computeBBox();
    if (bbox == null) {
      return;
    }
    const { x, y, width, height } = bbox;
    const topLeft = this.transformPoint(x, y);
    const bottomRight = this.transformPoint(x + width, y + height);
    ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
  }
  markDirty(_source, type = 1 /* TRIVIAL */, parentType = type) {
    if (this._dirty > type) {
      return;
    }
    if (this._dirty === type && type === parentType) {
      return;
    }
    this._dirty = type;
    if (this.parent) {
      this.parent.markDirty(this, parentType);
    } else if (this.layerManager) {
      this.layerManager.markDirty();
    }
  }
  get dirty() {
    return this._dirty;
  }
  markClean(opts) {
    const { force = false, recursive = true } = opts != null ? opts : {};
    if (this._dirty === 0 /* NONE */ && !force) {
      return;
    }
    this._dirty = 0 /* NONE */;
    if (recursive !== false) {
      for (const child of this._virtualChildren) {
        child.markClean({ force });
      }
    }
    if (recursive === true) {
      for (const child of this._children) {
        child.markClean({ force });
      }
    }
  }
  visibilityChanged() {
  }
  get nodeCount() {
    let count2 = 1;
    let dirtyCount = this._dirty >= 0 /* NONE */ || this.dirtyTransform ? 1 : 0;
    let visibleCount = this.visible ? 1 : 0;
    const countChild = (child) => {
      const { count: childCount, visibleCount: childVisibleCount, dirtyCount: childDirtyCount } = child.nodeCount;
      count2 += childCount;
      visibleCount += childVisibleCount;
      dirtyCount += childDirtyCount;
    };
    for (const child of this._children) {
      countChild(child);
    }
    for (const child of this._virtualChildren) {
      countChild(child);
    }
    return { count: count2, visibleCount, dirtyCount };
  }
  zIndexChanged() {
  }
};
_Node._nextSerialNumber = 0;
__decorateClass([
  SceneChangeDetection({ type: "transform" })
], _Node.prototype, "scalingX", 2);
__decorateClass([
  SceneChangeDetection({ type: "transform" })
], _Node.prototype, "scalingY", 2);
__decorateClass([
  SceneChangeDetection({ type: "transform" })
], _Node.prototype, "scalingCenterX", 2);
__decorateClass([
  SceneChangeDetection({ type: "transform" })
], _Node.prototype, "scalingCenterY", 2);
__decorateClass([
  SceneChangeDetection({ type: "transform" })
], _Node.prototype, "rotationCenterX", 2);
__decorateClass([
  SceneChangeDetection({ type: "transform" })
], _Node.prototype, "rotationCenterY", 2);
__decorateClass([
  SceneChangeDetection({ type: "transform" })
], _Node.prototype, "rotation", 2);
__decorateClass([
  SceneChangeDetection({ type: "transform" })
], _Node.prototype, "translationX", 2);
__decorateClass([
  SceneChangeDetection({ type: "transform" })
], _Node.prototype, "translationY", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o.visibilityChanged() })
], _Node.prototype, "visible", 2);
__decorateClass([
  SceneChangeDetection({
    redraw: 1 /* TRIVIAL */,
    changeCb: zIndexChangedCallback
  })
], _Node.prototype, "zIndex", 2);
__decorateClass([
  SceneChangeDetection({
    redraw: 1 /* TRIVIAL */,
    changeCb: zIndexChangedCallback
  })
], _Node.prototype, "zIndexSubOrder", 2);
var Node = _Node;

// packages/ag-charts-community/src/util/color.ts
var srgbToLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs <= 0.04045)
    return value / 12.92;
  return sign * __pow((abs + 0.055) / 1.055, 2.4);
};
var srgbFromLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs > 31308e-7) {
    return sign * (1.055 * __pow(abs, 1 / 2.4) - 0.055);
  }
  return 12.92 * value;
};
var _Color = class _Color {
  /**
   * Every color component should be in the [0, 1] range.
   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.
   * So, when animating colors, if the source or target color components are already near
   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color
   * component value to end up outside of that range mid-animation. For this reason the constructor
   * performs range checking/constraining.
   * @param r Red component.
   * @param g Green component.
   * @param b Blue component.
   * @param a Alpha (opacity) component.
   */
  constructor(r, g, b, a = 1) {
    this.r = clamp(0, r || 0, 1);
    this.g = clamp(0, g || 0, 1);
    this.b = clamp(0, b || 0, 1);
    this.a = clamp(0, a || 0, 1);
  }
  /**
   * A color string can be in one of the following formats to be valid:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   */
  static validColorString(str) {
    if (str.indexOf("#") >= 0) {
      return !!_Color.parseHex(str);
    }
    if (str.indexOf("rgb") >= 0) {
      return !!_Color.stringToRgba(str);
    }
    return !!_Color.nameToHex[str.toLowerCase()];
  }
  /**
   * The given string can be in one of the following formats:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   * @param str
   */
  static fromString(str) {
    if (str.indexOf("#") >= 0) {
      return _Color.fromHexString(str);
    }
    const hex = _Color.nameToHex[str.toLowerCase()];
    if (hex) {
      return _Color.fromHexString(hex);
    }
    if (str.indexOf("rgb") >= 0) {
      return _Color.fromRgbaString(str);
    }
    throw new Error(`Invalid color string: '${str}'`);
  }
  static tryParseFromString(str) {
    try {
      return _Color.fromString(str);
    } catch (e) {
      Logger.warnOnce(`invalid color string: '${str}'.`);
      return _Color.fromArray([0, 0, 0]);
    }
  }
  // See https://drafts.csswg.org/css-color/#hex-notation
  static parseHex(input) {
    input = input.replace(/ /g, "").slice(1);
    let parts;
    switch (input.length) {
      case 6:
      case 8:
        parts = [];
        for (let i = 0; i < input.length; i += 2) {
          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));
        }
        break;
      case 3:
      case 4:
        parts = input.split("").map((p) => parseInt(p, 16)).map((p) => p + p * 16);
        break;
    }
    if ((parts == null ? void 0 : parts.length) >= 3 && parts.every((p) => p >= 0)) {
      if (parts.length === 3) {
        parts.push(255);
      }
      return parts;
    }
  }
  static fromHexString(str) {
    const values = _Color.parseHex(str);
    if (values) {
      const [r, g, b, a] = values;
      return new _Color(r / 255, g / 255, b / 255, a / 255);
    }
    throw new Error(`Malformed hexadecimal color string: '${str}'`);
  }
  static stringToRgba(str) {
    let [po, pc] = [NaN, NaN];
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      if (!po && c === "(") {
        po = i;
      } else if (c === ")") {
        pc = i;
        break;
      }
    }
    const contents = po && pc && str.substring(po + 1, pc);
    if (!contents) {
      return;
    }
    const parts = contents.split(",");
    const rgba = [];
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      let value = parseFloat(part);
      if (isNaN(value)) {
        return;
      }
      if (part.indexOf("%") >= 0) {
        value = clamp(0, value, 100);
        value /= 100;
      } else {
        if (i === 3) {
          value = clamp(0, value, 1);
        } else {
          value = clamp(0, value, 255);
          value /= 255;
        }
      }
      rgba.push(value);
    }
    return rgba;
  }
  static fromRgbaString(str) {
    const rgba = _Color.stringToRgba(str);
    if (rgba) {
      if (rgba.length === 3) {
        return new _Color(rgba[0], rgba[1], rgba[2]);
      } else if (rgba.length === 4) {
        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);
      }
    }
    throw new Error(`Malformed rgb/rgba color string: '${str}'`);
  }
  static fromArray(arr) {
    if (arr.length === 4) {
      return new _Color(arr[0], arr[1], arr[2], arr[3]);
    }
    if (arr.length === 3) {
      return new _Color(arr[0], arr[1], arr[2]);
    }
    throw new Error("The given array should contain 3 or 4 color components (numbers).");
  }
  static fromHSB(h, s, b, alpha = 1) {
    const rgb = _Color.HSBtoRGB(h, s, b);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromHSL(h, s, l, alpha = 1) {
    const rgb = _Color.HSLtoRGB(h, s, l);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromOKLCH(l, c, h, alpha = 1) {
    const rgb = _Color.OKLCHtoRGB(l, c, h);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static padHex(str) {
    return str.length === 1 ? "0" + str : str;
  }
  toHexString() {
    let hex = "#" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));
    if (this.a < 1) {
      hex += _Color.padHex(Math.round(this.a * 255).toString(16));
    }
    return hex;
  }
  toRgbaString(fractionDigits = 3) {
    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];
    const k = Math.pow(10, fractionDigits);
    if (this.a !== 1) {
      components.push(Math.round(this.a * k) / k);
      return `rgba(${components.join(", ")})`;
    }
    return `rgb(${components.join(", ")})`;
  }
  toString() {
    if (this.a === 1) {
      return this.toHexString();
    }
    return this.toRgbaString();
  }
  toHSB() {
    return _Color.RGBtoHSB(this.r, this.g, this.b);
  }
  static RGBtoOKLCH(r, g, b) {
    const LSRGB0 = srgbToLinear(r);
    const LSRGB1 = srgbToLinear(g);
    const LSRGB2 = srgbToLinear(b);
    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);
    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);
    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);
    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;
    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;
    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;
    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;
    const OKLCH0 = OKLAB0;
    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);
    const OKLCH2 = hue >= 0 ? hue : hue + 360;
    return [OKLCH0, OKLCH1, OKLCH2];
  }
  static OKLCHtoRGB(l, c, h) {
    const OKLAB0 = l;
    const OKLAB1 = c * Math.cos(h * Math.PI / 180);
    const OKLAB2 = c * Math.sin(h * Math.PI / 180);
    const LMS0 = __pow(OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2, 3);
    const LMS1 = __pow(OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2, 3);
    const LMS2 = __pow(OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2, 3);
    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;
    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;
    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;
    const SRGB0 = srgbFromLinear(LSRGB0);
    const SRGB1 = srgbFromLinear(LSRGB1);
    const SRGB2 = srgbFromLinear(LSRGB2);
    return [SRGB0, SRGB1, SRGB2];
  }
  static RGBtoHSL(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const l = (max + min) / 2;
    let h;
    let s;
    if (max === min) {
      h = NaN;
      s = 0;
    } else {
      const delta = max - min;
      s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
      if (max === r) {
        h = (g - b) / delta + (g < b ? 6 : 0);
      } else if (max === g) {
        h = (b - r) / delta + 2;
      } else {
        h = (r - g) / delta + 4;
      }
      h *= 360 / 6;
    }
    return [h, s, l];
  }
  static HSLtoRGB(h, s, l) {
    if (s === 0) {
      return [l, l, l];
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    function hueToRgb(t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    const r = hueToRgb(h / 360 + 1 / 3);
    const g = hueToRgb(h / 360);
    const b = hueToRgb(h / 360 - 1 / 3);
    return [r, g, b];
  }
  /**
   * Converts the given RGB triple to an array of HSB (HSV) components.
   * The hue component will be `NaN` for achromatic colors.
   */
  static RGBtoHSB(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const S = max !== 0 ? (max - min) / max : 0;
    let H = NaN;
    if (min !== max) {
      const delta = max - min;
      const rc = (max - r) / delta;
      const gc = (max - g) / delta;
      const bc = (max - b) / delta;
      if (r === max) {
        H = bc - gc;
      } else if (g === max) {
        H = 2 + rc - bc;
      } else {
        H = 4 + gc - rc;
      }
      H /= 6;
      if (H < 0) {
        H = H + 1;
      }
    }
    return [H * 360, S, max];
  }
  /**
   * Converts the given HSB (HSV) triple to an array of RGB components.
   */
  static HSBtoRGB(H, S, B) {
    if (isNaN(H)) {
      H = 0;
    }
    H = (H % 360 + 360) % 360 / 360;
    let r = 0;
    let g = 0;
    let b = 0;
    if (S === 0) {
      r = g = b = B;
    } else {
      const h = (H - Math.floor(H)) * 6;
      const f = h - Math.floor(h);
      const p = B * (1 - S);
      const q = B * (1 - S * f);
      const t = B * (1 - S * (1 - f));
      switch (h >> 0) {
        case 0:
          r = B;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = B;
          b = p;
          break;
        case 2:
          r = p;
          g = B;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = B;
          break;
        case 4:
          r = t;
          g = p;
          b = B;
          break;
        case 5:
          r = B;
          g = p;
          b = q;
          break;
      }
    }
    return [r, g, b];
  }
  derive(hueShift, saturationFactor, brightnessFactor, opacityFactor) {
    const hsb = _Color.RGBtoHSB(this.r, this.g, this.b);
    let b = hsb[2];
    if (b == 0 && brightnessFactor > 1) {
      b = 0.05;
    }
    const h = ((hsb[0] + hueShift) % 360 + 360) % 360;
    const s = clamp(0, hsb[1] * saturationFactor, 1);
    b = clamp(0, b * brightnessFactor, 1);
    const a = clamp(0, this.a * opacityFactor, 1);
    const rgba = _Color.HSBtoRGB(h, s, b);
    rgba.push(a);
    return _Color.fromArray(rgba);
  }
  brighter() {
    return this.derive(0, 1, 1 / 0.7, 1);
  }
  darker() {
    return this.derive(0, 1, 0.7, 1);
  }
  static interpolate(color, other) {
    const c0 = _Color.tryParseFromString(color);
    const c1 = _Color.tryParseFromString(other);
    return (t) => {
      const i = (x, y) => x * (1 - t) + y * t;
      const c = new _Color(i(c0.r, c1.r), i(c0.g, c1.g), i(c0.b, c1.b), i(c0.a, c1.a));
      return c.toString();
    };
  }
};
_Color.didDebug = false;
/**
 * CSS Color Module Level 4:
 * https://drafts.csswg.org/css-color/#named-colors
 */
_Color.nameToHex = Object.freeze({
  aliceblue: "#F0F8FF",
  antiquewhite: "#FAEBD7",
  aqua: "#00FFFF",
  aquamarine: "#7FFFD4",
  azure: "#F0FFFF",
  beige: "#F5F5DC",
  bisque: "#FFE4C4",
  black: "#000000",
  blanchedalmond: "#FFEBCD",
  blue: "#0000FF",
  blueviolet: "#8A2BE2",
  brown: "#A52A2A",
  burlywood: "#DEB887",
  cadetblue: "#5F9EA0",
  chartreuse: "#7FFF00",
  chocolate: "#D2691E",
  coral: "#FF7F50",
  cornflowerblue: "#6495ED",
  cornsilk: "#FFF8DC",
  crimson: "#DC143C",
  cyan: "#00FFFF",
  darkblue: "#00008B",
  darkcyan: "#008B8B",
  darkgoldenrod: "#B8860B",
  darkgray: "#A9A9A9",
  darkgreen: "#006400",
  darkgrey: "#A9A9A9",
  darkkhaki: "#BDB76B",
  darkmagenta: "#8B008B",
  darkolivegreen: "#556B2F",
  darkorange: "#FF8C00",
  darkorchid: "#9932CC",
  darkred: "#8B0000",
  darksalmon: "#E9967A",
  darkseagreen: "#8FBC8F",
  darkslateblue: "#483D8B",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  darkturquoise: "#00CED1",
  darkviolet: "#9400D3",
  deeppink: "#FF1493",
  deepskyblue: "#00BFFF",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1E90FF",
  firebrick: "#B22222",
  floralwhite: "#FFFAF0",
  forestgreen: "#228B22",
  fuchsia: "#FF00FF",
  gainsboro: "#DCDCDC",
  ghostwhite: "#F8F8FF",
  gold: "#FFD700",
  goldenrod: "#DAA520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#ADFF2F",
  grey: "#808080",
  honeydew: "#F0FFF0",
  hotpink: "#FF69B4",
  indianred: "#CD5C5C",
  indigo: "#4B0082",
  ivory: "#FFFFF0",
  khaki: "#F0E68C",
  lavender: "#E6E6FA",
  lavenderblush: "#FFF0F5",
  lawngreen: "#7CFC00",
  lemonchiffon: "#FFFACD",
  lightblue: "#ADD8E6",
  lightcoral: "#F08080",
  lightcyan: "#E0FFFF",
  lightgoldenrodyellow: "#FAFAD2",
  lightgray: "#D3D3D3",
  lightgreen: "#90EE90",
  lightgrey: "#D3D3D3",
  lightpink: "#FFB6C1",
  lightsalmon: "#FFA07A",
  lightseagreen: "#20B2AA",
  lightskyblue: "#87CEFA",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#B0C4DE",
  lightyellow: "#FFFFE0",
  lime: "#00FF00",
  limegreen: "#32CD32",
  linen: "#FAF0E6",
  magenta: "#FF00FF",
  maroon: "#800000",
  mediumaquamarine: "#66CDAA",
  mediumblue: "#0000CD",
  mediumorchid: "#BA55D3",
  mediumpurple: "#9370DB",
  mediumseagreen: "#3CB371",
  mediumslateblue: "#7B68EE",
  mediumspringgreen: "#00FA9A",
  mediumturquoise: "#48D1CC",
  mediumvioletred: "#C71585",
  midnightblue: "#191970",
  mintcream: "#F5FFFA",
  mistyrose: "#FFE4E1",
  moccasin: "#FFE4B5",
  navajowhite: "#FFDEAD",
  navy: "#000080",
  oldlace: "#FDF5E6",
  olive: "#808000",
  olivedrab: "#6B8E23",
  orange: "#FFA500",
  orangered: "#FF4500",
  orchid: "#DA70D6",
  palegoldenrod: "#EEE8AA",
  palegreen: "#98FB98",
  paleturquoise: "#AFEEEE",
  palevioletred: "#DB7093",
  papayawhip: "#FFEFD5",
  peachpuff: "#FFDAB9",
  peru: "#CD853F",
  pink: "#FFC0CB",
  plum: "#DDA0DD",
  powderblue: "#B0E0E6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#FF0000",
  rosybrown: "#BC8F8F",
  royalblue: "#4169E1",
  saddlebrown: "#8B4513",
  salmon: "#FA8072",
  sandybrown: "#F4A460",
  seagreen: "#2E8B57",
  seashell: "#FFF5EE",
  sienna: "#A0522D",
  silver: "#C0C0C0",
  skyblue: "#87CEEB",
  slateblue: "#6A5ACD",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#FFFAFA",
  springgreen: "#00FF7F",
  steelblue: "#4682B4",
  tan: "#D2B48C",
  teal: "#008080",
  thistle: "#D8BFD8",
  tomato: "#FF6347",
  transparent: "#00000000",
  turquoise: "#40E0D0",
  violet: "#EE82EE",
  wheat: "#F5DEB3",
  white: "#FFFFFF",
  whitesmoke: "#F5F5F5",
  yellow: "#FFFF00",
  yellowgreen: "#9ACD32"
});
var Color = _Color;

// packages/ag-charts-community/src/util/interpolate.ts
function interpolateNumber(a, b) {
  return (d) => Number(a) * (1 - d) + Number(b) * d;
}
function interpolateColor(a, b) {
  if (typeof a === "string") {
    try {
      a = Color.fromString(a);
    } catch (e) {
      a = Color.fromArray([0, 0, 0]);
    }
  }
  if (typeof b === "string") {
    try {
      b = Color.fromString(b);
    } catch (e) {
      b = Color.fromArray([0, 0, 0]);
    }
  }
  const red = interpolateNumber(a.r, b.r);
  const green = interpolateNumber(a.g, b.g);
  const blue = interpolateNumber(a.b, b.b);
  const alpha = interpolateNumber(a.a, b.a);
  return (d) => Color.fromArray([red(d), green(d), blue(d), alpha(d)]).toRgbaString();
}

// packages/ag-charts-community/src/motion/easing.ts
var easing_exports = {};
__export(easing_exports, {
  easeIn: () => easeIn,
  easeInOut: () => easeInOut,
  easeInOutQuad: () => easeInOutQuad,
  easeInQuad: () => easeInQuad,
  easeOut: () => easeOut,
  easeOutQuad: () => easeOutQuad,
  inverseEaseOut: () => inverseEaseOut,
  linear: () => linear
});
var linear = (n) => n;
var easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);
var easeOut = (n) => Math.sin(n * Math.PI / 2);
var easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;
var easeInQuad = (n) => n * n;
var easeOutQuad = (n) => 1 - __pow(1 - n, 2);
var easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - __pow(-2 * n + 2, 2) / 2;
var inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;

// packages/ag-charts-community/src/motion/animation.ts
var QUICK_TRANSITION = 0.2;
var INITIAL_LOAD = {
  animationDuration: 1,
  animationDelay: 0
};
var REMOVE_PHASE = {
  animationDuration: 0.25,
  animationDelay: 0
};
var UPDATE_PHASE = {
  animationDuration: 0.5,
  animationDelay: 0.25
};
var ADD_PHASE = {
  animationDuration: 0.25,
  animationDelay: 0.75
};
var LABEL_PHASE = {
  animationDuration: QUICK_TRANSITION,
  animationDelay: 1
};
var ANIMATION_PHASE_ORDER = ["initial", "remove", "update", "add", "trailing", "end"];
var ANIMATION_PHASE_TIMINGS = {
  initial: INITIAL_LOAD,
  add: ADD_PHASE,
  remove: REMOVE_PHASE,
  update: UPDATE_PHASE,
  trailing: LABEL_PHASE,
  end: {
    animationDelay: 1 + QUICK_TRANSITION,
    animationDuration: 0
  }
};
var RepeatType = /* @__PURE__ */ ((RepeatType2) => {
  RepeatType2["Loop"] = "loop";
  RepeatType2["Reverse"] = "reverse";
  return RepeatType2;
})(RepeatType || {});
function isNodeArray(array) {
  return array.every((n) => n instanceof Node);
}
function deconstructSelectionsOrNodes(selectionsOrNodes) {
  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };
}
var Animation = class {
  constructor(opts) {
    this.isComplete = false;
    this.elapsed = 0;
    this.iteration = 0;
    this.isPlaying = false;
    this.isReverse = false;
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.id = opts.id;
    this.groupId = opts.groupId;
    this.autoplay = (_a = opts.autoplay) != null ? _a : true;
    this.ease = (_b = opts.ease) != null ? _b : linear;
    this.phase = opts.phase;
    const durationProportion = (_c = opts.duration) != null ? _c : ANIMATION_PHASE_TIMINGS[this.phase].animationDuration;
    this.duration = durationProportion * opts.defaultDuration;
    this.delay = ((_d = opts.delay) != null ? _d : 0) * opts.defaultDuration;
    this.onComplete = opts.onComplete;
    this.onPlay = opts.onPlay;
    this.onStop = opts.onStop;
    this.onUpdate = opts.onUpdate;
    this.interpolate = this.createInterpolator(opts.from, opts.to);
    if (opts.skip === true) {
      (_e = this.onUpdate) == null ? void 0 : _e.call(this, opts.to, false, this);
      (_f = this.onStop) == null ? void 0 : _f.call(this, this);
      (_g = this.onComplete) == null ? void 0 : _g.call(this, this);
      this.isComplete = true;
    } else if (this.autoplay) {
      this.play();
      (_h = this.onUpdate) == null ? void 0 : _h.call(this, opts.from, true, this);
    }
    if (opts.collapsable !== false) {
      this.duration = this.checkCollapse(opts, this.duration);
    }
  }
  checkCollapse(opts, calculatedDuration) {
    let isNoop = opts.from === opts.to;
    isNoop || (isNoop = typeof opts.from === "object" && jsonDiff(opts.from, opts.to) == null);
    if (isNoop) {
      return 0;
    }
    return calculatedDuration;
  }
  play() {
    var _a;
    if (!this.isPlaying && !this.isComplete) {
      this.isPlaying = true;
      (_a = this.onPlay) == null ? void 0 : _a.call(this, this);
    }
  }
  pause() {
    if (this.isPlaying) {
      this.isPlaying = false;
    }
  }
  stop() {
    var _a;
    if (this.isPlaying) {
      this.isPlaying = false;
      this.isComplete = true;
      (_a = this.onStop) == null ? void 0 : _a.call(this, this);
    }
  }
  update(time) {
    var _a, _b;
    const previousElapsed = this.elapsed;
    this.elapsed += time;
    if (this.delay > this.elapsed)
      return 0;
    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);
    (_a = this.onUpdate) == null ? void 0 : _a.call(this, value, false, this);
    const totalDuration = this.delay + this.duration;
    if (this.elapsed >= totalDuration) {
      this.stop();
      this.isComplete = true;
      (_b = this.onComplete) == null ? void 0 : _b.call(this, this);
      return time - (totalDuration - previousElapsed);
    }
    return 0;
  }
  get delta() {
    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));
  }
  createInterpolator(from, to) {
    if (typeof to !== "object") {
      return this.interpolateValue(from, to);
    }
    const interpolatorEntries = [];
    for (const key in to) {
      const interpolator = this.interpolateValue(from[key], to[key]);
      if (interpolator != null) {
        interpolatorEntries.push([key, interpolator]);
      }
    }
    return (d) => {
      const result = {};
      for (const [key, interpolator] of interpolatorEntries) {
        result[key] = interpolator(d);
      }
      return result;
    };
  }
  interpolateValue(a, b) {
    if (a === void 0 || b === void 0) {
      return void 0;
    }
    try {
      switch (typeof a) {
        case "number":
          return interpolateNumber(a, b);
        case "string":
          return interpolateColor(a, b);
      }
    } catch (e) {
    }
    throw new Error(`Unable to interpolate values: ${a}, ${b}`);
  }
};

// packages/ag-charts-community/src/motion/fromToMotion.ts
var NODE_UPDATE_PHASES = ["removed", "updated", "added"];
var NODE_UPDATE_STATE_TO_PHASE_MAPPING = {
  added: "add",
  updated: "update",
  removed: "remove",
  unknown: "initial"
};
function fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {
  const { fromFn, toFn, intermediateFn } = fns;
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const ids = { added: {}, removed: {} };
  if (getDatumId && diff2) {
    ids.added = zipObject(diff2.added, true);
    ids.removed = zipObject(diff2.removed, true);
  }
  const processNodes = (liveNodes, nodes2) => {
    var _c;
    let prevFromProps;
    let liveNodeIndex = 0;
    let nodeIndex = 0;
    for (const node of nodes2) {
      const isLive = liveNodes[liveNodeIndex] === node;
      const ctx = {
        last: nodeIndex >= nodes2.length - 1,
        lastLive: liveNodeIndex >= liveNodes.length - 1,
        prev: nodes2[nodeIndex - 1],
        prevFromProps,
        prevLive: liveNodes[liveNodeIndex - 1],
        next: nodes2[nodeIndex + 1],
        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]
      };
      const animationId = `${groupId}_${subId}_${node.id}`;
      animationManager.stopByAnimationId(animationId);
      let status = "unknown";
      if (!isLive) {
        status = "removed";
      } else if (getDatumId && diff2) {
        status = calculateStatus(node, node.datum, getDatumId, ids);
      }
      const _a = fromFn(node, node.datum, status, ctx), { phase, start, finish, delay, duration } = _a, from = __objRest(_a, ["phase", "start", "finish", "delay", "duration"]);
      const _b = toFn(node, node.datum, status, ctx), {
        phase: toPhase,
        start: toStart,
        finish: toFinish,
        delay: toDelay,
        duration: toDuration
      } = _b, to = __objRest(_b, [
        "phase",
        "start",
        "finish",
        "delay",
        "duration"
      ]);
      const collapsable = finish == null && toFinish == null;
      animationManager.animate({
        id: animationId,
        groupId,
        phase: (_c = phase != null ? phase : toPhase) != null ? _c : "update",
        duration: duration != null ? duration : toDuration,
        delay: delay != null ? delay : toDelay,
        from,
        to,
        ease: easeOut,
        collapsable,
        onPlay: () => {
          node.setProperties(__spreadValues(__spreadValues({}, start), toStart));
        },
        onUpdate(props) {
          node.setProperties(props);
          if (intermediateFn) {
            node.setProperties(intermediateFn(node, node.datum, status, ctx));
          }
        },
        onStop: () => {
          node.setProperties(__spreadValues(__spreadValues(__spreadValues({}, to), finish), toFinish));
        }
      });
      if (isLive) {
        liveNodeIndex++;
      }
      nodeIndex++;
      prevFromProps = from;
    }
  };
  let selectionIndex = 0;
  for (const selection of selections) {
    const nodes2 = selection.nodes();
    const liveNodes = nodes2.filter((n) => !selection.isGarbage(n));
    processNodes(liveNodes, nodes2);
    animationManager.animate({
      id: `${groupId}_${subId}_selection_${selectionIndex}`,
      groupId,
      phase: "end",
      from: 0,
      to: 1,
      ease: easeOut,
      onStop() {
        selection.cleanup();
      }
    });
    selectionIndex++;
  }
  processNodes(nodes, nodes);
}
function staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from, to, extraOpts) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const { start = {}, finish, phase } = extraOpts;
  const collapsable = finish == null;
  animationManager.animate({
    id: `${groupId}_${subId}`,
    groupId,
    phase: phase != null ? phase : "update",
    from,
    to,
    ease: easeOut,
    collapsable,
    onPlay: () => {
      for (const node of nodes) {
        node.setProperties(start);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(start);
        }
      }
    },
    onUpdate(props) {
      for (const node of nodes) {
        node.setProperties(props);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(props);
        }
      }
    },
    onStop: () => {
      for (const node of nodes) {
        node.setProperties(__spreadValues(__spreadValues({}, to), finish));
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(__spreadValues(__spreadValues({}, to), finish));
        }
      }
    }
  });
}
function calculateStatus(node, datum, getDatumId, ids) {
  const id = getDatumId(node, datum);
  if (ids.added[id]) {
    return "added";
  }
  return "updated";
}

// packages/ag-charts-community/src/util/angle.ts
var twoPi = Math.PI * 2;
function normalizeAngle360(radians) {
  radians %= twoPi;
  radians += twoPi;
  radians %= twoPi;
  return radians;
}
function normalizeAngle360Inclusive(radians) {
  radians %= twoPi;
  radians += twoPi;
  if (radians !== twoPi) {
    radians %= twoPi;
  }
  return radians;
}
function normalizeAngle180(radians) {
  radians %= twoPi;
  if (radians < -Math.PI) {
    radians += twoPi;
  } else if (radians >= Math.PI) {
    radians -= twoPi;
  }
  return radians;
}
function toRadians(degrees) {
  return degrees / 180 * Math.PI;
}
function toDegrees(radians) {
  return radians / Math.PI * 180;
}
function angleBetween(angle0, angle1) {
  angle0 = normalizeAngle360(angle0);
  angle1 = normalizeAngle360(angle1);
  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);
}

// packages/ag-charts-community/src/scale/invalidating.ts
var Invalidating = (target, propertyKey) => {
  const mappedProperty = Symbol(String(propertyKey));
  target[mappedProperty] = void 0;
  Object.defineProperty(target, propertyKey, {
    get() {
      return this[mappedProperty];
    },
    set(newValue) {
      const oldValue = this[mappedProperty];
      if (oldValue !== newValue) {
        this[mappedProperty] = newValue;
        this.invalid = true;
      }
    },
    enumerable: true,
    configurable: false
  });
};

// packages/ag-charts-community/src/scale/bandScale.ts
var BandScale = class {
  constructor() {
    this.type = "band";
    this.invalid = true;
    this.interval = 1;
    /**
     * Maps datum to its index in the {@link domain} array.
     * Used to check for duplicate datums (not allowed).
     */
    this.index = /* @__PURE__ */ new Map();
    /**
     * The output range values for datum at each index.
     */
    this.ordinalRange = [];
    /**
     * Contains unique datums only. Since `{}` is used in place of `Map`
     * for IE11 compatibility, the datums are converted `toString` before
     * the uniqueness check.
     */
    this._domain = [];
    this.range = [0, 1];
    this._bandwidth = 1;
    this._step = 1;
    this._rawBandwidth = 1;
    /**
     * The ratio of the range that is reserved for space between bands.
     */
    this._paddingInner = 0;
    /**
     * The ratio of the range that is reserved for space before the first
     * and after the last band.
     */
    this._paddingOuter = 0;
    this.round = false;
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      Logger.warnOnce("Expected update to not invalidate scale");
    }
  }
  set domain(values) {
    this.invalid = true;
    const domain = [];
    this.index = /* @__PURE__ */ new Map();
    const index = this.index;
    values.forEach((value) => {
      if (index.get(value) === void 0) {
        index.set(value, domain.push(value) - 1);
      }
    });
    this._domain = domain;
  }
  get domain() {
    return this._domain;
  }
  ticks() {
    this.refresh();
    const { interval = 1 } = this;
    const step = Math.abs(Math.round(interval));
    return this._domain.filter((_, i) => i % step === 0);
  }
  convert(d) {
    this.refresh();
    const i = this.index.get(d);
    if (i === void 0) {
      return NaN;
    }
    const r = this.ordinalRange[i];
    if (r === void 0) {
      return NaN;
    }
    return r;
  }
  invert(position) {
    this.refresh();
    const index = this.ordinalRange.findIndex((p) => p === position);
    return this.domain[index];
  }
  get bandwidth() {
    this.refresh();
    return this._bandwidth;
  }
  get step() {
    this.refresh();
    return this._step;
  }
  get rawBandwidth() {
    this.refresh();
    return this._rawBandwidth;
  }
  set padding(value) {
    value = clamp(0, value, 1);
    this._paddingInner = value;
    this._paddingOuter = value;
  }
  get padding() {
    return this._paddingInner;
  }
  set paddingInner(value) {
    this._paddingInner = clamp(0, value, 1);
  }
  get paddingInner() {
    return this._paddingInner;
  }
  set paddingOuter(value) {
    this._paddingOuter = clamp(0, value, 1);
  }
  get paddingOuter() {
    return this._paddingOuter;
  }
  update() {
    const count2 = this._domain.length;
    if (count2 === 0) {
      return;
    }
    const round3 = this.round;
    const paddingInner = this._paddingInner;
    const paddingOuter = this._paddingOuter;
    const [r0, r1] = this.range;
    const width = r1 - r0;
    const rawStep = width / Math.max(1, count2 + 2 * paddingOuter - paddingInner);
    const step = round3 ? Math.floor(rawStep) : rawStep;
    const fullBandWidth = step * (count2 - paddingInner);
    const x0 = r0 + (width - fullBandWidth) / 2;
    const start = round3 ? Math.round(x0) : x0;
    const bw = step * (1 - paddingInner);
    const bandwidth = round3 ? Math.round(bw) : bw;
    const rawBandwidth = rawStep * (1 - paddingInner);
    const values = [];
    for (let i = 0; i < count2; i++) {
      values.push(start + step * i);
    }
    this._bandwidth = bandwidth;
    this._rawBandwidth = rawBandwidth;
    this._step = step;
    this.ordinalRange = values;
  }
};
__decorateClass([
  Invalidating
], BandScale.prototype, "interval", 2);
__decorateClass([
  Invalidating
], BandScale.prototype, "range", 2);
__decorateClass([
  Invalidating
], BandScale.prototype, "round", 2);

// packages/ag-charts-community/src/util/validation.ts
function Validate(predicate, options = {}) {
  const { optional = false } = options;
  return addTransformToInstanceProperty(
    (target, property, value) => {
      var _a;
      const context = __spreadProps(__spreadValues({}, options), { target, property });
      if (optional && typeof value === "undefined" || predicate(value, context)) {
        if (isProperties(target[property]) && !isProperties(value)) {
          target[property].set(value);
          return target[property];
        }
        return value;
      }
      const cleanKey = String(property).replace(/^_*/, "");
      const targetName = (_a = target.constructor.className) != null ? _a : target.constructor.name.replace(/Properties$/, "");
      Logger.warn(
        `Property [${cleanKey}] of [${targetName}] cannot be set to [${stringify(value)}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : ""}, ignoring.`
      );
      return BREAK_TRANSFORM_CHAIN;
    },
    void 0,
    { optional }
  );
}
var AND = (...predicates) => {
  const messages = [];
  return predicateWithMessage(
    (value, ctx) => {
      messages.length = 0;
      return predicates.every((predicate) => {
        const isValid = predicate(value, ctx);
        if (!isValid) {
          messages.push(getPredicateMessage(predicate, ctx));
        }
        return isValid;
      });
    },
    () => messages.filter(Boolean).join(" AND ")
  );
};
var OR = (...predicates) => predicateWithMessage(
  (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),
  (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(" OR ")
);
var OBJECT = attachObjectRestrictions(
  predicateWithMessage(
    (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),
    "an object"
  )
);
var BOOLEAN = predicateWithMessage(isBoolean, "a boolean");
var FUNCTION = predicateWithMessage(isFunction, "a function");
var STRING = predicateWithMessage(isString, "a string");
var NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, "a number"));
var NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), "NaN");
var POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });
var RATIO = NUMBER.restrict({ min: 0, max: 1 });
var DEGREE = NUMBER.restrict({ min: -360, max: 360 });
var NUMBER_OR_NAN = OR(NUMBER, NAN);
var ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, "an array"));
var ARRAY_OF = (predicate, message) => predicateWithMessage(
  (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),
  (ctx) => {
    var _a;
    const arrayMessage = (_a = getPredicateMessage(ARRAY, ctx)) != null ? _a : "";
    return message ? `${arrayMessage} of ${message}` : arrayMessage;
  }
);
var isComparable = (value) => isFiniteNumber(value) || isValidDate(value);
var LESS_THAN = (otherField) => predicateWithMessage(
  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField],
  `expected to be less than ${otherField}`
);
var GREATER_THAN = (otherField) => predicateWithMessage(
  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField],
  `expected to be greater than ${otherField}`
);
var DATE = predicateWithMessage(isValidDate, "Date object");
var DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);
var colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;
var COLOR_STRING = predicateWithMessage(
  (v) => isString(v) && Color.validColorString(v),
  `color String. ${colorMessage}`
);
var COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);
var BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, "boolean values");
var NUMBER_ARRAY = ARRAY_OF(NUMBER, "numbers");
var STRING_ARRAY = ARRAY_OF(STRING, "strings");
var DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), "Date objects");
var OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), "objects");
var LINE_CAP = UNION(["butt", "round", "square"], "a line cap");
var LINE_JOIN = UNION(["round", "bevel", "miter"], "a line join");
var LINE_DASH = predicateWithMessage(
  ARRAY_OF(POSITIVE_NUMBER),
  "numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels."
);
var POSITION2 = UNION(["top", "right", "bottom", "left"], "a position");
var FONT_STYLE = UNION(["normal", "italic", "oblique"], "a font style");
var FONT_WEIGHT2 = OR(
  UNION(["normal", "bold", "bolder", "lighter"], "a font weight"),
  NUMBER.restrict({ min: 1, max: 1e3 })
);
var TEXT_WRAP = UNION(["never", "always", "hyphenate", "on-space"], "a text wrap strategy");
var TEXT_ALIGN = UNION(["left", "center", "right"], "a text align");
var VERTICAL_ALIGN = UNION(["top", "middle", "bottom"], "a vertical align");
var OVERFLOW_STRATEGY = UNION(["ellipsis", "hide"], "an overflow strategy");
var DIRECTION = UNION(["horizontal", "vertical"], "a direction");
var PLACEMENT = UNION(["inside", "outside"], "a placement");
var INTERACTION_RANGE = OR(UNION(["exact", "nearest"], "interaction range"), NUMBER);
function UNION(options, message = "a") {
  return predicateWithMessage(
    (v) => options.includes(v),
    `${message} keyword such as ${joinUnionOptions(options)}`
  );
}
var MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN("maxSpacing")), NAN);
var MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN("minSpacing")), NAN);
function predicateWithMessage(predicate, message) {
  predicate.message = message;
  return predicate;
}
function joinUnionOptions(options) {
  const values = options.map((option) => `'${option}'`);
  if (values.length === 1) {
    return values[0];
  }
  const lastValue = values.pop();
  return `${values.join(", ")} or ${lastValue}`;
}
function getPredicateMessage(predicate, ctx) {
  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;
}
function getPredicateMessageMapper(ctx) {
  return (predicate) => getPredicateMessage(predicate, ctx);
}
function attachArrayRestrictions(predicate) {
  return Object.assign(predicate, {
    restrict({ length, minLength } = {}) {
      return predicateWithMessage(
        (value) => isArray(value) && (isNumber(length) ? value.length === length : true) && (isNumber(minLength) ? value.length >= minLength : true),
        isNumber(minLength) && minLength > 0 ? "a non-empty array" : isNumber(length) ? `an array of length ${length}` : "an array"
      );
    }
  });
}
function attachNumberRestrictions(predicate) {
  return Object.assign(predicate, {
    restrict({ min, max } = {}) {
      const message = ["a number"];
      const hasMin = isNumber(min);
      const hasMax = isNumber(max);
      if (hasMin && hasMax) {
        message.push(`between ${min} and ${max} inclusive`);
      } else if (hasMin) {
        message.push(`greater than or equal to ${min}`);
      } else if (hasMax) {
        message.push(`less than or equal to ${max}`);
      }
      return predicateWithMessage(
        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),
        message.join(" ")
      );
    }
  });
}
function attachObjectRestrictions(predicate) {
  return Object.assign(predicate, {
    restrict(objectType) {
      const isInstanceOf = (value) => isProperties(value) && value instanceof objectType;
      return predicateWithMessage(
        (value, ctx) => isInstanceOf(value) || isObject(value) && isInstanceOf(ctx.target[ctx.property]),
        (ctx) => {
          var _a;
          return (_a = getPredicateMessage(predicate, ctx)) != null ? _a : "an object";
        }
      );
    }
  });
}
function stringify(value) {
  if (typeof value === "number") {
    if (isNaN(value))
      return "NaN";
    if (value === Infinity)
      return "Infinity";
    if (value === -Infinity)
      return "-Infinity";
  }
  return JSON.stringify(value);
}

// packages/ag-charts-community/src/chart/chartAxisDirection.ts
var ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {
  ChartAxisDirection2["X"] = "x";
  ChartAxisDirection2["Y"] = "y";
  return ChartAxisDirection2;
})(ChartAxisDirection || {});

// packages/ag-charts-community/src/util/userAgent.ts
function hasConstrainedCanvasMemory() {
  if (typeof navigator === "undefined")
    return false;
  const iPhoneOSMatch = navigator.userAgent.match(/\(iPhone; CPU iPhone OS (\d+_\d+_\d+) like Mac OS X\)/);
  if (iPhoneOSMatch == null)
    return false;
  const versionString = iPhoneOSMatch[1].split("_");
  const major = Number(versionString[0]);
  if (major > 16) {
    return false;
  } else if (major === 16) {
    const minor = Number(versionString[1]);
    return minor < 6;
  }
  return true;
}

// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts
var _HdpiCanvas = class _HdpiCanvas {
  // The width/height attributes of the Canvas element default to
  // 300/150 according to w3.org.
  constructor(opts) {
    this._enabled = true;
    // `NaN` is deliberate here, so that overrides are always applied
    // and the `resetTransform` inside the `resize` method works in IE11.
    this._pixelRatio = NaN;
    this._width = 0;
    this._height = 0;
    const {
      document: document2,
      window: window2,
      width = 600,
      height = 300,
      domLayer = false,
      zIndex = 0,
      name = void 0,
      overrideDevicePixelRatio = void 0
    } = opts;
    this.document = document2;
    this.window = window2;
    _HdpiCanvas.document = document2;
    this.element = document2.createElement("canvas");
    this.element.width = width;
    this.element.height = height;
    this.realContext = this.element.getContext("2d");
    this.imageSource = this.realContext.canvas;
    const { style } = this.element;
    style.userSelect = "none";
    style.display = "block";
    if (domLayer) {
      style.position = "absolute";
      style.zIndex = String(zIndex);
      style.top = "0";
      style.left = "0";
      style.pointerEvents = "none";
      style.opacity = `1`;
      if (name) {
        this.element.id = name;
      }
    }
    this.context = this.setPixelRatio(overrideDevicePixelRatio);
    this.resize(width, height);
  }
  set container(value) {
    if (this._container !== value) {
      this.remove();
      if (value) {
        value.appendChild(this.element);
      }
      this._container = value;
    }
  }
  get container() {
    return this._container;
  }
  set enabled(value) {
    this.element.style.display = value ? "block" : "none";
    this._enabled = !!value;
  }
  get enabled() {
    return this._enabled;
  }
  remove() {
    const { parentNode } = this.element;
    if (parentNode != null) {
      parentNode.removeChild(this.element);
    }
  }
  destroy() {
    this.element.remove();
    this.element.width = 0;
    this.element.height = 0;
    this.context.clearRect(0, 0, 0, 0);
    Object.freeze(this);
  }
  snapshot() {
  }
  clear() {
    this.context.save();
    this.context.resetTransform();
    this.context.clearRect(0, 0, this.width, this.height);
    this.context.restore();
  }
  toImage() {
    const img = this.document.createElement("img");
    img.src = this.getDataURL();
    return img;
  }
  getDataURL(type) {
    return this.element.toDataURL(type);
  }
  /**
   * @param fileName The name of the downloaded file.
   * @param fileFormat The file format, the default is `image/png`
   */
  download(fileName, fileFormat = "image/png") {
    fileName = (fileName != null ? fileName : "").trim() || "image";
    const dataUrl = this.getDataURL(fileFormat);
    const document2 = this.document;
    const a = document2.createElement("a");
    a.href = dataUrl;
    a.download = fileName;
    a.style.display = "none";
    document2.body.appendChild(a);
    a.click();
    document2.body.removeChild(a);
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  /**
   * Changes the pixel ratio of the Canvas element to the given value,
   * or uses the window.devicePixelRatio (default), then resizes the Canvas
   * element accordingly (default).
   */
  setPixelRatio(ratio) {
    let pixelRatio = ratio != null ? ratio : this.window.devicePixelRatio;
    if (hasConstrainedCanvasMemory()) {
      pixelRatio = 1;
    }
    this._pixelRatio = pixelRatio;
    return _HdpiCanvas.overrideScale(this.realContext, pixelRatio);
  }
  set pixelated(value) {
    this.element.style.imageRendering = value ? "pixelated" : "auto";
  }
  get pixelated() {
    return this.element.style.imageRendering === "pixelated";
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  resize(width, height) {
    if (!(width > 0 && height > 0)) {
      return;
    }
    const { element: element2, context, pixelRatio } = this;
    element2.width = Math.round(width * pixelRatio);
    element2.height = Math.round(height * pixelRatio);
    element2.style.width = width + "px";
    element2.style.height = height + "px";
    context.resetTransform();
    this._width = width;
    this._height = height;
  }
  static get textMeasuringContext() {
    if (this._textMeasuringContext) {
      return this._textMeasuringContext;
    }
    const canvas = this.document.createElement("canvas");
    this._textMeasuringContext = canvas.getContext("2d");
    return this._textMeasuringContext;
  }
  static get svgText() {
    if (this._svgText) {
      return this._svgText;
    }
    const xmlns = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(xmlns, "svg");
    svg.setAttribute("width", "100");
    svg.setAttribute("height", "100");
    if (svg.classList) {
      svg.classList.add("text-measuring-svg");
    } else {
      svg.setAttribute("class", "text-measuring-svg");
    }
    svg.style.position = "absolute";
    svg.style.top = "-1000px";
    svg.style.visibility = "hidden";
    const svgText = document.createElementNS(xmlns, "text");
    svgText.setAttribute("x", "0");
    svgText.setAttribute("y", "30");
    svgText.setAttribute("text", "black");
    svg.appendChild(svgText);
    document.body.appendChild(svg);
    this._svgText = svgText;
    return svgText;
  }
  static get has() {
    if (this._has) {
      return this._has;
    }
    const isChrome = typeof navigator === "undefined" || navigator.userAgent.indexOf("Chrome") > -1;
    const isFirefox = typeof navigator !== "undefined" && navigator.userAgent.indexOf("Firefox") > -1;
    const isSafari = !isChrome && typeof navigator !== "undefined" && navigator.userAgent.indexOf("Safari") > -1;
    this._has = Object.freeze({
      textMetrics: this.textMeasuringContext.measureText("test").actualBoundingBoxDescent !== void 0 && // Firefox implemented advanced TextMetrics object in v74:
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1102584
      // but it's buggy, so we'll keep using the SVG for text measurement in Firefox for now.
      !isFirefox && !isSafari,
      getTransform: this.textMeasuringContext.getTransform !== void 0
    });
    return this._has;
  }
  static measureText(text, font, textBaseline, textAlign) {
    const ctx = this.textMeasuringContext;
    ctx.font = font;
    ctx.textBaseline = textBaseline;
    ctx.textAlign = textAlign;
    return ctx.measureText(text);
  }
  /**
   * Returns the width and height of the measured text.
   * @param text The single-line text to measure.
   * @param font The font shorthand string.
   */
  static getTextSize(text, font) {
    if (this.has.textMetrics) {
      const ctx = this.textMeasuringContext;
      ctx.font = font;
      const metrics = ctx.measureText(text);
      return {
        width: metrics.width,
        height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
      };
    } else {
      return this.measureSvgText(text, font);
    }
  }
  static measureSvgText(text, font) {
    const cache = this.textSizeCache;
    const fontCache = cache[font];
    if (fontCache) {
      const size2 = fontCache[text];
      if (size2) {
        return size2;
      }
    } else {
      cache[font] = {};
    }
    const svgText = this.svgText;
    svgText.style.font = font;
    svgText.textContent = text;
    const bbox = svgText.getBBox();
    const size = {
      width: bbox.width,
      height: bbox.height
    };
    cache[font][text] = size;
    return size;
  }
  static overrideScale(ctx, scale2) {
    let depth = 0;
    const overrides = {
      save() {
        this.$save();
        depth++;
      },
      restore() {
        if (depth > 0) {
          this.$restore();
          depth--;
        } else {
          throw new Error("AG Charts - Unable to restore() past depth 0");
        }
      },
      setTransform(a, b, c, d, e, f) {
        if (typeof a === "object") {
          this.$setTransform(a);
        } else {
          this.$setTransform(a * scale2, b * scale2, c * scale2, d * scale2, e * scale2, f * scale2);
        }
      },
      resetTransform() {
        this.$setTransform(scale2, 0, 0, scale2, 0, 0);
      },
      verifyDepthZero() {
        if (depth !== 0) {
          throw new Error("AG Charts - Save/restore depth is non-zero: " + depth);
        }
      }
    };
    for (const name in overrides) {
      if (Object.hasOwn(overrides, name)) {
        if (!ctx["$" + name]) {
          ctx["$" + name] = ctx[name];
        }
        ctx[name] = overrides[name];
      }
    }
    return ctx;
  }
};
_HdpiCanvas.document = globalThis.document;
_HdpiCanvas.textSizeCache = {};
var HdpiCanvas = _HdpiCanvas;

// packages/ag-charts-community/src/scene/gradient/gradient.ts
var Gradient = class {
  constructor() {
    this.stops = [];
  }
};

// packages/ag-charts-community/src/scene/gradient/linearGradient.ts
var LinearGradient = class extends Gradient {
  constructor() {
    super(...arguments);
    this.angle = 0;
  }
  createGradient(ctx, bbox) {
    const angleOffset = 90;
    const { stops, angle } = this;
    const radians = normalizeAngle360(toRadians(angle + angleOffset));
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const w = bbox.width;
    const h = bbox.height;
    const cx = bbox.x + w * 0.5;
    const cy = bbox.y + h * 0.5;
    if (w > 0 && h > 0) {
      const diagonal = Math.sqrt(h * h + w * w) / 2;
      const diagonalAngle = Math.atan2(h, w);
      let quarteredAngle;
      if (radians < Math.PI / 2) {
        quarteredAngle = radians;
      } else if (radians < Math.PI) {
        quarteredAngle = Math.PI - radians;
      } else if (radians < 3 * Math.PI / 2) {
        quarteredAngle = radians - Math.PI;
      } else {
        quarteredAngle = 2 * Math.PI - radians;
      }
      const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));
      const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);
      stops.forEach((stop) => {
        gradient.addColorStop(stop.offset, stop.color);
      });
      return gradient;
    }
    return "black";
  }
};

// packages/ag-charts-community/src/scene/shape/shape.ts
var LINEAR_GRADIENT_REGEXP = /^linear-gradient\((.*?)deg,\s*(.*?)\s*\)$/i;
var _Shape = class _Shape extends Node {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.fill = _Shape.defaultStyles.fill;
    this.stroke = _Shape.defaultStyles.stroke;
    this.strokeWidth = _Shape.defaultStyles.strokeWidth;
    this.lineDash = _Shape.defaultStyles.lineDash;
    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;
    this.lineCap = _Shape.defaultStyles.lineCap;
    this.lineJoin = _Shape.defaultStyles.lineJoin;
    this.opacity = _Shape.defaultStyles.opacity;
    this.fillShadow = _Shape.defaultStyles.fillShadow;
  }
  /**
   * Restores the default styles introduced by this subclass.
   */
  restoreOwnStyles() {
    const styles = this.constructor.defaultStyles;
    const keys = Object.getOwnPropertyNames(styles);
    for (let i = 0, n = keys.length; i < n; i++) {
      const key = keys[i];
      this[key] = styles[key];
    }
  }
  updateGradient() {
    const { fill } = this;
    let linearGradientMatch;
    if ((fill == null ? void 0 : fill.startsWith("linear-gradient")) && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {
      const angle = parseFloat(linearGradientMatch[1]);
      const colors = [];
      const colorsPart = linearGradientMatch[2];
      const colorRegex = /(#[0-9a-f]+)|(rgba?\(.+?\))|([a-z]+)/gi;
      let c;
      while (c = colorRegex.exec(colorsPart)) {
        colors.push(c[0]);
      }
      this.gradient = new LinearGradient();
      this.gradient.angle = angle;
      this.gradient.stops = colors.map((color, index) => {
        const offset4 = index / (colors.length - 1);
        return { offset: offset4, color };
      });
    } else {
      this.gradient = void 0;
    }
  }
  /**
   * Returns a device-pixel aligned coordinate (or length if length is supplied).
   *
   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle
   * of a device pixel.
   */
  align(start, length) {
    var _a, _b, _c;
    const pixelRatio = (_c = (_b = (_a = this.layerManager) == null ? void 0 : _a.canvas) == null ? void 0 : _b.pixelRatio) != null ? _c : 1;
    const alignedStart = Math.round(start * pixelRatio) / pixelRatio;
    if (length == void 0) {
      return alignedStart;
    }
    if (length === 0) {
      return 0;
    }
    if (length < 1) {
      return Math.ceil(length * pixelRatio) / pixelRatio;
    }
    return Math.round((length + start) * pixelRatio) / pixelRatio - alignedStart;
  }
  fillStroke(ctx) {
    this.renderFill(ctx);
    this.renderStroke(ctx);
  }
  renderFill(ctx) {
    if (this.fill) {
      const { globalAlpha } = ctx;
      this.applyFill(ctx);
      this.applyFillAlpha(ctx);
      this.applyShadow(ctx);
      ctx.fill();
      ctx.globalAlpha = globalAlpha;
    }
    ctx.shadowColor = "rgba(0, 0, 0, 0)";
  }
  applyFill(ctx) {
    if (this.gradient) {
      ctx.fillStyle = this.gradient.createGradient(ctx, this.computeBBox());
    } else {
      ctx.fillStyle = this.fill;
    }
  }
  applyFillAlpha(ctx) {
    const { globalAlpha } = ctx;
    ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;
  }
  applyShadow(ctx) {
    var _a, _b;
    const pixelRatio = (_b = (_a = this.layerManager) == null ? void 0 : _a.canvas.pixelRatio) != null ? _b : 1;
    const fillShadow = this.fillShadow;
    if (fillShadow == null ? void 0 : fillShadow.enabled) {
      ctx.shadowColor = fillShadow.color;
      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
      ctx.shadowBlur = fillShadow.blur * pixelRatio;
    }
  }
  renderStroke(ctx) {
    if (this.stroke && this.strokeWidth) {
      const { globalAlpha } = ctx;
      ctx.strokeStyle = this.stroke;
      ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;
      ctx.lineWidth = this.strokeWidth;
      if (this.lineDash) {
        ctx.setLineDash(this.lineDash);
      }
      if (this.lineDashOffset) {
        ctx.lineDashOffset = this.lineDashOffset;
      }
      if (this.lineCap) {
        ctx.lineCap = this.lineCap;
      }
      if (this.lineJoin) {
        ctx.lineJoin = this.lineJoin;
      }
      ctx.stroke();
      ctx.globalAlpha = globalAlpha;
    }
  }
  containsPoint(x, y) {
    return this.isPointInPath(x, y);
  }
};
/**
 * Defaults for style properties. Note that properties that affect the position
 * and shape of the node are not considered style properties, for example:
 * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.
 * Can be used to reset to the original styling after some custom styling
 * has been applied (using the `restoreOwnStyles` method).
 * These static defaults are meant to be inherited by subclasses.
 */
_Shape.defaultStyles = Object.assign(
  {},
  {
    fill: "black",
    stroke: void 0,
    strokeWidth: 0,
    lineDash: void 0,
    lineDashOffset: 0,
    lineCap: void 0,
    lineJoin: void 0,
    opacity: 1,
    fillShadow: void 0
  }
);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "fillOpacity", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "strokeOpacity", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */, changeCb: (s) => s.updateGradient() })
], _Shape.prototype, "fill", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "stroke", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "strokeWidth", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "lineDash", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "lineDashOffset", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "lineCap", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], _Shape.prototype, "lineJoin", 2);
__decorateClass([
  SceneChangeDetection({
    redraw: 2 /* MINOR */,
    convertor: (v) => clamp(0, v, 1)
  })
], _Shape.prototype, "opacity", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */, checkDirtyOnAssignment: true })
], _Shape.prototype, "fillShadow", 2);
var Shape = _Shape;

// packages/ag-charts-community/src/scene/shape/text.ts
var ellipsis = "\u2026";
function SceneFontChangeDetection(opts) {
  const { redraw = 3 /* MAJOR */, changeCb } = opts != null ? opts : {};
  return SceneChangeDetection({ redraw, type: "font", changeCb });
}
var _Text = class _Text extends Shape {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.lines = [];
    this.text = void 0;
    this._dirtyFont = true;
    this.fontSize = 10;
    this.fontFamily = "sans-serif";
    this.textAlign = _Text.defaultStyles.textAlign;
    this.textBaseline = _Text.defaultStyles.textBaseline;
    this.lineHeight = void 0;
  }
  _setLines() {
    this.lines = splitText(this.text);
  }
  get font() {
    if (this._font == null || this._dirtyFont) {
      this._dirtyFont = false;
      this._font = getFont(this);
    }
    return this._font;
  }
  computeBBox() {
    return HdpiCanvas.has.textMetrics ? getPreciseBBox(this.lines, this.x, this.y, this) : getApproximateBBox(this.lines, this.x, this.y, this);
  }
  getLineHeight(line) {
    var _a, _b;
    if (this.lineHeight)
      return this.lineHeight;
    if (HdpiCanvas.has.textMetrics) {
      const metrics = HdpiCanvas.measureText(line, this.font, this.textBaseline, this.textAlign);
      return ((_a = metrics.fontBoundingBoxAscent) != null ? _a : metrics.emHeightAscent) + ((_b = metrics.fontBoundingBoxDescent) != null ? _b : metrics.emHeightDescent);
    }
    return HdpiCanvas.getTextSize(line, this.font).height;
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    const bbox = this.computeBBox();
    return bbox ? bbox.containsPoint(point.x, point.y) : false;
  }
  render(renderCtx) {
    const { ctx, forceRender, stats } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    if (!this.lines.length || !this.layerManager) {
      if (stats)
        stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    const { fill, stroke, strokeWidth } = this;
    ctx.font = this.font;
    ctx.textAlign = this.textAlign;
    ctx.textBaseline = this.textBaseline;
    const pixelRatio = this.layerManager.canvas.pixelRatio || 1;
    const { globalAlpha } = ctx;
    if (fill) {
      ctx.fillStyle = fill;
      ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;
      const { fillShadow } = this;
      if (fillShadow == null ? void 0 : fillShadow.enabled) {
        ctx.shadowColor = fillShadow.color;
        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
        ctx.shadowBlur = fillShadow.blur * pixelRatio;
      }
      this.renderLines((line, x, y) => ctx.fillText(line, x, y));
    }
    if (stroke && strokeWidth) {
      ctx.strokeStyle = stroke;
      ctx.lineWidth = strokeWidth;
      ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;
      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));
    }
    super.render(renderCtx);
  }
  renderLines(renderCallback) {
    const { lines, x, y } = this;
    const lineHeights = this.lines.map((line) => this.getLineHeight(line));
    const totalHeight = lineHeights.reduce((a, b) => a + b, 0);
    let offsetY = -(totalHeight - lineHeights[0]) * getVerticalOffset(this.textBaseline);
    for (let i = 0; i < lines.length; i++) {
      renderCallback(lines[i], x, y + offsetY);
      offsetY += lineHeights[i];
    }
  }
  static wrapLines(text, maxWidth, maxHeight, textProps, wrapping, overflow) {
    const canOverflow = overflow !== "hide";
    const font = getFont(textProps);
    const measurer = createTextMeasurer(font);
    const lines = text.split(/\r?\n/g);
    if (lines.length === 0) {
      return { lines: void 0, truncated: false };
    }
    if (wrapping === "never") {
      const { text: text2, truncated: truncated2 } = _Text.truncateLine(lines[0], maxWidth, measurer, canOverflow ? "auto" : "never");
      return { lines: text2 != null ? [text2] : void 0, truncated: truncated2 };
    }
    const wrappedLines = [];
    let cumulativeHeight = 0;
    let truncated = false;
    for (const line of lines) {
      const wrappedLine = _Text.wrapLine(
        line,
        maxWidth,
        maxHeight,
        measurer,
        textProps,
        wrapping,
        cumulativeHeight,
        canOverflow
      );
      if (wrappedLine == null) {
        return { lines: void 0, truncated: false };
      }
      wrappedLines.push(...wrappedLine.result);
      cumulativeHeight = wrappedLine.cumulativeHeight;
      if (wrappedLine.truncated) {
        truncated = true;
        break;
      }
    }
    return { lines: wrappedLines, truncated };
  }
  static wrap(text, maxWidth, maxHeight, textProps, wrapping, overflow = "ellipsis") {
    const { lines, truncated } = _Text.wrapLines(text, maxWidth, maxHeight, textProps, wrapping, overflow);
    return { text: lines != null ? lines.join("\n").trim() : "", truncated };
  }
  static wrapLine(text, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {
    text = text.trim();
    if (!text) {
      return { result: [], truncated: false, cumulativeHeight };
    }
    const initialSize = measurer.size(text);
    if (initialSize.width <= maxWidth) {
      return {
        result: [text],
        truncated: false,
        cumulativeHeight: cumulativeHeight + initialSize.height
      };
    }
    if (initialSize.height > maxHeight || measurer.width("W") > maxWidth) {
      return canOverflow ? { result: [], truncated: true, cumulativeHeight } : void 0;
    }
    const words = text.split(/\s+/g);
    const wrapResult = _Text.wrapLineSequentially(
      words,
      maxWidth,
      maxHeight,
      measurer,
      textProps,
      wrapping,
      cumulativeHeight,
      canOverflow
    );
    if (wrapResult == null) {
      return void 0;
    }
    cumulativeHeight = wrapResult.cumulativeHeight;
    let { lines } = wrapResult;
    if (!(wrapResult.wordsBrokenOrTruncated || wrapResult.linesTruncated)) {
      const linesCount = wrapResult.lines.length;
      const balanced = _Text.wrapLineBalanced(words, maxWidth, measurer, linesCount);
      if (balanced.length === lines.length) {
        lines = balanced;
      }
    }
    const wrappedText = lines.map((ln) => ln.join(" "));
    return { result: wrappedText, truncated: wrapResult.linesTruncated, cumulativeHeight };
  }
  static breakWord(word, firstLineWidth, maxWidth, hyphens, measurer) {
    const isPunctuationAt = (index) => _Text.punctuationMarks.includes(word[index]);
    const h = hyphens ? measurer.width("-") : 0;
    const breaks = [];
    let partWidth = 0;
    let p = 0;
    for (let i = 0; i < word.length; i++) {
      const c = word[i];
      const w = measurer.width(c);
      const limit = p === 0 ? firstLineWidth : maxWidth;
      if (partWidth + w + h > limit) {
        breaks.push(i);
        partWidth = 0;
        p++;
      }
      partWidth += w;
    }
    const parts = [];
    let start = 0;
    for (const index of breaks) {
      let part = word.substring(start, index);
      if (hyphens && part.length > 0 && !isPunctuationAt(index - 1) && !isPunctuationAt(index)) {
        part += "-";
      }
      parts.push(part);
      start = index;
    }
    parts.push(word.substring(start));
    return parts;
  }
  static truncateLine(text, maxWidth, measurer, ellipsisMode) {
    text = text.trimEnd();
    const lineWidth = measurer.width(text);
    if (lineWidth > maxWidth && ellipsisMode === "never") {
      return { text: void 0, truncated: false };
    } else if (lineWidth <= maxWidth && ellipsisMode !== "force") {
      return { text, truncated: false };
    }
    const ellipsisWidth = measurer.width(ellipsis);
    let trunc = text;
    let truncWidth = lineWidth;
    while (trunc.length > 0 && truncWidth + ellipsisWidth > maxWidth) {
      trunc = trunc.slice(0, -1).trimEnd();
      truncWidth = measurer.width(trunc);
    }
    if (truncWidth + ellipsisWidth <= maxWidth) {
      return { text: `${trunc}${ellipsis}`, truncated: true };
    } else {
      return { text: void 0, truncated: false };
    }
  }
  static wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {
    const { fontSize = 0, lineHeight = fontSize * _Text.defaultLineHeightRatio } = textProps;
    const breakWord = wrapping === "always" || wrapping === "hyphenate";
    const hyphenate = wrapping === "hyphenate";
    const spaceWidth = measurer.width(" ");
    let wordsBrokenOrTruncated = false;
    let linesTruncated = false;
    const lines = [];
    let currentLine = [];
    let lineWidth = 0;
    const getReturnValue = () => ({
      lines,
      linesTruncated,
      wordsBrokenOrTruncated,
      cumulativeHeight
    });
    const truncateLastLine = () => {
      if (!canOverflow) {
        return void 0;
      }
      const lastLine = currentLine.join(" ");
      const { text } = _Text.truncateLine(lastLine, maxWidth, measurer, "force");
      if (text == null) {
        return void 0;
      }
      currentLine.splice(0, currentLine.length, text);
      linesTruncated = true;
      return getReturnValue();
    };
    const addNewLine = () => {
      const expectedHeight = cumulativeHeight + lineHeight;
      if (expectedHeight >= maxHeight) {
        return false;
      }
      currentLine = [];
      lineWidth = 0;
      cumulativeHeight = expectedHeight;
      lines.push(currentLine);
      return true;
    };
    if (!addNewLine()) {
      return truncateLastLine();
    }
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      const wordWidth = measurer.width(word);
      const expectedSpaceWidth = currentLine.length === 0 ? 0 : spaceWidth;
      const expectedLineWidth = lineWidth + expectedSpaceWidth + wordWidth;
      if (expectedLineWidth <= maxWidth) {
        currentLine.push(word);
        lineWidth = expectedLineWidth;
        continue;
      }
      if (wordWidth <= maxWidth) {
        if (!addNewLine()) {
          return truncateLastLine();
        }
        currentLine.push(word);
        lineWidth = wordWidth;
        continue;
      }
      wordsBrokenOrTruncated = true;
      if (breakWord) {
        const availWidth = maxWidth - lineWidth - expectedSpaceWidth;
        const parts = _Text.breakWord(word, availWidth, maxWidth, hyphenate, measurer);
        for (let p = 0; p < parts.length; p++) {
          const part = parts[p];
          part && currentLine.push(part);
          if (p === parts.length - 1) {
            lineWidth = measurer.width(part);
          } else if (!addNewLine()) {
            return truncateLastLine();
          }
        }
      } else if (canOverflow) {
        if (!addNewLine()) {
          return truncateLastLine();
        }
        const { text } = _Text.truncateLine(word, maxWidth, measurer, "force");
        if (text == null) {
          return void 0;
        }
        currentLine.push(text);
        if (i < words.length - 1) {
          linesTruncated = true;
        }
        break;
      } else {
        return void 0;
      }
    }
    return getReturnValue();
  }
  static wrapLineBalanced(words, maxWidth, measurer, linesCount) {
    const totalWordsWidth = words.reduce((sum2, w) => sum2 + measurer.width(w), 0);
    const spaceWidth = measurer.width(" ");
    const totalSpaceWidth = spaceWidth * (words.length - linesCount - 2);
    const averageLineWidth = (totalWordsWidth + totalSpaceWidth) / linesCount;
    const lines = [];
    let currentLine = [];
    let lineWidth = measurer.width(words[0]);
    let newLine = true;
    for (const word of words) {
      const width = measurer.width(word);
      if (newLine) {
        currentLine = [];
        currentLine.push(word);
        lineWidth = width;
        newLine = false;
        lines.push(currentLine);
        continue;
      }
      const expectedLineWidth = lineWidth + spaceWidth + width;
      if (expectedLineWidth <= averageLineWidth) {
        currentLine.push(word);
        lineWidth = expectedLineWidth;
      } else if (expectedLineWidth <= maxWidth) {
        currentLine.push(word);
        newLine = true;
      } else {
        currentLine = [word];
        lineWidth = width;
        lines.push(currentLine);
      }
    }
    return lines;
  }
  setFont(props) {
    this.fontFamily = props.fontFamily;
    this.fontSize = props.fontSize;
    this.fontStyle = props.fontStyle;
    this.fontWeight = props.fontWeight;
  }
  setAlign(props) {
    this.textAlign = props.textAlign;
    this.textBaseline = props.textBaseline;
  }
};
_Text.className = "Text";
// The default line spacing for document editors is usually 1.15
_Text.defaultLineHeightRatio = 1.15;
_Text.defaultStyles = Object.assign({}, Shape.defaultStyles, {
  textAlign: "start",
  fontStyle: void 0,
  fontWeight: void 0,
  fontSize: 10,
  fontFamily: "sans-serif",
  textBaseline: "alphabetic"
});
_Text.ellipsis = ellipsis;
_Text.punctuationMarks = [".", ",", "-", ":", ";", "!", "?", `'`, '"', "(", ")"];
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o._setLines() })
], _Text.prototype, "text", 2);
__decorateClass([
  SceneFontChangeDetection()
], _Text.prototype, "fontStyle", 2);
__decorateClass([
  SceneFontChangeDetection()
], _Text.prototype, "fontWeight", 2);
__decorateClass([
  SceneFontChangeDetection()
], _Text.prototype, "fontSize", 2);
__decorateClass([
  SceneFontChangeDetection()
], _Text.prototype, "fontFamily", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "textAlign", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "textBaseline", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], _Text.prototype, "lineHeight", 2);
var Text = _Text;
function createTextMeasurer(font) {
  const cache = /* @__PURE__ */ new Map();
  const getTextSize = (text) => HdpiCanvas.getTextSize(text, font);
  const getLineWidth = (text) => {
    if (cache.has(text)) {
      return cache.get(text);
    }
    const { width } = getTextSize(text);
    cache.set(text, width);
    return width;
  };
  return { size: getTextSize, width: getLineWidth };
}
function getFont(fontProps) {
  const { fontFamily, fontSize, fontStyle, fontWeight } = fontProps;
  return [fontStyle != null ? fontStyle : "", fontWeight != null ? fontWeight : "", fontSize + "px", fontFamily].join(" ").trim();
}
function measureText(lines, x, y, textProps) {
  return HdpiCanvas.has.textMetrics ? getPreciseBBox(lines, x, y, textProps) : getApproximateBBox(lines, x, y, textProps);
}
function getPreciseBBox(lines, x, y, textProps) {
  var _a, _b;
  let left = 0;
  let top = 0;
  let width = 0;
  let height = 0;
  let baselineDistance = 0;
  const font = getFont(textProps);
  const {
    lineHeight,
    textBaseline = Text.defaultStyles.textBaseline,
    textAlign = Text.defaultStyles.textAlign
  } = textProps;
  for (let i = 0; i < lines.length; i++) {
    const metrics = HdpiCanvas.measureText(lines[i], font, textBaseline, textAlign);
    left = Math.max(left, metrics.actualBoundingBoxLeft);
    width = Math.max(width, metrics.width);
    if (i == 0) {
      top += metrics.actualBoundingBoxAscent;
      height += metrics.actualBoundingBoxAscent;
    } else {
      baselineDistance += (_a = metrics.fontBoundingBoxAscent) != null ? _a : metrics.emHeightAscent;
    }
    if (i == lines.length - 1) {
      height += metrics.actualBoundingBoxDescent;
    } else {
      baselineDistance += (_b = metrics.fontBoundingBoxDescent) != null ? _b : metrics.emHeightDescent;
    }
  }
  if (lineHeight !== void 0) {
    baselineDistance = (lines.length - 1) * lineHeight;
  }
  height += baselineDistance;
  top += baselineDistance * getVerticalOffset(textBaseline);
  return new BBox(x - left, y - top, width, height);
}
function getApproximateBBox(lines, x, y, textProps) {
  let width = 0;
  let firstLineHeight = 0;
  let baselineDistance = 0;
  const font = getFont(textProps);
  const {
    lineHeight,
    textBaseline = Text.defaultStyles.textBaseline,
    textAlign = Text.defaultStyles.textAlign
  } = textProps;
  if (lines.length > 0) {
    const lineSize = HdpiCanvas.getTextSize(lines[0], font);
    width = lineSize.width;
    firstLineHeight = lineSize.height;
  }
  for (let i = 1; i < lines.length; i++) {
    const lineSize = HdpiCanvas.getTextSize(lines[i], font);
    width = Math.max(width, lineSize.width);
    baselineDistance += lineHeight != null ? lineHeight : lineSize.height;
  }
  switch (textAlign) {
    case "end":
    case "right":
      x -= width;
      break;
    case "center":
      x -= width / 2;
  }
  switch (textBaseline) {
    case "alphabetic":
      y -= firstLineHeight * 0.7 + baselineDistance * 0.5;
      break;
    case "middle":
      y -= firstLineHeight * 0.45 + baselineDistance * 0.5;
      break;
    case "ideographic":
      y -= firstLineHeight + baselineDistance;
      break;
    case "hanging":
      y -= firstLineHeight * 0.2 + baselineDistance * 0.5;
      break;
    case "bottom":
      y -= firstLineHeight + baselineDistance;
      break;
  }
  return new BBox(x, y, width, firstLineHeight + baselineDistance);
}
function getVerticalOffset(textBaseline) {
  switch (textBaseline) {
    case "top":
    case "hanging":
      return 0;
    case "bottom":
    case "alphabetic":
    case "ideographic":
      return 1;
    case "middle":
      return 0.5;
  }
}
function splitText(text) {
  return typeof text === "string" ? text.split(/\r?\n/g) : [];
}

// packages/ag-charts-community/src/util/proxy.ts
function ProxyProperty(proxyPath) {
  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(".");
  if (pathArray.length === 1) {
    const [property] = pathArray;
    return addTransformToInstanceProperty(
      (target, _, value) => target[property] = value,
      (target) => target[property]
    );
  }
  return addTransformToInstanceProperty(
    (target, _, value) => setPath(target, pathArray, value),
    (target) => getPath(target, pathArray)
  );
}
function ProxyOnWrite(proxyProperty) {
  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);
}
function ProxyPropertyOnWrite(childName, childProperty) {
  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty != null ? childProperty : key] = value);
}
function ActionOnSet(opts) {
  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;
  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {
    if (newValue !== oldValue) {
      if (oldValue !== void 0) {
        oldValueFn == null ? void 0 : oldValueFn.call(target, oldValue);
      }
      if (newValue !== void 0) {
        newValueFn == null ? void 0 : newValueFn.call(target, newValue);
      }
      changeValueFn == null ? void 0 : changeValueFn.call(target, newValue, oldValue);
    }
    return newValue;
  });
}
function ObserveChanges(observerFn) {
  return addObserverToInstanceProperty(observerFn);
}

// packages/ag-charts-community/src/util/dom.ts
function injectStyle(document2, cssStyle) {
  const styleElement = document2.createElement("style");
  styleElement.innerHTML = cssStyle;
  document2.head.insertBefore(styleElement, document2.head.querySelector("style"));
}

// packages/ag-charts-community/src/chart/tooltip/tooltip.ts
var DEFAULT_TOOLTIP_CLASS = "ag-chart-tooltip";
var DEFAULT_TOOLTIP_DARK_CLASS = "ag-chart-dark-tooltip";
var defaultTooltipCss = `
.${DEFAULT_TOOLTIP_CLASS} {
    transition: transform 0.1s ease;
    max-width: 100%;
    position: fixed;
    left: 0px;
    top: 0px;
    z-index: 99999;
    font: 12px Verdana, sans-serif;
    color: rgb(70, 70, 70);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
}

.${DEFAULT_TOOLTIP_CLASS}-wrap-always {
    overflow-wrap: break-word;
    word-break: break-word;
    hyphens: none;
}

.${DEFAULT_TOOLTIP_CLASS}-wrap-hyphenate {
    overflow-wrap: break-word;
    word-break: break-word;
    hyphens: auto;
}

.${DEFAULT_TOOLTIP_CLASS}-wrap-on-space {
    overflow-wrap: normal;
    word-break: normal;
}

.${DEFAULT_TOOLTIP_CLASS}-wrap-never {
    white-space: pre;
    text-overflow: ellipsis;
}

.${DEFAULT_TOOLTIP_CLASS}-no-interaction {
    pointer-events: none;
    user-select: none;
}

.${DEFAULT_TOOLTIP_CLASS}-no-animation {
    transition: none !important;
}

.${DEFAULT_TOOLTIP_CLASS}-hidden {
    visibility: hidden;
}

.${DEFAULT_TOOLTIP_CLASS}-title {
    overflow: hidden;
    position: relative;
    padding: 8px 14px;
    border-top-left-radius: 2px;
    border-top-right-radius: 2px;
    color: white;
    background-color: #888888;
    z-index: 1;
    text-overflow: inherit;
}

.${DEFAULT_TOOLTIP_CLASS}-title:only-child {
    border-bottom-left-radius: 2px;
    border-bottom-right-radius: 2px;
}

.${DEFAULT_TOOLTIP_CLASS}-content {
    overflow: hidden;
    padding: 6px 14px;
    line-height: 1.7em;
    background: white;
    border-bottom-left-radius: 2px;
    border-bottom-right-radius: 2px;
    border: 1px solid rgba(0, 0, 0, 0.15);
    overflow: hidden;
    text-overflow: inherit;
}

.${DEFAULT_TOOLTIP_CLASS}-arrow::before {
    content: "";

    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);

    border: 5px solid #d9d9d9;

    border-left-color: transparent;
    border-right-color: transparent;
    border-bottom-color: transparent;

    width: 0;
    height: 0;

    margin: 0 auto;
}

.${DEFAULT_TOOLTIP_CLASS}-arrow::after {
    content: "";

    position: absolute;
    top: calc(100% - 1px);
    left: 50%;
    transform: translateX(-50%);

    border: 5px solid white;

    border-left-color: transparent;
    border-right-color: transparent;
    border-bottom-color: transparent;

    width: 0;
    height: 0;

    margin: 0 auto;
}

.ag-chart-wrapper {
    box-sizing: border-box;
    overflow: hidden;
}
`;
function toTooltipHtml(input, defaults) {
  var _a, _b, _c;
  if (typeof input === "string") {
    return input;
  }
  const {
    content = (_a = defaults == null ? void 0 : defaults.content) != null ? _a : "",
    title = defaults == null ? void 0 : defaults.title,
    color = (_b = defaults == null ? void 0 : defaults.color) != null ? _b : "white",
    backgroundColor = (_c = defaults == null ? void 0 : defaults.backgroundColor) != null ? _c : "#888"
  } = input;
  const titleHtml = title ? `<div class="${DEFAULT_TOOLTIP_CLASS}-title"
        style="color: ${color}; background-color: ${backgroundColor}">${title}</div>` : "";
  const contentHtml = content ? `<div class="${DEFAULT_TOOLTIP_CLASS}-content">${content}</div>` : "";
  return `${titleHtml}${contentHtml}`;
}
var TooltipPosition = class extends BaseProperties {
  constructor() {
    super(...arguments);
    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */
    this.type = "pointer";
    /** The horizontal offset in pixels for the position of the tooltip. */
    this.xOffset = 0;
    /** The vertical offset in pixels for the position of the tooltip. */
    this.yOffset = 0;
  }
};
__decorateClass([
  Validate(UNION(["pointer", "node"], "a position type"))
], TooltipPosition.prototype, "type", 2);
__decorateClass([
  Validate(NUMBER)
], TooltipPosition.prototype, "xOffset", 2);
__decorateClass([
  Validate(NUMBER)
], TooltipPosition.prototype, "yOffset", 2);
var _Tooltip = class _Tooltip {
  constructor(canvasElement, document2, window2, container) {
    this.enableInteraction = false;
    this.enabled = true;
    this.showArrow = void 0;
    this.class = void 0;
    this.lastClass = void 0;
    this.delay = 0;
    this.range = "nearest";
    this.wrapping = "hyphenate";
    this.darkTheme = false;
    this.lastVisibilityChange = Date.now();
    this.position = new TooltipPosition();
    this.showTimeout = 0;
    this._showArrow = true;
    this.tooltipRoot = container;
    this.window = window2;
    const element2 = document2.createElement("div");
    this.element = this.tooltipRoot.appendChild(element2);
    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);
    this.canvasElement = canvasElement;
    if (typeof IntersectionObserver !== "undefined") {
      const observer = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (entry.target === this.canvasElement && entry.intersectionRatio === 0) {
              this.toggle(false);
            }
          }
        },
        { root: this.tooltipRoot }
      );
      observer.observe(this.canvasElement);
      this.observer = observer;
    }
    if (_Tooltip.tooltipDocuments.indexOf(document2) < 0) {
      injectStyle(document2, defaultTooltipCss);
      _Tooltip.tooltipDocuments.push(document2);
    }
  }
  destroy() {
    const { parentNode } = this.element;
    if (parentNode) {
      parentNode.removeChild(this.element);
    }
    if (this.observer) {
      this.observer.unobserve(this.canvasElement);
    }
  }
  isVisible() {
    const { element: element2 } = this;
    return !element2.classList.contains(DEFAULT_TOOLTIP_CLASS + "-hidden");
  }
  updateClass(visible, showArrow, addCustomClass = true) {
    const { element: element2, class: newClass, lastClass, enableInteraction, lastVisibilityChange } = this;
    const wasVisible = this.isVisible();
    const nowVisible = !!visible;
    let timeSinceLastVisibilityChangeMs = Infinity;
    if (wasVisible !== nowVisible) {
      const now = Date.now();
      timeSinceLastVisibilityChangeMs = now - lastVisibilityChange;
      this.lastVisibilityChange = now;
    }
    const toggleClass = (name, include) => {
      const className = `${DEFAULT_TOOLTIP_CLASS}-${name}`;
      if (include) {
        element2.classList.add(className);
      } else {
        element2.classList.remove(className);
      }
    };
    const animatedMoveThresholdMs = 100;
    const thrashingThresholdMs = 5;
    const noAnimation = !wasVisible && nowVisible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;
    if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {
      toggleClass("no-animation", noAnimation);
    }
    toggleClass("no-interaction", !enableInteraction);
    toggleClass("hidden", !visible);
    toggleClass("arrow", !!showArrow);
    element2.classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);
    this.updateWrapping();
    if (addCustomClass) {
      if (newClass !== lastClass) {
        if (lastClass) {
          element2.classList.remove(lastClass);
        }
        if (newClass) {
          element2.classList.add(newClass);
        }
      }
      this.lastClass = newClass;
    } else {
      if (lastClass) {
        element2.classList.remove(lastClass);
      }
      this.lastClass = void 0;
    }
  }
  updateWrapping() {
    const { element: element2, wrapping } = this;
    const wrappingOptions = {
      always: false,
      hyphenate: false,
      "on-space": false,
      never: false
    };
    wrappingOptions[wrapping] = true;
    Object.entries(wrappingOptions).forEach(([name, force]) => {
      element2.classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-wrap-${name}`, force);
    });
  }
  /**
   * Shows tooltip at the given event's coordinates.
   * If the `html` parameter is missing, moves the existing tooltip to the new position.
   */
  show(meta, html, instantly = false) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { element: element2, canvasElement } = this;
    if (html !== void 0) {
      element2.innerHTML = html;
    } else if (!element2.innerHTML) {
      this.toggle(false);
      return;
    }
    const xOffset = (_b = (_a = meta.position) == null ? void 0 : _a.xOffset) != null ? _b : 0;
    const yOffset = (_d = (_c = meta.position) == null ? void 0 : _c.yOffset) != null ? _d : 0;
    const canvasRect = canvasElement.getBoundingClientRect();
    const naiveLeft = canvasRect.left + meta.offsetX - element2.clientWidth / 2 + xOffset;
    const naiveTop = canvasRect.top + meta.offsetY - element2.clientHeight - 8 + yOffset;
    const windowBounds = this.getWindowBoundingBox();
    const maxLeft = windowBounds.x + windowBounds.width - element2.clientWidth - 1;
    const maxTop = windowBounds.y + windowBounds.height - element2.clientHeight;
    const left = clamp(windowBounds.x, naiveLeft, maxLeft);
    const top = clamp(windowBounds.y, naiveTop, maxTop);
    const constrained = left !== naiveLeft || top !== naiveTop;
    const defaultShowArrow = !constrained && !xOffset && !yOffset;
    const showArrow = (_f = (_e = meta.showArrow) != null ? _e : this.showArrow) != null ? _f : defaultShowArrow;
    this.updateShowArrow(showArrow);
    element2.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;
    this.enableInteraction = (_g = meta.enableInteraction) != null ? _g : false;
    if (this.delay > 0 && !instantly) {
      this.toggle(false);
      this.showTimeout = this.window.setTimeout(() => {
        this.toggle(true, meta.addCustomClass);
      }, this.delay);
      return;
    }
    this.toggle(true, meta.addCustomClass);
  }
  getWindowBoundingBox() {
    return new BBox(0, 0, this.window.innerWidth, this.window.innerHeight);
  }
  toggle(visible, addCustomClass) {
    if (!visible) {
      this.window.clearTimeout(this.showTimeout);
    }
    this.updateClass(visible, this._showArrow, addCustomClass);
  }
  pointerLeftOntoTooltip(event) {
    var _a;
    if (!this.enableInteraction)
      return false;
    const classList = (_a = event.sourceEvent.relatedTarget) == null ? void 0 : _a.classList;
    const classes = ["", "-title", "-content"];
    const classListContains = Boolean(classes.filter((c) => classList == null ? void 0 : classList.contains(`${DEFAULT_TOOLTIP_CLASS}${c}`)));
    return classList !== void 0 && classListContains;
  }
  updateShowArrow(show) {
    this._showArrow = show;
  }
};
_Tooltip.tooltipDocuments = [];
__decorateClass([
  Validate(BOOLEAN)
], _Tooltip.prototype, "enabled", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], _Tooltip.prototype, "showArrow", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], _Tooltip.prototype, "class", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], _Tooltip.prototype, "delay", 2);
__decorateClass([
  Validate(INTERACTION_RANGE)
], _Tooltip.prototype, "range", 2);
__decorateClass([
  Validate(TEXT_WRAP)
], _Tooltip.prototype, "wrapping", 2);
__decorateClass([
  Validate(BOOLEAN)
], _Tooltip.prototype, "darkTheme", 2);
var Tooltip = _Tooltip;

// packages/ag-charts-community/src/chart/caption.ts
var Caption = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.id = createId(this);
    this.node = new Text().setProperties({
      textAlign: "center",
      pointerEvents: 1 /* None */
    });
    this.enabled = false;
    this.textAlign = "center";
    this.fontSize = 10;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
    this.truncated = false;
  }
  registerInteraction(moduleCtx) {
    return moduleCtx.interactionManager.addListener("hover", (event) => this.handleMouseMove(moduleCtx, event));
  }
  computeTextWrap(containerWidth, containerHeight) {
    var _a, _b;
    const { text, wrapping } = this;
    const maxWidth = Math.min((_a = this.maxWidth) != null ? _a : Infinity, containerWidth);
    const maxHeight = (_b = this.maxHeight) != null ? _b : containerHeight;
    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {
      this.node.text = text;
      return;
    }
    const { text: wrappedText, truncated } = Text.wrap(text != null ? text : "", maxWidth, maxHeight, this, wrapping);
    this.node.text = wrappedText;
    this.truncated = truncated;
  }
  handleMouseMove(moduleCtx, event) {
    if (!this.enabled) {
      return;
    }
    const { offsetX, offsetY } = event;
    const bbox = this.node.computeBBox();
    const pointerInsideCaption = this.node.visible && bbox.containsPoint(offsetX, offsetY);
    if (pointerInsideCaption) {
      event.consume();
    }
    if (!this.truncated || !pointerInsideCaption) {
      moduleCtx.tooltipManager.removeTooltip(this.id);
    } else {
      moduleCtx.tooltipManager.updateTooltip(
        this.id,
        { offsetX, offsetY, lastPointerEvent: event, showArrow: false, addCustomClass: false },
        toTooltipHtml({ content: this.text })
      );
    }
  }
};
Caption.SMALL_PADDING = 10;
Caption.LARGE_PADDING = 20;
__decorateClass([
  Validate(BOOLEAN)
], Caption.prototype, "enabled", 2);
__decorateClass([
  Validate(STRING, { optional: true }),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "text", 2);
__decorateClass([
  Validate(TEXT_ALIGN, { optional: true }),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "textAlign", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true }),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT2, { optional: true }),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING),
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontFamily", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true }),
  ProxyPropertyOnWrite("node", "fill")
], Caption.prototype, "color", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Caption.prototype, "spacing", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Caption.prototype, "lineHeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Caption.prototype, "maxWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Caption.prototype, "maxHeight", 2);
__decorateClass([
  Validate(TEXT_WRAP)
], Caption.prototype, "wrapping", 2);

// packages/ag-charts-community/src/chart/axis/axisTitle.ts
var AxisTitle = class {
  constructor() {
    this.enabled = false;
    this.spacing = Caption.SMALL_PADDING;
    this.fontSize = 10;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisTitle.prototype, "enabled", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], AxisTitle.prototype, "text", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], AxisTitle.prototype, "spacing", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], AxisTitle.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT2, { optional: true })
], AxisTitle.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisTitle.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], AxisTitle.prototype, "fontFamily", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], AxisTitle.prototype, "color", 2);
__decorateClass([
  Validate(TEXT_WRAP)
], AxisTitle.prototype, "wrapping", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], AxisTitle.prototype, "formatter", 2);

// packages/ag-charts-community/src/chart/chartOptions.ts
var JSON_APPLY_PLUGINS = {
  constructedArrays: /* @__PURE__ */ new WeakMap()
};
function assignJsonApplyConstructedArray(array, ctor) {
  var _a;
  (_a = JSON_APPLY_PLUGINS.constructedArrays) == null ? void 0 : _a.set(array, ctor);
}
var JSON_APPLY_OPTIONS = {
  constructors: {
    "axes[].title": AxisTitle
  },
  allowedTypes: {
    "legend.pagination.marker.shape": ["primitive", "function"],
    "axis[].tick.count": ["primitive", "class-instance"]
  }
};

// packages/ag-charts-community/src/scale/continuousScale.ts
var _ContinuousScale = class _ContinuousScale {
  constructor(domain, range3) {
    this.invalid = true;
    this.nice = false;
    this.interval = void 0;
    this.tickCount = _ContinuousScale.defaultTickCount;
    this.minTickCount = 0;
    this.maxTickCount = Infinity;
    this.niceDomain = [];
    this.defaultClampMode = "raw";
    this.domain = domain;
    this.range = range3;
  }
  static is(value) {
    return value instanceof _ContinuousScale;
  }
  transform(x) {
    return x;
  }
  transformInvert(x) {
    return x;
  }
  calcBandwidth(smallestInterval = 1) {
    const { range: range3 } = this;
    const domain = this.getDomain();
    const rangeDistance = Math.abs(range3[1] - range3[0]);
    const intervals = Math.abs(domain[1] - domain[0]) / smallestInterval + 1;
    const maxBands = Math.floor(rangeDistance);
    const bands = Math.min(intervals, maxBands);
    return rangeDistance / Math.max(1, bands);
  }
  fromDomain(d) {
    if (typeof d === "number") {
      return d;
    } else if (d instanceof Date) {
      return d.getTime();
    }
    return NaN;
  }
  getDomain() {
    if (this.nice) {
      this.refresh();
      if (this.niceDomain.length) {
        return this.niceDomain;
      }
    }
    return this.domain;
  }
  convert(x, opts) {
    var _a;
    const clampMode = (_a = opts == null ? void 0 : opts.clampMode) != null ? _a : this.defaultClampMode;
    if (!this.domain || this.domain.length < 2) {
      return NaN;
    }
    this.refresh();
    const domain = this.getDomain().map((d) => this.transform(d));
    const [d0, d1] = domain;
    const { range: range3 } = this;
    const [r0, r1] = range3;
    x = this.transform(x);
    if (clampMode === "clamped") {
      const start = Math.min(this.fromDomain(d0), this.fromDomain(d1));
      const stop = Math.max(this.fromDomain(d0), this.fromDomain(d1));
      if (this.fromDomain(x) < start) {
        return r0;
      } else if (this.fromDomain(x) > stop) {
        return r1;
      }
    }
    if (d0 === d1) {
      return (r0 + r1) / 2;
    } else if (x === d0) {
      return r0;
    } else if (x === d1) {
      return r1;
    }
    return r0 + (this.fromDomain(x) - this.fromDomain(d0)) / (this.fromDomain(d1) - this.fromDomain(d0)) * (r1 - r0);
  }
  invert(x) {
    this.refresh();
    const domain = this.getDomain().map((d2) => this.transform(d2));
    const [d0, d1] = domain;
    const { range: range3 } = this;
    const [r0, r1] = range3;
    const isReversed = r0 > r1;
    const rMin = isReversed ? r1 : r0;
    const rMax = isReversed ? r0 : r1;
    let d;
    if (x < rMin) {
      return isReversed ? d1 : d0;
    } else if (x > rMax) {
      return isReversed ? d0 : d1;
    } else if (r0 === r1) {
      d = this.toDomain((this.fromDomain(d0) + this.fromDomain(d1)) / 2);
    } else {
      d = this.toDomain(
        this.fromDomain(d0) + (x - r0) / (r1 - r0) * (this.fromDomain(d1) - this.fromDomain(d0))
      );
    }
    return this.transformInvert(d);
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      Logger.warnOnce("Expected update to not invalidate scale");
    }
  }
  getPixelRange() {
    const range3 = this.range.slice().sort((a, b) => a - b);
    return range3[1] - range3[0];
  }
  isDenseInterval({
    start,
    stop,
    interval,
    count: count2
  }) {
    const domain = stop - start;
    const availableRange = this.getPixelRange();
    const step = typeof interval === "number" ? interval : 1;
    count2 != null ? count2 : count2 = domain / step;
    if (count2 >= availableRange) {
      Logger.warn(
        `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`
      );
      return true;
    }
    return false;
  }
};
_ContinuousScale.defaultTickCount = 5;
_ContinuousScale.defaultMaxTickCount = 6;
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "domain", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "range", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "nice", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "interval", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "tickCount", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "minTickCount", 2);
__decorateClass([
  Invalidating
], _ContinuousScale.prototype, "maxTickCount", 2);
var ContinuousScale = _ContinuousScale;

// packages/ag-charts-community/src/util/compare.ts
function ascendingStringNumberUndefined(a, b) {
  let diff2 = 0;
  if (typeof a === "number" && typeof b === "number") {
    diff2 = a - b;
  } else if (typeof a === "string" && typeof b === "string") {
    diff2 = a.localeCompare(b);
  } else if (a == null && b == null) ; else if (a == null) {
    diff2 = -1;
  } else if (b == null) {
    diff2 = 1;
  } else {
    diff2 = String(a).localeCompare(String(b));
  }
  return diff2;
}
function compoundAscending(a, b, comparator) {
  const toLiteral = (v) => {
    if (typeof v === "function") {
      return v();
    }
    return v;
  };
  for (const idx in a) {
    const diff2 = comparator(toLiteral(a[idx]), toLiteral(b[idx]));
    if (diff2 !== 0) {
      return diff2;
    }
  }
  return 0;
}

// packages/ag-charts-community/src/scene/group.ts
var _Group = class _Group extends Node {
  constructor(opts) {
    var _a;
    super({ isVirtual: opts == null ? void 0 : opts.isVirtual });
    this.opts = opts;
    this.opacity = 1;
    this.lastBBox = void 0;
    const { zIndex, zIndexSubOrder } = opts != null ? opts : {};
    this.isContainerNode = true;
    if (zIndex !== void 0) {
      this.zIndex = zIndex;
    }
    if (zIndexSubOrder !== void 0) {
      this.zIndexSubOrder = zIndexSubOrder;
    }
    this.name = (_a = this.opts) == null ? void 0 : _a.name;
  }
  zIndexChanged() {
    var _a;
    if (this.layer) {
      (_a = this._layerManager) == null ? void 0 : _a.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);
    }
  }
  isLayer() {
    return this.layer != null;
  }
  _setLayerManager(scene) {
    var _a, _b;
    if (this._layerManager && this.layer) {
      this._layerManager.removeLayer(this.layer);
      this.layer = void 0;
    }
    if (this.layer) {
      throw new Error("AG Charts - unable to deregister scene rendering layer!");
    }
    super._setLayerManager(scene);
    if (scene && ((_a = this.opts) == null ? void 0 : _a.layer)) {
      const { zIndex, zIndexSubOrder, name } = (_b = this.opts) != null ? _b : {};
      const getComputedOpacity = () => this.getComputedOpacity();
      const getVisibility = () => this.getVisibility();
      this.layer = scene.addLayer({
        zIndex,
        zIndexSubOrder,
        name,
        getComputedOpacity,
        getVisibility
      });
    }
  }
  getComputedOpacity() {
    let opacity = 1;
    let node = this;
    do {
      if (node instanceof _Group) {
        opacity *= node.opacity;
      }
    } while (node = node.parent);
    return opacity;
  }
  getVisibility() {
    let node = this;
    let visible = this.visible;
    while (node = node.parent) {
      if (node.visible) {
        continue;
      }
      visible = node.visible;
    }
    return visible;
  }
  visibilityChanged() {
    if (this.layer) {
      this.layer.enabled = this.visible;
    }
  }
  markDirty(source, type = 1 /* TRIVIAL */) {
    if (this.isVirtual) {
      super.markDirty(source, type);
      return;
    }
    let parentType = type;
    if (type < 2 /* MINOR */ || this.layer != null) {
      parentType = 1 /* TRIVIAL */;
    }
    super.markDirty(source, type, parentType);
  }
  // We consider a group to be boundless, thus any point belongs to it.
  containsPoint(_x, _y) {
    return true;
  }
  computeBBox() {
    this.computeTransformMatrix();
    return _Group.computeBBox(this.children);
  }
  computeTransformedBBox() {
    return this.computeBBox();
  }
  render(renderCtx) {
    var _a, _b;
    const { opts: { name = void 0 } = {}, _debug: debug3 = () => {
    } } = this;
    const { dirty, dirtyZIndex, layer, children, clipRect, dirtyTransform } = this;
    let { ctx, forceRender, clipBBox } = renderCtx;
    const { resized, stats } = renderCtx;
    const canvasCtxTransform = ctx.getTransform();
    const isDirty = dirty >= 2 /* MINOR */ || dirtyZIndex || resized;
    let isChildDirty = isDirty;
    let isChildLayerDirty = false;
    for (const child of children) {
      isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= 1 /* TRIVIAL */);
      isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= 1 /* TRIVIAL */);
      if (isChildDirty) {
        break;
      }
    }
    if (name) {
      debug3({ name, group: this, isDirty, isChildDirty, dirtyTransform, renderCtx, forceRender });
    }
    if (dirtyTransform) {
      forceRender = "dirtyTransform";
    } else if (layer) {
      const currentBBox = this.computeBBox();
      if (this.lastBBox === void 0 || !this.lastBBox.equals(currentBBox)) {
        forceRender = "dirtyTransform";
        this.lastBBox = currentBBox;
      }
    }
    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {
      if (name && stats) {
        debug3({ name, result: "skipping", renderCtx, counts: this.nodeCount, group: this });
      }
      if (layer && stats) {
        stats.layersSkipped++;
        stats.nodesSkipped += this.nodeCount.count;
      }
      this.markClean({ recursive: false });
      return;
    }
    const groupVisible = this.visible;
    if (layer) {
      ctx = layer.context;
      ctx.save();
      ctx.resetTransform();
      if (forceRender !== "dirtyTransform") {
        forceRender = isChildDirty || dirtyZIndex;
      }
      if (forceRender)
        layer.clear();
      if (clipBBox) {
        const { width, height, x, y } = clipBBox;
        debug3(() => ({
          name,
          clipBBox,
          ctxTransform: ctx.getTransform(),
          renderCtx,
          group: this
        }));
        this.clipCtx(ctx, x, y, width, height);
      }
      ctx.setTransform(canvasCtxTransform);
    } else {
      ctx.globalAlpha *= this.opacity;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    if (clipRect) {
      const { x, y, width, height } = clipRect;
      ctx.save();
      debug3(() => ({ name, clipRect, ctxTransform: ctx.getTransform(), renderCtx, group: this }));
      this.clipCtx(ctx, x, y, width, height);
      clipBBox = this.matrix.transformBBox(clipRect);
    }
    const hasVirtualChildren = this.hasVirtualChildren();
    if (dirtyZIndex) {
      this.sortChildren(children);
      if (forceRender !== "dirtyTransform")
        forceRender = true;
    } else if (hasVirtualChildren) {
      this.sortChildren(children);
    }
    const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;
    const childRenderContext = renderContextChanged ? __spreadProps(__spreadValues({}, renderCtx), { ctx, forceRender, clipBBox }) : renderCtx;
    let skipped = 0;
    for (const child of children) {
      if (!child.visible || !groupVisible) {
        child.markClean();
        if (stats)
          skipped += child.nodeCount.count;
        continue;
      }
      if (!forceRender && child.dirty === 0 /* NONE */) {
        if (stats)
          skipped += child.nodeCount.count;
        continue;
      }
      ctx.save();
      child.render(childRenderContext);
      ctx.restore();
    }
    if (stats)
      stats.nodesSkipped += skipped;
    super.render(renderCtx);
    if (clipRect) {
      ctx.restore();
    }
    if (hasVirtualChildren) {
      for (const child of this.virtualChildren) {
        child.markClean({ recursive: "virtual" });
      }
    }
    if (layer) {
      if (stats)
        stats.layersRendered++;
      ctx.restore();
      if (forceRender)
        layer.snapshot();
      (_b = (_a = layer.context).verifyDepthZero) == null ? void 0 : _b.call(_a);
    }
    if (name && stats) {
      debug3({ name, result: "rendered", skipped, renderCtx, counts: this.nodeCount, group: this });
    }
  }
  sortChildren(children) {
    this.dirtyZIndex = false;
    children.sort((a, b) => {
      var _a, _b;
      return compoundAscending(
        [a.zIndex, ...(_a = a.zIndexSubOrder) != null ? _a : [void 0, void 0], a.serialNumber],
        [b.zIndex, ...(_b = b.zIndexSubOrder) != null ? _b : [void 0, void 0], b.serialNumber],
        ascendingStringNumberUndefined
      );
    });
  }
  clipCtx(ctx, x, y, width, height) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + width, y);
    ctx.lineTo(x + width, y + height);
    ctx.lineTo(x, y + height);
    ctx.closePath();
    ctx.clip();
  }
  static computeBBox(nodes) {
    let left = Infinity;
    let right = -Infinity;
    let top = Infinity;
    let bottom = -Infinity;
    nodes.forEach((n) => {
      if (!n.visible) {
        return;
      }
      const bbox = n.computeTransformedBBox();
      if (!bbox) {
        return;
      }
      const x = bbox.x;
      const y = bbox.y;
      if (x < left) {
        left = x;
      }
      if (y < top) {
        top = y;
      }
      if (x + bbox.width > right) {
        right = x + bbox.width;
      }
      if (y + bbox.height > bottom) {
        bottom = y + bbox.height;
      }
    });
    return new BBox(left, top, right - left, bottom - top);
  }
  /**
   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and
   * sets this group's clipRect to the transformed bbox.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRectInGroupCoordinateSpace(bbox) {
    this.clipRect = bbox ? this.transformBBox(bbox) : void 0;
  }
};
_Group.className = "Group";
__decorateClass([
  SceneChangeDetection({
    redraw: 3 /* MAJOR */,
    convertor: (v) => clamp(0, v, 1)
  })
], _Group.prototype, "opacity", 2);
var Group = _Group;

// packages/ag-charts-community/src/scene/shape/range.ts
var Range = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.startLine = false;
    this.endLine = false;
    this.isRange = false;
    this.restoreOwnStyles();
  }
  computeBBox() {
    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
  }
  isPointInPath(_x, _y) {
    return false;
  }
  render(renderCtx) {
    var _a;
    const { ctx, forceRender, stats } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    let { x1, y1, x2, y2 } = this;
    x1 = this.align(x1);
    y1 = this.align(y1);
    x2 = this.align(x2);
    y2 = this.align(y2);
    const { fill, opacity, isRange } = this;
    const fillActive = !!(isRange && fill);
    if (fillActive) {
      const { fillOpacity } = this;
      ctx.fillStyle = fill;
      ctx.globalAlpha = opacity * fillOpacity;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x1, y2);
      ctx.closePath();
      ctx.fill();
    }
    const { stroke, strokeWidth, startLine, endLine } = this;
    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);
    if (strokeActive) {
      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;
      ctx.strokeStyle = stroke;
      ctx.globalAlpha = opacity * strokeOpacity;
      ctx.lineWidth = strokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.beginPath();
      if (startLine) {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
      }
      if (endLine) {
        ctx.moveTo(x2, y2);
        ctx.lineTo(x1, y2);
      }
      ctx.stroke();
    }
    (_a = this.fillShadow) == null ? void 0 : _a.markClean();
    super.render(renderCtx);
  }
};
Range.className = "Range";
Range.defaultStyles = __spreadProps(__spreadValues({}, Shape.defaultStyles), {
  strokeWidth: 1
});
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "y2", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "startLine", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "endLine", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 2 /* MINOR */ })
], Range.prototype, "isRange", 2);

// packages/ag-charts-community/src/chart/label.ts
var Label = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.color = "#464646";
    this.fontSize = 12;
    this.fontFamily = "Verdana, sans-serif";
  }
  getFont() {
    return getFont(this);
  }
};
__decorateClass([
  Validate(BOOLEAN)
], Label.prototype, "enabled", 2);
__decorateClass([
  Validate(COLOR_STRING)
], Label.prototype, "color", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], Label.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT2, { optional: true })
], Label.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Label.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], Label.prototype, "fontFamily", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], Label.prototype, "formatter", 2);
function calculateLabelRotation(opts) {
  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;
  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;
  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;
  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;
  let defaultRotation = 0;
  if (opts.parallel) {
    defaultRotation = parallelFlipFlag * Math.PI / 2;
  } else if (regularFlipFlag === -1) {
    defaultRotation = Math.PI;
  }
  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };
}
function getLabelSpacing(minSpacing, rotated) {
  if (!isNaN(minSpacing)) {
    return minSpacing;
  }
  return rotated ? 0 : 10;
}
function getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {
  if (parallel && !labelRotation) {
    return sideFlag * parallelFlipFlag === -1 ? "hanging" : "bottom";
  }
  return "middle";
}
function getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {
  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;
  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;
  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;
  if (parallel) {
    if (labelRotation || labelAutoRotation) {
      if (sideFlag * alignFlag === -1) {
        return "end";
      }
    } else {
      return "center";
    }
  } else if (sideFlag * regularFlipFlag === -1) {
    return "end";
  }
  return "start";
}
function calculateLabelBBox(text, bbox, labelX, labelY, labelMatrix) {
  const { width, height } = bbox;
  const translatedBBox = new BBox(labelX, labelY, 0, 0);
  labelMatrix.transformBBox(translatedBBox, bbox);
  const { x = 0, y = 0 } = bbox;
  bbox.width = width;
  bbox.height = height;
  return {
    point: { x, y, size: 0 },
    label: { width, height, text }
  };
}

// packages/ag-charts-community/src/chart/layers.ts
var Layers = /* @__PURE__ */ ((Layers2) => {
  Layers2[Layers2["SERIES_BACKGROUND_ZINDEX"] = 0] = "SERIES_BACKGROUND_ZINDEX";
  Layers2[Layers2["AXIS_GRID_ZINDEX"] = 1] = "AXIS_GRID_ZINDEX";
  Layers2[Layers2["AXIS_ZINDEX"] = 2] = "AXIS_ZINDEX";
  Layers2[Layers2["SERIES_CROSSLINE_RANGE_ZINDEX"] = 3] = "SERIES_CROSSLINE_RANGE_ZINDEX";
  Layers2[Layers2["SERIES_LAYER_ZINDEX"] = 4] = "SERIES_LAYER_ZINDEX";
  Layers2[Layers2["AXIS_FOREGROUND_ZINDEX"] = 5] = "AXIS_FOREGROUND_ZINDEX";
  Layers2[Layers2["SERIES_CROSSHAIR_ZINDEX"] = 6] = "SERIES_CROSSHAIR_ZINDEX";
  Layers2[Layers2["SERIES_LABEL_ZINDEX"] = 7] = "SERIES_LABEL_ZINDEX";
  Layers2[Layers2["SERIES_CROSSLINE_LINE_ZINDEX"] = 8] = "SERIES_CROSSLINE_LINE_ZINDEX";
  Layers2[Layers2["LEGEND_ZINDEX"] = 9] = "LEGEND_ZINDEX";
  return Layers2;
})(Layers || {});

// packages/ag-charts-community/src/util/value.ts
var isStringObject = (value) => !!value && Object.hasOwn(value, "toString") && isString(value.toString());
var isNumberObject = (value) => !!value && Object.hasOwn(value, "valueOf") && isFiniteNumber(value.valueOf());
var isContinuous = (value) => isFiniteNumber(value) || isNumberObject(value) || isValidDate(value);
function checkDatum(value, isContinuousScale) {
  if (isContinuousScale && isContinuous(value)) {
    return value;
  } else if (!isContinuousScale) {
    return isString(value) || isStringObject(value) ? value : String(value);
  }
}
function transformIntegratedCategoryValue(value) {
  if (isStringObject(value) && Object.hasOwn(value, "id")) {
    return value.id;
  }
  return value;
}

// packages/ag-charts-community/src/chart/crossline/crossLine.ts
var MATCHING_CROSSLINE_TYPE = (property) => {
  return property === "value" ? predicateWithMessage(
    (_, ctx) => ctx.target["type"] === "line",
    (ctx) => ctx.target["type"] === "range" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`
  ) : predicateWithMessage(
    (_, ctx) => ctx.target["type"] === "range",
    (ctx) => ctx.target.type === "line" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`
  );
};
var validateCrossLineValues = (type, value, range3, scale2) => {
  const lineCrossLine = type === "line" && value !== void 0;
  const rangeCrossLine = type === "range" && range3 !== void 0;
  if (!lineCrossLine && !rangeCrossLine) {
    return true;
  }
  const [start, end] = range3 != null ? range3 : [value, void 0];
  const isContinuous2 = ContinuousScale.is(scale2);
  const validStart = checkDatum(start, isContinuous2) != null && !isNaN(scale2.convert(start));
  const validEnd = checkDatum(end, isContinuous2) != null && !isNaN(scale2.convert(end));
  if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {
    return true;
  }
  const message = [`Expecting crossLine`];
  if (rangeCrossLine) {
    if (!validStart) {
      message.push(`range start ${stringify(start)}`);
    }
    if (!validEnd) {
      message.push(`${!validStart ? "and " : ""}range end ${stringify(end)}`);
    }
  } else {
    message.push(`value ${stringify(start)}`);
  }
  message.push(`to match the axis scale domain.`);
  Logger.warnOnce(message.join(" "));
  return false;
};

// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts
var horizontalCrosslineTranslationDirections = {
  top: { xTranslationDirection: 0, yTranslationDirection: -1 },
  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },
  left: { xTranslationDirection: -1, yTranslationDirection: 0 },
  right: { xTranslationDirection: 1, yTranslationDirection: 0 },
  topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
  topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },
  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
  bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
  insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },
  insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },
  insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },
  insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },
  insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
  insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }
};
var verticalCrossLineTranslationDirections = {
  top: { xTranslationDirection: 1, yTranslationDirection: 0 },
  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },
  left: { xTranslationDirection: 0, yTranslationDirection: -1 },
  right: { xTranslationDirection: 0, yTranslationDirection: 1 },
  topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },
  topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
  bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },
  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
  insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },
  insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },
  insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },
  insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },
  insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },
  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },
  insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }
};
function calculateLabelTranslation({
  yDirection,
  padding = 0,
  position = "top",
  bbox
}) {
  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;
  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];
  const w = yDirection ? bbox.width : bbox.height;
  const h = yDirection ? bbox.height : bbox.width;
  const xTranslation = xTranslationDirection * (padding + w / 2);
  const yTranslation = yTranslationDirection * (padding + h / 2);
  return {
    xTranslation,
    yTranslation
  };
}
function calculateLabelChartPadding({
  yDirection,
  bbox,
  padding = 0,
  position = "top"
}) {
  const chartPadding = {};
  if (position.startsWith("inside"))
    return chartPadding;
  if (position === "top" && !yDirection) {
    chartPadding.top = padding + bbox.height;
  } else if (position === "bottom" && !yDirection) {
    chartPadding.bottom = padding + bbox.height;
  } else if (position === "left" && yDirection) {
    chartPadding.left = padding + bbox.width;
  } else if (position === "right" && yDirection) {
    chartPadding.right = padding + bbox.width;
  }
  return chartPadding;
}
var POSITION_TOP_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {
  if (yDirection) {
    return { x: xEnd / 2, y: yStart };
  } else {
    return { x: xEnd, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };
  }
};
var POSITION_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {
  if (yDirection) {
    return { x: xStart, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };
  } else {
    return { x: xEnd / 2, y: yStart };
  }
};
var POSITION_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {
  if (yDirection) {
    return { x: xEnd, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };
  } else {
    return { x: xEnd / 2, y: !isNaN(yEnd) ? yEnd : yStart };
  }
};
var POSITION_BOTTOM_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {
  if (yDirection) {
    return { x: xEnd / 2, y: !isNaN(yEnd) ? yEnd : yStart };
  } else {
    return { x: xStart, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };
  }
};
var POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {
  return { x: xEnd / 2, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };
};
var POSITION_TOP_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart }) => {
  if (yDirection) {
    return { x: xStart / 2, y: yStart };
  } else {
    return { x: xEnd, y: yStart };
  }
};
var POSITION_BOTTOM_LEFT_COORDINATES = ({ yDirection, xStart, yStart, yEnd }) => {
  if (yDirection) {
    return { x: xStart, y: !isNaN(yEnd) ? yEnd : yStart };
  } else {
    return { x: xStart, y: yStart };
  }
};
var POSITION_TOP_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {
  if (yDirection) {
    return { x: xEnd, y: yStart };
  } else {
    return { x: xEnd, y: !isNaN(yEnd) ? yEnd : yStart };
  }
};
var POSITION_BOTTOM_RIGHT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {
  if (yDirection) {
    return { x: xEnd, y: !isNaN(yEnd) ? yEnd : yStart };
  } else {
    return { x: xStart, y: !isNaN(yEnd) ? yEnd : yStart };
  }
};
var labelDirectionHandling = {
  top: { c: POSITION_TOP_COORDINATES },
  bottom: { c: POSITION_BOTTOM_COORDINATES },
  left: { c: POSITION_LEFT_COORDINATES },
  right: { c: POSITION_RIGHT_COORDINATES },
  topLeft: { c: POSITION_TOP_LEFT_COORDINATES },
  topRight: { c: POSITION_TOP_RIGHT_COORDINATES },
  bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },
  bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },
  inside: { c: POSITION_INSIDE_COORDINATES },
  insideLeft: { c: POSITION_LEFT_COORDINATES },
  insideRight: { c: POSITION_RIGHT_COORDINATES },
  insideTop: { c: POSITION_TOP_COORDINATES },
  insideBottom: { c: POSITION_BOTTOM_COORDINATES },
  insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },
  insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },
  insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },
  insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES }
};

// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts
var CROSSLINE_LABEL_POSITION = UNION(
  [
    "top",
    "left",
    "right",
    "bottom",
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight",
    "inside",
    "insideLeft",
    "insideRight",
    "insideTop",
    "insideBottom",
    "insideTopLeft",
    "insideBottomLeft",
    "insideTopRight",
    "insideBottomRight"
  ],
  "crossLine label position"
);
var CartesianCrossLineLabel = class {
  constructor() {
    this.enabled = void 0;
    this.text = void 0;
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 14;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.color = "rgba(87, 87, 87, 1)";
    this.position = void 0;
    this.rotation = void 0;
    this.parallel = void 0;
  }
};
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], CartesianCrossLineLabel.prototype, "enabled", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], CartesianCrossLineLabel.prototype, "text", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], CartesianCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT2, { optional: true })
], CartesianCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], CartesianCrossLineLabel.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], CartesianCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass([
  Validate(NUMBER)
], CartesianCrossLineLabel.prototype, "padding", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], CartesianCrossLineLabel.prototype, "color", 2);
__decorateClass([
  Validate(CROSSLINE_LABEL_POSITION, { optional: true })
], CartesianCrossLineLabel.prototype, "position", 2);
__decorateClass([
  Validate(DEGREE, { optional: true })
], CartesianCrossLineLabel.prototype, "rotation", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], CartesianCrossLineLabel.prototype, "parallel", 2);
var _CartesianCrossLine = class _CartesianCrossLine {
  constructor() {
    this.id = createId(this);
    this.enabled = void 0;
    this.type = void 0;
    this.range = void 0;
    this.value = void 0;
    this.fill = void 0;
    this.fillOpacity = void 0;
    this.stroke = void 0;
    this.strokeWidth = void 0;
    this.strokeOpacity = void 0;
    this.lineDash = void 0;
    this.label = new CartesianCrossLineLabel();
    this.scale = void 0;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.sideFlag = -1;
    this.parallelFlipRotation = 0;
    this.regularFlipRotation = 0;
    this.direction = "x" /* X */;
    this.group = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LINE_LAYER_ZINDEX });
    this.labelGroup = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LABEL_LAYER_ZINDEX });
    this.crossLineRange = new Range();
    this.crossLineLabel = new Text();
    this.labelPoint = void 0;
    this.data = [];
    this.startLine = false;
    this.endLine = false;
    this.isRange = false;
    const { group: group2, labelGroup, crossLineRange, crossLineLabel } = this;
    group2.append(crossLineRange);
    labelGroup.append(crossLineLabel);
    crossLineRange.pointerEvents = 1 /* None */;
  }
  update(visible) {
    const { enabled, data, type, value, range: range3, scale: scale2 } = this;
    if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range3, scale2) || data.length === 0) {
      this.group.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.group.visible = visible;
    this.labelGroup.visible = visible;
    this.group.zIndex = this.getZIndex(this.isRange);
    this.updateNodes();
  }
  calculateLayout(visible, reversedAxis) {
    if (!visible) {
      return;
    }
    const dataCreated = this.createNodeData(reversedAxis);
    if (!dataCreated) {
      return;
    }
    const { sideFlag, gridLength, data } = this;
    const boxes = [];
    const x1 = 0;
    const x2 = sideFlag * gridLength;
    const y1 = data[0];
    const y2 = data[1];
    const crossLineBox = new BBox(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
    boxes.push(crossLineBox);
    const labelBox = this.computeLabelBBox();
    if (labelBox) {
      boxes.push(labelBox);
    }
    return BBox.merge(boxes);
  }
  updateNodes() {
    this.updateRangeNode();
    if (this.label.enabled) {
      this.updateLabel();
      this.positionLabel();
    }
  }
  createNodeData(reversedAxis) {
    var _a, _b, _c;
    const {
      scale: scale2,
      gridLength,
      sideFlag,
      direction,
      label: { position = "top" },
      clippedRange,
      strokeWidth = 0
    } = this;
    this.data = [];
    if (!scale2) {
      return false;
    }
    const bandwidth = (_a = scale2.bandwidth) != null ? _a : 0;
    const step = (_b = scale2.step) != null ? _b : 0;
    const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);
    const [xStart, xEnd] = [0, sideFlag * gridLength];
    let [yStart, yEnd] = this.getRange();
    let [clampedYStart, clampedYEnd] = [
      Number(scale2.convert(yStart, { clampMode: "clamped" })) - padding,
      scale2.convert(yEnd, { clampMode: "clamped" }) + bandwidth + padding
    ];
    clampedYStart = clampArray(clampedYStart, clippedRange);
    clampedYEnd = clampArray(clampedYEnd, clippedRange);
    [yStart, yEnd] = [Number(scale2.convert(yStart)), scale2.convert(yEnd) + bandwidth];
    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;
    if (validRange && clampedYStart > clampedYEnd) {
      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];
      [yStart, yEnd] = [yEnd, yStart];
    }
    if (yStart - padding >= clampedYStart)
      yStart -= padding;
    if (yEnd + padding <= clampedYEnd)
      yEnd += padding;
    this.isRange = validRange;
    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;
    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;
    if (!validRange && !this.startLine && !this.endLine) {
      return false;
    }
    this.data = [clampedYStart, clampedYEnd];
    if (this.label.enabled) {
      const yDirection = direction === "y" /* Y */;
      const { c = POSITION_TOP_COORDINATES } = (_c = labelDirectionHandling[position]) != null ? _c : {};
      const { x: labelX, y: labelY } = c({
        yDirection,
        xStart,
        xEnd,
        yStart: clampedYStart,
        yEnd: clampedYEnd
      });
      this.labelPoint = {
        x: labelX,
        y: labelY
      };
    }
    return true;
  }
  updateRangeNode() {
    var _a;
    const {
      crossLineRange,
      sideFlag,
      gridLength,
      data,
      startLine,
      endLine,
      isRange,
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      lineDash
    } = this;
    crossLineRange.x1 = 0;
    crossLineRange.x2 = sideFlag * gridLength;
    crossLineRange.y1 = data[0];
    crossLineRange.y2 = data[1];
    crossLineRange.startLine = startLine;
    crossLineRange.endLine = endLine;
    crossLineRange.isRange = isRange;
    crossLineRange.fill = fill;
    crossLineRange.fillOpacity = fillOpacity != null ? fillOpacity : 1;
    crossLineRange.stroke = stroke;
    crossLineRange.strokeWidth = strokeWidth != null ? strokeWidth : 1;
    crossLineRange.strokeOpacity = (_a = this.strokeOpacity) != null ? _a : 1;
    crossLineRange.lineDash = lineDash;
  }
  updateLabel() {
    const { crossLineLabel, label } = this;
    if (!label.text) {
      return;
    }
    crossLineLabel.fontStyle = label.fontStyle;
    crossLineLabel.fontWeight = label.fontWeight;
    crossLineLabel.fontSize = label.fontSize;
    crossLineLabel.fontFamily = label.fontFamily;
    crossLineLabel.fill = label.color;
    crossLineLabel.text = label.text;
  }
  positionLabel() {
    const {
      crossLineLabel,
      labelPoint: { x = void 0, y = void 0 } = {},
      label: { parallel, rotation, position = "top", padding = 0 },
      direction,
      parallelFlipRotation,
      regularFlipRotation
    } = this;
    if (x === void 0 || y === void 0) {
      return;
    }
    const { defaultRotation, configuredRotation } = calculateLabelRotation({
      rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    });
    crossLineLabel.rotation = defaultRotation + configuredRotation;
    crossLineLabel.textBaseline = "middle";
    crossLineLabel.textAlign = "center";
    const bbox = crossLineLabel.computeTransformedBBox();
    if (!bbox) {
      return;
    }
    const yDirection = direction === "y" /* Y */;
    const { xTranslation, yTranslation } = calculateLabelTranslation({
      yDirection,
      padding,
      position,
      bbox
    });
    crossLineLabel.translationX = x + xTranslation;
    crossLineLabel.translationY = y + yTranslation;
  }
  getZIndex(isRange = false) {
    if (isRange) {
      return _CartesianCrossLine.RANGE_LAYER_ZINDEX;
    }
    return _CartesianCrossLine.LINE_LAYER_ZINDEX;
  }
  getRange() {
    var _a;
    const { value, range: range3, scale: scale2 } = this;
    const isContinuous2 = ContinuousScale.is(scale2);
    const start = (_a = range3 == null ? void 0 : range3[0]) != null ? _a : value;
    let end = range3 == null ? void 0 : range3[1];
    if (!isContinuous2 && end === void 0) {
      end = start;
    }
    if (isContinuous2 && start === end) {
      end = void 0;
    }
    return [start, end];
  }
  computeLabelBBox() {
    const { label } = this;
    if (!label.enabled) {
      return void 0;
    }
    const tempText = new Text();
    tempText.fontFamily = label.fontFamily;
    tempText.fontSize = label.fontSize;
    tempText.fontStyle = label.fontStyle;
    tempText.fontWeight = label.fontWeight;
    tempText.text = label.text;
    const {
      labelPoint: { x = void 0, y = void 0 } = {},
      label: { parallel, rotation, position = "top", padding = 0 },
      direction,
      parallelFlipRotation,
      regularFlipRotation
    } = this;
    if (x === void 0 || y === void 0) {
      return void 0;
    }
    const { configuredRotation } = calculateLabelRotation({
      rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    });
    tempText.rotation = configuredRotation;
    tempText.textBaseline = "middle";
    tempText.textAlign = "center";
    const bbox = tempText.computeTransformedBBox();
    if (!bbox) {
      return void 0;
    }
    const yDirection = direction === "y" /* Y */;
    const { xTranslation, yTranslation } = calculateLabelTranslation({
      yDirection,
      padding,
      position,
      bbox
    });
    tempText.translationX = x + xTranslation;
    tempText.translationY = y + yTranslation;
    return tempText.computeTransformedBBox();
  }
  calculatePadding(padding) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const {
      isRange,
      startLine,
      endLine,
      direction,
      label: { padding: labelPadding = 0, position = "top" }
    } = this;
    if (!isRange && !startLine && !endLine) {
      return;
    }
    const crossLineLabelBBox = this.computeLabelBBox();
    if ((crossLineLabelBBox == null ? void 0 : crossLineLabelBBox.x) == null || (crossLineLabelBBox == null ? void 0 : crossLineLabelBBox.y) == null) {
      return;
    }
    const chartPadding = calculateLabelChartPadding({
      yDirection: direction === "y" /* Y */,
      padding: labelPadding,
      position,
      bbox: crossLineLabelBBox
    });
    padding.left = Math.max((_a = padding.left) != null ? _a : 0, (_b = chartPadding.left) != null ? _b : 0);
    padding.right = Math.max((_c = padding.right) != null ? _c : 0, (_d = chartPadding.right) != null ? _d : 0);
    padding.top = Math.max((_e = padding.top) != null ? _e : 0, (_f = chartPadding.top) != null ? _f : 0);
    padding.bottom = Math.max((_g = padding.bottom) != null ? _g : 0, (_h = chartPadding.bottom) != null ? _h : 0);
  }
};
_CartesianCrossLine.LINE_LAYER_ZINDEX = 8 /* SERIES_CROSSLINE_LINE_ZINDEX */;
_CartesianCrossLine.RANGE_LAYER_ZINDEX = 3 /* SERIES_CROSSLINE_RANGE_ZINDEX */;
_CartesianCrossLine.LABEL_LAYER_ZINDEX = 7 /* SERIES_LABEL_ZINDEX */;
_CartesianCrossLine.className = "CrossLine";
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], _CartesianCrossLine.prototype, "enabled", 2);
__decorateClass([
  Validate(UNION(["range", "line"], "a crossLine type"), { optional: true })
], _CartesianCrossLine.prototype, "type", 2);
__decorateClass([
  Validate(AND(MATCHING_CROSSLINE_TYPE("range"), ARRAY.restrict({ length: 2 })), {
    optional: true
  })
], _CartesianCrossLine.prototype, "range", 2);
__decorateClass([
  Validate(MATCHING_CROSSLINE_TYPE("value"), { optional: true })
], _CartesianCrossLine.prototype, "value", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], _CartesianCrossLine.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], _CartesianCrossLine.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], _CartesianCrossLine.prototype, "stroke", 2);
__decorateClass([
  Validate(NUMBER, { optional: true })
], _CartesianCrossLine.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], _CartesianCrossLine.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH, { optional: true })
], _CartesianCrossLine.prototype, "lineDash", 2);
var CartesianCrossLine = _CartesianCrossLine;

// packages/ag-charts-community/src/module/moduleMap.ts
var ModuleMap = class {
  constructor() {
    this.moduleMap = /* @__PURE__ */ new Map();
  }
  addModule(module, moduleFactory) {
    if (this.moduleMap.has(module.optionsKey)) {
      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);
    }
    this.moduleMap.set(module.optionsKey, moduleFactory(module));
  }
  removeModule(module) {
    var _a;
    const moduleKey = isString(module) ? module : module.optionsKey;
    (_a = this.moduleMap.get(moduleKey)) == null ? void 0 : _a.destroy();
    this.moduleMap.delete(moduleKey);
  }
  isModuleEnabled(module) {
    return this.moduleMap.has(isString(module) ? module : module.optionsKey);
  }
  getModule(module) {
    return this.moduleMap.get(isString(module) ? module : module.optionsKey);
  }
  get modules() {
    return this.moduleMap.values();
  }
  mapValues(callback) {
    return Array.from(this.moduleMap.values()).map(callback);
  }
  destroy() {
    for (const optionsKey of this.moduleMap.keys()) {
      this.removeModule({ optionsKey });
    }
  }
};

// packages/ag-charts-community/src/motion/resetMotion.ts
var resetMotion_exports = {};
__export(resetMotion_exports, {
  resetMotion: () => resetMotion
});
function resetMotion(selectionsOrNodes, propsFn) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  for (const selection of selections) {
    for (const node of selection.nodes()) {
      const from = propsFn(node, node.datum);
      node.setProperties(from);
    }
    selection.cleanup();
  }
  for (const node of nodes) {
    const from = propsFn(node, node.datum);
    node.setProperties(from);
  }
}

// packages/ag-charts-community/src/motion/states.ts
var StateMachine = class {
  constructor(initialState, states, preTransitionCb) {
    this.states = states;
    this.preTransitionCb = preTransitionCb;
    this.debug = Debug.create(true, "animation");
    this.state = initialState;
    this.debug(`%c${this.constructor.name} | init -> ${initialState}`, "color: green");
  }
  transition(event, data) {
    var _a, _b;
    const currentStateConfig = this.states[this.state];
    const destinationTransition = currentStateConfig == null ? void 0 : currentStateConfig[event];
    if (!destinationTransition) {
      this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.state}`, "color: grey");
      return;
    }
    let destinationState = this.state;
    if (typeof destinationTransition === "string") {
      destinationState = destinationTransition;
    } else if (typeof destinationTransition === "object") {
      destinationState = destinationTransition.target;
    }
    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${destinationState}`, "color: green");
    (_a = this.preTransitionCb) == null ? void 0 : _a.call(this, this.state, destinationState);
    this.state = destinationState;
    if (typeof destinationTransition === "function") {
      destinationTransition(data);
    } else if (typeof destinationTransition === "object") {
      (_b = destinationTransition.action) == null ? void 0 : _b.call(destinationTransition, data);
    }
    return this.state;
  }
};

// packages/ag-charts-community/src/util/numberFormat.ts
var group = (content) => `(${content})`;
var optionalGroup = (content) => `${group(content)}?`;
var nonCapturingGroup = (content) => optionalGroup(`?:${content}`);
var formatRegEx = (() => {
  const fill = ".";
  const align = "[<>=^]";
  const sign = "[+\\-( ]";
  const symbol = "[$\u20AC\xA3\xA5\u20A3\u20B9#]";
  const zero = "0";
  const width = "\\d+";
  const comma = ",";
  const precision = "\\d+";
  const tilde = "~";
  const type = "[%a-z]";
  return new RegExp(
    [
      "^",
      nonCapturingGroup(`${optionalGroup(fill)}${group(align)}`),
      optionalGroup(sign),
      optionalGroup(symbol),
      optionalGroup(zero),
      optionalGroup(width),
      optionalGroup(comma),
      nonCapturingGroup(`\\.${group(precision)}`),
      optionalGroup(tilde),
      optionalGroup(type),
      "$"
    ].join(""),
    "i"
  );
})();
var surroundedRegEx = (() => {
  const prefix = ".*?";
  const content = ".+?";
  const suffix = ".*?";
  return new RegExp(["^", group(prefix), `#\\{${group(content)}\\}`, group(suffix), "$"].join(""));
})();
function parseFormatter(formatter) {
  let prefix;
  let suffix;
  const surrounded = surroundedRegEx.exec(formatter);
  if (surrounded) {
    [, prefix, formatter, suffix] = surrounded;
  }
  const match = formatRegEx.exec(formatter);
  if (!match) {
    throw new Error(`The number formatter is invalid: ${formatter}`);
  }
  const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;
  return {
    fill,
    align,
    sign,
    symbol,
    zero,
    width: parseInt(width),
    comma,
    precision: parseInt(precision),
    trim: Boolean(trim),
    type,
    prefix,
    suffix
  };
}
function format(formatter) {
  const options = typeof formatter === "string" ? parseFormatter(formatter) : formatter;
  const { fill, align, sign = "-", symbol, zero, width, comma, type, prefix = "", suffix = "", precision } = options;
  let { trim } = options;
  const precisionIsNaN = precision === void 0 || isNaN(precision);
  let formatBody;
  if (!type) {
    formatBody = decimalTypes["g"];
    trim = true;
  } else if (type in decimalTypes && type in integerTypes) {
    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];
  } else if (type in decimalTypes) {
    formatBody = decimalTypes[type];
  } else if (type in integerTypes) {
    formatBody = integerTypes[type];
  } else {
    throw new Error(`The number formatter type is invalid: ${type}`);
  }
  let formatterPrecision;
  if (precision == null || precisionIsNaN) {
    formatterPrecision = type ? 6 : 12;
  } else {
    formatterPrecision = precision;
  }
  return (n) => {
    let result = formatBody(n, formatterPrecision);
    if (trim) {
      result = removeTrailingZeros(result);
    }
    if (comma) {
      result = insertSeparator(result, comma);
    }
    result = addSign(n, result, sign);
    if (symbol && symbol !== "#") {
      result = `${symbol}${result}`;
    }
    if (symbol === "#" && type === "x") {
      result = `0x${result}`;
    }
    if (type === "s") {
      result = `${result}${getSIPrefix(n)}`;
    }
    if (type === "%" || type === "p") {
      result = `${result}%`;
    }
    if (width != null && !isNaN(width)) {
      result = addPadding(result, width, fill != null ? fill : zero, align);
    }
    result = `${prefix}${result}${suffix}`;
    return result;
  };
}
var absFloor = (n) => Math.floor(Math.abs(n));
var integerTypes = {
  b: (n) => absFloor(n).toString(2),
  c: (n) => String.fromCharCode(n),
  d: (n) => Math.round(Math.abs(n)).toFixed(0),
  o: (n) => absFloor(n).toString(8),
  x: (n) => absFloor(n).toString(16),
  X: (n) => integerTypes.x(n).toUpperCase(),
  n: (n) => integerTypes.d(n),
  "%": (n) => `${absFloor(n * 100).toFixed(0)}`
};
var decimalTypes = {
  e: (n, f) => Math.abs(n).toExponential(f),
  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),
  f: (n, f) => Math.abs(n).toFixed(f),
  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),
  g: (n, f) => {
    if (n === 0) {
      return "0";
    }
    const a = Math.abs(n);
    const p = Math.floor(Math.log10(a));
    if (p >= -4 && p < f) {
      return a.toFixed(f - 1 - p);
    }
    return a.toExponential(f - 1);
  },
  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),
  n: (n, f) => decimalTypes.g(n, f),
  p: (n, f) => decimalTypes.r(n * 100, f),
  r: (n, f) => {
    if (n === 0) {
      return "0";
    }
    const a = Math.abs(n);
    const p = Math.floor(Math.log10(a));
    const q = p - (f - 1);
    if (q <= 0) {
      return a.toFixed(-q);
    }
    const x = Math.pow(10, q);
    return (Math.round(a / x) * x).toFixed();
  },
  s: (n, f) => {
    const p = getSIPrefixPower(n);
    return decimalTypes.r(n / Math.pow(10, p), f);
  },
  "%": (n, f) => decimalTypes.f(n * 100, f)
};
function removeTrailingZeros(numString) {
  return numString.replace(/\.0+$/, "").replace(/(\.[1-9])0+$/, "$1");
}
function insertSeparator(numString, separator) {
  let dotIndex = numString.indexOf(".");
  if (dotIndex < 0) {
    dotIndex = numString.length;
  }
  const integerChars = numString.substring(0, dotIndex).split("");
  const fractionalPart = numString.substring(dotIndex);
  for (let i = integerChars.length - 3; i > 0; i -= 3) {
    integerChars.splice(i, 0, separator);
  }
  return `${integerChars.join("")}${fractionalPart}`;
}
function getSIPrefix(n) {
  return siPrefixes[getSIPrefixPower(n)];
}
function getSIPrefixPower(n) {
  return clamp(minSIPrefix, Math.floor(Math.log10(Math.abs(n)) / 3) * 3, maxSIPrefix);
}
var minSIPrefix = -24;
var maxSIPrefix = 24;
var siPrefixes = {
  [minSIPrefix]: "y",
  [-21]: "z",
  [-18]: "a",
  [-15]: "f",
  [-12]: "p",
  [-9]: "n",
  [-6]: "\xB5",
  [-3]: "m",
  [0]: "",
  [3]: "k",
  [6]: "M",
  [9]: "G",
  [12]: "T",
  [15]: "P",
  [18]: "E",
  [21]: "Z",
  [maxSIPrefix]: "Y"
};
var minusSign = "\u2212";
function addSign(num, numString, signType = "") {
  if (signType === "(") {
    return num >= 0 ? numString : `(${numString})`;
  }
  const plusSign = signType === "+" ? "+" : "";
  return `${num >= 0 ? plusSign : minusSign}${numString}`;
}
function addPadding(numString, width, fill = " ", align = ">") {
  let result = numString;
  if (align === ">" || !align) {
    result = result.padStart(width, fill);
  } else if (align === "<") {
    result = result.padEnd(width, fill);
  } else if (align === "^") {
    const padWidth = Math.max(0, width - result.length);
    const padLeft = Math.ceil(padWidth / 2);
    const padRight = Math.floor(padWidth / 2);
    result = result.padStart(padLeft + result.length, fill);
    result = result.padEnd(padRight + result.length, fill);
  }
  return result;
}
function tickFormat(ticks, formatter) {
  const options = parseFormatter(formatter != null ? formatter : ",f");
  const { precision } = options;
  if (precision == null || isNaN(precision)) {
    if (options.type === "f" || options.type === "%") {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (typeof x !== "number" || x === 0) {
            return 0;
          }
          const l = Math.floor(Math.log10(Math.abs(x)));
          const digits = options.type ? 6 : 12;
          const exp = x.toExponential(digits - 1).replace(/\.?0+e/, "e");
          const dotIndex = exp.indexOf(".");
          if (dotIndex < 0) {
            return l >= 0 ? 0 : -l;
          }
          const s = exp.indexOf("e") - dotIndex;
          return Math.max(0, s - l - 1);
        })
      );
    } else if (!options.type || options.type in decimalTypes) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (typeof x !== "number") {
            return 0;
          }
          const exp = x.toExponential((options.type ? 6 : 12) - 1).replace(/\.?0+e/, "e");
          return exp.substring(0, exp.indexOf("e")).replace(".", "").length;
        })
      );
    }
  }
  const f = format(options);
  return (n) => f(Number(n));
}

// packages/ag-charts-community/src/util/ticks.ts
var createNumericTicks = (fractionDigits, takingValues = []) => Object.assign(takingValues, { fractionDigits });
function ticks_default(start, stop, count2, minCount, maxCount) {
  if (count2 < 2) {
    return range(start, stop, stop - start);
  }
  const step = tickStep(start, stop, count2, minCount, maxCount);
  if (isNaN(step)) {
    return createNumericTicks(0);
  }
  start = Math.ceil(start / step) * step;
  stop = Math.floor(stop / step) * step;
  return range(start, stop, step);
}
var tickMultipliers = [1, 2, 5, 10];
function tickStep(a, b, count2, minCount = 0, maxCount = Infinity) {
  const extent2 = Math.abs(b - a);
  const rawStep = extent2 / count2;
  const power = Math.floor(Math.log10(rawStep));
  const step = Math.pow(10, power);
  const m = tickMultipliers.map((multiplier) => {
    const s = multiplier * step;
    const c = Math.ceil(extent2 / s);
    const isWithinBounds = c >= minCount && c <= maxCount;
    const diffCount = Math.abs(c - count2);
    return { multiplier, isWithinBounds, diffCount };
  }).sort((a2, b2) => {
    if (a2.isWithinBounds !== b2.isWithinBounds) {
      return a2.isWithinBounds ? -1 : 1;
    }
    return a2.diffCount - b2.diffCount;
  })[0].multiplier;
  if (!m || isNaN(m)) {
    return NaN;
  }
  return m * step;
}
function singleTickDomain(a, b) {
  const extent2 = Math.abs(b - a);
  const power = Math.floor(Math.log10(extent2));
  const step = Math.pow(10, power);
  const roundStart = a > b ? Math.ceil : Math.floor;
  const roundStop = b < a ? Math.floor : Math.ceil;
  return tickMultipliers.map((multiplier) => {
    const s = multiplier * step;
    const start = roundStart(a / s) * s;
    const end = roundStop(b / s) * s;
    const error = 1 - extent2 / Math.abs(end - start);
    const domain = [start, end];
    return { error, domain };
  }).sort((a2, b2) => a2.error - b2.error)[0].domain;
}
function range(start, stop, step) {
  const d0 = Math.min(start, stop);
  const d1 = Math.max(start, stop);
  const fractionalDigits = countFractionDigits(step);
  const f = Math.pow(10, fractionalDigits);
  const n = Math.ceil((d1 - d0) / step);
  const values = createNumericTicks(fractionalDigits);
  for (let i = 0; i <= n; i++) {
    const value = d0 + step * i;
    values.push(Math.round(value * f) / f);
  }
  return values;
}

// packages/ag-charts-community/src/scale/logScale.ts
var _LogScale = class _LogScale extends ContinuousScale {
  constructor() {
    super([1, 10], [0, 1]);
    this.type = "log";
    this.base = 10;
    this.baseLog = identity;
    this.basePow = identity;
    this.log = (x) => {
      const start = Math.min(...this.domain);
      return start >= 0 ? this.baseLog(x) : -this.baseLog(-x);
    };
    this.pow = (x) => {
      const start = Math.min(...this.domain);
      return start >= 0 ? this.basePow(x) : -this.basePow(-x);
    };
    this.defaultClampMode = "clamped";
  }
  toDomain(d) {
    return d;
  }
  transform(x) {
    const start = Math.min(...this.domain);
    return start >= 0 ? Math.log(x) : -Math.log(-x);
  }
  transformInvert(x) {
    const start = Math.min(...this.domain);
    return start >= 0 ? Math.exp(x) : -Math.exp(-x);
  }
  refresh() {
    if (this.base <= 0) {
      this.base = 0;
      Logger.warnOnce("expecting a finite Number greater than to 0");
    }
    super.refresh();
  }
  update() {
    if (!this.domain || this.domain.length < 2) {
      return;
    }
    this.baseLog = _LogScale.getBaseLogMethod(this.base);
    this.basePow = _LogScale.getBasePowerMethod(this.base);
    if (this.nice) {
      this.updateNiceDomain();
    }
  }
  updateNiceDomain() {
    const [d0, d1] = this.domain;
    const roundStart = d0 > d1 ? Math.ceil : Math.floor;
    const roundStop = d0 > d1 ? Math.floor : Math.ceil;
    const n0 = this.pow(roundStart(this.log(d0)));
    const n1 = this.pow(roundStop(this.log(d1)));
    this.niceDomain = [n0, n1];
  }
  ticks() {
    var _a;
    const count2 = (_a = this.tickCount) != null ? _a : 10;
    if (!this.domain || this.domain.length < 2 || count2 < 1) {
      return [];
    }
    this.refresh();
    const base = this.base;
    const [d0, d1] = this.getDomain();
    const start = Math.min(d0, d1);
    const stop = Math.max(d0, d1);
    let p0 = this.log(start);
    let p1 = this.log(stop);
    if (this.interval) {
      const step = Math.abs(this.interval);
      const absDiff = Math.abs(p1 - p0);
      let ticks2 = range(p0, p1, Math.min(absDiff, step));
      ticks2 = createNumericTicks(
        ticks2.fractionDigits,
        ticks2.map((x) => this.pow(x)).filter((t) => t >= start && t <= stop)
      );
      if (!this.isDenseInterval({ start, stop, interval: step, count: ticks2.length })) {
        return ticks2;
      }
    }
    const isBaseInteger = base % 1 === 0;
    const isDiffLarge = p1 - p0 >= count2;
    if (!isBaseInteger || isDiffLarge) {
      let ticks2 = ticks_default(p0, p1, Math.min(p1 - p0, count2));
      ticks2 = createNumericTicks(
        ticks2.fractionDigits,
        ticks2.map((x) => this.pow(x))
      );
      return ticks2;
    }
    const ticks = [];
    const isPositive = start > 0;
    p0 = Math.floor(p0) - 1;
    p1 = Math.round(p1) + 1;
    const availableSpacing = findRangeExtent(this.range) / count2;
    let lastTickPosition = Infinity;
    for (let p = p0; p <= p1; p++) {
      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));
      for (let k = 1; k < base; k++) {
        const q = isPositive ? k : base - k + 1;
        const t = this.pow(p) * q;
        const tickPosition = this.convert(t);
        const prevSpacing = Math.abs(lastTickPosition - tickPosition);
        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);
        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;
        if (t >= start && t <= stop && (k === 1 || fits)) {
          ticks.push(t);
          lastTickPosition = tickPosition;
        }
      }
    }
    return ticks;
  }
  tickFormat({
    count: count2,
    ticks,
    specifier
  }) {
    if (count2 !== Infinity && ticks == null) {
      this.ticks();
    }
    specifier != null ? specifier : specifier = this.base === 10 ? ".0e" : ",";
    return isString(specifier) ? format(specifier) : specifier;
  }
  static getBaseLogMethod(base) {
    switch (base) {
      case 10:
        return Math.log10;
      case Math.E:
        return Math.log;
      case 2:
        return Math.log2;
      default:
        const logBase = Math.log(base);
        return (x) => Math.log(x) / logBase;
    }
  }
  static getBasePowerMethod(base) {
    switch (base) {
      case 10:
        return (x) => x >= 0 ? __pow(10, x) : 1 / __pow(10, -x);
      case Math.E:
        return Math.exp;
      default:
        return (x) => __pow(base, x);
    }
  }
};
__decorateClass([
  Invalidating
], _LogScale.prototype, "base", 2);
var LogScale = _LogScale;

// packages/ag-charts-community/src/util/timeFormat.ts
var CONSTANTS = {
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
};
function dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {
  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();
  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 6e4;
  const timeOneDay = 36e5 * 24;
  return Math.floor(timeDiff / timeOneDay);
}
function weekOfYear(date, startDay) {
  const startOfYear = new Date(date.getFullYear(), 0, 1);
  const startOfYearDay = startOfYear.getDay();
  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;
  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);
  if (startOffset <= date) {
    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;
  }
  return 0;
}
var SUNDAY = 0;
var MONDAY = 1;
var THURSDAY = 4;
function isoWeekOfYear(date, year2 = date.getFullYear()) {
  const firstOfYear = new Date(year2, 0, 1);
  const firstOfYearDay = firstOfYear.getDay();
  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;
  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);
  if (startOffset <= date) {
    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;
  }
  return isoWeekOfYear(date, year2 - 1);
}
function timezone(date) {
  const offset4 = date.getTimezoneOffset();
  const unsignedOffset = Math.abs(offset4);
  const sign = offset4 > 0 ? "-" : "+";
  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, "0")}${pad(Math.floor(unsignedOffset % 60), 2, "0")}`;
}
var FORMATTERS = {
  a: (d) => CONSTANTS.shortDays[d.getDay()],
  A: (d) => CONSTANTS.days[d.getDay()],
  b: (d) => CONSTANTS.shortMonths[d.getMonth()],
  B: (d) => CONSTANTS.months[d.getMonth()],
  c: "%x, %X",
  d: (d, p) => pad(d.getDate(), 2, p != null ? p : "0"),
  e: "%_d",
  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p != null ? p : "0"),
  H: (d, p) => pad(d.getHours(), 2, p != null ? p : "0"),
  I: (d, p) => {
    const hours = d.getHours() % 12;
    return hours === 0 ? "12" : pad(hours, 2, p != null ? p : "0");
  },
  j: (d, p) => pad(dayOfYear(d) + 1, 3, p != null ? p : "0"),
  m: (d, p) => pad(d.getMonth() + 1, 2, p != null ? p : "0"),
  M: (d, p) => pad(d.getMinutes(), 2, p != null ? p : "0"),
  L: (d, p) => pad(d.getMilliseconds(), 3, p != null ? p : "0"),
  p: (d) => d.getHours() < 12 ? "AM" : "PM",
  Q: (d) => String(d.getTime()),
  s: (d) => String(Math.floor(d.getTime() / 1e3)),
  S: (d, p) => pad(d.getSeconds(), 2, p != null ? p : "0"),
  u: (d) => {
    let day2 = d.getDay();
    if (day2 < 1)
      day2 += 7;
    return String(day2 % 7);
  },
  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p != null ? p : "0"),
  V: (d, p) => pad(isoWeekOfYear(d), 2, p != null ? p : "0"),
  w: (d, p) => pad(d.getDay(), 2, p != null ? p : "0"),
  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p != null ? p : "0"),
  x: "%-m/%-d/%Y",
  X: "%-I:%M:%S %p",
  y: (d, p) => pad(d.getFullYear() % 100, 2, p != null ? p : "0"),
  Y: (d, p) => pad(d.getFullYear(), 4, p != null ? p : "0"),
  Z: (d) => timezone(d),
  "%": () => "%"
};
var PADS = {
  _: " ",
  "0": "0",
  "-": ""
};
function pad(value, size, padChar) {
  const output = String(Math.floor(value));
  if (output.length >= size) {
    return output;
  }
  return `${padChar.repeat(size - output.length)}${output}`;
}
function buildFormatter(formatString) {
  const formatParts = [];
  while (formatString.length > 0) {
    let nextEscapeIdx = formatString.indexOf("%");
    if (nextEscapeIdx !== 0) {
      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;
      formatParts.push(literalPart);
    }
    if (nextEscapeIdx < 0)
      break;
    const maybePadSpecifier = formatString[nextEscapeIdx + 1];
    const maybePad = PADS[maybePadSpecifier];
    if (maybePad != null) {
      nextEscapeIdx++;
    }
    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];
    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];
    if (typeof maybeFormatter === "function") {
      formatParts.push([maybeFormatter, maybePad]);
    } else if (typeof maybeFormatter === "string") {
      const formatter = buildFormatter(maybeFormatter);
      formatParts.push([formatter, maybePad]);
    } else {
      formatParts.push(`${maybePad != null ? maybePad : ""}${maybeFormatterSpecifier}`);
    }
    formatString = formatString.substring(nextEscapeIdx + 2);
  }
  return (dateTime) => {
    const dateTimeAsDate = typeof dateTime === "number" ? new Date(dateTime) : dateTime;
    return formatParts.map((c) => typeof c === "string" ? c : c[0](dateTimeAsDate, c[1])).join("");
  };
}

// packages/ag-charts-community/src/scale/timeScale.ts
var formatStrings = {
  [0 /* MILLISECOND */]: ".%L",
  [1 /* SECOND */]: ":%S",
  [2 /* MINUTE */]: "%I:%M",
  [3 /* HOUR */]: "%I %p",
  [4 /* WEEK_DAY */]: "%a",
  [5 /* SHORT_MONTH */]: "%b %d",
  [6 /* MONTH */]: "%B",
  [7 /* SHORT_YEAR */]: "%y",
  [8 /* YEAR */]: "%Y"
};
function toNumber(x) {
  return x instanceof Date ? x.getTime() : x;
}
var TimeScale = class extends ContinuousScale {
  constructor() {
    super([], [0, 1]);
    this.type = "time";
    this.year = year_default;
    this.month = month_default;
    this.week = week_default;
    this.day = day_default;
    this.hour = hour_default;
    this.minute = minute_default;
    this.second = second_default;
    this.millisecond = millisecond_default;
    /**
     * Array of default tick intervals in the following format:
     *
     *     [
     *         interval (unit of time),
     *         number of units (step),
     *         the length of that number of units in milliseconds
     *     ]
     */
    this.tickIntervals = [
      [this.second, 1, durationSecond],
      [this.second, 5, 5 * durationSecond],
      [this.second, 15, 15 * durationSecond],
      [this.second, 30, 30 * durationSecond],
      [this.minute, 1, durationMinute],
      [this.minute, 5, 5 * durationMinute],
      [this.minute, 15, 15 * durationMinute],
      [this.minute, 30, 30 * durationMinute],
      [this.hour, 1, durationHour],
      [this.hour, 3, 3 * durationHour],
      [this.hour, 6, 6 * durationHour],
      [this.hour, 12, 12 * durationHour],
      [this.day, 1, durationDay],
      [this.day, 2, 2 * durationDay],
      [this.week, 1, durationWeek],
      [this.week, 2, 2 * durationWeek],
      [this.week, 3, 3 * durationWeek],
      [this.month, 1, durationMonth],
      [this.month, 2, 2 * durationMonth],
      [this.month, 3, 3 * durationMonth],
      [this.month, 4, 4 * durationMonth],
      [this.month, 6, 6 * durationMonth],
      [this.year, 1, durationYear]
    ];
  }
  toDomain(d) {
    return new Date(d);
  }
  calculateDefaultTickFormat(ticks = []) {
    let defaultTimeFormat = 8 /* YEAR */;
    const updateFormat = (format2) => {
      if (format2 < defaultTimeFormat) {
        defaultTimeFormat = format2;
      }
    };
    for (const value of ticks) {
      const format2 = this.getLowestGranularityFormat(value);
      updateFormat(format2);
    }
    const firstTick = toNumber(ticks[0]);
    const lastTick = toNumber(ticks.at(-1));
    const startYear = new Date(firstTick).getFullYear();
    const stopYear = new Date(lastTick).getFullYear();
    const yearChange = stopYear - startYear > 0;
    return this.buildFormatString(defaultTimeFormat, yearChange);
  }
  buildFormatString(defaultTimeFormat, yearChange) {
    let formatStringArray = [formatStrings[defaultTimeFormat]];
    let timeEndIndex = 0;
    const domain = this.getDomain();
    const extent2 = findRangeExtent(domain.map(toNumber));
    switch (defaultTimeFormat) {
      case 1 /* SECOND */:
        if (extent2 / durationMinute > 1) {
          formatStringArray.push(formatStrings[2 /* MINUTE */]);
        }
      case 2 /* MINUTE */:
        if (extent2 / durationHour > 1) {
          formatStringArray.push(formatStrings[3 /* HOUR */]);
        }
      case 3 /* HOUR */:
        timeEndIndex = formatStringArray.length;
        if (extent2 / durationDay > 1) {
          formatStringArray.push(formatStrings[4 /* WEEK_DAY */]);
        }
      case 4 /* WEEK_DAY */:
        if (extent2 / durationWeek > 1 || yearChange) {
          const weekDayIndex = formatStringArray.indexOf(formatStrings[4 /* WEEK_DAY */]);
          if (weekDayIndex > -1) {
            formatStringArray.splice(weekDayIndex, 1, formatStrings[5 /* SHORT_MONTH */]);
          }
        }
      case 5 /* SHORT_MONTH */:
      case 6 /* MONTH */:
        if (extent2 / durationYear > 1 || yearChange) {
          formatStringArray.push(formatStrings[8 /* YEAR */]);
        }
    }
    if (timeEndIndex < formatStringArray.length) {
      formatStringArray = [
        ...formatStringArray.slice(0, timeEndIndex),
        formatStringArray.slice(timeEndIndex).join(" ")
      ];
    }
    if (timeEndIndex > 0) {
      formatStringArray = [
        ...formatStringArray.slice(0, timeEndIndex).reverse(),
        ...formatStringArray.slice(timeEndIndex)
      ];
      if (timeEndIndex < formatStringArray.length) {
        formatStringArray.splice(timeEndIndex, 0, " ");
      }
    }
    return formatStringArray.join("");
  }
  getLowestGranularityFormat(value) {
    if (this.second.floor(value) < value) {
      return 0 /* MILLISECOND */;
    } else if (this.minute.floor(value) < value) {
      return 1 /* SECOND */;
    } else if (this.hour.floor(value) < value) {
      return 2 /* MINUTE */;
    } else if (this.day.floor(value) < value) {
      return 3 /* HOUR */;
    } else if (this.month.floor(value) < value) {
      if (this.week.floor(value) < value) {
        return 4 /* WEEK_DAY */;
      }
      return 5 /* SHORT_MONTH */;
    } else if (this.year.floor(value) < value) {
      return 6 /* MONTH */;
    }
    return 8 /* YEAR */;
  }
  defaultTickFormat(ticks) {
    const formatString = this.calculateDefaultTickFormat(ticks);
    return (date) => buildFormatter(formatString)(date);
  }
  /**
   * @param options Tick interval options.
   * @param options.start The start time (timestamp).
   * @param options.stop The end time (timestamp).
   * @param options.count Number of intervals between ticks.
   */
  getTickInterval({
    start,
    stop,
    count: count2,
    minCount,
    maxCount
  }) {
    const { tickIntervals } = this;
    let countableTimeInterval;
    let step;
    const tickCount = count2 != null ? count2 : ContinuousScale.defaultTickCount;
    const target = Math.abs(stop - start) / Math.max(tickCount, 1);
    let i = 0;
    while (i < tickIntervals.length && target > tickIntervals[i][2]) {
      i++;
    }
    if (i === 0) {
      step = Math.max(tickStep(start, stop, tickCount, minCount, maxCount), 1);
      countableTimeInterval = this.millisecond;
    } else if (i === tickIntervals.length) {
      const y0 = start / durationYear;
      const y1 = stop / durationYear;
      step = tickStep(y0, y1, tickCount, minCount, maxCount);
      countableTimeInterval = this.year;
    } else {
      const diff0 = target - tickIntervals[i - 1][2];
      const diff1 = tickIntervals[i][2] - target;
      const index = diff0 < diff1 ? i - 1 : i;
      [countableTimeInterval, step] = tickIntervals[index];
    }
    return countableTimeInterval.every(step);
  }
  invert(y) {
    return new Date(super.invert(y));
  }
  /**
   * Returns uniformly-spaced dates that represent the scale's domain.
   */
  ticks() {
    if (!this.domain || this.domain.length < 2) {
      return [];
    }
    this.refresh();
    const [t0, t1] = this.getDomain().map(toNumber);
    const start = Math.min(t0, t1);
    const stop = Math.max(t0, t1);
    if (this.interval !== void 0) {
      return this.getTicksForInterval({ start, stop });
    }
    if (this.nice) {
      const { tickCount } = this;
      if (tickCount === 2) {
        return this.niceDomain;
      }
      if (tickCount === 1) {
        return this.niceDomain.slice(0, 1);
      }
    }
    return this.getDefaultTicks({ start, stop });
  }
  getDefaultTicks({ start, stop }) {
    const t = this.getTickInterval({
      start,
      stop,
      count: this.tickCount,
      minCount: this.minTickCount,
      maxCount: this.maxTickCount
    });
    return t ? t.range(new Date(start), new Date(stop)) : [];
  }
  getTicksForInterval({ start, stop }) {
    const { interval, tickIntervals } = this;
    if (!interval) {
      return [];
    }
    if (interval instanceof TimeInterval) {
      const ticks2 = interval.range(new Date(start), new Date(stop));
      if (this.isDenseInterval({ start, stop, interval, count: ticks2.length })) {
        return this.getDefaultTicks({ start, stop });
      }
      return ticks2;
    }
    const absInterval = Math.abs(interval);
    if (this.isDenseInterval({ start, stop, interval: absInterval })) {
      return this.getDefaultTicks({ start, stop });
    }
    const reversedInterval = [...tickIntervals];
    reversedInterval.reverse();
    const timeInterval = reversedInterval.find((tickInterval) => absInterval % tickInterval[2] === 0);
    if (timeInterval) {
      const i = timeInterval[0].every(absInterval / (timeInterval[2] / timeInterval[1]));
      return i.range(new Date(start), new Date(stop));
    }
    let date = new Date(start);
    const stopDate = new Date(stop);
    const ticks = [];
    while (date <= stopDate) {
      ticks.push(date);
      date = new Date(date);
      date.setMilliseconds(date.getMilliseconds() + absInterval);
    }
    return ticks;
  }
  /**
   * Returns a time format function suitable for displaying tick values.
   * @param specifier If the specifier string is provided, this method is equivalent to
   * the {@link TimeLocaleObject.format} method.
   * If no specifier is provided, this method returns the default time format function.
   */
  tickFormat({ ticks, specifier }) {
    return specifier == void 0 ? this.defaultTickFormat(ticks) : buildFormatter(specifier);
  }
  update() {
    if (!this.domain || this.domain.length < 2) {
      return;
    }
    if (this.nice) {
      this.updateNiceDomain();
    }
  }
  /**
   * Extends the domain so that it starts and ends on nice round values.
   * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.
   */
  updateNiceDomain() {
    const maxAttempts = 4;
    let [d0, d1] = this.domain;
    for (let i = 0; i < maxAttempts; i++) {
      this.updateNiceDomainIteration(d0, d1);
      const [n0, n1] = this.niceDomain;
      if (toNumber(d0) === toNumber(n0) && toNumber(d1) === toNumber(n1)) {
        break;
      }
      d0 = n0;
      d1 = n1;
    }
  }
  updateNiceDomainIteration(d0, d1) {
    const start = Math.min(toNumber(d0), toNumber(d1));
    const stop = Math.max(toNumber(d0), toNumber(d1));
    const isReversed = d0 > d1;
    const { interval } = this;
    let i;
    if (interval instanceof TimeInterval) {
      i = interval;
    } else {
      const tickCount = typeof interval === "number" ? (stop - start) / Math.max(interval, 1) : this.tickCount;
      i = this.getTickInterval({
        start,
        stop,
        count: tickCount,
        minCount: this.minTickCount,
        maxCount: this.maxTickCount
      });
    }
    if (i) {
      const intervalRange = i.range(new Date(start), new Date(stop), true);
      const domain = isReversed ? [...intervalRange].reverse() : intervalRange;
      const n0 = domain[0];
      const n1 = domain.at(-1);
      this.niceDomain = [n0, n1];
    }
  }
};

// packages/ag-charts-community/src/scene/selection.ts
var Selection = class _Selection {
  constructor(parentNode, classOrFactory, autoCleanup = true) {
    this.parentNode = parentNode;
    this.autoCleanup = autoCleanup;
    this.garbageBin = /* @__PURE__ */ new Set();
    this._nodesMap = /* @__PURE__ */ new Map();
    this._nodes = [];
    this.data = [];
    this.debug = Debug.create(true, "scene", "scene:selections");
    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;
  }
  static select(parent, classOrFactory, garbageCollection = true) {
    return new _Selection(parent, classOrFactory, garbageCollection);
  }
  static selectAll(parent, predicate) {
    const results = [];
    const traverse = (node) => {
      if (predicate(node)) {
        results.push(node);
      }
      node.children.forEach(traverse);
    };
    traverse(parent);
    return results;
  }
  static selectByClass(node, Class) {
    return _Selection.selectAll(node, (node2) => node2 instanceof Class);
  }
  static selectByTag(node, tag) {
    return _Selection.selectAll(node, (node2) => node2.tag === tag);
  }
  createNode(datum, initializer, idx) {
    const node = this.nodeFactory(datum);
    node.datum = datum;
    initializer == null ? void 0 : initializer(node);
    if (idx != null) {
      this._nodes.splice(idx, 0, node);
    } else {
      this._nodes.push(node);
    }
    this.parentNode.appendChild(node);
    return node;
  }
  /**
   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to
   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end
   * of the array.
   */
  update(data, initializer, getDatumId) {
    if (this.garbageBin.size > 0) {
      this.debug(`Selection - update() called with pending garbage: ${data}`);
    }
    if (getDatumId) {
      const dataMap = new Map(
        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])
      );
      for (const [node, datumId] of this._nodesMap.entries()) {
        if (dataMap.has(datumId)) {
          const [newDatum] = dataMap.get(datumId);
          node.datum = newDatum;
          this.garbageBin.delete(node);
          dataMap.delete(datumId);
        } else {
          this.garbageBin.add(node);
        }
      }
      for (const [datumId, [datum, idx]] of dataMap.entries()) {
        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);
      }
    } else {
      const maxLength = Math.max(data.length, this.data.length);
      for (let i = 0; i < maxLength; i++) {
        if (i >= data.length) {
          this.garbageBin.add(this._nodes[i]);
        } else if (i >= this._nodes.length) {
          this.createNode(data[i], initializer);
        } else {
          this._nodes[i].datum = data[i];
          this.garbageBin.delete(this._nodes[i]);
        }
      }
    }
    this.data = data.slice();
    if (this.autoCleanup) {
      this.cleanup();
    }
    return this;
  }
  cleanup() {
    if (this.garbageBin.size === 0) {
      return this;
    }
    this._nodes = this._nodes.filter((node) => {
      if (this.garbageBin.has(node)) {
        this._nodesMap.delete(node);
        this.garbageBin.delete(node);
        this.parentNode.removeChild(node);
        return false;
      }
      return true;
    });
    return this;
  }
  clear() {
    this.update([]);
    return this;
  }
  isGarbage(node) {
    return this.garbageBin.has(node);
  }
  hasGarbage() {
    return this.garbageBin.size > 0;
  }
  each(iterate) {
    this._nodes.forEach((node, i) => iterate(node, node.datum, i));
    return this;
  }
  *[Symbol.iterator]() {
    for (let index = 0; index < this._nodes.length; index++) {
      const node = this._nodes[index];
      const datum = this._nodes[index].datum;
      yield { node, datum, index };
    }
  }
  select(predicate) {
    return _Selection.selectAll(this.parentNode, predicate);
  }
  selectByClass(Class) {
    return _Selection.selectByClass(this.parentNode, Class);
  }
  selectByTag(tag) {
    return _Selection.selectByTag(this.parentNode, tag);
  }
  nodes() {
    return this._nodes;
  }
};

// packages/ag-charts-community/src/scene/shape/line.ts
var Line = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.restoreOwnStyles();
  }
  set x(value) {
    this.x1 = value;
    this.x2 = value;
  }
  set y(value) {
    this.y1 = value;
    this.y2 = value;
  }
  computeBBox() {
    return new BBox(
      Math.min(this.x1, this.x2),
      Math.min(this.y1, this.y2),
      Math.abs(this.x2 - this.x1),
      Math.abs(this.y2 - this.y1)
    );
  }
  isPointInPath(px, py) {
    if (this.x1 === this.x2 || this.y1 === this.y2) {
      const { x, y } = this.transformPoint(px, py);
      return this.computeBBox().grow(this.strokeWidth / 2).containsPoint(x, y);
    }
    return false;
  }
  render(renderCtx) {
    var _a;
    const { ctx, forceRender, stats, devicePixelRatio } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    let { x1, y1, x2, y2 } = this;
    if (x1 === x2) {
      const { strokeWidth } = this;
      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      x1 = x;
      x2 = x;
    } else if (y1 === y2) {
      const { strokeWidth } = this;
      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      y1 = y;
      y2 = y;
    }
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    this.fillStroke(ctx);
    (_a = this.fillShadow) == null ? void 0 : _a.markClean();
    super.render(renderCtx);
  }
};
Line.className = "Line";
Line.defaultStyles = Object.assign({}, Shape.defaultStyles, {
  fill: void 0,
  strokeWidth: 1
});
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Line.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Line.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Line.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Line.prototype, "y2", 2);

// packages/ag-charts-community/src/scene/util/labelPlacement.ts
function circleRectOverlap(c, x, y, w, h) {
  let edgeX = c.x;
  if (c.x < x) {
    edgeX = x;
  } else if (c.x > x + w) {
    edgeX = x + w;
  }
  let edgeY = c.y;
  if (c.y < y) {
    edgeY = y;
  } else if (c.y > y + h) {
    edgeY = y + h;
  }
  const dx = c.x - edgeX;
  const dy = c.y - edgeY;
  const d = Math.sqrt(dx * dx + dy * dy);
  return d <= c.size * 0.5;
}
function rectRectOverlap(r1, x2, y2, w2, h2) {
  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;
  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;
  return xOverlap && yOverlap;
}
function rectContainsRect(r1, r2x, r2y, r2w, r2h) {
  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;
}
function isPointLabelDatum(x) {
  return x != null && typeof x.point === "object" && typeof x.label === "object";
}
function placeLabels(data, bounds, padding = 5) {
  const result = [];
  data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));
  for (let j = 0; j < data.length; j++) {
    const labels = result[j] = [];
    const datum = data[j];
    if (!((datum == null ? void 0 : datum.length) && datum[0].label)) {
      continue;
    }
    for (let i = 0, ln = datum.length; i < ln; i++) {
      const d = datum[i];
      const l = d.label;
      const r = d.point.size * 0.5;
      const x = d.point.x - l.width * 0.5;
      const y = d.point.y - r - l.height - padding;
      const { width, height } = l;
      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);
      if (!withinBounds) {
        continue;
      }
      const overlapPoints = data.some(
        (datum2) => datum2.some((d2) => circleRectOverlap(d2.point, x, y, width, height))
      );
      if (overlapPoints) {
        continue;
      }
      const overlapLabels = result.some((labels2) => labels2.some((l2) => rectRectOverlap(l2, x, y, width, height)));
      if (overlapLabels) {
        continue;
      }
      labels.push({
        index: i,
        text: l.text,
        x,
        y,
        width,
        height,
        datum: d
      });
    }
  }
  return result;
}
function axisLabelsOverlap(data, padding) {
  const result = [];
  for (let i = 0; i < data.length; i++) {
    const datum = data[i];
    const {
      point: { x, y },
      label: { text }
    } = datum;
    let {
      label: { width, height }
    } = datum;
    width += padding != null ? padding : 0;
    height += padding != null ? padding : 0;
    const overlapLabels = result.some((l) => {
      return rectRectOverlap(l, x, y, width, height);
    });
    if (overlapLabels) {
      return true;
    }
    result.push({
      index: i,
      text,
      x,
      y,
      width,
      height,
      datum
    });
  }
  return false;
}

// packages/ag-charts-community/src/util/equal.ts
function areArrayNumbersEqual(arrA, arrB) {
  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));
}

// packages/ag-charts-community/src/chart/axis/axisGridLine.ts
var GRID_STYLE_KEYS = ["stroke", "lineDash"];
var GRID_STYLE = ARRAY_OF(
  (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),
  "objects with gridline style properties such as 'stroke' or 'lineDash'"
);
var AxisGridLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.style = [
      {
        stroke: void 0,
        lineDash: []
      }
    ];
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisGridLine.prototype, "enabled", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisGridLine.prototype, "width", 2);
__decorateClass([
  Validate(GRID_STYLE)
], AxisGridLine.prototype, "style", 2);

// packages/ag-charts-community/src/util/default.ts
function Default(defaultValue, replaces = [void 0]) {
  return addTransformToInstanceProperty((_, __, v) => {
    if (replaces.includes(v)) {
      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;
    }
    return v;
  });
}

// packages/ag-charts-community/src/chart/axis/axisLabel.ts
var AxisLabel = class {
  constructor() {
    this.enabled = true;
    this.autoWrap = false;
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 12;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.minSpacing = NaN;
    this.color = "rgba(87, 87, 87, 1)";
    this.rotation = void 0;
    this.avoidCollisions = true;
    this.mirrored = false;
    this.parallel = false;
    /**
     * In case {@param value} is a number, the {@param fractionDigits} parameter will
     * be provided as well. The `fractionDigits` corresponds to the number of fraction
     * digits used by the tick step. For example, if the tick step is `0.0005`,
     * the `fractionDigits` is 4.
     */
    this.formatter = void 0;
  }
  /**
   * The side of the axis line to position the labels on.
   * -1 = left (default)
   * 1 = right
   */
  getSideFlag() {
    return this.mirrored ? 1 : -1;
  }
  getFont() {
    return getFont(this);
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisLabel.prototype, "enabled", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], AxisLabel.prototype, "autoWrap", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], AxisLabel.prototype, "maxWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], AxisLabel.prototype, "maxHeight", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], AxisLabel.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT2, { optional: true })
], AxisLabel.prototype, "fontWeight", 2);
__decorateClass([
  Validate(NUMBER.restrict({ min: 1 }))
], AxisLabel.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], AxisLabel.prototype, "fontFamily", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisLabel.prototype, "padding", 2);
__decorateClass([
  Validate(NUMBER_OR_NAN),
  Default(NaN)
], AxisLabel.prototype, "minSpacing", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], AxisLabel.prototype, "color", 2);
__decorateClass([
  Validate(DEGREE, { optional: true })
], AxisLabel.prototype, "rotation", 2);
__decorateClass([
  Validate(BOOLEAN)
], AxisLabel.prototype, "avoidCollisions", 2);
__decorateClass([
  Validate(BOOLEAN)
], AxisLabel.prototype, "mirrored", 2);
__decorateClass([
  Validate(BOOLEAN)
], AxisLabel.prototype, "parallel", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], AxisLabel.prototype, "format", 2);

// packages/ag-charts-community/src/chart/axis/axisLine.ts
var AxisLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.color = void 0;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisLine.prototype, "enabled", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisLine.prototype, "width", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], AxisLine.prototype, "color", 2);

// packages/ag-charts-community/src/chart/axis/axisTick.ts
var TICK_INTERVAL = predicateWithMessage(
  (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,
  `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`
);
var AxisTick = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.size = 6;
    this.color = void 0;
    this.interval = void 0;
    this.values = void 0;
    this.minSpacing = NaN;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], AxisTick.prototype, "enabled", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisTick.prototype, "width", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AxisTick.prototype, "size", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], AxisTick.prototype, "color", 2);
__decorateClass([
  Validate(TICK_INTERVAL, { optional: true })
], AxisTick.prototype, "interval", 2);
__decorateClass([
  Validate(ARRAY, { optional: true })
], AxisTick.prototype, "values", 2);
__decorateClass([
  Validate(MIN_SPACING),
  Default(NaN)
], AxisTick.prototype, "minSpacing", 2);

// packages/ag-charts-community/src/chart/axis/axisUtil.ts
function prepareAxisAnimationContext(axis) {
  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);
  const min = Math.floor(requestedRangeMin);
  const max = Math.ceil(requestedRangeMax);
  return { min, max, visible: min !== max };
}
var fullCircle = Math.PI * 2;
var halfCircle = fullCircle / 2;
function normaliseEndRotation(start, end) {
  const directDistance = Math.abs(end - start);
  if (directDistance < halfCircle)
    return end;
  if (start > end)
    return end + fullCircle;
  return end - fullCircle;
}
function prepareAxisAnimationFunctions(ctx) {
  const outOfBounds = (y, range3) => {
    const [min = ctx.min, max = ctx.max] = findMinMax(range3 != null ? range3 : []);
    return y < min || y > max;
  };
  const tick = {
    fromFn(node, datum, status) {
      let y = node.y1 + node.translationY;
      let opacity = node.opacity;
      if (status === "added" || outOfBounds(node.datum.translationY, node.datum.range)) {
        y = datum.translationY;
        opacity = 0;
      }
      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };
    },
    toFn(_node, datum, status) {
      const y = datum.translationY;
      let opacity = 1;
      if (status === "removed") {
        opacity = 0;
      }
      return {
        y: 0,
        translationY: y,
        opacity,
        finish: {
          // Set explicit y after animation so it's pixel aligned
          y,
          translationY: 0
        }
      };
    },
    intermediateFn(node, _datum, _status) {
      return { visible: !outOfBounds(node.y) };
    }
  };
  const label = {
    fromFn(node, newDatum, status) {
      var _a;
      const datum = (_a = node.previousDatum) != null ? _a : newDatum;
      const x = datum.x;
      const y = datum.y;
      const rotationCenterX = datum.rotationCenterX;
      let translationY = Math.round(node.translationY);
      let rotation = datum.rotation;
      let opacity = node.opacity;
      if (status === "removed" || outOfBounds(datum.y, datum.range)) ; else if (status === "added" || outOfBounds(node.datum.y, node.datum.range)) {
        translationY = Math.round(datum.translationY);
        opacity = 0;
        rotation = newDatum.rotation;
      }
      return {
        x,
        y,
        rotationCenterX,
        translationY,
        rotation,
        opacity,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
      };
    },
    toFn(node, datum, status) {
      var _a, _b;
      const x = datum.x;
      const y = datum.y;
      const rotationCenterX = datum.rotationCenterX;
      const translationY = Math.round(datum.translationY);
      let rotation = 0;
      let opacity = 1;
      if (status === "added") {
        opacity = 1;
        rotation = datum.rotation;
      } else if (status === "removed") {
        opacity = 0;
        rotation = datum.rotation;
      } else {
        rotation = normaliseEndRotation((_b = (_a = node.previousDatum) == null ? void 0 : _a.rotation) != null ? _b : datum.rotation, datum.rotation);
      }
      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };
    }
  };
  const line = {
    fromFn(node, datum) {
      var _a;
      return __spreadProps(__spreadValues({}, (_a = node.previousDatum) != null ? _a : datum), {
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      });
    },
    toFn(_node, datum) {
      return __spreadValues({}, datum);
    }
  };
  const group2 = {
    fromFn(group3, _datum) {
      const { rotation, translationX, translationY } = group3;
      return {
        rotation,
        translationX,
        translationY,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_group, datum) {
      const { rotation, translationX, translationY } = datum;
      return {
        rotation,
        translationX,
        translationY
      };
    }
  };
  return { tick, line, label, group: group2 };
}
function resetAxisGroupFn() {
  return (_node, datum) => {
    return {
      rotation: datum.rotation,
      rotationCenterX: datum.rotationCenterX,
      rotationCenterY: datum.rotationCenterY,
      translationX: datum.translationX,
      translationY: datum.translationY
    };
  };
}
function resetAxisSelectionFn(ctx) {
  const { visible: rangeVisible, min, max } = ctx;
  return (_node, datum) => {
    const y = datum.translationY;
    const visible = rangeVisible && y >= min && y <= max;
    return {
      y,
      translationY: 0,
      opacity: 1,
      visible
    };
  };
}
function resetAxisLabelSelectionFn() {
  return (_node, datum) => {
    return {
      x: datum.x,
      y: datum.y,
      translationY: datum.translationY,
      rotation: datum.rotation,
      rotationCenterX: datum.rotationCenterX
    };
  };
}
function resetAxisLineSelectionFn() {
  return (_node, datum) => {
    return __spreadValues({}, datum);
  };
}

// packages/ag-charts-community/src/chart/axis/axis.ts
var Tags = /* @__PURE__ */ ((Tags2) => {
  Tags2[Tags2["TickLine"] = 0] = "TickLine";
  Tags2[Tags2["TickLabel"] = 1] = "TickLabel";
  Tags2[Tags2["GridLine"] = 2] = "GridLine";
  Tags2[Tags2["GridArc"] = 3] = "GridArc";
  Tags2[Tags2["AxisLine"] = 4] = "AxisLine";
  return Tags2;
})(Tags || {});
var _Axis = class _Axis {
  constructor(moduleCtx, scale2, options) {
    this.moduleCtx = moduleCtx;
    this.scale = scale2;
    this.id = createId(this);
    this.nice = true;
    this.reverse = false;
    this.keys = [];
    this.dataDomain = { domain: [], clipped: false };
    this.boundSeries = [];
    this.includeInvisibleDomains = false;
    this.interactionEnabled = true;
    this.axisGroup = new Group({ name: `${this.id}-axis`, zIndex: 2 /* AXIS_ZINDEX */ });
    this.lineNode = this.axisGroup.appendChild(new Line());
    this.tickLineGroup = this.axisGroup.appendChild(
      new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 2 /* AXIS_ZINDEX */ })
    );
    this.tickLabelGroup = this.axisGroup.appendChild(
      new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* AXIS_ZINDEX */ })
    );
    this.crossLineGroup = new Group({ name: `${this.id}-CrossLines` });
    this.gridGroup = new Group({ name: `${this.id}-Axis-grid` });
    this.gridLineGroup = this.gridGroup.appendChild(
      new Group({
        name: `${this.id}-gridLines`,
        zIndex: 1 /* AXIS_GRID_ZINDEX */
      })
    );
    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);
    this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text, false);
    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);
    this.line = new AxisLine();
    this.tick = this.createTick();
    this.gridLine = new AxisGridLine();
    this.label = this.createLabel();
    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;
    this.translation = { x: 0, y: 0 };
    this.rotation = 0;
    // axis rotation angle in degrees
    this.layout = {
      label: {
        fractionDigits: 0,
        padding: this.label.padding,
        format: this.label.format
      }
    };
    this.destroyFns = [];
    this.range = [0, 1];
    this.visibleRange = [0, 1];
    this.title = void 0;
    this._titleCaption = new Caption();
    this.gridLength = 0;
    this.fractionDigits = 0;
    /**
     * The distance between the grid ticks and the axis ticks.
     */
    this.gridPadding = 0;
    /**
     * Is used to avoid collisions between axis labels and series.
     */
    this.seriesAreaPadding = 0;
    this.tickGenerationResult = void 0;
    this.maxThickness = Infinity;
    this.moduleMap = new ModuleMap();
    this.refreshScale();
    this._titleCaption.registerInteraction(this.moduleCtx);
    this._titleCaption.node.rotation = -Math.PI / 2;
    this.axisGroup.appendChild(this._titleCaption.node);
    this.destroyFns.push(moduleCtx.interactionManager.addListener("hover", (e) => this.checkAxisHover(e)));
    this.animationManager = moduleCtx.animationManager;
    this.animationState = new StateMachine("empty", {
      empty: {
        update: {
          target: "ready",
          action: () => this.resetSelectionNodes()
        },
        reset: "empty"
      },
      ready: {
        update: (data) => this.animateReadyUpdate(data),
        resize: () => this.resetSelectionNodes(),
        reset: "empty"
      }
    });
    this._crossLines = [];
    this.assignCrossLineArrayConstructor(this._crossLines);
    let previousSize = void 0;
    this.destroyFns.push(
      moduleCtx.layoutService.addListener("layout-complete", (e) => {
        if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {
          this.animationState.transition("resize");
        }
        previousSize = __spreadValues({}, e.chart);
      })
    );
    if ((options == null ? void 0 : options.respondsToZoom) !== false) {
      this.destroyFns.push(
        moduleCtx.updateService.addListener("update-complete", (e) => {
          this.minRect = e.minRect;
        })
      );
    }
  }
  get type() {
    var _a;
    return (_a = this.constructor.type) != null ? _a : "";
  }
  set crossLines(value) {
    var _a, _b;
    (_a = this._crossLines) == null ? void 0 : _a.forEach((crossLine) => this.detachCrossLine(crossLine));
    if (value) {
      this.assignCrossLineArrayConstructor(value);
    }
    this._crossLines = value;
    (_b = this._crossLines) == null ? void 0 : _b.forEach((crossLine) => {
      this.attachCrossLine(crossLine);
      this.initCrossLine(crossLine);
    });
  }
  get crossLines() {
    return this._crossLines;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    }
  }
  attachCrossLine(crossLine) {
    this.crossLineGroup.appendChild(crossLine.group);
    this.crossLineGroup.appendChild(crossLine.labelGroup);
  }
  detachCrossLine(crossLine) {
    this.crossLineGroup.removeChild(crossLine.group);
    this.crossLineGroup.removeChild(crossLine.labelGroup);
  }
  destroy() {
    this.moduleMap.destroy();
    this.destroyFns.forEach((f) => f());
  }
  refreshScale() {
    var _a;
    this.range = this.scale.range.slice();
    (_a = this.crossLines) == null ? void 0 : _a.forEach(this.initCrossLine, this);
  }
  updateRange() {
    var _a;
    const { range: rr, visibleRange: vr, scale: scale2 } = this;
    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const shift = span * vr[0];
    const start = rr[0] - shift;
    scale2.range = [start, start + span];
    (_a = this.crossLines) == null ? void 0 : _a.forEach((crossLine) => {
      crossLine.clippedRange = [rr[0], rr[1]];
    });
  }
  setCrossLinesVisible(visible) {
    this.crossLineGroup.visible = visible;
  }
  attachAxis(axisNode, gridNode) {
    gridNode.appendChild(this.gridGroup);
    axisNode.appendChild(this.axisGroup);
    axisNode.appendChild(this.crossLineGroup);
  }
  detachAxis(axisNode, gridNode) {
    gridNode.removeChild(this.gridGroup);
    axisNode.removeChild(this.axisGroup);
    axisNode.removeChild(this.crossLineGroup);
  }
  /**
   * Checks if a point or an object is in range.
   * @param x A point (or object's starting point).
   * @param width Object's width.
   * @param tolerance Expands the range on both ends by this amount.
   */
  inRange(x, width = 0, tolerance = 0) {
    const [min, max] = findMinMax(this.range);
    return x + width >= min - tolerance && x <= max + tolerance;
  }
  onLabelFormatChange(ticks, format2) {
    const { scale: scale2, fractionDigits } = this;
    const logScale = scale2 instanceof LogScale;
    const defaultLabelFormatter = !logScale && fractionDigits > 0 ? (x) => typeof x === "number" ? x.toFixed(fractionDigits) : String(x) : (x) => String(x);
    if (format2 && scale2 && scale2.tickFormat) {
      try {
        this.labelFormatter = scale2.tickFormat({ ticks, specifier: format2 });
      } catch (e) {
        this.labelFormatter = defaultLabelFormatter;
        Logger.warnOnce(`the axis label format string ${format2} is invalid. No formatting will be applied`);
      }
    } else {
      this.labelFormatter = defaultLabelFormatter;
    }
  }
  setTickInterval(interval) {
    var _a;
    this.scale.interval = (_a = this.tick.interval) != null ? _a : interval;
  }
  setTickCount(count2, minTickCount, maxTickCount) {
    const { scale: scale2 } = this;
    if (!(count2 && ContinuousScale.is(scale2))) {
      return;
    }
    if (typeof count2 === "number") {
      scale2.tickCount = count2;
      scale2.minTickCount = minTickCount != null ? minTickCount : 0;
      scale2.maxTickCount = maxTickCount != null ? maxTickCount : Infinity;
      return;
    }
    if (scale2 instanceof TimeScale) {
      this.setTickInterval(count2);
    }
  }
  onGridLengthChange(value, prevValue) {
    var _a;
    if (prevValue && !value || !prevValue && value) {
      this.onGridVisibilityChange();
    }
    (_a = this.crossLines) == null ? void 0 : _a.forEach(this.initCrossLine, this);
  }
  onGridVisibilityChange() {
    this.gridLineGroupSelection.clear();
  }
  createTick() {
    return new AxisTick();
  }
  createLabel() {
    return new AxisLabel();
  }
  checkAxisHover(event) {
    if (!this.interactionEnabled)
      return;
    const bbox = this.computeBBox();
    const isInAxis = bbox.containsPoint(event.offsetX, event.offsetY);
    if (!isInAxis)
      return;
    this.moduleCtx.chartEventManager.axisHover(this.id, this.direction);
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   */
  update(_primaryTickCount = 0, animated = true) {
    if (!this.tickGenerationResult) {
      return;
    }
    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
    const sideFlag = this.label.getSideFlag();
    this.updatePosition();
    const lineData = this.getAxisLineCoordinates();
    const { tickData, combinedRotation, textBaseline, textAlign, primaryTickCount } = this.tickGenerationResult;
    const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);
    this.updateSelections(lineData, tickData.ticks, {
      combinedRotation,
      textAlign,
      textBaseline,
      range: this.scale.range
    });
    if (!animated || this.animationManager.isSkipped()) {
      this.resetSelectionNodes();
    } else {
      const diff2 = this.calculateUpdateDiff(previousTicks, tickData);
      this.animationState.transition("update", diff2);
    }
    this.updateAxisLine();
    this.updateLabels();
    this.updateVisibility();
    this.updateGridLines(sideFlag);
    this.updateTickLines();
    this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });
    this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });
    this.updateLayoutState();
    return primaryTickCount;
  }
  getAxisLineCoordinates() {
    const [min, max] = findMinMax(this.range);
    return { x: 0, y1: min, y2: max };
  }
  getTickLineCoordinates(datum) {
    const sideFlag = this.label.getSideFlag();
    const x = sideFlag * this.getTickSize();
    const x1 = Math.min(0, x);
    const x2 = x1 + Math.abs(x);
    const y = datum.translationY;
    return { x1, x2, y };
  }
  getTickLabelProps(datum, params) {
    const { label } = this;
    const { combinedRotation, textBaseline, textAlign, range: range3 } = params;
    const text = datum.tickLabel;
    const sideFlag = label.getSideFlag();
    const labelX = sideFlag * (this.getTickSize() + label.padding + this.seriesAreaPadding);
    const visible = text !== "" && text != void 0;
    return {
      tickId: datum.tickId,
      translationY: datum.translationY,
      fill: label.color,
      fontFamily: label.fontFamily,
      fontSize: label.fontSize,
      fontStyle: label.fontStyle,
      fontWeight: label.fontWeight,
      rotation: combinedRotation,
      rotationCenterX: labelX,
      text,
      textAlign,
      textBaseline,
      visible,
      x: labelX,
      y: 0,
      range: range3
    };
  }
  getTickSize() {
    return this.tick.enabled ? this.tick.size : this.createTick().size;
  }
  setTitleProps(caption, params) {
    var _a;
    const { title } = this;
    if (!title) {
      caption.enabled = false;
      return;
    }
    caption.color = title.color;
    caption.fontFamily = title.fontFamily;
    caption.fontSize = title.fontSize;
    caption.fontStyle = title.fontStyle;
    caption.fontWeight = title.fontWeight;
    caption.enabled = title.enabled;
    caption.wrapping = title.wrapping;
    if (title.enabled) {
      const titleNode = caption.node;
      const padding = ((_a = title.spacing) != null ? _a : 0) + params.spacing;
      const sideFlag = this.label.getSideFlag();
      const parallelFlipRotation = normalizeAngle360(this.rotation);
      const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;
      const rotation = titleRotationFlag * sideFlag * Math.PI / 2;
      const textBaseline = titleRotationFlag === 1 ? "bottom" : "top";
      const { range: range3 } = this;
      const x = Math.floor(titleRotationFlag * sideFlag * (range3[0] + range3[1]) / 2);
      const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);
      const { callbackCache } = this.moduleCtx;
      const { formatter = (params2) => params2.defaultValue } = title;
      const text = callbackCache.call(formatter, this.getTitleFormatterParams());
      titleNode.setProperties({
        rotation,
        text,
        textBaseline,
        visible: true,
        x,
        y
      });
    }
  }
  calculateLayout(primaryTickCount) {
    var _b, _c;
    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
    const sideFlag = this.label.getSideFlag();
    const labelX = sideFlag * (this.getTickSize() + this.label.padding + this.seriesAreaPadding);
    this.updateScale();
    this.tickGenerationResult = this.generateTicks({
      primaryTickCount,
      parallelFlipRotation,
      regularFlipRotation,
      labelX,
      sideFlag
    });
    this.updateLayoutState();
    const _a = this.tickGenerationResult, { tickData, combinedRotation, textBaseline, textAlign } = _a, ticksResult = __objRest(_a, ["tickData", "combinedRotation", "textBaseline", "textAlign"]);
    const boxes = [];
    const { x, y1, y2 } = this.getAxisLineCoordinates();
    const lineBox = new BBox(
      x + Math.min(sideFlag * this.seriesAreaPadding, 0),
      y1,
      this.seriesAreaPadding,
      y2 - y1
    );
    boxes.push(lineBox);
    if (this.tick.enabled) {
      tickData.ticks.forEach((datum) => {
        const { x1, x2, y } = this.getTickLineCoordinates(datum);
        const tickLineBox = new BBox(x1, y, x2 - x1, 0);
        boxes.push(tickLineBox);
      });
    }
    if (this.label.enabled) {
      const tempText = new Text();
      tickData.ticks.forEach((datum) => {
        const labelProps = this.getTickLabelProps(datum, {
          combinedRotation,
          textAlign,
          textBaseline,
          range: this.scale.range
        });
        if (!labelProps.visible) {
          return;
        }
        tempText.setProperties(__spreadProps(__spreadValues({}, labelProps), {
          translationY: Math.round(datum.translationY)
        }));
        const box = tempText.computeTransformedBBox();
        if (box) {
          boxes.push(box);
        }
      });
    }
    const getTransformBox = (bbox2) => {
      const matrix = new Matrix();
      const {
        rotation: axisRotation,
        translationX,
        translationY,
        rotationCenterX,
        rotationCenterY
      } = this.getAxisTransform();
      Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {
        scalingCenterX: 0,
        scalingCenterY: 0,
        rotationCenterX,
        rotationCenterY
      });
      return matrix.transformBBox(bbox2);
    };
    if ((_b = this.title) == null ? void 0 : _b.enabled) {
      const caption = new Caption();
      const spacing = BBox.merge(boxes).width;
      this.setTitleProps(caption, { spacing });
      const titleNode = caption.node;
      const titleBox = titleNode.computeTransformedBBox();
      if (titleBox) {
        boxes.push(titleBox);
      }
    }
    const bbox = BBox.merge(boxes);
    const transformedBBox = getTransformBox(bbox);
    const anySeriesActive = this.isAnySeriesActive();
    (_c = this.crossLines) == null ? void 0 : _c.forEach((crossLine) => {
      var _a2;
      crossLine.sideFlag = -sideFlag;
      crossLine.direction = rotation === -Math.PI / 2 ? "x" /* X */ : "y" /* Y */;
      if (crossLine instanceof CartesianCrossLine) {
        crossLine.label.parallel = (_a2 = crossLine.label.parallel) != null ? _a2 : this.label.parallel;
      }
      crossLine.parallelFlipRotation = parallelFlipRotation;
      crossLine.regularFlipRotation = regularFlipRotation;
      crossLine.calculateLayout(anySeriesActive, this.reverse);
    });
    primaryTickCount = ticksResult.primaryTickCount;
    return { primaryTickCount, bbox: transformedBBox };
  }
  updateLayoutState() {
    this.layout.label = {
      fractionDigits: this.fractionDigits,
      padding: this.label.padding,
      format: this.label.format
    };
  }
  setDomain(domain) {
    this.dataDomain = this.normaliseDataDomain(domain);
    if (this.reverse) {
      this.dataDomain.domain.reverse();
    }
    this.scale.domain = this.dataDomain.domain;
  }
  updateScale() {
    this.updateRange();
    this.calculateDomain();
    this.setTickInterval(this.tick.interval);
    const { scale: scale2, nice } = this;
    if (!ContinuousScale.is(scale2)) {
      return;
    }
    scale2.nice = nice;
    scale2.update();
  }
  calculateRotations() {
    const rotation = toRadians(this.rotation);
    const parallelFlipRotation = normalizeAngle360(rotation);
    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);
    return { rotation, parallelFlipRotation, regularFlipRotation };
  }
  generateTicks({
    primaryTickCount,
    parallelFlipRotation,
    regularFlipRotation,
    labelX,
    sideFlag
  }) {
    var _a;
    const {
      scale: scale2,
      tick,
      label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }
    } = this;
    const secondaryAxis = primaryTickCount !== void 0;
    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({
      rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    });
    const initialRotation = configuredRotation + defaultRotation;
    const labelMatrix = new Matrix();
    const { maxTickCount } = this.estimateTickCount({
      minSpacing: tick.minSpacing,
      maxSpacing: (_a = tick.maxSpacing) != null ? _a : NaN
    });
    const continuous = ContinuousScale.is(scale2);
    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);
    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);
    const textProps = {
      fontFamily,
      fontSize,
      fontStyle,
      fontWeight,
      textBaseline,
      textAlign
    };
    let tickData = {
      rawTicks: [],
      ticks: [],
      labelCount: 0
    };
    let index = 0;
    let autoRotation = 0;
    let labelOverlap = true;
    let terminate = false;
    while (labelOverlap && index <= maxIterations) {
      if (terminate) {
        break;
      }
      autoRotation = 0;
      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);
      const tickStrategies = this.getTickStrategies({ secondaryAxis, index });
      for (const strategy of tickStrategies) {
        ({ tickData, index, autoRotation, terminate } = strategy({
          index,
          tickData,
          textProps,
          labelOverlap,
          terminate,
          primaryTickCount
        }));
        const rotated = configuredRotation !== 0 || autoRotation !== 0;
        const rotation2 = initialRotation + autoRotation;
        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);
        labelOverlap = this.checkLabelOverlap(rotation2, rotated, labelMatrix, tickData.ticks, labelX, __spreadProps(__spreadValues({}, textProps), {
          textAlign
        }));
      }
    }
    const combinedRotation = defaultRotation + configuredRotation + autoRotation;
    if (!secondaryAxis && tickData.rawTicks.length > 0) {
      primaryTickCount = tickData.rawTicks.length;
    }
    return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign };
  }
  getTickStrategies({ index, secondaryAxis }) {
    const { scale: scale2, label, tick } = this;
    const continuous = ContinuousScale.is(scale2);
    const avoidLabelCollisions = label.enabled && label.avoidCollisions;
    const filterTicks = !continuous && index !== 0 && avoidLabelCollisions;
    const autoRotate = label.autoRotate === true && label.rotation === void 0;
    const strategies = [];
    let tickGenerationType;
    if (this.tick.values) {
      tickGenerationType = 3 /* VALUES */;
    } else if (secondaryAxis) {
      tickGenerationType = 1 /* CREATE_SECONDARY */;
    } else if (filterTicks) {
      tickGenerationType = 2 /* FILTER */;
    } else {
      tickGenerationType = 0 /* CREATE */;
    }
    const tickGenerationStrategy = ({ index: index2, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index2, tickData, terminate, primaryTickCount);
    strategies.push(tickGenerationStrategy);
    if (!continuous && !isNaN(tick.minSpacing)) {
      const tickFilterStrategy = ({ index: index2, tickData, primaryTickCount, terminate }) => this.createTickData(2 /* FILTER */, index2, tickData, terminate, primaryTickCount);
      strategies.push(tickFilterStrategy);
    }
    if (!avoidLabelCollisions) {
      return strategies;
    }
    if (label.autoWrap) {
      const autoWrapStrategy = ({ index: index2, tickData, textProps }) => this.wrapLabels(tickData, index2, textProps);
      strategies.push(autoWrapStrategy);
    } else if (autoRotate) {
      const autoRotateStrategy = ({ index: index2, tickData, labelOverlap, terminate }) => ({
        index: index2,
        tickData,
        autoRotation: this.getAutoRotation(labelOverlap),
        terminate
      });
      strategies.push(autoRotateStrategy);
    }
    return strategies;
  }
  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {
    var _a;
    const { scale: scale2, tick } = this;
    const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({
      minSpacing: tick.minSpacing,
      maxSpacing: (_a = tick.maxSpacing) != null ? _a : NaN
    });
    const continuous = ContinuousScale.is(scale2);
    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
    let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;
    const regenerateTicks = tick.interval === void 0 && tick.values === void 0 && tickCount > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);
    let unchanged = true;
    while (unchanged && index <= maxIterations) {
      const prevTicks = tickData.rawTicks;
      tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;
      const { rawTicks, ticks, labelCount } = this.getTicks({
        tickGenerationType,
        previousTicks: prevTicks,
        tickCount,
        minTickCount,
        maxTickCount,
        primaryTickCount
      });
      tickData.rawTicks = rawTicks;
      tickData.ticks = ticks;
      tickData.labelCount = labelCount;
      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;
      index++;
    }
    const shouldTerminate = tick.interval !== void 0 || tick.values !== void 0;
    terminate || (terminate = shouldTerminate);
    return { tickData, index, autoRotation: 0, terminate };
  }
  checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textProps) {
    Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);
    const labelData = this.createLabelData(tickData, labelX, textProps, labelMatrix);
    const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);
    return axisLabelsOverlap(labelData, labelSpacing);
  }
  createLabelData(tickData, labelX, textProps, labelMatrix) {
    const labelData = [];
    for (const tickDatum of tickData) {
      const { tickLabel, translationY } = tickDatum;
      if (tickLabel === "" || tickLabel == void 0) {
        continue;
      }
      const lines = splitText(tickLabel);
      const { width, height } = measureText(lines, labelX, translationY, textProps);
      const bbox = new BBox(labelX, translationY, width, height);
      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelX, translationY, labelMatrix);
      labelData.push(labelDatum);
    }
    return labelData;
  }
  getAutoRotation(labelOverlap) {
    var _a;
    return labelOverlap ? normalizeAngle360(toRadians((_a = this.label.autoRotateAngle) != null ? _a : 0)) : 0;
  }
  getTicks({
    tickGenerationType,
    previousTicks,
    tickCount,
    minTickCount,
    maxTickCount,
    primaryTickCount
  }) {
    var _a;
    const { range: range3, scale: scale2, visibleRange } = this;
    let rawTicks;
    switch (tickGenerationType) {
      case 3 /* VALUES */:
        if (ContinuousScale.is(scale2)) {
          const scaleDomain = scale2.getDomain();
          const start2 = scale2.fromDomain(scaleDomain[0]);
          const stop = scale2.fromDomain(scaleDomain[1]);
          const d0 = Math.min(start2, stop);
          const d1 = Math.max(start2, stop);
          rawTicks = this.tick.values.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);
        } else {
          rawTicks = this.tick.values;
        }
        break;
      case 1 /* CREATE_SECONDARY */:
        rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);
        break;
      case 2 /* FILTER */:
        rawTicks = this.filterTicks(previousTicks, tickCount);
        break;
      default:
        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);
        break;
    }
    this.fractionDigits = rawTicks.fractionDigits >= 0 ? rawTicks.fractionDigits : 0;
    this.onLabelFormatChange(rawTicks, this.label.format);
    const halfBandwidth = ((_a = scale2.bandwidth) != null ? _a : 0) / 2;
    const ticks = [];
    let labelCount = 0;
    const tickIdCounts = /* @__PURE__ */ new Map();
    const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));
    const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));
    for (let i = start; i < end; i++) {
      const rawTick = rawTicks[i];
      const translationY = scale2.convert(rawTick) + halfBandwidth;
      if (range3.length > 0 && !this.inRange(translationY, 0, 1e-3))
        continue;
      const tickLabel = this.formatTick(rawTick, i);
      let tickId = tickLabel;
      if (tickIdCounts.has(tickId)) {
        const count2 = tickIdCounts.get(tickId);
        tickIdCounts.set(tickId, count2 + 1);
        tickId = `${tickId}_${count2}`;
      } else {
        tickIdCounts.set(tickId, 1);
      }
      ticks.push({ tick: rawTick, tickId, tickLabel, translationY });
      if (tickLabel === "" || tickLabel == void 0) {
        continue;
      }
      labelCount++;
    }
    return { rawTicks, ticks, labelCount };
  }
  filterTicks(ticks, tickCount) {
    var _a;
    const tickSpacing = !isNaN(this.tick.minSpacing) || !isNaN((_a = this.tick.maxSpacing) != null ? _a : NaN);
    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;
    return ticks.filter((_, i) => i % keepEvery === 0);
  }
  createTicks(tickCount, minTickCount, maxTickCount) {
    var _a, _b, _c;
    this.setTickCount(tickCount, minTickCount, maxTickCount);
    return (_c = (_b = (_a = this.scale).ticks) == null ? void 0 : _b.call(_a)) != null ? _c : [];
  }
  estimateTickCount({ minSpacing, maxSpacing }) {
    const { minRect } = this;
    const rangeWithBleed = this.calculateRangeWithBleed();
    const defaultMinSpacing = Math.max(
      this.defaultTickMinSpacing,
      rangeWithBleed / ContinuousScale.defaultMaxTickCount
    );
    let clampMaxTickCount = !isNaN(maxSpacing);
    if (isNaN(minSpacing)) {
      minSpacing = defaultMinSpacing;
    }
    if (isNaN(maxSpacing)) {
      maxSpacing = rangeWithBleed;
    }
    if (minSpacing > maxSpacing) {
      if (minSpacing === defaultMinSpacing) {
        minSpacing = maxSpacing;
      } else {
        maxSpacing = minSpacing;
      }
    }
    const minRectDistance = minRect ? this.direction === "x" /* X */ ? minRect.width : minRect.height : 1;
    clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);
    const maxTickCount = clamp(
      1,
      Math.floor(rangeWithBleed / minSpacing),
      clampMaxTickCount ? Math.floor(rangeWithBleed / minRectDistance) : Infinity
    );
    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));
    const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);
    return { minTickCount, maxTickCount, defaultTickCount };
  }
  updateVisibility() {
    if (this.moduleCtx.animationManager.isSkipped()) {
      this.resetSelectionNodes();
    }
    this.tickLineGroup.visible = this.tick.enabled;
    this.gridLineGroup.visible = this.gridLine.enabled;
    this.tickLabelGroup.visible = this.label.enabled;
  }
  updateCrossLines({
    rotation,
    parallelFlipRotation,
    regularFlipRotation
  }) {
    var _a;
    const sideFlag = this.label.getSideFlag();
    const anySeriesActive = this.isAnySeriesActive();
    (_a = this.crossLines) == null ? void 0 : _a.forEach((crossLine) => {
      var _a2;
      crossLine.sideFlag = -sideFlag;
      crossLine.direction = rotation === -Math.PI / 2 ? "x" /* X */ : "y" /* Y */;
      if (crossLine instanceof CartesianCrossLine) {
        crossLine.label.parallel = (_a2 = crossLine.label.parallel) != null ? _a2 : this.label.parallel;
      }
      crossLine.parallelFlipRotation = parallelFlipRotation;
      crossLine.regularFlipRotation = regularFlipRotation;
      crossLine.update(anySeriesActive);
    });
  }
  updateTickLines() {
    const { tick, label } = this;
    const sideFlag = label.getSideFlag();
    this.tickLineGroupSelection.each((line) => {
      line.strokeWidth = tick.width;
      line.stroke = tick.color;
      line.x1 = sideFlag * this.getTickSize();
      line.x2 = 0;
    });
  }
  calculateAvailableRange() {
    return findRangeExtent(this.range);
  }
  /**
   * Calculates the available range with an additional "bleed" beyond the canvas that encompasses the full axis when
   * the visible range is only a portion of the axis.
   */
  calculateRangeWithBleed() {
    const visibleScale = 1 / findRangeExtent(this.visibleRange);
    return round(this.calculateAvailableRange() * visibleScale, 2);
  }
  calculateDomain() {
    const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());
    const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));
    this.setDomain(domains);
  }
  getAxisTransform() {
    return {
      rotation: toRadians(this.rotation),
      rotationCenterX: 0,
      rotationCenterY: 0,
      translationX: Math.floor(this.translation.x),
      translationY: Math.floor(this.translation.y)
    };
  }
  updatePosition() {
    const { crossLineGroup, axisGroup, gridGroup, translation, gridLineGroupSelection, gridPadding, gridLength } = this;
    const { rotation } = this.calculateRotations();
    const sideFlag = this.label.getSideFlag();
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    crossLineGroup.setProperties({ rotation, translationX, translationY });
    gridGroup.setProperties({ rotation, translationX, translationY });
    axisGroup.datum = this.getAxisTransform();
    gridLineGroupSelection.each((line) => {
      line.x1 = gridPadding;
      line.x2 = -sideFlag * gridLength + gridPadding;
    });
  }
  updateSecondaryAxisTicks(_primaryTickCount) {
    throw new Error("AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.");
  }
  updateSelections(lineData, data, params) {
    this.lineNode.datum = lineData;
    this.gridLineGroupSelection.update(
      this.gridLength ? data : [],
      (group2) => group2.append(new Line({ tag: 2 /* GridLine */ })),
      (datum) => datum.tickId
    );
    this.tickLineGroupSelection.update(
      data,
      (group2) => group2.appendChild(new Line({ tag: 0 /* TickLine */ })),
      (datum) => datum.tickId
    );
    this.tickLabelGroupSelection.update(
      data.map((d) => this.getTickLabelProps(d, params)),
      (group2) => group2.appendChild(new Text({ tag: 1 /* TickLabel */ })),
      (datum) => datum.tickId
    );
  }
  updateAxisLine() {
    const { line } = this;
    const strokeWidth = line.enabled ? line.width : 0;
    this.lineNode.setProperties({
      stroke: line.color,
      strokeWidth
    });
  }
  updateGridLines(sideFlag) {
    const {
      gridLine: { style, width },
      gridPadding,
      gridLength
    } = this;
    if (gridLength === 0 || style.length === 0) {
      return;
    }
    this.gridLineGroupSelection.each((line, _, index) => {
      const { stroke, lineDash } = style[index % style.length];
      line.setProperties({
        x1: gridPadding,
        x2: -sideFlag * gridLength + gridPadding,
        fill: void 0,
        stroke,
        strokeWidth: width,
        lineDash
      });
    });
  }
  updateLabels() {
    const { label } = this;
    if (!label.enabled) {
      return;
    }
    this.tickLabelGroupSelection.each((node, datum) => {
      node.setProperties(datum, [
        "fill",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "text",
        "textAlign",
        "textBaseline"
      ]);
    });
  }
  wrapLabels(tickData, index, labelProps) {
    const { parallel, maxWidth, maxHeight } = this.label;
    let defaultMaxWidth = this.maxThickness;
    let defaultMaxHeight = Math.round(this.calculateAvailableRange() / tickData.labelCount);
    if (parallel) {
      [defaultMaxWidth, defaultMaxHeight] = [defaultMaxHeight, defaultMaxWidth];
    }
    tickData.ticks.forEach((tickDatum) => {
      const { text } = Text.wrap(
        tickDatum.tickLabel,
        maxWidth != null ? maxWidth : defaultMaxWidth,
        maxHeight != null ? maxHeight : defaultMaxHeight,
        labelProps,
        "hyphenate"
      );
      tickDatum.tickLabel = text;
    });
    return { tickData, index, autoRotation: 0, terminate: true };
  }
  updateTitle(params) {
    const { rotation, title, _titleCaption, lineNode, tickLineGroup, tickLabelGroup } = this;
    if (!title) {
      _titleCaption.enabled = false;
      return;
    }
    let spacing = 0;
    if (title.enabled && params.anyTickVisible) {
      const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup, lineNode]);
      const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;
      spacing += tickWidth + (!this.tickLabelGroup.visible ? this.seriesAreaPadding : 0);
    }
    this.setTitleProps(_titleCaption, { spacing });
  }
  // For formatting (nice rounded) tick values.
  formatTick(datum, index) {
    var _a, _b;
    const {
      label,
      labelFormatter,
      fractionDigits,
      moduleCtx: { callbackCache }
    } = this;
    if (label.formatter) {
      const value = fractionDigits > 0 ? datum : String(datum);
      return (_a = callbackCache.call(label.formatter, {
        value,
        index,
        fractionDigits,
        formatter: labelFormatter
      })) != null ? _a : value;
    } else if (labelFormatter) {
      return (_b = callbackCache.call(labelFormatter, datum)) != null ? _b : String(datum);
    }
    return String(datum);
  }
  // For formatting arbitrary values between the ticks.
  formatDatum(datum) {
    return String(datum);
  }
  computeBBox() {
    return this.axisGroup.computeBBox();
  }
  initCrossLine(crossLine) {
    crossLine.scale = this.scale;
    crossLine.gridLength = this.gridLength;
  }
  isAnySeriesActive() {
    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());
  }
  clipTickLines(x, y, width, height) {
    this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));
  }
  clipGrid(x, y, width, height) {
    this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));
  }
  calculatePadding(min, max, reverse) {
    const padding = Math.abs(reverse ? max : min) * 0.01;
    return [padding, padding];
  }
  getTitleFormatterParams() {
    var _a;
    const boundSeries = this.boundSeries.reduce((acc, next) => {
      const keys = next.getKeys(this.direction);
      const names = next.getNames(this.direction);
      for (let idx = 0; idx < keys.length; idx++) {
        acc.push({ key: keys[idx], name: names[idx] });
      }
      return acc;
    }, []);
    return {
      direction: this.direction,
      boundSeries,
      defaultValue: (_a = this.title) == null ? void 0 : _a.text
    };
  }
  normaliseDataDomain(d) {
    return { domain: [...d], clipped: false };
  }
  getLayoutState() {
    return __spreadValues({
      rect: this.computeBBox(),
      gridPadding: this.gridPadding,
      seriesAreaPadding: this.seriesAreaPadding,
      tickSize: this.getTickSize()
    }, this.layout);
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    var _a;
    (_a = this.axisContext) != null ? _a : this.axisContext = this.createAxisContext();
    return __spreadProps(__spreadValues({}, this.moduleCtx), { parent: this.axisContext });
  }
  createAxisContext() {
    return {
      axisId: this.id,
      direction: this.direction,
      continuous: ContinuousScale.is(this.scale),
      keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),
      scaleValueFormatter: (specifier) => {
        var _a, _b;
        return (_b = (_a = this.scale).tickFormat) == null ? void 0 : _b.call(_a, { specifier });
      },
      scaleBandwidth: () => {
        var _a;
        return (_a = this.scale.bandwidth) != null ? _a : 0;
      },
      scaleConvert: (val) => this.scale.convert(val),
      scaleInvert: (val) => {
        var _a, _b;
        return (_b = (_a = this.scale).invert) == null ? void 0 : _b.call(_a, val);
      }
    };
  }
  animateReadyUpdate(diff2) {
    const { animationManager } = this.moduleCtx;
    const selectionCtx = prepareAxisAnimationContext(this);
    const fns = prepareAxisAnimationFunctions(selectionCtx);
    fromToMotion(this.id, "axis-group", animationManager, [this.axisGroup], fns.group);
    fromToMotion(this.id, "line", animationManager, [this.lineNode], fns.line);
    fromToMotion(
      this.id,
      "line-paths",
      animationManager,
      [this.gridLineGroupSelection, this.tickLineGroupSelection],
      fns.tick,
      (_, d) => d.tickId,
      diff2
    );
    fromToMotion(
      this.id,
      "tick-labels",
      animationManager,
      [this.tickLabelGroupSelection],
      fns.label,
      (_, d) => d.tickId,
      diff2
    );
  }
  resetSelectionNodes() {
    const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;
    const selectionCtx = prepareAxisAnimationContext(this);
    resetMotion([this.axisGroup], resetAxisGroupFn());
    resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));
    resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());
    resetMotion([lineNode], resetAxisLineSelectionFn());
  }
  calculateUpdateDiff(previous, tickData) {
    const added = /* @__PURE__ */ new Set();
    const removed = /* @__PURE__ */ new Set();
    const tickCount = Math.max(previous.length, tickData.ticks.length);
    for (let i = 0; i < tickCount; i++) {
      const tickDatum = tickData.ticks[i];
      const prev = previous[i];
      const tick = tickDatum == null ? void 0 : tickDatum.tickId;
      if (prev === tick) {
        continue;
      }
      if (removed.has(tick)) {
        removed.delete(tick);
      } else if (tick) {
        added.add(tick);
      }
      if (added.has(prev)) {
        added.delete(prev);
      } else if (prev) {
        removed.add(prev);
      }
    }
    return {
      changed: added.size > 0 || removed.size > 0,
      added: Array.from(added.values()),
      removed: Array.from(removed.values())
    };
  }
  isReversed() {
    return this.reverse;
  }
};
_Axis.defaultTickMinSpacing = 50;
__decorateClass([
  Validate(BOOLEAN)
], _Axis.prototype, "nice", 2);
__decorateClass([
  Validate(BOOLEAN)
], _Axis.prototype, "reverse", 2);
__decorateClass([
  Validate(STRING_ARRAY)
], _Axis.prototype, "keys", 2);
__decorateClass([
  Validate(predicateWithMessage((title) => typeof title == "object", "Title object"), { optional: true })
], _Axis.prototype, "title", 2);
__decorateClass([
  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))
], _Axis.prototype, "gridLength", 2);
var Axis = _Axis;

// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts
var CartesianAxisLabel = class extends AxisLabel {
  constructor() {
    super(...arguments);
    this.autoRotateAngle = 335;
  }
};
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], CartesianAxisLabel.prototype, "autoRotate", 2);
__decorateClass([
  Validate(DEGREE)
], CartesianAxisLabel.prototype, "autoRotateAngle", 2);

// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts
var _CartesianAxis = class _CartesianAxis extends Axis {
  constructor() {
    super(...arguments);
    this.thickness = 0;
    this.position = "left";
  }
  static is(value) {
    return value instanceof _CartesianAxis;
  }
  get direction() {
    return ["top", "bottom"].includes(this.position) ? "x" /* X */ : "y" /* Y */;
  }
  updateDirection() {
    switch (this.position) {
      case "top":
        this.rotation = -90;
        this.label.mirrored = true;
        this.label.parallel = true;
        break;
      case "right":
        this.rotation = 0;
        this.label.mirrored = true;
        this.label.parallel = false;
        break;
      case "bottom":
        this.rotation = -90;
        this.label.mirrored = false;
        this.label.parallel = true;
        break;
      case "left":
        this.rotation = 0;
        this.label.mirrored = false;
        this.label.parallel = false;
        break;
    }
    if (this.axisContext) {
      this.axisContext.position = this.position;
      this.axisContext.direction = this.direction;
    }
  }
  update(primaryTickCount, animated) {
    this.updateDirection();
    return super.update(primaryTickCount, animated);
  }
  calculateLayout(primaryTickCount) {
    this.updateDirection();
    return super.calculateLayout(primaryTickCount);
  }
  createAxisContext() {
    return __spreadProps(__spreadValues({}, super.createAxisContext()), {
      position: this.position
    });
  }
  assignCrossLineArrayConstructor(crossLines) {
    assignJsonApplyConstructedArray(crossLines, CartesianCrossLine);
  }
  createLabel() {
    return new CartesianAxisLabel();
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], _CartesianAxis.prototype, "thickness", 2);
__decorateClass([
  Validate(POSITION2)
], _CartesianAxis.prototype, "position", 2);
var CartesianAxis = _CartesianAxis;

// packages/ag-charts-community/src/chart/axis/categoryAxis.ts
var CategoryAxis = class extends CartesianAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale());
    this._paddingOverrideEnabled = false;
    this.groupPaddingInner = 0.1;
    this.includeInvisibleDomains = true;
  }
  set paddingInner(value) {
    this._paddingOverrideEnabled = true;
    this.scale.paddingInner = value;
  }
  get paddingInner() {
    this._paddingOverrideEnabled = true;
    return this.scale.paddingInner;
  }
  set paddingOuter(value) {
    this.scale.paddingOuter = value;
  }
  get paddingOuter() {
    return this.scale.paddingOuter;
  }
  normaliseDataDomain(d) {
    const domain = [];
    const uniqueValues = /* @__PURE__ */ new Set();
    for (const v of d) {
      const key = v instanceof Date ? v.getTime() : v;
      if (!uniqueValues.has(key)) {
        uniqueValues.add(key);
        domain.push(v);
      }
    }
    return { domain, clipped: false };
  }
  calculateDomain() {
    if (!this._paddingOverrideEnabled) {
      const paddings = this.boundSeries.map((s) => {
        var _a;
        return (_a = s.getBandScalePadding) == null ? void 0 : _a.call(s);
      }).filter((p) => p != null);
      if (paddings.length > 0) {
        this.scale.paddingInner = Math.min(...paddings.map((p) => p.inner));
        this.scale.paddingOuter = Math.max(...paddings.map((p) => p.outer));
      }
    }
    return super.calculateDomain();
  }
};
CategoryAxis.className = "CategoryAxis";
CategoryAxis.type = "category";
__decorateClass([
  Validate(RATIO)
], CategoryAxis.prototype, "groupPaddingInner", 2);

// packages/ag-charts-community/src/chart/axis/tree.ts
var TreeNode = class {
  // current number in sibling group (index)
  constructor(label = "", parent, number = 0) {
    this.x = 0;
    this.y = 0;
    this.subtreeLeft = NaN;
    this.subtreeRight = NaN;
    this.screenX = 0;
    this.screenY = 0;
    this.children = [];
    this.leafCount = 0;
    this.prelim = 0;
    this.mod = 0;
    this.ancestor = this;
    this.change = 0;
    this.shift = 0;
    this.label = label;
    this.parent = parent;
    this.depth = parent ? parent.depth + 1 : 0;
    this.number = number;
  }
  getLeftSibling() {
    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;
  }
  getLeftmostSibling() {
    return this.number > 0 && this.parent ? this.parent.children[0] : void 0;
  }
  // traverse the left contour of a subtree, return the successor of v on this contour
  nextLeft() {
    return this.children ? this.children[0] : this.thread;
  }
  // traverse the right contour of a subtree, return the successor of v on this contour
  nextRight() {
    return this.children ? this.children[this.children.length - 1] : this.thread;
  }
  getSiblings() {
    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];
  }
};
function ticksToTree(ticks, pad2 = true) {
  const root = new TreeNode();
  let depth = 0;
  if (pad2) {
    ticks.forEach((tick) => depth = Math.max(depth, tick.labels.length));
  }
  ticks.forEach((tick) => {
    if (pad2) {
      while (tick.labels.length < depth) {
        tick.labels.unshift("");
      }
    }
    insertTick(root, tick);
  });
  return root;
}
function insertTick(root, tick) {
  const pathParts = tick.labels.slice().reverse();
  const lastPartIndex = pathParts.length - 1;
  pathParts.forEach((pathPart, partIndex) => {
    const children = root.children;
    const existingNode = children.find((child) => child.label === pathPart);
    const isNotLeaf = partIndex !== lastPartIndex;
    if (existingNode && isNotLeaf) {
      root = existingNode;
    } else {
      const node = new TreeNode(pathPart, root);
      node.number = children.length;
      children.push(node);
      if (isNotLeaf) {
        root = node;
      }
    }
  });
}
function moveSubtree(wm, wp, shift) {
  const subtrees = wp.number - wm.number;
  const ratio = shift / subtrees;
  wp.change -= ratio;
  wp.shift += shift;
  wm.change += ratio;
  wp.prelim += shift;
  wp.mod += shift;
}
function ancestor(vim, v, defaultAncestor) {
  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;
}
function executeShifts(v) {
  const children = v.children;
  if (children) {
    let shift = 0;
    let change = 0;
    for (let i = children.length - 1; i >= 0; i--) {
      const w = children[i];
      w.prelim += shift;
      w.mod += shift;
      change += w.change;
      shift += w.shift + change;
    }
  }
}
function apportion(v, defaultAncestor, distance2) {
  const w = v.getLeftSibling();
  if (w) {
    let vop = v;
    let vip = v;
    let vim = w;
    let vom = vip.getLeftmostSibling();
    let sip = vip.mod;
    let sop = vop.mod;
    let sim = vim.mod;
    let som = vom.mod;
    while (vim.nextRight() && vip.nextLeft()) {
      vim = vim.nextRight();
      vip = vip.nextLeft();
      vom = vom.nextLeft();
      vop = vop.nextRight();
      vop.ancestor = v;
      const shift = vim.prelim + sim - (vip.prelim + sip) + distance2;
      if (shift > 0) {
        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);
        sip += shift;
        sop += shift;
      }
      sim += vim.mod;
      sip += vip.mod;
      som += vom.mod;
      sop += vop.mod;
    }
    if (vim.nextRight() && !vop.nextRight()) {
      vop.thread = vim.nextRight();
      vop.mod += sim - sop;
    } else {
      if (vip.nextLeft() && !vom.nextLeft()) {
        vom.thread = vip.nextLeft();
        vom.mod += sip - som;
      }
      defaultAncestor = v;
    }
  }
  return defaultAncestor;
}
function firstWalk(node, distance2) {
  const children = node.children;
  if (children.length) {
    let defaultAncestor = children[0];
    children.forEach((child) => {
      firstWalk(child, distance2);
      defaultAncestor = apportion(child, defaultAncestor, distance2);
    });
    executeShifts(node);
    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;
    const leftSibling = node.getLeftSibling();
    if (leftSibling) {
      node.prelim = leftSibling.prelim + distance2;
      node.mod = node.prelim - midpoint;
    } else {
      node.prelim = midpoint;
    }
  } else {
    const leftSibling = node.getLeftSibling();
    node.prelim = leftSibling ? leftSibling.prelim + distance2 : 0;
  }
}
var Dimensions = class {
  constructor() {
    this.top = Infinity;
    this.right = -Infinity;
    this.bottom = -Infinity;
    this.left = Infinity;
  }
  update(node, xy) {
    const { x, y } = xy(node);
    if (x > this.right) {
      this.right = x;
    }
    if (x < this.left) {
      this.left = x;
    }
    if (y > this.bottom) {
      this.bottom = y;
    }
    if (y < this.top) {
      this.top = y;
    }
  }
};
function secondWalk(v, m, layout) {
  v.x = v.prelim + m;
  v.y = v.depth;
  layout.update(v);
  v.children.forEach((w) => secondWalk(w, m + v.mod, layout));
}
function thirdWalk(v) {
  const children = v.children;
  let leafCount = 0;
  children.forEach((w) => {
    thirdWalk(w);
    if (w.children.length) {
      leafCount += w.leafCount;
    } else {
      leafCount++;
    }
  });
  v.leafCount = leafCount;
  if (children.length) {
    v.subtreeLeft = children[0].subtreeLeft;
    v.subtreeRight = children[v.children.length - 1].subtreeRight;
    v.x = (v.subtreeLeft + v.subtreeRight) / 2;
  } else {
    v.subtreeLeft = v.x;
    v.subtreeRight = v.x;
  }
}
function treeLayout(root) {
  const layout = new TreeLayout();
  firstWalk(root, 1);
  secondWalk(root, -root.prelim, layout);
  thirdWalk(root);
  return layout;
}
var TreeLayout = class {
  constructor() {
    this.dimensions = new Dimensions();
    this.leafCount = 0;
    this.nodes = [];
    // One might want to process leaf nodes separately from the rest of the tree.
    // For example, position labels corresponding to leafs vertically, rather than horizontally.
    this.leafNodes = [];
    this.nonLeafNodes = [];
    this.depth = 0;
  }
  update(node) {
    this.dimensions.update(node, (node2) => ({ x: node2.x, y: node2.y }));
    if (!node.children.length) {
      this.leafCount++;
      this.leafNodes.push(node);
    } else {
      this.nonLeafNodes.push(node);
    }
    if (node.depth > this.depth) {
      this.depth = node.depth;
    }
    this.nodes.push(node);
  }
  resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {
    const xSteps = this.leafCount - 1;
    const ySteps = this.depth;
    const dimensions = this.dimensions;
    let scalingX = 1;
    let scalingY = 1;
    if (width > 0 && xSteps) {
      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;
      const desiredSpacingX = width / xSteps;
      scalingX = desiredSpacingX / existingSpacingX;
      if (flipX) {
        scalingX = -scalingX;
      }
    }
    if (height > 0 && ySteps) {
      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;
      const desiredSpacingY = height / ySteps;
      scalingY = desiredSpacingY / existingSpacingY;
    }
    const screenDimensions = new Dimensions();
    this.nodes.forEach((node) => {
      node.screenX = node.x * scalingX;
      node.screenY = node.y * scalingY;
      screenDimensions.update(node, (node2) => ({ x: node2.screenX, y: node2.screenY }));
    });
    const offsetX = -screenDimensions.left;
    const offsetY = -screenDimensions.top;
    this.nodes.forEach((node) => {
      node.screenX += offsetX + shiftX;
      node.screenY += offsetY + shiftY;
    });
  }
};

// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts
var GroupedCategoryAxisLabel = class extends AxisLabel {
  constructor() {
    super(...arguments);
    this.grid = false;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], GroupedCategoryAxisLabel.prototype, "grid", 2);
var GroupedCategoryAxis = class extends CartesianAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale());
    // Label scale (labels are positioned between ticks, tick count = label count + 1).
    // We don't call is `labelScale` for consistency with other axes.
    this.tickScale = new BandScale();
    this.line = new AxisLine();
    this.label = new GroupedCategoryAxisLabel();
    this.labelColor = "rgba(87, 87, 87, 1)";
    this.includeInvisibleDomains = true;
    const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale, scale: scale2 } = this;
    scale2.paddingOuter = 0.1;
    scale2.paddingInner = scale2.paddingOuter * 2;
    this.refreshScale();
    tickScale.paddingInner = 1;
    tickScale.paddingOuter = 0;
    this.gridLineSelection = Selection.select(gridLineGroup, Line);
    this.axisLineSelection = Selection.select(tickLineGroup, Line);
    this.separatorSelection = Selection.select(tickLineGroup, Line);
    this.labelSelection = Selection.select(tickLabelGroup, Text);
  }
  updateRange() {
    const { range: rr, visibleRange: vr, scale: scale2 } = this;
    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const shift = span * vr[0];
    const start = rr[0] - shift;
    this.tickScale.range = scale2.range = [start, start + span];
    this.resizeTickTree();
  }
  resizeTickTree() {
    var _a;
    const s = this.scale;
    const range3 = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;
    const layout = this.tickTreeLayout;
    const lineHeight = this.lineHeight;
    if (layout) {
      layout.resize(
        Math.abs(range3[1] - range3[0]),
        layout.depth * lineHeight,
        (Math.min(range3[0], range3[1]) || 0) + ((_a = s.bandwidth) != null ? _a : 0) / 2,
        -layout.depth * lineHeight,
        range3[1] - range3[0] < 0
      );
    }
  }
  get lineHeight() {
    return this.label.fontSize * 1.5;
  }
  /**
   * The length of the grid. The grid is only visible in case of a non-zero value.
   */
  onGridVisibilityChange() {
    this.gridLineSelection.clear();
    this.labelSelection.clear();
  }
  calculateDomain() {
    var _a;
    const { direction } = this;
    let isNumericX = null;
    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => {
      if (direction === "y" /* Y */ || isNumericX) {
        return series.getDomain(direction);
      }
      if (isNumericX === null) {
        const domain2 = series.getDomain(direction);
        isNumericX = isNumber(domain2[0]);
        return domain2;
      }
      return [];
    });
    this.setDomain((_a = extent(flatDomains)) != null ? _a : unique(flatDomains));
    const { domain } = this.dataDomain;
    this.tickTreeLayout = treeLayout(ticksToTree(domain));
    this.tickScale.domain = domain.concat("");
    this.resizeTickTree();
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   * Supposed to be called _manually_ after changing _any_ of the axis properties.
   * This allows to bulk set axis properties before updating the nodes.
   * The node changes made by this method are rendered on the next animation frame.
   * We could schedule this method call automatically on the next animation frame
   * when any of the axis properties change (the way we do when properties of scene graph's
   * nodes change), but this will mean that we first wait for the next animation
   * frame to make changes to the nodes of the axis, then wait for another animation
   * frame to render those changes. It's nice to have everything update automatically,
   * but this extra level of async indirection will not just introduce an unwanted delay,
   * it will also make it harder to reason about the program.
   */
  update() {
    if (!this.computedLayout) {
      return;
    }
    this.updatePosition();
    this.updateTitleCaption();
    this.updateCategoryLabels();
    this.updateSeparators();
    this.updateAxisLines();
    this.updateCategoryGridLines();
    this.resetSelectionNodes();
    return void 0;
  }
  updateTitleCaption() {
    const { _titleCaption } = this;
    _titleCaption.node.visible = false;
  }
  updateCategoryLabels() {
    if (!this.computedLayout)
      return;
    const { tickLabelLayout } = this.computedLayout;
    const labelSelection = this.labelSelection.update(tickLabelLayout);
    labelSelection.each((node, datum) => {
      node.setProperties(datum);
    });
  }
  updateSeparators() {
    if (!this.computedLayout)
      return;
    const { separatorLayout } = this.computedLayout;
    const { range: range3 } = this;
    const epsilon2 = 1e-7;
    const separatorSelection = this.separatorSelection.update(separatorLayout);
    separatorSelection.each((line, datum) => {
      line.x1 = datum.x1;
      line.x2 = datum.x2;
      line.y1 = datum.y;
      line.y2 = datum.y;
      line.visible = datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2;
      line.stroke = this.tick.color;
      line.fill = void 0;
      line.strokeWidth = 1;
    });
  }
  updateAxisLines() {
    if (!this.computedLayout)
      return;
    const { axisLineLayout } = this.computedLayout;
    const axisLineSelection = this.axisLineSelection.update(axisLineLayout);
    axisLineSelection.each((line, datum) => {
      line.setProperties(__spreadProps(__spreadValues({}, datum), {
        stroke: this.line.color,
        strokeWidth: this.line.width
      }));
      line.x1 = datum.x;
      line.x2 = datum.x;
      line.y1 = datum.y1;
      line.y2 = datum.y2;
      line.strokeWidth = this.line.width;
      line.stroke = this.line.color;
    });
  }
  updateCategoryGridLines() {
    const { gridLength, gridLine, label, range: range3, tickScale } = this;
    const ticks = tickScale.ticks();
    const sideFlag = label.getSideFlag();
    const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);
    if (gridLength) {
      const { width, style } = gridLine;
      const styleCount = style.length;
      gridSelection.each((line, datum, index) => {
        const y = Math.round(tickScale.convert(datum));
        line.x1 = 0;
        line.x2 = -sideFlag * gridLength;
        line.y1 = y;
        line.y2 = y;
        line.visible = y >= range3[0] && y <= range3[1];
        const { stroke, lineDash } = style[index % styleCount];
        line.stroke = stroke;
        line.strokeWidth = width;
        line.lineDash = lineDash;
        line.fill = void 0;
      });
    }
  }
  computeLayout() {
    this.updateDirection();
    this.calculateDomain();
    this.updateRange();
    const {
      scale: scale2,
      label,
      label: { parallel },
      moduleCtx: { callbackCache },
      range: range3,
      title,
      title: { formatter = (p) => p.defaultValue } = {}
    } = this;
    const rangeStart = scale2.range[0];
    const rangeEnd = scale2.range[1];
    const rangeLength = Math.abs(rangeEnd - rangeStart);
    const bandwidth = rangeLength / scale2.domain.length || 0;
    const keepEvery = Math.ceil(label.fontSize / bandwidth);
    const rotation = toRadians(this.rotation);
    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;
    const sideFlag = label.getSideFlag();
    const lineHeight = this.lineHeight;
    const tickTreeLayout = this.tickTreeLayout;
    const labels = scale2.ticks();
    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];
    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;
    const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({
      rotation: label.rotation,
      parallel,
      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),
      parallelFlipRotation: normalizeAngle360(rotation)
    });
    const tickLabelLayout = [];
    const copyLabelProps = (node) => {
      return {
        fill: node.fill,
        fontFamily: node.fontFamily,
        fontSize: node.fontSize,
        fontStyle: node.fontStyle,
        fontWeight: node.fontWeight,
        rotation: node.rotation,
        rotationCenterX: node.rotationCenterX,
        rotationCenterY: node.rotationCenterY,
        text: node.text,
        textAlign: node.textAlign,
        textBaseline: node.textBaseline,
        translationX: node.translationX,
        translationY: node.translationY,
        visible: node.visible,
        x: node.x,
        y: node.y
      };
    };
    const labelBBoxes = /* @__PURE__ */ new Map();
    let maxLeafLabelWidth = 0;
    const tempText = new Text();
    const setLabelProps = (datum, index) => {
      var _a;
      tempText.setProperties({
        fill: label.color,
        fontFamily: label.fontFamily,
        fontSize: label.fontSize,
        fontStyle: label.fontStyle,
        fontWeight: label.fontWeight,
        textAlign: "center",
        textBaseline: parallelFlipFlag === -1 ? "bottom" : "hanging",
        translationX: datum.screenY - label.fontSize * 0.25,
        translationY: datum.screenX
      });
      if (index === 0) {
        const isCaptionEnabled = (title == null ? void 0 : title.enabled) && labels.length > 0;
        if (!isCaptionEnabled) {
          return false;
        }
        const text = callbackCache.call(formatter, this.getTitleFormatterParams());
        tempText.setProperties({
          fill: title.color,
          fontFamily: title.fontFamily,
          fontSize: title.fontSize,
          fontStyle: title.fontStyle,
          fontWeight: title.fontWeight,
          text,
          textBaseline: "hanging",
          translationX: datum.screenY - label.fontSize * 0.25,
          translationY: datum.screenX
        });
      } else if (index % keepEvery !== 0) {
        return false;
      } else {
        const isInRange = datum.screenX >= range3[0] && datum.screenX <= range3[1];
        if (!isInRange) {
          return false;
        }
        if (label.formatter) {
          tempText.text = (_a = callbackCache.call(label.formatter, {
            value: String(datum.label),
            index
          })) != null ? _a : String(datum.label);
        } else {
          tempText.text = String(datum.label);
        }
      }
      return true;
    };
    treeLabels.forEach((datum, index) => {
      const isVisible = setLabelProps(datum, index);
      if (!isVisible)
        return;
      const bbox2 = tempText.computeTransformedBBox();
      if (!bbox2)
        return;
      labelBBoxes.set(index, bbox2);
      const isLeaf = !datum.children.length;
      if (isLeaf && bbox2.width > maxLeafLabelWidth) {
        maxLeafLabelWidth = bbox2.width;
      }
    });
    const labelX = sideFlag * label.padding;
    const labelGrid = this.label.grid;
    const separatorData = [];
    treeLabels.forEach((datum, index) => {
      let visible = setLabelProps(datum, index);
      const id = index;
      tempText.x = labelX;
      tempText.rotationCenterX = labelX;
      const isLeaf = !datum.children.length;
      if (isLeaf) {
        tempText.rotation = configuredRotation;
        tempText.textAlign = "end";
        tempText.textBaseline = "middle";
      } else {
        tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;
        const availableRange = datum.leafCount * bandwidth;
        const bbox2 = labelBBoxes.get(id);
        if (bbox2 && bbox2.width > availableRange) {
          visible = false;
          labelBBoxes.delete(id);
        } else if (isHorizontal) {
          tempText.rotation = defaultRotation;
        } else {
          tempText.rotation = -Math.PI / 2;
        }
      }
      if (datum.parent && isLabelTree) {
        const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;
        if (isLeaf) {
          if (datum.number !== datum.children.length - 1 || labelGrid) {
            separatorData.push({
              y,
              x1: 0,
              x2: -maxLeafLabelWidth - this.label.padding * 2
            });
          }
        } else {
          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;
          separatorData.push({
            y,
            x1: x + lineHeight,
            x2: x
          });
        }
      }
      let props;
      if (visible) {
        const bbox2 = tempText.computeTransformedBBox();
        if (bbox2) {
          labelBBoxes.set(index, bbox2);
        }
        props = __spreadProps(__spreadValues({}, copyLabelProps(tempText)), { visible });
      } else {
        labelBBoxes.delete(index);
        props = { visible };
      }
      tickLabelLayout.push(props);
    });
    let minX = 0;
    separatorData.forEach((d) => minX = Math.min(minX, d.x2));
    separatorData.push({
      y: Math.max(rangeStart, rangeEnd),
      x1: 0,
      x2: minX
    });
    const separatorLayout = [];
    const separatorBoxes = [];
    const epsilon2 = 1e-7;
    separatorData.forEach((datum) => {
      if (datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2) {
        const { x1, x2, y } = datum;
        const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);
        separatorBoxes.push(separatorBox);
        separatorLayout.push({ x1, x2, y });
      }
    });
    const axisLineLayout = [];
    const axisLineBoxes = [];
    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;
    for (let i = 0; i < lineCount; i++) {
      const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);
      const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;
      const lineBox = new BBox(x, Math.min(...range3), 0, Math.abs(range3[1] - range3[0]));
      axisLineBoxes.push(lineBox);
      axisLineLayout.push({ x, y1: range3[0], y2: range3[1], visible });
    }
    const getTransformBox = (bbox2) => {
      const matrix = new Matrix();
      const {
        rotation: axisRotation,
        translationX,
        translationY,
        rotationCenterX,
        rotationCenterY
      } = this.getAxisTransform();
      Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {
        scalingCenterX: 0,
        scalingCenterY: 0,
        rotationCenterX,
        rotationCenterY
      });
      return matrix.transformBBox(bbox2);
    };
    const bbox = BBox.merge([...labelBBoxes.values(), ...separatorBoxes, ...axisLineBoxes]);
    const transformedBBox = getTransformBox(bbox);
    return {
      bbox: transformedBBox,
      tickLabelLayout,
      separatorLayout,
      axisLineLayout
    };
  }
  calculateLayout() {
    const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();
    this.computedLayout = {
      axisLineLayout,
      separatorLayout,
      tickLabelLayout
    };
    return { bbox, primaryTickCount: void 0 };
  }
};
GroupedCategoryAxis.className = "GroupedCategoryAxis";
GroupedCategoryAxis.type = "grouped-category";
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], GroupedCategoryAxis.prototype, "labelColor", 2);

// packages/ag-charts-community/src/scene/canvas/hdpiOffscreenCanvas.ts
var HdpiOffscreenCanvas = class {
  // The width/height attributes of the Canvas element default to
  // 300/150 according to w3.org.
  constructor({ width = 600, height = 300, overrideDevicePixelRatio }) {
    this.enabled = true;
    // `NaN` is deliberate here, so that overrides are always applied
    // and the `resetTransform` inside the `resize` method works in IE11.
    this._pixelRatio = NaN;
    this._width = 0;
    this._height = 0;
    this.canvas = new OffscreenCanvas(width, height);
    this.realContext = this.canvas.getContext("2d");
    this.imageSource = this.canvas.transferToImageBitmap();
    this.context = this.setPixelRatio(overrideDevicePixelRatio);
    this.resize(width, height);
  }
  static isSupported() {
    return typeof OffscreenCanvas !== "undefined" && OffscreenCanvas.prototype.transferToImageBitmap != null;
  }
  snapshot() {
    this.imageSource.close();
    this.imageSource = this.canvas.transferToImageBitmap();
  }
  destroy() {
    this.imageSource.close();
    this.canvas.width = 0;
    this.canvas.height = 0;
    this.context.clearRect(0, 0, 0, 0);
  }
  clear() {
    this.context.save();
    this.context.resetTransform();
    this.context.clearRect(0, 0, this.width, this.height);
    this.context.restore();
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  /**
   * Changes the pixel ratio of the Canvas element to the given value,
   * or uses the window.devicePixelRatio (default), then resizes the Canvas
   * element accordingly (default).
   */
  setPixelRatio(ratio) {
    let pixelRatio = ratio != null ? ratio : window.devicePixelRatio;
    if (hasConstrainedCanvasMemory()) {
      pixelRatio = 1;
    }
    this._pixelRatio = pixelRatio;
    return HdpiCanvas.overrideScale(this.realContext, pixelRatio);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  resize(width, height) {
    if (!(width > 0 && height > 0)) {
      return;
    }
    const { canvas, context, pixelRatio } = this;
    canvas.width = Math.round(width * pixelRatio);
    canvas.height = Math.round(height * pixelRatio);
    context.resetTransform();
    this._width = width;
    this._height = height;
  }
};

// packages/ag-charts-community/src/scene/scene.ts
var advancedCompositeIdentifier = "adv-composite";
var domCompositeIdentifier = "dom-composite";
var Scene = class {
  constructor(opts) {
    this.id = createId(this);
    this.layers = [];
    this._nextZIndex = 0;
    this._nextLayerId = 0;
    this._dirty = false;
    this._root = null;
    this.debug = Debug.create(true, "scene" /* SCENE */);
    var _a;
    const {
      document: document2,
      window: window2,
      mode = (_a = windowValue("agChartsSceneRenderModel")) != null ? _a : advancedCompositeIdentifier,
      width,
      height,
      overrideDevicePixelRatio = void 0
    } = opts;
    this.overrideDevicePixelRatio = overrideDevicePixelRatio;
    this.opts = { document: document2, window: window2, mode };
    this.canvas = new HdpiCanvas({ document: document2, window: window2, width, height, overrideDevicePixelRatio });
  }
  set container(value) {
    this.canvas.container = value;
  }
  get container() {
    return this.canvas.container;
  }
  download(fileName, fileFormat) {
    this.canvas.download(fileName, fileFormat);
  }
  /** NOTE: Integrated Charts undocumented image download method. */
  getDataURL(type) {
    return this.canvas.getDataURL(type);
  }
  get width() {
    return this.pendingSize ? this.pendingSize[0] : this.canvas.width;
  }
  get height() {
    return this.pendingSize ? this.pendingSize[1] : this.canvas.height;
  }
  resize(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    const lessThanZero = width <= 0 || height <= 0;
    const nan = isNaN(width) || isNaN(height);
    const unchanged = width === this.width && height === this.height;
    if (unchanged || nan || lessThanZero) {
      return false;
    }
    this.pendingSize = [width, height];
    this.markDirty();
    return true;
  }
  addLayer(opts) {
    var _a;
    const { mode } = this.opts;
    const layeredModes = ["composite", domCompositeIdentifier, advancedCompositeIdentifier];
    if (!layeredModes.includes(mode)) {
      return void 0;
    }
    const { zIndex = this._nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;
    const { width, height, overrideDevicePixelRatio } = this;
    const domLayer = mode === domCompositeIdentifier;
    const advLayer = mode === advancedCompositeIdentifier;
    const canvas = !advLayer || !HdpiOffscreenCanvas.isSupported() ? new HdpiCanvas({
      document: this.opts.document,
      window: this.opts.window,
      width,
      height,
      domLayer,
      zIndex,
      name,
      overrideDevicePixelRatio
    }) : new HdpiOffscreenCanvas({
      width,
      height,
      overrideDevicePixelRatio
    });
    const newLayer = {
      id: this._nextLayerId++,
      name,
      zIndex,
      zIndexSubOrder,
      canvas,
      getComputedOpacity,
      getVisibility
    };
    if (zIndex >= this._nextZIndex) {
      this._nextZIndex = zIndex + 1;
    }
    this.layers.push(newLayer);
    this.sortLayers();
    if (domLayer) {
      const domCanvases = this.layers.map((v) => v.canvas).filter((v) => v instanceof HdpiCanvas);
      const newLayerIndex = domCanvases.findIndex((v) => v === canvas);
      const lastLayer = (_a = domCanvases[newLayerIndex - 1]) != null ? _a : this.canvas;
      lastLayer.element.insertAdjacentElement("afterend", canvas.element);
    }
    this.debug("Scene.addLayer() - layers", this.layers);
    return newLayer.canvas;
  }
  removeLayer(canvas) {
    const index = this.layers.findIndex((l) => l.canvas === canvas);
    if (index >= 0) {
      this.layers.splice(index, 1);
      canvas.destroy();
      this.markDirty();
      this.debug("Scene.removeLayer() -  layers", this.layers);
    }
  }
  moveLayer(canvas, newZIndex, newZIndexSubOrder) {
    const layer = this.layers.find((l) => l.canvas === canvas);
    if (layer) {
      layer.zIndex = newZIndex;
      layer.zIndexSubOrder = newZIndexSubOrder;
      this.sortLayers();
      this.markDirty();
      this.debug("Scene.moveLayer() -  layers", this.layers);
    }
  }
  sortLayers() {
    this.layers.sort((a, b) => {
      var _a, _b;
      return compoundAscending(
        [a.zIndex, ...(_a = a.zIndexSubOrder) != null ? _a : [void 0, void 0], a.id],
        [b.zIndex, ...(_b = b.zIndexSubOrder) != null ? _b : [void 0, void 0], b.id],
        ascendingStringNumberUndefined
      );
    });
  }
  markDirty() {
    this._dirty = true;
  }
  get dirty() {
    return this._dirty;
  }
  set root(node) {
    var _a;
    if (node === this._root) {
      return;
    }
    (_a = this._root) == null ? void 0 : _a._setLayerManager();
    this._root = node;
    if (node) {
      node._setLayerManager({
        addLayer: (opts) => this.addLayer(opts),
        moveLayer: (...opts) => this.moveLayer(...opts),
        removeLayer: (...opts) => this.removeLayer(...opts),
        markDirty: () => this.markDirty(),
        canvas: this.canvas,
        debug: Debug.create("scene" /* SCENE */)
      });
    }
    this.markDirty();
  }
  get root() {
    return this._root;
  }
  /** Alternative to destroy() that preserves re-usable resources. */
  strip() {
    const { layers } = this;
    for (const layer of layers) {
      layer.canvas.destroy();
      delete layer["canvas"];
    }
    layers.splice(0, layers.length);
    this.root = null;
    this._dirty = false;
    this.canvas.context.resetTransform();
  }
  destroy() {
    this.container = void 0;
    this.strip();
    this.canvas.destroy();
    Object.assign(this, { canvas: void 0, ctx: void 0 });
  }
  render(opts) {
    return __async(this, null, function* () {
      var _a, _b;
      const { debugSplitTimes = { start: performance.now() }, extraDebugStats = {} } = opts != null ? opts : {};
      const {
        canvas,
        canvas: { context: ctx },
        root,
        layers,
        pendingSize,
        opts: { mode }
      } = this;
      if (pendingSize) {
        this.canvas.resize(...pendingSize);
        this.layers.forEach((layer) => layer.canvas.resize(...pendingSize));
        this.pendingSize = void 0;
      }
      if (root && !root.visible) {
        this._dirty = false;
        return;
      }
      if (root && !this.dirty) {
        this.debug("Scene.render() - no-op", {
          redrawType: RedrawType[root.dirty],
          tree: this.buildTree(root)
        });
        this.debugStats(debugSplitTimes, ctx, void 0, extraDebugStats);
        return;
      }
      const renderCtx = {
        ctx,
        devicePixelRatio: (_a = this.canvas.pixelRatio) != null ? _a : 1,
        forceRender: true,
        resized: !!pendingSize,
        debugNodes: {}
      };
      if (Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */)) {
        renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };
      }
      let canvasCleared = false;
      if (!root || root.dirty >= 1 /* TRIVIAL */) {
        canvasCleared = true;
        canvas.clear();
      }
      if (root && Debug.check("scene:dirtyTree" /* SCENE_DIRTY_TREE */)) {
        const { dirtyTree, paths } = this.buildDirtyTree(root);
        Debug.create("scene:dirtyTree" /* SCENE_DIRTY_TREE */)("Scene.render() - dirtyTree", {
          dirtyTree,
          paths
        });
      }
      if (root && canvasCleared) {
        this.debug("Scene.render() - before", {
          redrawType: RedrawType[root.dirty],
          canvasCleared,
          tree: this.buildTree(root)
        });
        if (root.visible) {
          ctx.save();
          root.render(renderCtx);
          ctx.restore();
        }
      }
      debugSplitTimes["\u270D\uFE0F"] = performance.now();
      if (mode !== domCompositeIdentifier && layers.length > 0 && canvasCleared) {
        this.sortLayers();
        ctx.save();
        ctx.setTransform(1 / canvas.pixelRatio, 0, 0, 1 / canvas.pixelRatio, 0, 0);
        layers.forEach(({ canvas: { imageSource, enabled }, getComputedOpacity, getVisibility }) => {
          if (!enabled || !getVisibility()) {
            return;
          }
          ctx.globalAlpha = getComputedOpacity();
          ctx.drawImage(imageSource, 0, 0);
        });
        ctx.restore();
        debugSplitTimes["\u26D9"] = performance.now();
      }
      (_b = ctx.verifyDepthZero) == null ? void 0 : _b.call(ctx);
      this._dirty = false;
      this.debugStats(debugSplitTimes, ctx, renderCtx.stats, extraDebugStats);
      this.debugSceneNodeHighlight(ctx, renderCtx.debugNodes);
      if (root) {
        this.debug("Scene.render() - after", {
          redrawType: RedrawType[root.dirty],
          canvasCleared,
          tree: this.buildTree(root)
        });
      }
    });
  }
  debugStats(debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}) {
    if (Debug.check("scene:stats" /* SCENE_STATS */, "scene:stats:verbose" /* SCENE_STATS_VERBOSE */)) {
      const end = performance.now();
      const start = debugSplitTimes["start"];
      debugSplitTimes["end"] = performance.now();
      const pct = (rendered, skipped) => {
        const total = rendered + skipped;
        return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;
      };
      const time = (name, start2, end2) => {
        return `${name}: ${Math.round((end2 - start2) * 100) / 100}ms`;
      };
      const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats != null ? renderCtxStats : {};
      let lastSplit = 0;
      const splits = Object.entries(debugSplitTimes).filter(([n]) => n !== "end").map(([n, t], i) => {
        const result = i > 0 ? time(n, lastSplit, t) : null;
        lastSplit = t;
        return result;
      }).filter((v) => v != null).join(" + ");
      const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(" ; ");
      const detailedStats = Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */);
      const stats = [
        `${time("\u23F1\uFE0F", start, end)} (${splits})`,
        `${extras}`,
        `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : this.layers.length}`,
        detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null
      ].filter((v) => v != null);
      const statsSize = stats.map((t) => [t, HdpiCanvas.getTextSize(t, ctx.font)]);
      const width = Math.max(...statsSize.map(([, { width: width2 }]) => width2));
      const height = statsSize.reduce((total, [, { height: height2 }]) => total + height2, 0);
      ctx.save();
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, width, height);
      ctx.fillStyle = "black";
      let y = 0;
      for (const [stat, size] of statsSize) {
        y += size.height;
        ctx.fillText(stat, 2, y);
      }
      ctx.restore();
    }
  }
  debugSceneNodeHighlight(ctx, debugNodes) {
    var _a;
    const regexpPredicate = (matcher) => (n) => {
      if (matcher.test(n.id)) {
        return true;
      }
      return n instanceof Group && n.name != null && matcher.test(n.name);
    };
    const stringPredicate = (match) => (n) => {
      if (match === n.id) {
        return true;
      }
      return n instanceof Group && n.name != null && match === n.name;
    };
    const sceneNodeHighlight = toArray(windowValue("agChartsSceneDebug")).flatMap(
      (name) => name === "layout" ? ["seriesRoot", "legend", "root", /.*Axis-\d+-axis.*/] : name
    );
    for (const next of sceneNodeHighlight) {
      if (typeof next === "string" && debugNodes[next] != null)
        continue;
      const predicate = typeof next === "string" ? stringPredicate(next) : regexpPredicate(next);
      const nodes = (_a = this.root) == null ? void 0 : _a.findNodes(predicate);
      if (!nodes || nodes.length === 0) {
        Logger.log(`Scene.render() - no debugging node with id [${next}] in scene graph.`);
        continue;
      }
      for (const node of nodes) {
        if (node instanceof Group && node.name) {
          debugNodes[node.name] = node;
        } else {
          debugNodes[node.id] = node;
        }
      }
    }
    ctx.save();
    for (const [name, node] of Object.entries(debugNodes)) {
      const bbox = node.computeTransformedBBox();
      if (!bbox) {
        Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);
        continue;
      }
      ctx.globalAlpha = 0.8;
      ctx.strokeStyle = "red";
      ctx.lineWidth = 1;
      ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
      ctx.fillStyle = "red";
      ctx.strokeStyle = "white";
      ctx.font = "16px sans-serif";
      ctx.textBaseline = "top";
      ctx.textAlign = "left";
      ctx.lineWidth = 2;
      ctx.strokeText(name, bbox.x, bbox.y, bbox.width);
      ctx.fillText(name, bbox.x, bbox.y, bbox.width);
    }
    ctx.restore();
  }
  buildTree(node) {
    var _a, _b;
    const name = (_a = node instanceof Group ? node.name : null) != null ? _a : node.id;
    if (!this.debug.check()) {
      return {};
    }
    return __spreadValues(__spreadValues({
      name,
      node,
      dirty: RedrawType[node.dirty]
    }, ((_b = node.parent) == null ? void 0 : _b.isVirtual) ? {
      virtualParentDirty: RedrawType[node.parent.dirty],
      virtualParent: node.parent
    } : {}), node.children.map((c) => this.buildTree(c)).reduce((result, childTree) => {
      let { name: treeNodeName } = childTree;
      const {
        node: { visible, opacity, zIndex, zIndexSubOrder },
        node: childNode,
        virtualParent
      } = childTree;
      if (!visible || opacity <= 0) {
        treeNodeName = `(${treeNodeName})`;
      }
      if (childNode instanceof Group && childNode.isLayer()) {
        treeNodeName = `*${treeNodeName}*`;
      }
      const key = [
        `${treeNodeName != null ? treeNodeName : "<unknown>"}`,
        `z: ${zIndex}`,
        zIndexSubOrder && `zo: ${zIndexSubOrder.map((v) => typeof v === "function" ? `${v()} (fn)` : v).join(" / ")}`,
        virtualParent && `(virtual parent)`
      ].filter((v) => !!v).join(" ");
      let selectedKey = key;
      let index = 1;
      while (result[selectedKey] != null && index < 100) {
        selectedKey = `${key} (${index++})`;
      }
      result[selectedKey] = childTree;
      return result;
    }, {}));
  }
  buildDirtyTree(node) {
    var _a;
    if (node.dirty === 0 /* NONE */) {
      return { dirtyTree: {}, paths: [] };
    }
    const childrenDirtyTree = node.children.map((c) => this.buildDirtyTree(c)).filter((c) => c.paths.length > 0);
    const name = (_a = node instanceof Group ? node.name : null) != null ? _a : node.id;
    const paths = childrenDirtyTree.length === 0 ? [name] : childrenDirtyTree.map((c) => c.paths).reduce((r, p) => r.concat(p), []).map((p) => `${name}.${p}`);
    return {
      dirtyTree: __spreadValues({
        name,
        node,
        dirty: RedrawType[node.dirty]
      }, childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty !== void 0).reduce((result, childTree) => {
        var _a2;
        result[(_a2 = childTree.name) != null ? _a2 : "<unknown>"] = childTree;
        return result;
      }, {})),
      paths
    };
  }
};
Scene.className = "Scene";

// packages/ag-charts-community/src/util/async.ts
function sleep(sleepTimeoutMs) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(void 0), sleepTimeoutMs);
  });
}

// packages/ag-charts-community/src/util/callbackCache.ts
var CallbackCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
  call(fn, ...params) {
    let serialisedParams;
    let paramCache = this.cache.get(fn);
    const invoke = () => {
      try {
        const result = fn(...params);
        if (paramCache && serialisedParams != null) {
          paramCache.set(serialisedParams, result);
        }
        return result;
      } catch (e) {
        Logger.warnOnce(`User callback errored, ignoring`, e);
        return void 0;
      }
    };
    try {
      serialisedParams = JSON.stringify(params);
    } catch (e) {
      return invoke();
    }
    if (paramCache == null) {
      paramCache = /* @__PURE__ */ new Map();
      this.cache.set(fn, paramCache);
    }
    if (!paramCache.has(serialisedParams)) {
      return invoke();
    }
    return paramCache.get(serialisedParams);
  }
  invalidateCache() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
};

// packages/ag-charts-community/src/util/mutex.ts
var Mutex = class {
  constructor() {
    this.available = true;
    this.acquireQueue = [];
  }
  acquire(cb) {
    return new Promise((resolve) => {
      this.acquireQueue.push([cb, resolve]);
      if (this.available) {
        this.dispatchNext();
      }
    });
  }
  acquireImmediately(cb) {
    return __async(this, null, function* () {
      if (!this.available) {
        return false;
      }
      yield this.acquire(cb);
      return true;
    });
  }
  waitForClearAcquireQueue() {
    return __async(this, null, function* () {
      return this.acquire(() => __async(this, null, function* () {
        return void 0;
      }));
    });
  }
  dispatchNext() {
    return __async(this, null, function* () {
      var _a, _b;
      this.available = false;
      let [next, done] = (_a = this.acquireQueue.shift()) != null ? _a : [];
      while (next) {
        try {
          yield next();
          done == null ? void 0 : done();
        } catch (error) {
          Logger.error("mutex callback error", error);
          done == null ? void 0 : done();
        }
        [next, done] = (_b = this.acquireQueue.shift()) != null ? _b : [];
      }
      this.available = true;
    });
  }
};

// packages/ag-charts-community/src/util/observable.ts
var Observable = class {
  constructor() {
    this.eventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(eventType, listener) {
    if (typeof listener !== "function") {
      throw new Error("AG Charts - listener must be a Function");
    }
    const eventTypeListeners = this.eventListeners.get(eventType);
    if (eventTypeListeners) {
      eventTypeListeners.add(listener);
    } else {
      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));
    }
  }
  removeEventListener(type, listener) {
    var _a;
    (_a = this.eventListeners.get(type)) == null ? void 0 : _a.delete(listener);
    if (this.eventListeners.size === 0) {
      this.eventListeners.delete(type);
    }
  }
  hasEventListener(type) {
    return this.eventListeners.has(type);
  }
  clearEventListeners() {
    this.eventListeners.clear();
  }
  fireEvent(event) {
    var _a;
    (_a = this.eventListeners.get(event.type)) == null ? void 0 : _a.forEach((listener) => listener(event));
  }
};

// packages/ag-charts-community/src/util/padding.ts
var Padding = class extends BaseProperties {
  constructor(top = 0, right = top, bottom = top, left = right) {
    super();
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
  }
  clear() {
    this.top = this.right = this.bottom = this.left = 0;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Padding.prototype, "top", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Padding.prototype, "right", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Padding.prototype, "bottom", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Padding.prototype, "left", 2);

// packages/ag-charts-community/src/util/render.ts
function debouncedAnimationFrame(cb) {
  return buildScheduler((cb2, _delayMs) => requestAnimationFrame(cb2), cb);
}
function debouncedCallback(cb) {
  return buildScheduler((cb2, delayMs = 0) => setTimeout(cb2, delayMs), cb);
}
function buildScheduler(scheduleFn, cb) {
  let scheduleCount = 0;
  let promiseRunning = false;
  let awaitingPromise;
  let awaitingDone;
  const busy = () => {
    return promiseRunning;
  };
  const done = () => {
    promiseRunning = false;
    awaitingDone == null ? void 0 : awaitingDone();
    awaitingDone = void 0;
    awaitingPromise = void 0;
    if (scheduleCount > 0) {
      scheduleFn(scheduleCb);
    }
  };
  const scheduleCb = () => {
    const count2 = scheduleCount;
    scheduleCount = 0;
    promiseRunning = true;
    const maybePromise = cb({ count: count2 });
    if (!maybePromise) {
      done();
      return;
    }
    maybePromise.then(done, done);
  };
  return {
    schedule(delayMs) {
      if (scheduleCount === 0 && !busy()) {
        scheduleFn(scheduleCb, delayMs);
      }
      scheduleCount++;
    },
    await() {
      return __async(this, null, function* () {
        if (!busy()) {
          return;
        }
        if (awaitingPromise == null) {
          awaitingPromise = new Promise((resolve) => {
            awaitingDone = resolve;
          });
        }
        while (busy()) {
          yield awaitingPromise;
        }
      });
    }
  };
}

// packages/ag-charts-community/src/util/sizeMonitor.ts
var _SizeMonitor = class _SizeMonitor {
  static init(document2) {
    if (typeof ResizeObserver === "undefined") {
      for (const [element2, entry] of this.elements) {
        this.checkClientSize(element2, entry);
      }
      return;
    }
    this.resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        this.checkSize(this.elements.get(entry.target), entry.target, width, height);
      }
    });
    this.ownerDocument = document2;
    this.ready = true;
    this.documentReady = document2.readyState !== "loading";
    if (!this.documentReady) {
      document2.addEventListener("DOMContentLoaded", this.onContentLoaded);
    }
  }
  static destroy() {
    var _a, _b;
    (_a = this.ownerDocument) == null ? void 0 : _a.removeEventListener("DOMContentLoaded", this.onContentLoaded);
    (_b = this.resizeObserver) == null ? void 0 : _b.disconnect();
    delete this.resizeObserver;
    delete this.ownerDocument;
    this.ready = false;
  }
  static checkSize(entry, element2, width, height) {
    var _a, _b;
    if (!entry)
      return;
    if (width !== ((_a = entry.size) == null ? void 0 : _a.width) || height !== ((_b = entry.size) == null ? void 0 : _b.height)) {
      entry.size = { width, height };
      entry.cb(entry.size, element2);
    }
  }
  // Only a single callback is supported.
  static observe(element2, cb) {
    var _a;
    if (!this.ready) {
      this.init(element2.ownerDocument);
    }
    if (!this.documentReady) {
      this.queuedObserveRequests.push([element2, cb]);
      return;
    }
    if (this.elements.has(element2)) {
      this.removeFromQueue(element2);
    } else {
      (_a = this.resizeObserver) == null ? void 0 : _a.observe(element2);
    }
    this.elements.set(element2, { cb });
  }
  static unobserve(element2) {
    var _a;
    (_a = this.resizeObserver) == null ? void 0 : _a.unobserve(element2);
    this.elements.delete(element2);
    this.removeFromQueue(element2);
    if (!this.elements.size) {
      this.destroy();
    }
  }
  static removeFromQueue(element2) {
    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);
  }
  static checkClientSize(element2, entry) {
    var _a, _b;
    const width = (_a = element2.clientWidth) != null ? _a : 0;
    const height = (_b = element2.clientHeight) != null ? _b : 0;
    this.checkSize(entry, element2, width, height);
  }
};
_SizeMonitor.elements = /* @__PURE__ */ new Map();
_SizeMonitor.ready = false;
_SizeMonitor.documentReady = false;
_SizeMonitor.queuedObserveRequests = [];
_SizeMonitor.onContentLoaded = () => {
  var _a;
  const newState = ((_a = _SizeMonitor.ownerDocument) == null ? void 0 : _a.readyState) !== "loading";
  const oldState = _SizeMonitor.documentReady;
  _SizeMonitor.documentReady = newState;
  if (newState && newState !== oldState) {
    _SizeMonitor.queuedObserveRequests.forEach(([el, cb]) => _SizeMonitor.observe(el, cb));
    _SizeMonitor.queuedObserveRequests = [];
  }
};
var SizeMonitor = _SizeMonitor;

// packages/ag-charts-community/src/chart/chartHighlight.ts
var ChartHighlight = class {
  constructor() {
    this.range = "tooltip";
  }
};
__decorateClass([
  Validate(UNION(["tooltip", "node"], "a range"))
], ChartHighlight.prototype, "range", 2);

// packages/ag-charts-community/src/chart/chartUpdateType.ts
var ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType2) => {
  ChartUpdateType2[ChartUpdateType2["FULL"] = 0] = "FULL";
  ChartUpdateType2[ChartUpdateType2["UPDATE_DATA"] = 1] = "UPDATE_DATA";
  ChartUpdateType2[ChartUpdateType2["PROCESS_DATA"] = 2] = "PROCESS_DATA";
  ChartUpdateType2[ChartUpdateType2["PERFORM_LAYOUT"] = 3] = "PERFORM_LAYOUT";
  ChartUpdateType2[ChartUpdateType2["SERIES_UPDATE"] = 4] = "SERIES_UPDATE";
  ChartUpdateType2[ChartUpdateType2["TOOLTIP_RECALCULATION"] = 5] = "TOOLTIP_RECALCULATION";
  ChartUpdateType2[ChartUpdateType2["SCENE_RENDER"] = 6] = "SCENE_RENDER";
  ChartUpdateType2[ChartUpdateType2["NONE"] = 7] = "NONE";
  return ChartUpdateType2;
})(ChartUpdateType || {});

// packages/ag-charts-community/src/chart/data/dataDomain.ts
var DataDomain = class {
  constructor(type) {
    this.type = type;
    this.continuousDomain = [Infinity, -Infinity];
    this.discreteDomain = /* @__PURE__ */ new Set();
  }
  extend(val) {
    if (this.type === "discrete") {
      this.discreteDomain.add(val);
    } else if (this.type === "continuous") {
      if (this.continuousDomain[0] > val) {
        this.continuousDomain[0] = val;
      }
      if (this.continuousDomain[1] < val) {
        this.continuousDomain[1] = val;
      }
    }
  }
  getDomain() {
    if (this.type === "discrete") {
      return this.discreteDomain;
    } else if (this.type === "continuous") {
      return this.continuousDomain;
    }
    throw new Error("AG Charts - Unsupported data domain type: " + this.type);
  }
};

// packages/ag-charts-community/src/chart/data/utilFunctions.ts
function extendDomain(values, domain = [Infinity, -Infinity]) {
  for (const value of values) {
    if (typeof value !== "number") {
      continue;
    }
    if (value < domain[0]) {
      domain[0] = value;
    }
    if (value > domain[1]) {
      domain[1] = value;
    }
  }
  return domain;
}

// packages/ag-charts-community/src/chart/data/dataModel.ts
function toKeyString(keys) {
  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join("-");
}
function round2(val) {
  const accuracy = 1e4;
  if (Number.isInteger(val)) {
    return val;
  } else if (Math.abs(val) > accuracy) {
    return Math.trunc(val);
  }
  return Math.round(val * accuracy) / accuracy;
}
function fixNumericExtentInternal(extent2) {
  if (extent2 === void 0) {
    return [];
  }
  let [min, max] = extent2;
  min = Number(min);
  max = Number(max);
  if (min === 0 && max === 0) {
    return [0, 1];
  }
  if (min === Infinity && max === -Infinity) {
    return [];
  }
  if (min === Infinity) {
    min = 0;
  }
  if (max === -Infinity) {
    max = 0;
  }
  return isFiniteNumber(min) && isFiniteNumber(max) ? [min, max] : [];
}
function fixNumericExtent(extent2, axis) {
  var _a;
  const fixedExtent = fixNumericExtentInternal(extent2);
  if (fixedExtent.length === 0) {
    return fixedExtent;
  }
  let [min, max] = fixedExtent;
  if (min === max) {
    const [paddingMin, paddingMax] = (_a = axis == null ? void 0 : axis.calculatePadding(min, max, axis.isReversed())) != null ? _a : [1, 1];
    min -= paddingMin;
    max += paddingMax;
  }
  return [min, max];
}
function defaultMissMap() {
  return /* @__PURE__ */ new Map([[void 0, 0]]);
}
function getMissCount(scopeProvider, missMap) {
  var _a;
  return missMap === void 0 ? 0 : (_a = missMap.get(scopeProvider.id)) != null ? _a : 0;
}
var INVALID_VALUE = Symbol("invalid");
var DataModel = class {
  constructor(opts) {
    this.debug = Debug.create(true, "data-model");
    const { props, mode = "standalone" } = opts;
    this.mode = mode;
    let keys = true;
    for (const next of props) {
      if (next.type === "key" && !keys) {
        throw new Error("AG Charts - internal config error: keys must come before values.");
      }
      if (next.type === "value" && keys) {
        keys = false;
      }
    }
    this.opts = __spreadValues({ dataVisible: true }, opts);
    this.keys = props.filter((def) => def.type === "key").map((def, index) => __spreadProps(__spreadValues({}, def), { index, missing: defaultMissMap() }));
    this.values = props.filter((def) => def.type === "value").map((def, index) => __spreadProps(__spreadValues({}, def), { index, missing: defaultMissMap() }));
    this.aggregates = props.filter((def) => def.type === "aggregate").map((def, index) => __spreadProps(__spreadValues({}, def), { index }));
    this.groupProcessors = props.filter((def) => def.type === "group-value-processor").map((def, index) => __spreadProps(__spreadValues({}, def), { index }));
    this.propertyProcessors = props.filter((def) => def.type === "property-value-processor").map((def, index) => __spreadProps(__spreadValues({}, def), { index }));
    this.reducers = props.filter((def) => def.type === "reducer").map((def, index) => __spreadProps(__spreadValues({}, def), { index }));
    this.processors = props.filter((def) => def.type === "processor").map((def, index) => __spreadProps(__spreadValues({}, def), { index }));
    for (const def of this.values) {
      if (def.property == null) {
        throw new Error(
          `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(
            def
          )}`
        );
      }
    }
    const verifyMatchGroupId = ({ matchGroupIds }) => {
      for (const matchGroupId of matchGroupIds != null ? matchGroupIds : []) {
        if (!this.values.some((def) => def.groupId === matchGroupId)) {
          throw new Error(
            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`
          );
        }
      }
    };
    const verifyMatchIds = ({ matchIds }) => {
      for (const matchId of matchIds != null ? matchIds : []) {
        if (!this.values.some(
          (def) => {
            var _a;
            return (_a = def.ids) == null ? void 0 : _a.some(([scope, id]) => scope === matchId[0] && id === matchId[1]);
          }
        )) {
          throw new Error(
            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchId}).`
          );
        }
      }
    };
    for (const def of [...this.groupProcessors, ...this.aggregates]) {
      verifyMatchIds(def);
      verifyMatchGroupId(def);
    }
  }
  resolveProcessedDataIndexById(scope, searchId) {
    var _a;
    const { index, def } = (_a = this.resolveProcessedDataDefById(scope, searchId)) != null ? _a : {};
    return { index, def };
  }
  resolveProcessedDataIndicesById(scope, searchId) {
    return this.resolveProcessedDataDefsById(scope, searchId).map(({ index, def }) => ({ index, def }));
  }
  resolveProcessedDataDefById(scope, searchId) {
    return this.resolveProcessedDataDefsById(scope, searchId)[0];
  }
  resolveProcessedDataDefsByIds(scope, searchIds) {
    const defs = [];
    for (const searchId of searchIds) {
      defs.push([searchId, this.resolveProcessedDataDefsById(scope, searchId)]);
    }
    return defs;
  }
  resolveProcessedDataDefsValues(defs, { keys, values }) {
    const result = {};
    for (const [searchId, [{ index, def }]] of defs) {
      const processedData = def.type === "key" ? keys : values;
      result[searchId] = processedData[index];
    }
    return result;
  }
  resolveProcessedDataDefsById(searchScope, searchId) {
    const { keys, values, aggregates, groupProcessors, reducers } = this;
    const match = (prop) => {
      const { ids, scopes } = prop;
      if (ids == null)
        return false;
      if (searchScope != null && !(scopes == null ? void 0 : scopes.some((scope) => scope === searchScope.id)))
        return false;
      return ids.some(
        ([scope, id]) => scope === searchScope.id && (typeof searchId === "string" ? id === searchId : searchId.test(id))
      );
    };
    const allDefs = [
      keys,
      values,
      aggregates,
      groupProcessors,
      reducers
    ];
    const result = [];
    for (const defs of allDefs) {
      result.push(...defs.filter(match).map((def) => ({ index: def.index, def })));
    }
    if (result.length > 0) {
      return result;
    }
    throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${searchScope.id}]`);
  }
  getDomain(scope, searchId, type = "value", processedData) {
    var _a, _b, _c, _d;
    let matches;
    try {
      matches = this.resolveProcessedDataIndicesById(scope, searchId);
    } catch (e) {
      if (typeof searchId !== "string" && /didn't find property definition/.test(e.message))
        return [];
      throw e;
    }
    let domainProp;
    switch (type) {
      case "key":
        domainProp = "keys";
        break;
      case "value":
        domainProp = "values";
        break;
      case "aggregate":
        domainProp = "aggValues";
        break;
      case "group-value-processor":
        domainProp = "groups";
        break;
      default:
        return [];
    }
    const firstMatch = (_b = (_a = processedData.domain[domainProp]) == null ? void 0 : _a[matches[0].index]) != null ? _b : [];
    if (matches.length === 1) {
      return firstMatch;
    }
    const result = [...firstMatch];
    for (const idx of matches.slice(1)) {
      extendDomain((_d = (_c = processedData.domain[domainProp]) == null ? void 0 : _c[idx.index]) != null ? _d : [], result);
    }
    return result;
  }
  processData(data, sources) {
    const {
      opts: { groupByKeys, groupByFn },
      aggregates,
      groupProcessors,
      reducers,
      processors,
      propertyProcessors
    } = this;
    const start = performance.now();
    if (groupByKeys && this.keys.length === 0) {
      return void 0;
    }
    let processedData = this.extractData(data, sources);
    if (groupByKeys) {
      processedData = this.groupData(processedData);
    } else if (groupByFn) {
      processedData = this.groupData(processedData, groupByFn(processedData));
    }
    if (groupProcessors.length > 0) {
      this.postProcessGroups(processedData);
    }
    if (aggregates.length > 0) {
      this.aggregateData(processedData);
    }
    if (propertyProcessors.length > 0) {
      this.postProcessProperties(processedData);
    }
    if (reducers.length > 0) {
      this.reduceData(processedData);
    }
    if (processors.length > 0) {
      this.postProcessData(processedData);
    }
    for (const def of [...this.keys, ...this.values]) {
      if (data.length > 0) {
        for (const [scope, missCount] of def.missing) {
          if (missCount >= data.length) {
            const scopeHint = scope === void 0 ? "" : ` for ${scope}`;
            Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);
          }
        }
      }
    }
    const end = performance.now();
    processedData.time = end - start;
    if (this.debug.check()) {
      logProcessedData(processedData);
    }
    return processedData;
  }
  valueGroupIdxLookup({ matchGroupIds, matchIds }) {
    return this.values.map((def, index) => ({ def, index })).filter(({ def }) => {
      if (matchGroupIds && (def.groupId == null || !matchGroupIds.includes(def.groupId))) {
        return false;
      }
      if (!matchIds)
        return true;
      if (def.ids == null)
        return false;
      return matchIds.some(
        ([matchScope, matchId]) => {
          var _a;
          return (_a = def.ids) == null ? void 0 : _a.some(([defScope, defId]) => defScope === matchScope && defId === matchId);
        }
      );
    }).map(({ index }) => index);
  }
  valueIdxLookup(scopes, prop) {
    const noScopesToMatch = scopes == null || scopes.length === 0;
    const scopeMatch = (compareTo) => {
      const anyScope = compareTo == null;
      if (anyScope)
        return true;
      const noScopes = compareTo == null || compareTo.length === 0;
      if (noScopesToMatch === noScopes)
        return true;
      return compareTo == null ? void 0 : compareTo.some((s) => scopes.includes(s));
    };
    const propId = typeof prop === "string" ? prop : prop.id;
    const idMatch = ([scope, id]) => {
      return scopeMatch([scope]) && id === propId;
    };
    const result = this.values.findIndex((def) => {
      var _a;
      return scopeMatch(def.scopes) && (((_a = def.ids) == null ? void 0 : _a.some((id) => idMatch(id))) || def.property === propId || def.id === propId);
    });
    if (result >= 0) {
      return result;
    }
    throw new Error(
      `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(
        scopes
      )}`
    );
  }
  extractData(data, sources) {
    var _a, _b, _c, _d, _e, _f;
    const {
      keys: keyDefs,
      values: valueDefs,
      opts: { dataVisible }
    } = this;
    const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();
    const resultData = new Array(dataVisible ? data.length : 0);
    let resultDataIdx = 0;
    let partialValidDataCount = 0;
    for (const [datumIdx, datum] of data.entries()) {
      const sourceDatums = {};
      const validScopes = scopes.size > 0 ? new Set(scopes) : void 0;
      const keys = dataVisible ? new Array(keyDefs.length) : void 0;
      let keyIdx = 0;
      let key;
      for (const def of keyDefs) {
        key = processValue(def, datum, key);
        if (key === INVALID_VALUE)
          break;
        if (keys) {
          keys[keyIdx++] = key;
        }
      }
      if (key === INVALID_VALUE)
        continue;
      const values = dataVisible && valueDefs.length > 0 ? new Array(valueDefs.length) : void 0;
      let value;
      const sourcesById = {};
      for (const source of sources != null ? sources : []) {
        sourcesById[source.id] = source;
      }
      for (const [valueDefIdx, def] of valueDefs.entries()) {
        for (const scope of (_a = def.scopes) != null ? _a : scopes) {
          const source = sourcesById[scope];
          const valueDatum = (_b = source == null ? void 0 : source.data[datumIdx]) != null ? _b : datum;
          value = processValue(def, valueDatum, value, scope);
          if (value === INVALID_VALUE || !values)
            continue;
          if (source !== void 0) {
            (_d = sourceDatums[_c = source.id]) != null ? _d : sourceDatums[_c] = {};
            sourceDatums[source.id][def.property] = value;
          }
          if (def.useScopedValues) {
            (_e = values[valueDefIdx]) != null ? _e : values[valueDefIdx] = {};
            values[valueDefIdx][scope] = value;
          } else {
            values[valueDefIdx] = value;
          }
        }
        if (value === INVALID_VALUE) {
          if (allScopesHaveSameDefs)
            break;
          for (const scope of (_f = def.scopes) != null ? _f : scopes) {
            validScopes == null ? void 0 : validScopes.delete(scope);
          }
          if ((validScopes == null ? void 0 : validScopes.size) === 0)
            break;
        }
      }
      if (value === INVALID_VALUE && allScopesHaveSameDefs)
        continue;
      if ((validScopes == null ? void 0 : validScopes.size) === 0)
        continue;
      if (dataVisible) {
        const result = {
          datum: __spreadValues(__spreadValues({}, datum), sourceDatums),
          keys,
          values
        };
        if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {
          partialValidDataCount++;
          result.validScopes = [...validScopes];
        }
        resultData[resultDataIdx++] = result;
      }
    }
    resultData.length = resultDataIdx;
    const propertyDomain = (def) => {
      const result = dataDomain.get(def).getDomain();
      if (Array.isArray(result) && result[0] > result[1]) {
        return [];
      }
      return [...result];
    };
    return {
      type: "ungrouped",
      input: { count: data.length },
      data: resultData,
      domain: {
        keys: keyDefs.map((def) => propertyDomain(def)),
        values: valueDefs.map((def) => propertyDomain(def))
      },
      defs: {
        allScopesHaveSameDefs,
        keys: keyDefs,
        values: valueDefs
      },
      partialValidDataCount,
      time: 0
    };
  }
  groupData(data, groupingFn) {
    var _a, _b, _c, _d;
    const processedData = /* @__PURE__ */ new Map();
    for (const dataEntry of data.data) {
      const { keys, values, datum, validScopes } = dataEntry;
      const group2 = groupingFn ? groupingFn(dataEntry) : keys;
      const groupStr = toKeyString(group2);
      if (processedData.has(groupStr)) {
        const existingData = processedData.get(groupStr);
        existingData.values.push(values);
        existingData.datum.push(datum);
        if (validScopes != null) {
          for (let index = 0; index < ((_b = (_a = existingData.validScopes) == null ? void 0 : _a.length) != null ? _b : 0); index++) {
            const scope = (_c = existingData.validScopes) == null ? void 0 : _c[index];
            if (validScopes.some((s) => s === scope))
              continue;
            (_d = existingData.validScopes) == null ? void 0 : _d.splice(index, 1);
          }
        }
      } else {
        processedData.set(groupStr, {
          keys: group2,
          values: [values],
          datum: [datum],
          validScopes
        });
      }
    }
    const resultData = new Array(processedData.size);
    const resultGroups = new Array(processedData.size);
    let dataIndex = 0;
    for (const [, { keys, values, datum, validScopes }] of processedData.entries()) {
      if ((validScopes == null ? void 0 : validScopes.length) === 0)
        continue;
      resultGroups[dataIndex] = keys;
      resultData[dataIndex++] = {
        keys,
        values,
        datum,
        validScopes
      };
    }
    return __spreadProps(__spreadValues({}, data), {
      type: "grouped",
      data: resultData,
      domain: __spreadProps(__spreadValues({}, data.domain), {
        groups: resultGroups
      })
    });
  }
  aggregateData(processedData) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { aggregates: aggDefs } = this;
    if (!aggDefs)
      return;
    const resultAggValues = aggDefs.map(() => [Infinity, -Infinity]);
    const resultAggValueIndices = aggDefs.map((def) => this.valueGroupIdxLookup(def));
    const resultAggFns = aggDefs.map((def) => def.aggregateFunction);
    const resultGroupAggFns = aggDefs.map((def) => def.groupAggregateFunction);
    const resultFinalFns = aggDefs.map((def) => def.finalFunction);
    for (const group2 of processedData.data) {
      let { values } = group2;
      const { validScopes } = group2;
      (_a = group2.aggValues) != null ? _a : group2.aggValues = new Array(resultAggValueIndices.length);
      if (processedData.type === "ungrouped") {
        values = [values];
      }
      let resultIdx = 0;
      for (const indices of resultAggValueIndices) {
        const scopeValid = (_b = validScopes == null ? void 0 : validScopes.some((s) => {
          var _a2;
          return (_a2 = aggDefs[resultIdx].matchScopes) == null ? void 0 : _a2.some((as) => s === as);
        })) != null ? _b : true;
        if (!scopeValid) {
          resultIdx++;
          continue;
        }
        let groupAggValues = (_d = (_c = resultGroupAggFns[resultIdx]) == null ? void 0 : _c.call(resultGroupAggFns)) != null ? _d : extendDomain([]);
        for (const distinctValues of values) {
          const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);
          const valuesAgg = resultAggFns[resultIdx](valuesToAgg, group2.keys);
          if (valuesAgg) {
            groupAggValues = (_f = (_e = resultGroupAggFns[resultIdx]) == null ? void 0 : _e.call(resultGroupAggFns, valuesAgg, groupAggValues)) != null ? _f : extendDomain(valuesAgg, groupAggValues);
          }
        }
        const finalValues = ((_h = (_g = resultFinalFns[resultIdx]) == null ? void 0 : _g.call(resultFinalFns, groupAggValues)) != null ? _h : groupAggValues).map(
          (v) => round2(v)
        );
        extendDomain(finalValues, resultAggValues[resultIdx]);
        group2.aggValues[resultIdx++] = finalValues;
      }
    }
    processedData.domain.aggValues = resultAggValues;
  }
  postProcessGroups(processedData) {
    var _a, _b, _c, _d, _e;
    const { groupProcessors } = this;
    if (!groupProcessors)
      return;
    const affectedIndices = /* @__PURE__ */ new Set();
    const updatedDomains = /* @__PURE__ */ new Map();
    const groupProcessorIndices = /* @__PURE__ */ new Map();
    const groupProcessorInitFns = /* @__PURE__ */ new Map();
    for (const processor of groupProcessors) {
      const indices = this.valueGroupIdxLookup(processor);
      groupProcessorIndices.set(processor, indices);
      groupProcessorInitFns.set(processor, processor.adjust());
      for (const idx of indices) {
        const valueDef = this.values[idx];
        affectedIndices.add(idx);
        updatedDomains.set(idx, new DataDomain(valueDef.valueType === "category" ? "discrete" : "continuous"));
      }
    }
    const updateDomains = (values) => {
      var _a2;
      for (const valueIndex of affectedIndices) {
        (_a2 = updatedDomains.get(valueIndex)) == null ? void 0 : _a2.extend(values[valueIndex]);
      }
    };
    for (const group2 of processedData.data) {
      for (const processor of groupProcessors) {
        const scopeValid = (_b = (_a = group2.validScopes) == null ? void 0 : _a.some((s) => {
          var _a2;
          return (_a2 = processor.matchScopes) == null ? void 0 : _a2.some((as) => s === as);
        })) != null ? _b : true;
        if (!scopeValid) {
          continue;
        }
        const valueIndexes = (_c = groupProcessorIndices.get(processor)) != null ? _c : [];
        const adjustFn = (_e = (_d = groupProcessorInitFns.get(processor)) == null ? void 0 : _d()) != null ? _e : () => void 0;
        if (processedData.type === "grouped") {
          for (const values of group2.values) {
            if (values) {
              adjustFn(values, valueIndexes);
            }
          }
          continue;
        }
        if (group2.values) {
          adjustFn(group2.values, valueIndexes);
        }
      }
      if (processedData.type === "grouped") {
        for (const values of group2.values) {
          updateDomains(values);
        }
      } else {
        updateDomains(group2.values);
      }
    }
    for (const [idx, dataDomain] of updatedDomains) {
      processedData.domain.values[idx] = [...dataDomain.getDomain()];
    }
  }
  postProcessProperties(processedData) {
    const { propertyProcessors } = this;
    if (!propertyProcessors)
      return;
    for (const { adjust, property, scopes } of propertyProcessors) {
      adjust()(processedData, this.valueIdxLookup(scopes != null ? scopes : [], property));
    }
  }
  reduceData(processedData) {
    var _a, _b, _c;
    const { reducers: reducerDefs } = this;
    const scopes = reducerDefs.map((def) => def.scopes);
    const reducers = reducerDefs.map((def) => def.reducer());
    const accValues = reducerDefs.map((def) => def.initialValue);
    for (const group2 of processedData.data) {
      let reducerIndex = 0;
      for (const reducer of reducers) {
        const scopeValid = (_b = (_a = group2.validScopes) == null ? void 0 : _a.some((s) => {
          var _a2;
          return (_a2 = scopes[reducerIndex]) == null ? void 0 : _a2.some((as) => s === as);
        })) != null ? _b : true;
        if (!scopeValid) {
          reducerIndex++;
          continue;
        }
        accValues[reducerIndex] = reducer(accValues[reducerIndex], group2);
        reducerIndex++;
      }
    }
    for (let accIdx = 0; accIdx < accValues.length; accIdx++) {
      (_c = processedData.reduced) != null ? _c : processedData.reduced = {};
      processedData.reduced[reducerDefs[accIdx].property] = accValues[accIdx];
    }
  }
  postProcessData(processedData) {
    var _a;
    const { processors: processorDefs } = this;
    for (const def of processorDefs) {
      (_a = processedData.reduced) != null ? _a : processedData.reduced = {};
      processedData.reduced[def.property] = def.calculate(processedData);
    }
  }
  initDataDomainProcessor() {
    var _a;
    const { keys: keyDefs, values: valueDefs } = this;
    const scopes = /* @__PURE__ */ new Set();
    for (const valueDef of valueDefs) {
      for (const scope of (_a = valueDef.scopes) != null ? _a : []) {
        scopes.add(scope);
      }
    }
    const scopesCount = scopes.size;
    const dataDomain = /* @__PURE__ */ new Map();
    const processorFns = /* @__PURE__ */ new Map();
    let allScopesHaveSameDefs = true;
    const initDataDomainKey = (key, type, updateDataDomain = dataDomain) => {
      var _a2;
      if (type === "category") {
        updateDataDomain.set(key, new DataDomain("discrete"));
      } else {
        updateDataDomain.set(key, new DataDomain("continuous"));
        allScopesHaveSameDefs && (allScopesHaveSameDefs = ((_a2 = key.scopes) != null ? _a2 : []).length === scopesCount);
      }
    };
    const initDataDomain = () => {
      keyDefs.forEach((def) => initDataDomainKey(def, def.valueType));
      valueDefs.forEach((def) => initDataDomainKey(def, def.valueType));
    };
    initDataDomain();
    const accessors = this.buildAccessors(...keyDefs, ...valueDefs);
    const processValue = (def, datum, previousDatum, scope) => {
      var _a2, _b, _c, _d, _e;
      const hasAccessor = def.property in accessors;
      let valueInDatum = false;
      let value;
      if (hasAccessor) {
        try {
          value = accessors[def.property](datum);
        } catch (error) {
        }
        valueInDatum = value !== void 0;
      } else {
        valueInDatum = def.property in datum;
        value = valueInDatum ? datum[def.property] : def.missingValue;
      }
      if (def.forceValue != null) {
        const valueNegative = valueInDatum && isNegative(value);
        value = valueNegative ? -1 * def.forceValue : def.forceValue;
        valueInDatum = true;
      }
      const missingValueDef = "missingValue" in def;
      if (!valueInDatum && !missingValueDef) {
        const missCount = (_a2 = def.missing.get(scope)) != null ? _a2 : 0;
        def.missing.set(scope, missCount + 1);
      }
      if (!dataDomain.has(def)) {
        initDataDomain();
      }
      if (valueInDatum) {
        const valid = (_c = (_b = def.validation) == null ? void 0 : _b.call(def, value, datum)) != null ? _c : true;
        if (!valid) {
          if ("invalidValue" in def) {
            value = def.invalidValue;
          } else {
            if (this.mode !== "integrated") {
              Logger.warnOnce(`invalid value of type [${typeof value}] ignored:`, `[${value}]`);
            }
            return INVALID_VALUE;
          }
        }
      }
      if (def.processor) {
        if (!processorFns.has(def)) {
          processorFns.set(def, def.processor());
        }
        value = (_d = processorFns.get(def)) == null ? void 0 : _d(value, previousDatum !== INVALID_VALUE ? previousDatum : void 0);
      }
      (_e = dataDomain.get(def)) == null ? void 0 : _e.extend(value);
      return value;
    };
    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };
  }
  buildAccessors(...defs) {
    const result = {};
    if (this.mode === "integrated")
      return result;
    for (const def of defs) {
      const isPath = def.property.indexOf(".") >= 0 || def.property.indexOf("[") >= 0;
      if (!isPath)
        continue;
      let fnBody;
      if (def.property.startsWith("[")) {
        fnBody = `return datum${def.property};`;
      } else {
        fnBody = `return datum.${def.property};`;
      }
      result[def.property] = new Function("datum", fnBody);
    }
    return result;
  }
};
function logProcessedData(processedData) {
  var _a, _b;
  const logValues = (name, data) => {
    if (data.length > 0) {
      Logger.log(`DataModel.processData() - ${name}`);
      Logger.table(data);
    }
  };
  Logger.log("DataModel.processData() - processedData", processedData);
  logValues("Key Domains", processedData.domain.keys);
  logValues("Group Domains", (_a = processedData.domain.groups) != null ? _a : []);
  logValues("Value Domains", processedData.domain.values);
  logValues("Aggregate Domains", (_b = processedData.domain.aggValues) != null ? _b : []);
  if (processedData.type === "grouped") {
    const flattenedValues = processedData.data.reduce((acc, next) => {
      var _a2, _b2;
      const keys = (_a2 = next.keys) != null ? _a2 : [];
      const aggValues = (_b2 = next.aggValues) != null ? _b2 : [];
      const skipKeys = next.keys.map(() => void 0);
      const skipAggValues = aggValues == null ? void 0 : aggValues.map(() => void 0);
      acc.push(
        ...next.values.map((v, i) => [
          ...i === 0 ? keys : skipKeys,
          ...v != null ? v : [],
          ...i == 0 ? aggValues : skipAggValues
        ])
      );
      return acc;
    }, []);
    logValues("Values", flattenedValues);
  } else {
    const flattenedValues = processedData.data.reduce((acc, next) => {
      var _a2;
      const aggValues = (_a2 = next.aggValues) != null ? _a2 : [];
      acc.push([...next.keys, ...next.values, ...aggValues]);
      return acc;
    }, []);
    logValues("Values", flattenedValues);
  }
}

// packages/ag-charts-community/src/chart/data/dataController.ts
var DataController = class {
  constructor(mode) {
    this.mode = mode;
    this.debug = Debug.create(true, "data-model");
    this.requested = [];
    this.status = "setup";
  }
  request(id, data, opts) {
    return __async(this, null, function* () {
      if (this.status !== "setup")
        throw new Error(`AG Charts - data request after data setup phase.`);
      return new Promise((resolve, reject) => {
        this.requested.push({
          id,
          opts,
          data,
          resultCb: resolve,
          reject
        });
      });
    });
  }
  execute() {
    if (this.status !== "setup")
      throw new Error(`AG Charts - data request after data setup phase.`);
    this.status = "executed";
    this.debug("DataController.execute() - requested", this.requested);
    const { valid, invalid } = this.validateRequests(this.requested);
    this.debug("DataController.execute() - validated", valid);
    const merged = this.mergeRequested(valid);
    this.debug("DataController.execute() - merged", merged);
    if (this.debug.check()) {
      window.processedData = [];
    }
    const multipleSources = valid.some((v) => v.data != null);
    for (const { opts, data, resultCbs, rejects, ids } of merged) {
      const needsValueExtraction = multipleSources || opts.props.some((p) => {
        var _a;
        if (p.type !== "value" && p.type !== "key")
          return false;
        return (_a = p.useScopedValues) != null ? _a : false;
      });
      try {
        const dataModel = new DataModel(__spreadProps(__spreadValues({}, opts), { mode: this.mode }));
        const processedData = dataModel.processData(data, valid);
        if (this.debug.check()) {
          window.processedData.push(processedData);
        }
        if (processedData && processedData.partialValidDataCount === 0) {
          resultCbs.forEach((cb, requestIdx) => {
            const id = ids[requestIdx];
            let requestProcessedData = processedData;
            if (needsValueExtraction) {
              requestProcessedData = this.extractScopedData(id, processedData);
            }
            cb({ dataModel, processedData: requestProcessedData });
          });
        } else if (processedData) {
          this.splitResult(dataModel, processedData, ids, resultCbs);
        } else {
          rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));
        }
      } catch (error) {
        rejects.forEach((cb) => cb(error));
      }
    }
    invalid.forEach(({ error, reject }) => reject(error));
  }
  extractScopedData(id, processedData) {
    const extractDatum = (datum) => {
      if (Array.isArray(datum)) {
        return datum.map(extractDatum);
      }
      return __spreadValues(__spreadValues({}, datum), datum[id]);
    };
    const extractValues = (values) => {
      var _a;
      if (Array.isArray(values)) {
        return values.map(extractValues);
      }
      return (_a = values == null ? void 0 : values[id]) != null ? _a : values;
    };
    return __spreadProps(__spreadValues({}, processedData), {
      data: processedData.data.map((datum) => __spreadProps(__spreadValues({}, datum), {
        datum: extractDatum(datum.datum),
        values: datum.values.map(extractValues)
      }))
    });
  }
  validateRequests(requested) {
    const valid = [];
    const invalid = [];
    for (const [index, request] of requested.entries()) {
      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false) {
        invalid.push(__spreadProps(__spreadValues({}, request), {
          error: new Error("all series[].data arrays must be of the same length and have matching keys.")
        }));
      } else {
        valid.push(request);
      }
    }
    return { valid, invalid };
  }
  mergeRequested(requested) {
    const grouped = [];
    const keys = (props) => {
      return props.filter((p) => p.type === "key").map((p) => p.property).join(";");
    };
    const groupMatch = ({ opts, data }) => (gr) => {
      return (opts.groupByData === false || gr[0].data === data) && gr[0].opts.groupByKeys === opts.groupByKeys && gr[0].opts.dataVisible === opts.dataVisible && gr[0].opts.groupByFn === opts.groupByFn && keys(gr[0].opts.props) === keys(opts.props);
    };
    const propMatch = (prop) => (existing) => {
      var _a;
      if (existing.type !== prop.type)
        return false;
      const diff2 = (_a = jsonDiff(existing, prop)) != null ? _a : {};
      delete diff2["scopes"];
      delete diff2["id"];
      delete diff2["ids"];
      if ("useScopedValues" in diff2) {
        delete diff2["useScopedValues"];
      }
      return Object.keys(diff2).length === 0;
    };
    const updateKeyValueOpts = (prop) => {
      var _a;
      if (prop.type !== "key" && prop.type !== "value")
        return;
      const uniqueScopes = new Set((_a = prop.scopes) != null ? _a : []);
      prop.useScopedValues = uniqueScopes.size > 1;
    };
    const mergeOpts = (opts) => {
      return __spreadProps(__spreadValues({}, opts[0]), {
        props: opts.reduce((result, next) => {
          var _a, _b, _c, _d, _e, _f;
          for (const prop of next.props) {
            if (prop.id != null) {
              (_a = prop.ids) != null ? _a : prop.ids = [];
              for (const scope of (_b = prop.scopes) != null ? _b : []) {
                prop.ids.push([scope, prop.id]);
              }
            }
            const match = result.find(propMatch(prop));
            if (!match) {
              updateKeyValueOpts(prop);
              result.push(prop);
              continue;
            }
            (_c = match.scopes) != null ? _c : match.scopes = [];
            match.scopes.push(...(_d = prop.scopes) != null ? _d : []);
            updateKeyValueOpts(prop);
            if ((match.type === "key" || match.type === "value") && ((_e = prop.ids) == null ? void 0 : _e.length)) {
              (_f = match.ids) == null ? void 0 : _f.push(...prop.ids);
            }
          }
          return result;
        }, [])
      });
    };
    const merge = (props) => {
      return {
        ids: props.map(({ id }) => id),
        resultCbs: props.map(({ resultCb }) => resultCb),
        rejects: props.map(({ reject }) => reject),
        data: props[0].data,
        opts: mergeOpts(props.map(({ opts }) => opts))
      };
    };
    for (const request of requested) {
      const match = grouped.find(groupMatch(request));
      if (match) {
        match.push(request);
      } else {
        grouped.push([request]);
      }
    }
    return grouped.map(merge);
  }
  splitResult(dataModel, processedData, scopes, resultCbs) {
    for (let index = 0; index < scopes.length; index++) {
      const scope = scopes[index];
      const resultCb = resultCbs[index];
      resultCb({
        dataModel,
        processedData: __spreadProps(__spreadValues({}, processedData), {
          data: processedData.data.filter(({ validScopes }) => {
            return validScopes == null || validScopes.some((s) => s === scope);
          })
        })
      });
    }
  }
};

// packages/ag-charts-community/src/util/listeners.ts
var Listeners = class {
  constructor() {
    this.registeredListeners = /* @__PURE__ */ new Map();
  }
  addListener(eventType, handler) {
    const record = { symbol: Symbol(eventType), handler };
    if (this.registeredListeners.has(eventType)) {
      this.registeredListeners.get(eventType).push(record);
    } else {
      this.registeredListeners.set(eventType, [record]);
    }
    return () => this.removeListener(record.symbol);
  }
  removeListener(eventSymbol) {
    for (const [type, listeners] of this.registeredListeners.entries()) {
      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);
      if (matchIndex >= 0) {
        listeners.splice(matchIndex, 1);
        if (listeners.length === 0) {
          this.registeredListeners.delete(type);
        }
        break;
      }
    }
  }
  dispatch(eventType, ...params) {
    for (const listener of this.getListenersByType(eventType)) {
      try {
        listener.handler(...params);
      } catch (e) {
        Logger.errorOnce(e);
      }
    }
  }
  dispatchWrapHandlers(eventType, wrapFn, ...params) {
    for (const listener of this.getListenersByType(eventType)) {
      try {
        wrapFn(listener.handler, ...params);
      } catch (e) {
        Logger.errorOnce(e);
      }
    }
  }
  getListenersByType(eventType) {
    var _a;
    return (_a = this.registeredListeners.get(eventType)) != null ? _a : [];
  }
  destroy() {
    this.registeredListeners.clear();
  }
};

// packages/ag-charts-community/src/chart/data/dataService.ts
var DataService = class extends Listeners {
  constructor(animationManager) {
    super();
    this.animationManager = animationManager;
    this.dispatchOnlyLatest = true;
    this.dispatchThrottle = 0;
    this.requestThrottle = 300;
    this.isLoadingInitialData = false;
    this.freshRequests = [];
    this.requestCounter = 0;
    this.debug = Debug.create(true, "data-model", "data-source");
    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);
    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);
  }
  updateCallback(dataSourceCallback) {
    if (typeof dataSourceCallback !== "function")
      return;
    this.debug("DataService - updated data source callback");
    this.dataSourceCallback = dataSourceCallback;
    this.isLoadingInitialData = true;
    this.animationManager.skip();
    this.dispatch("data-source-change");
  }
  clearCallback() {
    this.dataSourceCallback = void 0;
  }
  load(params) {
    this.throttledFetch(params);
  }
  isLazy() {
    return this.dataSourceCallback != null;
  }
  isLoading() {
    return this.isLazy() && (this.isLoadingInitialData || this.freshRequests.length > 0);
  }
  createThrottledFetch(requestThrottle) {
    return throttle((params) => this.fetch(params), requestThrottle, {
      leading: false,
      trailing: true
    });
  }
  createThrottledDispatch(dispatchThrottle) {
    return throttle(
      (id, data) => {
        this.debug(`DataService - dispatching 'data-load' | ${id}`);
        this.dispatch("data-load", { type: "data-load", data });
      },
      dispatchThrottle,
      {
        leading: true,
        trailing: true
      }
    );
  }
  fetch(params) {
    return __async(this, null, function* () {
      if (!this.dataSourceCallback) {
        throw new Error("DataService - [dataSource.getData] callback not initialised");
      }
      const start = performance.now();
      const id = this.requestCounter++;
      this.debug(`DataService - requesting | ${id}`);
      this.freshRequests.push(id);
      let response;
      try {
        response = yield this.dataSourceCallback(params);
        this.debug(`DataService - response | ${performance.now() - start}ms | ${id}`);
      } catch (error) {
        this.debug(`DataService - request failed | ${id}`);
        Logger.errorOnce(`DataService - request failed | [${error}]`);
      }
      this.isLoadingInitialData = false;
      const requestIndex = this.freshRequests.findIndex((rid) => rid === id);
      if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {
        this.debug(`DataService - discarding stale request | ${id}`);
        return;
      }
      this.freshRequests = this.freshRequests.slice(requestIndex + 1);
      if (Array.isArray(response)) {
        this.throttledDispatch(id, response);
      } else {
        this.dispatch("data-error");
      }
    });
  }
};
__decorateClass([
  ActionOnSet({
    newValue(dispatchThrottle) {
      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);
    }
  })
], DataService.prototype, "dispatchThrottle", 2);
__decorateClass([
  ActionOnSet({
    newValue(requestThrottle) {
      this.throttledFetch = this.createThrottledFetch(requestThrottle);
    }
  })
], DataService.prototype, "requestThrottle", 2);

// packages/ag-charts-community/src/chart/interaction/animationBatch.ts
var DEBUG_SELECTORS = [true, "animation"];
var AnimationBatch = class {
  constructor() {
    this.stoppedCbs = /* @__PURE__ */ new Set();
    this.controllers = /* @__PURE__ */ new Map();
    this.debug = Debug.create(...DEBUG_SELECTORS);
    this.currentPhase = 0;
    this.phases = new Map(ANIMATION_PHASE_ORDER.map((p) => [p, []]));
    this.skipAnimations = false;
  }
  get size() {
    return this.controllers.size;
  }
  isActive() {
    return this.controllers.size > 0;
  }
  getActiveControllers() {
    var _a;
    return (_a = this.phases.get(ANIMATION_PHASE_ORDER[this.currentPhase])) != null ? _a : [];
  }
  checkOverlappingId(id) {
    if (id != null && this.controllers.has(id)) {
      this.controllers.get(id).stop();
      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);
      this.skip();
    }
  }
  addAnimation(animation) {
    var _a;
    if (animation.isComplete)
      return;
    const animationPhaseIdx = ANIMATION_PHASE_ORDER.indexOf(animation.phase);
    if (animationPhaseIdx < this.currentPhase) {
      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);
      animation.stop();
      return;
    }
    this.controllers.set(animation.id, animation);
    (_a = this.phases.get(animation.phase)) == null ? void 0 : _a.push(animation);
  }
  removeAnimation(animation) {
    this.controllers.delete(animation.id);
    const phase = this.phases.get(animation.phase);
    const index = phase == null ? void 0 : phase.indexOf(animation);
    if (index != null && index >= 0) {
      phase == null ? void 0 : phase.splice(index, 1);
    }
  }
  progress(deltaTime) {
    const phase = ANIMATION_PHASE_ORDER[this.currentPhase];
    let phaseControllers = [...this.getActiveControllers()];
    const total = this.controllers.size;
    this.debug(
      `AnimationBatch - progressing by ${deltaTime}; current phase ${phase} with ${phaseControllers == null ? void 0 : phaseControllers.length} active controllers of ${total} total`,
      this.phases
    );
    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;
    const arePhasesComplete = () => ANIMATION_PHASE_ORDER[this.currentPhase] == null;
    const progressPhase = () => {
      phaseControllers = [...this.getActiveControllers()];
      while (!arePhasesComplete() && phaseControllers.length === 0) {
        this.currentPhase++;
        phaseControllers = [...this.getActiveControllers()];
        this.debug(
          `AnimationBatch - phase changing to ${ANIMATION_PHASE_ORDER[this.currentPhase]}`,
          { unusedTime },
          phaseControllers
        );
      }
    };
    while (unusedTime > 0 && !arePhasesComplete()) {
      progressPhase();
      const phaseDeltaTime = unusedTime;
      let completeCount = 0;
      for (const controller of phaseControllers) {
        unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);
        if (controller.isComplete) {
          completeCount++;
          this.removeAnimation(controller);
        }
      }
      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);
    }
  }
  skip(skip = true) {
    if (this.skipAnimations === false && skip === true) {
      for (const controller of this.controllers.values()) {
        controller.stop();
      }
      this.controllers.clear();
    }
    this.skipAnimations = skip;
  }
  play() {
    for (const controller of this.controllers.values()) {
      controller.play();
    }
  }
  pause() {
    for (const controller of this.controllers.values()) {
      controller.pause();
    }
  }
  stop() {
    for (const controller of this.controllers.values()) {
      try {
        controller.stop();
        this.removeAnimation(controller);
      } catch (error) {
        Logger.error("Error during animation stop", error);
      }
    }
    this.dispatchStopped();
  }
  stopByAnimationId(id) {
    if (id != null && this.controllers.has(id)) {
      const controller = this.controllers.get(id);
      if (controller) {
        controller.stop();
        this.removeAnimation(controller);
      }
    }
  }
  stopByAnimationGroupId(id) {
    for (const controller of this.controllers.values()) {
      if (controller.groupId === id) {
        this.stopByAnimationId(controller.id);
      }
    }
  }
  dispatchStopped() {
    this.stoppedCbs.forEach((cb) => cb());
    this.stoppedCbs.clear();
  }
  isSkipped() {
    return this.skipAnimations;
  }
  destroy() {
  }
};

// packages/ag-charts-community/src/chart/interaction/baseManager.ts
var BaseManager = class {
  constructor() {
    this.listeners = new Listeners();
  }
  addListener(type, handler) {
    return this.listeners.addListener(type, handler);
  }
  removeListener(listenerSymbol) {
    this.listeners.removeListener(listenerSymbol);
  }
  destroy() {
    this.listeners.destroy();
  }
};

// packages/ag-charts-community/src/chart/interaction/interactionManager.ts
var INTERACTION_TYPES = [
  "click",
  "dblclick",
  "contextmenu",
  "hover",
  "drag-start",
  "drag",
  "drag-end",
  "leave",
  "page-left",
  "wheel"
];
var WINDOW_EVENT_HANDLERS = ["pagehide", "mousemove", "mouseup"];
var EVENT_HANDLERS = [
  "click",
  "dblclick",
  "contextmenu",
  "mousedown",
  "mouseout",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  "wheel"
];
var CSS = `
.ag-chart-wrapper {
    touch-action: none;
}
`;
var InteractionState = /* @__PURE__ */ ((InteractionState2) => {
  InteractionState2[InteractionState2["Default"] = 8] = "Default";
  InteractionState2[InteractionState2["ZoomDrag"] = 4] = "ZoomDrag";
  InteractionState2[InteractionState2["ContextMenu"] = 2] = "ContextMenu";
  InteractionState2[InteractionState2["Animation"] = 1] = "Animation";
  InteractionState2[InteractionState2["All"] = 15] = "All";
  return InteractionState2;
})(InteractionState || {});
var DEBUG_SELECTORS2 = [true, "interaction"];
var _InteractionManager = class _InteractionManager extends BaseManager {
  constructor(element2, document2, window2) {
    super();
    this.debug = Debug.create(...DEBUG_SELECTORS2);
    this.eventHandler = (event) => this.processEvent(event);
    this.mouseDown = false;
    this.touchDown = false;
    this.stateQueue = 8 /* Default */;
    this.rootElement = document2.body;
    this.element = element2;
    this.window = window2;
    for (const type of EVENT_HANDLERS) {
      if (type.startsWith("touch")) {
        element2.addEventListener(type, this.eventHandler, { passive: true });
      } else if (type === "wheel") {
        element2.addEventListener(type, this.eventHandler, { passive: false });
      } else {
        element2.addEventListener(type, this.eventHandler);
      }
    }
    for (const type of WINDOW_EVENT_HANDLERS) {
      this.window.addEventListener(type, this.eventHandler);
    }
    if (!_InteractionManager.interactionDocuments.includes(document2)) {
      injectStyle(document2, CSS);
      _InteractionManager.interactionDocuments.push(document2);
    }
  }
  destroy() {
    super.destroy();
    for (const type of WINDOW_EVENT_HANDLERS) {
      this.window.removeEventListener(type, this.eventHandler);
    }
    for (const type of EVENT_HANDLERS) {
      this.element.removeEventListener(type, this.eventHandler);
    }
  }
  // Wrapper to only broadcast events when the InteractionManager is a given state.
  addListener(type, handler, triggeringStates = 8 /* Default */) {
    return super.addListener(type, (e) => {
      const currentState = this.getState();
      if (currentState & triggeringStates) {
        handler(e);
      }
    });
  }
  pushState(state) {
    this.stateQueue |= state;
  }
  popState(state) {
    this.stateQueue &= ~state;
  }
  getState() {
    return this.stateQueue & -this.stateQueue;
  }
  processEvent(event) {
    const types = this.decideInteractionEventTypes(event);
    if (types.length > 0) {
      this.dispatchEvent(event, types).catch((e) => Logger.errorOnce(e));
    }
  }
  dispatchEvent(event, types) {
    return __async(this, null, function* () {
      const coords = this.calculateCoordinates(event);
      if (coords == null) {
        return;
      }
      for (const type of types) {
        this.listeners.dispatchWrapHandlers(
          type,
          (handler, interactionEvent) => {
            if (!interactionEvent.consumed) {
              handler(interactionEvent);
            }
          },
          this.buildEvent(__spreadValues({ type, event }, coords))
        );
      }
    });
  }
  decideInteractionEventTypes(event) {
    const dragStart = "drag-start";
    switch (event.type) {
      case "click":
      case "dblclick":
      case "contextmenu":
      case "wheel":
        return [event.type];
      case "mousedown":
        this.mouseDown = true;
        this.dragStartElement = event.target;
        return [dragStart];
      case "touchstart":
        this.touchDown = true;
        this.dragStartElement = event.target;
        return [dragStart];
      case "touchmove":
      case "mousemove":
        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {
          return [];
        }
        return this.mouseDown || this.touchDown ? ["drag"] : ["hover"];
      case "mouseup":
        if (!this.mouseDown && !this.isEventOverElement(event)) {
          return [];
        }
        this.mouseDown = false;
        this.dragStartElement = void 0;
        return ["drag-end"];
      case "touchend":
        if (!this.touchDown && !this.isEventOverElement(event)) {
          return [];
        }
        this.touchDown = false;
        this.dragStartElement = void 0;
        return ["drag-end"];
      case "mouseout":
      case "touchcancel":
        return ["leave"];
      case "mouseenter":
        const mouseButtonDown = event instanceof MouseEvent && (event.buttons & 1) === 1;
        if (this.mouseDown !== mouseButtonDown) {
          this.mouseDown = mouseButtonDown;
          return [mouseButtonDown ? dragStart : "drag-end"];
        }
        return [];
      case "pagehide":
        return ["page-left"];
    }
    return [];
  }
  isEventOverElement(event) {
    var _a;
    return event.target === this.element || ((_a = event.target) == null ? void 0 : _a.parentElement) === this.element;
  }
  calculateCoordinates(event) {
    var _a;
    if (event instanceof MouseEvent) {
      return this.getMouseEventCoords(event);
    } else if (typeof TouchEvent !== "undefined" && event instanceof TouchEvent) {
      const lastTouch = (_a = event.touches[0]) != null ? _a : event.changedTouches[0];
      const { clientX, clientY, pageX, pageY } = lastTouch;
      return __spreadProps(__spreadValues({}, _InteractionManager.NULL_COORDS), { clientX, clientY, pageX, pageY });
    } else if (event instanceof PageTransitionEvent) {
      if (event.persisted) {
        return;
      }
      return _InteractionManager.NULL_COORDS;
    }
  }
  getMouseEventCoords(event) {
    const { clientX, clientY, pageX, pageY } = event;
    let { offsetX, offsetY } = event;
    const offsets = (el) => {
      let x = 0;
      let y = 0;
      while (el) {
        x += el.offsetLeft;
        y += el.offsetTop;
        el = el.offsetParent;
      }
      return { x, y };
    };
    if (this.dragStartElement != null && event.target !== this.dragStartElement) {
      const offsetDragStart = offsets(this.dragStartElement);
      const offsetEvent = offsets(event.target);
      offsetX -= offsetDragStart.x - offsetEvent.x;
      offsetY -= offsetDragStart.y - offsetEvent.y;
    }
    return { clientX, clientY, pageX, pageY, offsetX, offsetY };
  }
  isWheelEvent(event) {
    return event.type === "wheel";
  }
  buildEvent(opts) {
    const { type, event, clientX, clientY } = opts;
    let { offsetX, offsetY, pageX, pageY } = opts;
    if (!isFiniteNumber(offsetX) || !isFiniteNumber(offsetY)) {
      const rect = this.element.getBoundingClientRect();
      offsetX = clientX - rect.left;
      offsetY = clientY - rect.top;
    }
    if (!isFiniteNumber(pageX) || !isFiniteNumber(pageY)) {
      const pageRect = this.rootElement.getBoundingClientRect();
      pageX = clientX - pageRect.left;
      pageY = clientY - pageRect.top;
    }
    const deltaFactor = (input) => {
      const scaleOutput = 3;
      const zeroInput = 0.1;
      const outputCurveFit = 60;
      const sign = Math.sign(input);
      return (Math.log10(Math.abs(input) / outputCurveFit + zeroInput) * scaleOutput + scaleOutput) * sign;
    };
    let [deltaX, deltaY] = [NaN, NaN];
    if (this.isWheelEvent(event)) {
      const factorFn = event.deltaMode === 0 ? deltaFactor : (x) => x;
      deltaX = factorFn(event.deltaX);
      deltaY = factorFn(event.deltaY);
    }
    const builtEvent = {
      type,
      offsetX,
      offsetY,
      pageX,
      pageY,
      deltaX,
      deltaY,
      sourceEvent: event,
      consumed: false,
      consume() {
        builtEvent.consumed = true;
      }
    };
    this.debug("InteractionManager - builtEvent: ", builtEvent);
    return builtEvent;
  }
};
_InteractionManager.interactionDocuments = [];
_InteractionManager.NULL_COORDS = {
  clientX: -Infinity,
  clientY: -Infinity,
  pageX: -Infinity,
  pageY: -Infinity,
  offsetX: -Infinity,
  offsetY: -Infinity
};
var InteractionManager = _InteractionManager;

// packages/ag-charts-community/src/chart/interaction/animationManager.ts
var DEBUG_SELECTORS3 = [true, "animation"];
var AnimationManager = class extends BaseManager {
  constructor(interactionManager, chartUpdateMutex) {
    super();
    this.interactionManager = interactionManager;
    this.chartUpdateMutex = chartUpdateMutex;
    this.defaultDuration = 1e3;
    this.batch = new AnimationBatch();
    this.debug = Debug.create(...DEBUG_SELECTORS3);
    this.rafAvailable = typeof requestAnimationFrame !== "undefined";
    this.isPlaying = false;
    this.requestId = null;
    this.skipAnimations = false;
  }
  /**
   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists
   * with the same `id`, immediately stop it.
   */
  animate(_a) {
    var _b = _a, opts = __objRest(_b, [
      "disableInteractions"
    ]);
    var _a2;
    const batch = this.batch;
    try {
      batch.checkOverlappingId(opts.id);
    } catch (error) {
      this.failsafeOnError(error);
      return;
    }
    const id = (_a2 = opts.id) != null ? _a2 : Math.random().toString();
    const skip = this.isSkipped();
    if (skip) {
      this.debug("AnimationManager - skipping animation");
    }
    const animation = new Animation(__spreadProps(__spreadValues({}, opts), {
      id,
      skip,
      autoplay: this.isPlaying ? opts.autoplay : false,
      phase: opts.phase,
      defaultDuration: this.defaultDuration
    }));
    if (this.forceTimeJump(animation, this.defaultDuration)) {
      return;
    }
    this.batch.addAnimation(animation);
    return animation;
  }
  play() {
    if (this.isPlaying) {
      return;
    }
    this.isPlaying = true;
    this.debug("AnimationManager.play()");
    try {
      this.batch.play();
    } catch (error) {
      this.failsafeOnError(error);
    }
    this.requestAnimation();
  }
  pause() {
    if (!this.isPlaying) {
      return;
    }
    this.isPlaying = false;
    this.cancelAnimation();
    this.debug("AnimationManager.pause()");
    try {
      this.batch.pause();
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  stop() {
    this.isPlaying = false;
    this.cancelAnimation();
    this.debug("AnimationManager.stop()");
    this.batch.stop();
  }
  stopByAnimationId(id) {
    try {
      this.batch.stopByAnimationId(id);
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  stopByAnimationGroupId(id) {
    try {
      this.batch.stopByAnimationGroupId(id);
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  reset() {
    if (this.isPlaying) {
      this.stop();
      this.play();
    } else {
      this.stop();
    }
  }
  skip(skip = true) {
    this.skipAnimations = skip;
  }
  isSkipped() {
    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();
  }
  isActive() {
    return this.isPlaying && this.batch.isActive();
  }
  skipCurrentBatch() {
    if (this.debug.check()) {
      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });
    }
    this.batch.skip();
  }
  /** Mocking point for tests to guarantee that animation updates happen. */
  isSkippingFrames() {
    return true;
  }
  /** Mocking point for tests to capture requestAnimationFrame callbacks. */
  scheduleAnimationFrame(cb) {
    this.requestId = requestAnimationFrame(cb);
  }
  /** Mocking point for tests to skip animations to a specific point in time. */
  forceTimeJump(_animation, _defaultDuration) {
    return false;
  }
  requestAnimation() {
    if (!this.rafAvailable)
      return;
    if (!this.batch.isActive() || this.requestId !== null)
      return;
    let prevTime;
    const onAnimationFrame = (time) => __async(this, null, function* () {
      const executeAnimationFrame = () => __async(this, null, function* () {
        const deltaTime = time - (prevTime != null ? prevTime : time);
        prevTime = time;
        this.debug("AnimationManager - onAnimationFrame()", {
          controllersCount: this.batch.size,
          deltaTime
        });
        this.interactionManager.pushState(1 /* Animation */);
        try {
          this.batch.progress(deltaTime);
        } catch (error) {
          this.failsafeOnError(error);
        }
        this.listeners.dispatch("animation-frame", {
          type: "animation-frame",
          deltaMs: deltaTime
        });
      });
      if (this.isSkippingFrames()) {
        yield this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);
      } else {
        yield this.chartUpdateMutex.acquire(executeAnimationFrame);
      }
      if (this.batch.isActive()) {
        this.scheduleAnimationFrame(onAnimationFrame);
      } else {
        this.batch.stop();
      }
    });
    this.scheduleAnimationFrame(onAnimationFrame);
  }
  cancelAnimation() {
    if (this.requestId === null)
      return;
    cancelAnimationFrame(this.requestId);
    this.requestId = null;
    this.startBatch();
  }
  failsafeOnError(error, cancelAnimation = true) {
    Logger.error("Error during animation, skipping animations", error);
    if (cancelAnimation) {
      this.cancelAnimation();
    }
  }
  startBatch(skipAnimations) {
    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);
    this.reset();
    this.batch.stop();
    this.batch.destroy();
    this.batch = new AnimationBatch();
    if (skipAnimations === true) {
      this.batch.skip();
    }
  }
  endBatch() {
    this.debug(
      `AnimationManager - endBatch() with ${this.batch.size} animations; skipped: ${this.batch.isSkipped()}.`
    );
    if (!this.batch.isActive()) {
      this.interactionManager.popState(1 /* Animation */);
    }
    if (this.batch.isSkipped() && !this.batch.isActive()) {
      this.batch.skip(false);
    }
    this.requestAnimation();
  }
  onBatchStop(cb) {
    this.batch.stoppedCbs.add(cb);
  }
};

// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts
var ChartEventManager = class extends BaseManager {
  legendItemClick(series, itemId, enabled, legendItemName) {
    const event = {
      type: "legend-item-click",
      series,
      itemId,
      enabled,
      legendItemName
    };
    this.listeners.dispatch("legend-item-click", event);
  }
  legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {
    const event = {
      type: "legend-item-double-click",
      series,
      itemId,
      enabled,
      legendItemName,
      numVisibleItems
    };
    this.listeners.dispatch("legend-item-double-click", event);
  }
  axisHover(axisId, direction) {
    const event = {
      type: "axis-hover",
      axisId,
      direction
    };
    this.listeners.dispatch("axis-hover", event);
  }
};

// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts
var ContextMenuRegistry = class {
  constructor() {
    this.defaultActions = [];
    this.disabledActions = /* @__PURE__ */ new Set();
  }
  copyDefaultAction() {
    return [...this.defaultActions];
  }
  registerDefaultAction(action) {
    if (action.id && this.defaultActions.find(({ id }) => id === action.id)) {
      return;
    }
    this.defaultActions.push(action);
  }
  enableAction(actionId) {
    this.disabledActions.delete(actionId);
  }
  disableAction(actionId) {
    this.disabledActions.add(actionId);
  }
  isDisabled(actionId) {
    return this.disabledActions.has(actionId);
  }
};

// packages/ag-charts-community/src/chart/interaction/cursorManager.ts
var CursorManager = class {
  constructor(element2) {
    this.states = {};
    this.element = element2;
  }
  updateCursor(callerId, style) {
    delete this.states[callerId];
    if (style != null) {
      this.states[callerId] = { style };
    }
    this.applyStates();
  }
  applyStates() {
    let styleToApply = "default";
    Object.entries(this.states).reverse().slice(0, 1).forEach(([_, { style }]) => styleToApply = style);
    this.element.style.cursor = styleToApply;
  }
  getCursor() {
    return this.element.style.cursor;
  }
};

// packages/ag-charts-community/src/chart/interaction/gestureDetector.ts
function distanceSquared(finger1, finger2) {
  const dx = finger1.screenX - finger2.screenX;
  const dy = finger1.screenY - finger2.screenY;
  return dx * dx + dy * dy;
}
function distance(finger1, finger2) {
  return Math.sqrt(distanceSquared(finger1, finger2));
}
var MIN_DISTANCE_TO_START_PINCH = 1;
var GestureDetector = class extends BaseManager {
  constructor(element2) {
    super();
    this.touchstart = (event) => this.onTouchStart(event);
    this.touchmove = (event) => this.onTouchMove(event);
    this.touchend = (event) => this.onTouchEnd(event);
    this.touchcancel = (event) => this.onTouchCancel(event);
    this.pinch = {
      finger1: { identifier: NaN, screenX: NaN, screenY: NaN },
      finger2: { identifier: NaN, screenX: NaN, screenY: NaN },
      origin: { x: NaN, y: NaN },
      distance: NaN,
      status: 0 /* Off */
    };
    this.element = element2;
    element2.addEventListener("touchstart", this.touchstart, { passive: true });
    element2.addEventListener("touchmove", this.touchmove, { passive: true });
    element2.addEventListener("touchend", this.touchend);
    element2.addEventListener("touchcancel", this.touchcancel);
  }
  destroy() {
    const { element: element2 } = this;
    element2.removeEventListener("touchstart", this.touchstart);
    element2.removeEventListener("touchmove", this.touchmove);
    element2.removeEventListener("touchend", this.touchend);
    element2.removeEventListener("touchcancel", this.touchcancel);
  }
  findPinchTouches(moveEvent) {
    const { touches } = moveEvent;
    const { finger1, finger2 } = this.pinch;
    if (this.pinch.status !== 0 /* Off */ && touches.length === 2) {
      if (touches[0].identifier === finger1.identifier && touches[1].identifier === finger2.identifier) {
        return [touches[0], touches[1]];
      }
      if (touches[0].identifier === finger2.identifier && touches[1].identifier === finger1.identifier) {
        return [touches[1], touches[0]];
      }
    }
    return void 0;
  }
  copyTouchData(event) {
    const keys = ["identifier", "screenX", "screenY"];
    partialAssign(keys, this.pinch.finger1, event.touches[0]);
    partialAssign(keys, this.pinch.finger2, event.touches[1]);
    this.pinch.distance = distance(this.pinch.finger1, this.pinch.finger2);
  }
  dispatchPinchEvent(type, deltaDistance) {
    const { finger1, finger2, origin } = this.pinch;
    const newEvent = { type, finger1, finger2, deltaDistance, origin };
    this.listeners.dispatch(type, newEvent);
  }
  onTouchStart(event) {
    this.stopPinchTracking();
    const { pinch } = this;
    if (event.touches.length === 2) {
      pinch.status = 1 /* Initialized */;
      this.copyTouchData(event);
      pinch.origin.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;
      pinch.origin.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;
    }
  }
  onTouchMove(event) {
    const pinchTouches = this.findPinchTouches(event);
    if (pinchTouches !== void 0) {
      const [touch1, touch2] = pinchTouches;
      const { pinch } = this;
      const newDistance = distance(touch1, touch2);
      const deltaDistance = newDistance - pinch.distance;
      if (pinch.status === 1 /* Initialized */) {
        if (Math.abs(deltaDistance) > MIN_DISTANCE_TO_START_PINCH) {
          pinch.status = 2 /* Running */;
          this.copyTouchData(event);
          this.dispatchPinchEvent("pinch-start", 0);
        }
      } else if (pinch.status === 2 /* Running */) {
        pinch.distance = newDistance;
        this.copyTouchData(event);
        this.dispatchPinchEvent("pinch-move", deltaDistance);
      } else {
        Logger.error(`unexpected pinch.status: ${pinch.status}`);
      }
    }
  }
  onTouchEnd(_event) {
    this.stopPinchTracking();
  }
  onTouchCancel(_event) {
    this.stopPinchTracking();
  }
  stopPinchTracking() {
    const { pinch } = this;
    if (pinch.status === 2 /* Running */) {
      this.dispatchPinchEvent("pinch-end", 0);
    }
    this.pinch.status = 0 /* Off */;
  }
};

// packages/ag-charts-community/src/chart/interaction/highlightManager.ts
var HighlightManager = class extends BaseManager {
  constructor() {
    super(...arguments);
    this.highlightStates = /* @__PURE__ */ new Map();
    this.pickedStates = /* @__PURE__ */ new Map();
  }
  updateHighlight(callerId, highlightedDatum) {
    this.highlightStates.delete(callerId);
    if (highlightedDatum != null) {
      this.highlightStates.set(callerId, highlightedDatum);
    }
    this.applyHighlightStates();
  }
  getActiveHighlight() {
    return this.activeHighlight;
  }
  updatePicked(callerId, clickableDatum) {
    this.pickedStates.delete(callerId);
    if (clickableDatum != null) {
      this.pickedStates.set(callerId, clickableDatum);
    }
    this.applyPickedStates();
  }
  getActivePicked() {
    return this.activePicked;
  }
  applyHighlightStates() {
    const { activeHighlight: previousHighlight } = this;
    this.activeHighlight = Array.from(this.highlightStates.values()).pop();
    if (!this.isEqual(this.activeHighlight, previousHighlight)) {
      this.listeners.dispatch("highlight-change", {
        type: "highlight-change",
        currentHighlight: this.activeHighlight,
        previousHighlight
      });
    }
  }
  applyPickedStates() {
    this.activePicked = Array.from(this.pickedStates.values()).pop();
  }
  isEqual(a, b) {
    return a === b || (a == null ? void 0 : a.series) === (b == null ? void 0 : b.series) && (a == null ? void 0 : a.itemId) === (b == null ? void 0 : b.itemId) && (a == null ? void 0 : a.datum) === (b == null ? void 0 : b.datum);
  }
};

// packages/ag-charts-community/src/util/bboxset.ts
function nodeContainsPoint(node, x, y) {
  var _a, _b;
  return (_b = (_a = node.bbox.computeBBox()) == null ? void 0 : _a.containsPoint(x, y)) != null ? _b : false;
}
function nodeArea(node) {
  var _a;
  const { width = 0, height = 0 } = (_a = node.bbox.computeBBox()) != null ? _a : {};
  return width * height;
}
var BBoxSet = class {
  constructor() {
    this.nodes = [];
  }
  add(value, bbox) {
    this.nodes.push({ value, bbox });
  }
  find(x, y) {
    return this.nodes.filter((node) => nodeContainsPoint(node, x, y)).sort((a, b) => nodeArea(a) - nodeArea(b)).map((node) => node.value);
  }
  *[Symbol.iterator]() {
    for (const { value } of Object.values(this.nodes)) {
      yield value;
    }
  }
  clear() {
    this.nodes.length = 0;
  }
};

// packages/ag-charts-community/src/chart/interaction/regionManager.ts
var RegionListeners = class extends Listeners {
};
var RegionManager = class {
  constructor(interactionManager) {
    this.interactionManager = interactionManager;
    this.eventHandler = (event) => this.processEvent(event);
    this.regions = new BBoxSet();
    this.destroyFns = [];
    INTERACTION_TYPES.forEach(
      (t) => this.destroyFns.push(interactionManager.addListener(t, this.eventHandler, 15 /* All */))
    );
  }
  destroy() {
    this.destroyFns.forEach((fn) => fn());
    this.currentRegion = void 0;
    for (const region of this.regions) {
      region.listeners.destroy();
    }
    this.regions.clear();
  }
  pushRegion(name, bboxprovider) {
    const region = { name, listeners: new RegionListeners() };
    this.regions.add(region, bboxprovider);
    return region;
  }
  addRegion(name, bboxprovider) {
    const region = this.pushRegion(name, bboxprovider);
    const { interactionManager } = this;
    class ObservableRegionImplementation {
      addListener(type, handler, triggeringStates = 8 /* Default */) {
        return region.listeners.addListener(type, (e) => {
          if (!e.consumed) {
            const currentState = interactionManager.getState();
            if (currentState & triggeringStates) {
              handler(e);
            }
          }
        });
      }
    }
    return new ObservableRegionImplementation();
  }
  processEvent(event) {
    const { currentRegion } = this;
    const newRegion = this.pickRegion(event.offsetX, event.offsetY);
    if (currentRegion !== void 0 && (newRegion == null ? void 0 : newRegion.name) !== currentRegion.name) {
      currentRegion == null ? void 0 : currentRegion.listeners.dispatch("leave", __spreadProps(__spreadValues({}, event), { type: "leave" }));
    }
    if (newRegion !== void 0) {
      const dispatcher = () => __async(this, null, function* () {
        return newRegion.listeners.dispatch(event.type, event);
      });
      dispatcher().catch((e) => Logger.errorOnce(e));
    }
    this.currentRegion = newRegion;
  }
  pickRegion(x, y) {
    const matchingRegions = this.regions.find(x, y);
    return matchingRegions.length > 0 ? matchingRegions[0] : void 0;
  }
};

// packages/ag-charts-community/src/chart/interaction/syncManager.ts
var _SyncManager = class _SyncManager extends BaseManager {
  constructor(chart) {
    super();
    this.chart = chart;
  }
  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    let syncGroup = this.get(groupId);
    if (!syncGroup) {
      syncGroup = /* @__PURE__ */ new Set();
      _SyncManager.chartsGroups.set(groupId, syncGroup);
    }
    syncGroup.add(this.chart);
    return this;
  }
  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    var _a;
    (_a = this.get(groupId)) == null ? void 0 : _a.delete(this.chart);
    return this;
  }
  getChart() {
    return this.chart;
  }
  getGroup(groupId = _SyncManager.DEFAULT_GROUP) {
    const syncGroup = this.get(groupId);
    return syncGroup ? Array.from(syncGroup) : [];
  }
  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {
    return this.getGroup(groupId).filter((chart) => chart !== this.chart);
  }
  get(groupId) {
    return _SyncManager.chartsGroups.get(groupId);
  }
};
_SyncManager.chartsGroups = /* @__PURE__ */ new Map();
_SyncManager.DEFAULT_GROUP = Symbol("sync-group-default");
var SyncManager = _SyncManager;

// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts
var TooltipManager = class {
  constructor(tooltip, interactionManager) {
    this.states = {};
    this.exclusiveAreas = {};
    this.destroyFns = [];
    this.tooltip = tooltip;
    this.destroyFns.push(interactionManager.addListener("hover", (e) => this.checkExclusiveRects(e)));
  }
  getRange() {
    return this.tooltip.range;
  }
  updateTooltip(callerId, meta, content) {
    var _a;
    if (content == null) {
      content = (_a = this.states[callerId]) == null ? void 0 : _a.content;
    }
    this.states[callerId] = { content, meta };
    this.applyStates();
  }
  updateExclusiveRect(callerId, area2) {
    if (area2) {
      this.exclusiveAreas[callerId] = area2;
    } else {
      delete this.exclusiveAreas[callerId];
    }
  }
  removeTooltip(callerId) {
    delete this.states[callerId];
    this.applyStates();
  }
  getTooltipMeta(callerId) {
    var _a;
    return (_a = this.states[callerId]) == null ? void 0 : _a.meta;
  }
  destroy() {
    for (const destroyFn of this.destroyFns) {
      destroyFn();
    }
  }
  checkExclusiveRects(e) {
    let newAppliedExclusiveArea;
    for (const [entryId, area2] of Object.entries(this.exclusiveAreas)) {
      if (!area2.containsPoint(e.offsetX, e.offsetY)) {
        continue;
      }
      newAppliedExclusiveArea = entryId;
      break;
    }
    if (newAppliedExclusiveArea === this.appliedExclusiveArea) {
      return;
    }
    this.appliedExclusiveArea = newAppliedExclusiveArea;
    this.applyStates();
  }
  applyStates() {
    var _a;
    const ids = this.appliedExclusiveArea ? [this.appliedExclusiveArea] : Object.keys(this.states);
    let contentToApply;
    let metaToApply;
    ids.reverse();
    ids.slice(0, 1).forEach((id) => {
      var _a2;
      const { content, meta } = (_a2 = this.states[id]) != null ? _a2 : {};
      contentToApply = content;
      metaToApply = meta;
    });
    if (metaToApply === void 0 || contentToApply === void 0) {
      this.appliedState = void 0;
      this.tooltip.toggle(false);
      return;
    }
    if (((_a = this.appliedState) == null ? void 0 : _a.content) === contentToApply) {
      const renderInstantly = this.tooltip.isVisible();
      this.tooltip.show(metaToApply, void 0, renderInstantly);
    } else {
      this.tooltip.show(metaToApply, contentToApply);
    }
    this.appliedState = { content: contentToApply, meta: metaToApply };
  }
  static makeTooltipMeta(event, datum) {
    var _a, _b, _c, _d;
    const { offsetX, offsetY } = event;
    const { tooltip } = datum.series.properties;
    const position = {
      xOffset: tooltip.position.xOffset,
      yOffset: tooltip.position.yOffset
    };
    const meta = {
      offsetX,
      offsetY,
      lastPointerEvent: { offsetX, offsetY },
      showArrow: tooltip.showArrow,
      position
    };
    const refPoint = (_b = (_a = datum.yBar) == null ? void 0 : _a.upperPoint) != null ? _b : datum.midPoint;
    if (tooltip.position.type === "node" && refPoint) {
      const { x, y } = refPoint;
      const point = datum.series.contentGroup.inverseTransformPoint(x, y);
      return __spreadProps(__spreadValues({}, meta), {
        offsetX: Math.round(point.x),
        offsetY: Math.round(point.y)
      });
    }
    meta.enableInteraction = (_d = (_c = tooltip.interaction) == null ? void 0 : _c.enabled) != null ? _d : false;
    return meta;
  }
};

// packages/ag-charts-community/src/chart/interaction/zoomManager.ts
var ZoomManager = class extends BaseManager {
  constructor() {
    super(...arguments);
    this.axisZoomManagers = /* @__PURE__ */ new Map();
  }
  updateAxes(axes) {
    var _a;
    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));
    this.axisZoomManagers.clear();
    for (const axis of axes) {
      this.axisZoomManagers.set(axis.id, (_a = zoomManagers.get(axis.id)) != null ? _a : new AxisZoomManager(axis));
    }
    if (this.initialZoom) {
      this.updateZoom(this.initialZoom);
      this.initialZoom = void 0;
    }
  }
  updateZoom(newZoom) {
    if (this.axisZoomManagers.size === 0) {
      this.initialZoom = newZoom;
      return;
    }
    this.axisZoomManagers.forEach((axis) => {
      axis.updateZoom(newZoom == null ? void 0 : newZoom[axis.getDirection()]);
    });
    this.applyChanges();
  }
  updateAxisZoom(axisId, newZoom) {
    var _a;
    (_a = this.axisZoomManagers.get(axisId)) == null ? void 0 : _a.updateZoom(newZoom);
    this.applyChanges();
  }
  getZoom() {
    let x;
    let y;
    this.axisZoomManagers.forEach((axis) => {
      if (axis.getDirection() === "x" /* X */) {
        x != null ? x : x = axis.getZoom();
      } else if (axis.getDirection() === "y" /* Y */) {
        y != null ? y : y = axis.getZoom();
      }
    });
    if (x || y) {
      return { x, y };
    }
  }
  getAxisZoom(axisId) {
    var _a, _b;
    return (_b = (_a = this.axisZoomManagers.get(axisId)) == null ? void 0 : _a.getZoom()) != null ? _b : { min: 0, max: 1 };
  }
  getAxisZooms() {
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = {
        direction: axis.getDirection(),
        zoom: axis.getZoom()
      };
    }
    return axes;
  }
  applyChanges() {
    const changed = Array.from(this.axisZoomManagers.values()).map((axis) => axis.applyChanges()).some(Boolean);
    if (!changed) {
      return;
    }
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = axis.getZoom();
    }
    this.listeners.dispatch("zoom-change", __spreadProps(__spreadValues({ type: "zoom-change" }, this.getZoom()), { axes }));
  }
};
var AxisZoomManager = class {
  constructor(axis) {
    this.pendingZoom = null;
    this.axis = axis;
    const [min = 0, max = 1] = axis.visibleRange;
    this.initialZoom = this.currentZoom = { min, max };
  }
  getDirection() {
    return this.axis.direction;
  }
  updateZoom(newZoom) {
    this.pendingZoom = newZoom ? __spreadValues({}, newZoom) : null;
  }
  getZoom() {
    return deepClone(this.currentZoom);
  }
  applyChanges() {
    var _a;
    const prevZoom = this.currentZoom;
    this.currentZoom = (_a = this.pendingZoom) != null ? _a : this.initialZoom;
    return prevZoom.min !== this.currentZoom.min || prevZoom.max !== this.currentZoom.max;
  }
};

// packages/ag-charts-community/src/chart/layout/layoutService.ts
var LayoutService = class extends Listeners {
  constructor() {
    super(...arguments);
    this.layoutComplete = "layout-complete";
  }
  addListener(eventType, handler) {
    if (this.isLayoutStage(eventType) || this.isLayoutComplete(eventType)) {
      return super.addListener(eventType, handler);
    }
    throw new Error(`AG Charts - unsupported listener type: ${eventType}`);
  }
  dispatchPerformLayout(stage, ctx) {
    if (this.isLayoutStage(stage)) {
      return this.getListenersByType(stage).reduce((result, listener) => {
        try {
          return listener.handler(result);
        } catch (e) {
          Logger.errorOnce(e);
          return result;
        }
      }, ctx);
    }
    return ctx;
  }
  dispatchLayoutComplete(event) {
    this.dispatch(this.layoutComplete, event);
  }
  isLayoutStage(eventType) {
    return eventType !== this.layoutComplete;
  }
  isLayoutComplete(eventType) {
    return eventType === this.layoutComplete;
  }
};

// packages/ag-charts-community/src/chart/gridLayout.ts
function gridLayout({
  orientation,
  bboxes,
  maxHeight,
  maxWidth,
  itemPaddingY = 0,
  itemPaddingX = 0,
  forceResult = false
}) {
  const horizontal = orientation === "horizontal";
  const primary = {
    max: horizontal ? maxWidth : maxHeight,
    fn: horizontal ? (b) => b.width : (b) => b.height,
    padding: horizontal ? itemPaddingX : itemPaddingY
  };
  const secondary = {
    max: !horizontal ? maxWidth : maxHeight,
    fn: !horizontal ? (b) => b.width : (b) => b.height,
    padding: !horizontal ? itemPaddingX : itemPaddingY
  };
  let processedBBoxCount = 0;
  const rawPages = [];
  while (processedBBoxCount < bboxes.length) {
    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);
    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);
    if (!result) {
      return;
    }
    processedBBoxCount += result.processedBBoxCount;
    rawPages.push(result.pageIndices);
  }
  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);
}
function processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {
  const minGuess = 1;
  let startingGuess = estimateStartingGuess(bboxes, primary);
  if (startingGuess < minGuess) {
    if (!forceResult) {
      return void 0;
    }
    startingGuess = minGuess;
  }
  for (let guess = startingGuess; guess >= minGuess; guess--) {
    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);
    if (pageIndices == null && guess <= minGuess) {
      return void 0;
    }
    if (pageIndices == null) {
      continue;
    }
    if (typeof pageIndices === "number") {
      if (pageIndices <= minGuess) {
        return void 0;
      }
      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;
      continue;
    }
    const processedBBoxCount = pageIndices.length * pageIndices[0].length;
    return { processedBBoxCount, pageIndices };
  }
}
function calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {
  var _a;
  const result = [];
  let sumSecondary = 0;
  let currentMaxSecondary = 0;
  let currentPrimaryIndices = [];
  const maxPrimaryValues = [];
  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {
    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;
    if (primaryValueIdx === 0) {
      sumSecondary += currentMaxSecondary;
      currentMaxSecondary = 0;
      if (currentPrimaryIndices.length > 0) {
        result.push(currentPrimaryIndices);
      }
      currentPrimaryIndices = [];
    }
    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;
    maxPrimaryValues[primaryValueIdx] = Math.max((_a = maxPrimaryValues[primaryValueIdx]) != null ? _a : 0, primaryValue);
    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);
    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;
    const returnResult = !forceResult || result.length > 0;
    if (currentSecondaryDimension > secondary.max && returnResult) {
      currentPrimaryIndices = [];
      break;
    }
    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);
    if (sumPrimary > primary.max && !forceResult) {
      if (maxPrimaryValues.length < primaryCount) {
        return maxPrimaryValues.length;
      }
      return void 0;
    }
    currentPrimaryIndices.push(bboxIndex + indexOffset);
  }
  if (currentPrimaryIndices.length > 0) {
    result.push(currentPrimaryIndices);
  }
  return result.length > 0 ? result : void 0;
}
function buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {
  let maxPageWidth = 0;
  let maxPageHeight = 0;
  const pages = rawPages.map((indices) => {
    if (orientation === "horizontal") {
      indices = transpose(indices);
    }
    let endIndex = 0;
    const columns = indices.map((colIndices) => {
      const colBBoxes = colIndices.map((bboxIndex) => {
        endIndex = Math.max(bboxIndex, endIndex);
        return bboxes[bboxIndex];
      });
      let columnHeight = 0;
      let columnWidth = 0;
      colBBoxes.forEach((bbox) => {
        columnHeight += bbox.height + itemPaddingY;
        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);
      });
      return {
        indices: colIndices,
        bboxes: colBBoxes,
        columnHeight: Math.ceil(columnHeight),
        columnWidth: Math.ceil(columnWidth)
      };
    });
    let pageWidth = 0;
    let pageHeight = 0;
    columns.forEach((column) => {
      pageWidth += column.columnWidth;
      pageHeight = Math.max(pageHeight, column.columnHeight);
    });
    maxPageWidth = Math.max(pageWidth, maxPageWidth);
    maxPageHeight = Math.max(pageHeight, maxPageHeight);
    return {
      columns,
      startIndex: indices[0][0],
      endIndex,
      pageWidth,
      pageHeight
    };
  });
  return { pages, maxPageWidth, maxPageHeight };
}
function transpose(data) {
  const result = [];
  for (const _ of data[0]) {
    result.push([]);
  }
  data.forEach((innerData, dataIdx) => {
    innerData.forEach((item, itemIdx) => {
      result[itemIdx][dataIdx] = item;
    });
  });
  return result;
}
function estimateStartingGuess(bboxes, primary) {
  const n = bboxes.length;
  let primarySum = 0;
  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {
    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;
    if (primarySum > primary.max) {
      const ratio = n / bboxIndex;
      if (ratio < 2) {
        return Math.ceil(n / 2);
      }
      return bboxIndex;
    }
  }
  return n;
}

// packages/ag-charts-community/src/scene/polyRoots.ts
function linearRoot(a, b) {
  const t = -b / a;
  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];
}
function quadraticRoots(a, b, c) {
  if (a === 0) {
    return linearRoot(b, c);
  }
  const D = b * b - 4 * a * c;
  const roots = [];
  if (D === 0) {
    const t = -b / (2 * a);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
  } else if (D > 0) {
    const rD = Math.sqrt(D);
    const t1 = (-b - rD) / (2 * a);
    const t2 = (-b + rD) / (2 * a);
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
  }
  return roots;
}
function cubicRoots(a, b, c, d) {
  if (a === 0) {
    return quadraticRoots(b, c, d);
  }
  const A = b / a;
  const B = c / a;
  const C = d / a;
  const Q = (3 * B - A * A) / 9;
  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;
  const D = Q * Q * Q + R * R;
  const third = 1 / 3;
  const roots = [];
  if (D >= 0) {
    const rD = Math.sqrt(D);
    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);
    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);
    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);
    const t = -third * A + (S + T);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
    if (Im === 0) {
      const t2 = -third * A - (S + T) / 2;
      if (t2 >= 0 && t2 <= 1) {
        roots.push(t2);
      }
    }
  } else {
    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));
    const thirdA = third * A;
    const twoSqrtQ = 2 * Math.sqrt(-Q);
    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;
    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;
    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
    if (t3 >= 0 && t3 <= 1) {
      roots.push(t3);
    }
  }
  return roots;
}

// packages/ag-charts-community/src/scene/intersection.ts
function segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);
  if (d === 0) {
    return null;
  }
  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;
  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    return {
      x: ax1 + ua * (ax2 - ax1),
      y: ay1 + ua * (ay2 - ay1)
    };
  }
  return null;
}
function cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {
  const intersections = [];
  const A = y1 - y2;
  const B = x2 - x1;
  const C = x1 * (y2 - y1) - y1 * (x2 - x1);
  const bx = bezierCoefficients(px1, px2, px3, px4);
  const by = bezierCoefficients(py1, py2, py3, py4);
  const a = A * bx[0] + B * by[0];
  const b = A * bx[1] + B * by[1];
  const c = A * bx[2] + B * by[2];
  const d = A * bx[3] + B * by[3] + C;
  const roots = cubicRoots(a, b, c, d);
  for (const t of roots) {
    const tt = t * t;
    const ttt = t * tt;
    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
    let s;
    if (x1 !== x2) {
      s = (x - x1) / (x2 - x1);
    } else {
      s = (y - y1) / (y2 - y1);
    }
    if (s >= 0 && s <= 1) {
      intersections.push({ x, y });
    }
  }
  return intersections;
}
function bezierCoefficients(P1, P2, P3, P4) {
  return [
    // Bézier expressed as matrix operations:
    -P1 + 3 * P2 - 3 * P3 + P4,
    //                 |-1  3 -3  1| |P1|
    3 * P1 - 6 * P2 + 3 * P3,
    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|
    -3 * P1 + 3 * P2,
    //                 |-3  3  0  0| |P3|
    P1
    //                 | 1  0  0  0| |P4|
  ];
}
function arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {
  const k = (y2 - y1) / (x2 - x1);
  const y0 = y1 - k * x1;
  const a = Math.pow(k, 2) + 1;
  const b = 2 * (k * (y0 - cy) - cx);
  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);
  const d = Math.pow(b, 2) - 4 * a * c;
  if (d < 0) {
    return [];
  }
  const i1x = (-b + Math.sqrt(d)) / 2 / a;
  const i2x = (-b - Math.sqrt(d)) / 2 / a;
  const intersections = [];
  [i1x, i2x].forEach((x) => {
    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);
    if (!isXInsideLine) {
      return;
    }
    const y = k * x + y0;
    const a1 = normalizeAngle360(startAngle);
    let a2 = normalizeAngle360(endAngle);
    let a3 = normalizeAngle360(Math.atan2(y, x));
    if (a2 <= a1) {
      a2 += 2 * Math.PI;
    }
    if (a3 < a1) {
      a3 += 2 * Math.PI;
    }
    if (counterClockwise !== (a3 >= a1 && a3 <= a2)) {
      intersections.push({ x, y });
    }
  });
  return intersections;
}

// packages/ag-charts-community/src/scene/path2D.ts
var Path2D = class {
  constructor() {
    this.previousCommands = [];
    this.previousParams = [];
    this.previousClosedPath = false;
    this.commands = [];
    this.params = [];
    this._closedPath = false;
  }
  isDirty() {
    if (this._closedPath !== this.previousClosedPath) {
      return true;
    }
    if (this.previousCommands.length !== this.commands.length) {
      return true;
    }
    if (this.previousParams.length !== this.params.length) {
      return true;
    }
    for (let i = 0; i < this.commands.length; i++) {
      if (this.commands[i] !== this.previousCommands[i]) {
        return true;
      }
    }
    for (let i = 0; i < this.params.length; i++) {
      if (this.params[i] !== this.previousParams[i]) {
        return true;
      }
    }
    return false;
  }
  draw(ctx) {
    const commands = this.commands;
    const params = this.params;
    let j = 0;
    ctx.beginPath();
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
          ctx.moveTo(params[j++], params[j++]);
          break;
        case 1 /* Line */:
          ctx.lineTo(params[j++], params[j++]);
          break;
        case 3 /* Curve */:
          ctx.bezierCurveTo(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++]);
          break;
        case 2 /* Arc */:
          ctx.arc(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++] === 1);
          break;
        case 4 /* ClosePath */:
          ctx.closePath();
          break;
      }
    }
    if (commands.length === 0) {
      ctx.closePath();
    }
  }
  moveTo(x, y) {
    if (this.xy) {
      this.xy[0] = x;
      this.xy[1] = y;
    } else {
      this.xy = [x, y];
    }
    this.commands.push(0 /* Move */);
    this.params.push(x, y);
  }
  lineTo(x, y) {
    if (this.xy) {
      this.commands.push(1 /* Line */);
      this.params.push(x, y);
      this.xy[0] = x;
      this.xy[1] = y;
    } else {
      this.moveTo(x, y);
    }
  }
  rect(x, y, width, height) {
    this.moveTo(x, y);
    this.lineTo(x + width, y);
    this.lineTo(x + width, y + height);
    this.lineTo(x, y + height);
    this.closePath();
  }
  roundRect(x, y, width, height, radii) {
    radii = Math.min(radii, width / 2, height / 2);
    this.moveTo(x, y + radii);
    this.arc(x + radii, y + radii, radii, Math.PI, 3 * Math.PI / 2);
    this.lineTo(x + radii, y);
    this.lineTo(x + width - radii, y);
    this.arc(x + width - radii, y + radii, radii, 3 * Math.PI / 2, 2 * Math.PI);
    this.lineTo(x + width, y + radii);
    this.lineTo(x + width, y + height - radii);
    this.arc(x + width - radii, y + height - radii, radii, 0, Math.PI / 2);
    this.lineTo(x + width - radii, y + height);
    this.lineTo(x + radii, y + height);
    this.arc(x + +radii, y + height - radii, radii, Math.PI / 2, Math.PI);
    this.lineTo(x, y + height - radii);
    this.closePath();
  }
  arc(x, y, r, sAngle, eAngle, antiClockwise = false) {
    const endX = x + r * Math.cos(eAngle);
    const endY = y + r * Math.sin(eAngle);
    if (this.xy) {
      this.xy[0] = endX;
      this.xy[1] = endY;
    } else {
      this.xy = [endX, endY];
    }
    this.commands.push(2 /* Arc */);
    this.params.push(x, y, r, sAngle, eAngle, antiClockwise ? 1 : 0);
  }
  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {
    if (!this.xy) {
      this.moveTo(cx1, cy1);
    }
    this.commands.push(3 /* Curve */);
    this.params.push(cx1, cy1, cx2, cy2, x, y);
    if (this.xy) {
      this.xy[0] = x;
      this.xy[1] = y;
    }
  }
  get closedPath() {
    return this._closedPath;
  }
  closePath() {
    if (this.xy) {
      this.xy = void 0;
      this.commands.push(4 /* ClosePath */);
      this._closedPath = true;
    }
  }
  clear({ trackChanges } = { trackChanges: false }) {
    if (trackChanges) {
      this.previousCommands = this.commands;
      this.previousParams = this.params;
      this.previousClosedPath = this._closedPath;
      this.commands = [];
      this.params = [];
    } else {
      this.commands.length = 0;
      this.params.length = 0;
    }
    this.xy = void 0;
    this._closedPath = false;
  }
  isPointInPath(x, y) {
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    const ox = -1e4;
    const oy = -1e4;
    let sx = NaN;
    let sy = NaN;
    let px = 0;
    let py = 0;
    let intersectionCount = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
          if (!isNaN(sx) && segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {
            intersectionCount++;
          }
          px = params[pi++];
          sx = px;
          py = params[pi++];
          sy = py;
          break;
        case 1 /* Line */:
          if (segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y)) {
            intersectionCount++;
          }
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 3 /* Curve */:
          intersectionCount += cubicSegmentIntersections(
            px,
            py,
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            ox,
            oy,
            x,
            y
          ).length;
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 2 /* Arc */:
          const cx = params[pi++];
          const cy = params[pi++];
          const r = params[pi++];
          const startAngle = params[pi++];
          const endAngle = params[pi++];
          const counterClockwise = Boolean(params[pi++]);
          intersectionCount += arcIntersections(
            cx,
            cy,
            r,
            startAngle,
            endAngle,
            counterClockwise,
            ox,
            oy,
            x,
            y
          ).length;
          px = cx + Math.cos(endAngle) * r;
          py = cy + Math.sin(endAngle) * r;
          break;
        case 4 /* ClosePath */:
          if (!isNaN(sx) && segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {
            intersectionCount++;
          }
          break;
      }
    }
    return intersectionCount % 2 === 1;
  }
  getPoints() {
    const { commands, params } = this;
    const coords = [];
    let pi = 0;
    for (let ci = 0; ci < commands.length; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
        case 1 /* Line */:
          coords.push({ x: params[pi++], y: params[pi++] });
          break;
        case 3 /* Curve */:
          pi += 4;
          coords.push({ x: params[pi++], y: params[pi++] });
          break;
        case 2 /* Arc */:
          coords.push({ x: params[pi++], y: params[pi++] });
          pi += 4;
          break;
      }
    }
    return coords;
  }
};

// packages/ag-charts-community/src/scene/shape/path.ts
function ScenePathChangeDetection(opts) {
  const { redraw = 3 /* MAJOR */, changeCb, convertor } = opts != null ? opts : {};
  return SceneChangeDetection({ redraw, type: "path", convertor, changeCb });
}
var Path = class extends Shape {
  constructor() {
    super(...arguments);
    /**
     * Declare a path to retain for later rendering and hit testing
     * using custom Path2D class. Think of it as a TypeScript version
     * of the native Path2D (with some differences) that works in all browsers.
     */
    this.path = new Path2D();
    this._clipX = NaN;
    this._clipY = NaN;
    /**
     * The path only has to be updated when certain attributes change.
     * For example, if transform attributes (such as `translationX`)
     * are changed, we don't have to update the path. The `dirtyPath` flag
     * is how we keep track if the path has to be updated or not.
     */
    this._dirtyPath = true;
  }
  set clipX(value) {
    this._clipX = value;
    this.dirtyPath = true;
  }
  set clipY(value) {
    this._clipY = value;
    this.dirtyPath = true;
  }
  set dirtyPath(value) {
    if (this._dirtyPath !== value) {
      this._dirtyPath = value;
      if (value) {
        this.markDirty(this, 3 /* MAJOR */);
      }
    }
  }
  get dirtyPath() {
    return this._dirtyPath;
  }
  checkPathDirty() {
    var _a, _b, _c, _d;
    if (this._dirtyPath) {
      return;
    }
    this.dirtyPath = this.path.isDirty() || ((_b = (_a = this.fillShadow) == null ? void 0 : _a.isDirty()) != null ? _b : false) || ((_d = (_c = this._clipPath) == null ? void 0 : _c.isDirty()) != null ? _d : false);
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    return this.path.closedPath && this.path.isPointInPath(point.x, point.y);
  }
  isDirtyPath() {
    return false;
  }
  updatePath() {
  }
  render(renderCtx) {
    var _a, _b, _c, _d, _e;
    const { ctx, forceRender, stats } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped += this.nodeCount.count;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    if (this.dirtyPath || this.isDirtyPath()) {
      this.updatePath();
      this.dirtyPath = false;
    }
    if (!isNaN(this._clipX) && !isNaN(this._clipY) && this.clipMode != null) {
      ctx.save();
      const margin = this.strokeWidth / 2;
      (_a = this._clipPath) != null ? _a : this._clipPath = new Path2D();
      this._clipPath.clear();
      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);
      if (this.clipMode === "normal") {
        (_b = this._clipPath) == null ? void 0 : _b.draw(ctx);
        ctx.clip();
      }
      if (this._clipX > 0 && this._clipY > 0) {
        this.path.draw(ctx);
        this.fillStroke(ctx);
      }
      if (this.clipMode === "punch-out") {
        (_c = this._clipPath) == null ? void 0 : _c.draw(ctx);
        ctx.clip();
        const { x = -1e4, y = -1e4, width = 2e4, height = 2e4 } = (_d = this.computeBBox()) != null ? _d : {};
        ctx.clearRect(x, y, width, height);
      }
      ctx.restore();
    } else {
      this.path.draw(ctx);
      this.fillStroke(ctx);
    }
    (_e = this.fillShadow) == null ? void 0 : _e.markClean();
    super.render(renderCtx);
  }
};
Path.className = "Path";
__decorateClass([
  ScenePathChangeDetection()
], Path.prototype, "clipMode", 2);
__decorateClass([
  ScenePathChangeDetection()
], Path.prototype, "clipX", 1);
__decorateClass([
  ScenePathChangeDetection()
], Path.prototype, "clipY", 1);

// packages/ag-charts-community/src/chart/marker/marker.ts
var Marker = class extends Path {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.size = 12;
  }
  computeBBox() {
    const { x, y, size } = this;
    const half = size / 2;
    return new BBox(x - half, y - half, size, size);
  }
  applyPath(s, moves) {
    const { path } = this;
    let { x, y } = this;
    path.clear();
    for (const { x: mx, y: my, t } of moves) {
      x += mx * s;
      y += my * s;
      if (t === "move") {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    }
    path.closePath();
  }
};
__decorateClass([
  ScenePathChangeDetection()
], Marker.prototype, "x", 2);
__decorateClass([
  ScenePathChangeDetection()
], Marker.prototype, "y", 2);
__decorateClass([
  ScenePathChangeDetection({ convertor: Math.abs })
], Marker.prototype, "size", 2);

// packages/ag-charts-community/src/chart/marker/circle.ts
var Circle = class extends Marker {
  updatePath() {
    const { x, y, path, size } = this;
    const r = size / 2;
    path.clear();
    path.arc(x, y, r, 0, Math.PI * 2);
    path.closePath();
  }
};
Circle.className = "Circle";

// packages/ag-charts-community/src/chart/marker/cross.ts
var _Cross = class _Cross extends Marker {
  updatePath() {
    const s = this.size / 4.2;
    super.applyPath(s, _Cross.moves);
  }
};
_Cross.className = "Cross";
_Cross.moves = [
  { x: -1, y: 0, t: "move" },
  { x: -1, y: -1 },
  { x: 1, y: -1 },
  { x: 1, y: 1 },
  { x: 1, y: -1 },
  { x: 1, y: 1 },
  { x: -1, y: 1 },
  { x: 1, y: 1 },
  { x: -1, y: 1 },
  { x: -1, y: -1 },
  { x: -1, y: 1 },
  { x: -1, y: -1 }
];
var Cross = _Cross;

// packages/ag-charts-community/src/chart/marker/diamond.ts
var _Diamond = class _Diamond extends Marker {
  updatePath() {
    const s = this.size / 2;
    super.applyPath(s, _Diamond.moves);
  }
};
_Diamond.className = "Diamond";
_Diamond.moves = [
  { x: 0, y: -1, t: "move" },
  { x: 1, y: 1 },
  { x: -1, y: 1 },
  { x: -1, y: -1 },
  { x: 1, y: -1 }
];
var Diamond = _Diamond;

// packages/ag-charts-community/src/chart/marker/heart.ts
var Heart = class extends Marker {
  rad(degree) {
    return degree / 180 * Math.PI;
  }
  updatePath() {
    const { x, path, size, rad } = this;
    const r = size / 4;
    const y = this.y + r / 2;
    path.clear();
    path.arc(x - r, y - r, r, rad(130), rad(330));
    path.arc(x + r, y - r, r, rad(220), rad(50));
    path.lineTo(x, y + r);
    path.closePath();
  }
};
Heart.className = "Heart";

// packages/ag-charts-community/src/chart/marker/plus.ts
var _Plus = class _Plus extends Marker {
  updatePath() {
    const s = this.size / 3;
    super.applyPath(s, _Plus.moves);
  }
};
_Plus.className = "Plus";
_Plus.moves = [
  { x: -0.5, y: -0.5, t: "move" },
  { x: 0, y: -1 },
  { x: 1, y: 0 },
  { x: 0, y: 1 },
  { x: 1, y: 0 },
  { x: 0, y: 1 },
  { x: -1, y: 0 },
  { x: 0, y: 1 },
  { x: -1, y: 0 },
  { x: 0, y: -1 },
  { x: -1, y: 0 },
  { x: 0, y: -1 }
];
var Plus = _Plus;

// packages/ag-charts-community/src/chart/marker/square.ts
var Square = class extends Marker {
  updatePath() {
    const { path, x, y } = this;
    const hs = this.size / 2;
    path.clear();
    path.moveTo(this.align(x - hs), this.align(y - hs));
    path.lineTo(this.align(x + hs), this.align(y - hs));
    path.lineTo(this.align(x + hs), this.align(y + hs));
    path.lineTo(this.align(x - hs), this.align(y + hs));
    path.closePath();
  }
};
Square.className = "Square";

// packages/ag-charts-community/src/chart/marker/triangle.ts
var _Triangle = class _Triangle extends Marker {
  updatePath() {
    const s = this.size * 1.1;
    super.applyPath(s, _Triangle.moves);
  }
};
_Triangle.className = "Triangle";
_Triangle.moves = [
  { x: 0, y: -0.48, t: "move" },
  { x: 0.5, y: 0.87 },
  { x: -1, y: 0 }
];
var Triangle = _Triangle;

// packages/ag-charts-community/src/chart/marker/util.ts
var MARKER_SHAPES = {
  circle: Circle,
  cross: Cross,
  diamond: Diamond,
  heart: Heart,
  plus: Plus,
  square: Square,
  triangle: Triangle
};
var MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);
function isMarkerShape(shape) {
  return typeof shape === "string" && MARKER_SUPPORTED_SHAPES.includes(shape);
}
function getMarker(shape = Square) {
  if (isMarkerShape(shape)) {
    return MARKER_SHAPES[shape];
  }
  if (typeof shape === "function") {
    return shape;
  }
  return Square;
}

// packages/ag-charts-community/src/chart/markerLabel.ts
var MarkerLabel = class extends Group {
  constructor() {
    super({ name: "markerLabelGroup" });
    this.label = new Text();
    this.line = new Line();
    this._marker = new Square();
    this._markerSize = 15;
    this._spacing = 8;
    const { marker, label, line } = this;
    label.textBaseline = "middle";
    label.fontSize = 12;
    label.fontFamily = "Verdana, sans-serif";
    label.fill = "black";
    label.y = HdpiCanvas.has.textMetrics ? 1 : 0;
    this.append([line, marker, label]);
    this.update();
  }
  set marker(value) {
    if (this._marker !== value) {
      this.removeChild(this._marker);
      this._marker = value;
      this.appendChild(value);
      this.update();
    }
  }
  get marker() {
    return this._marker;
  }
  set markerSize(value) {
    if (this._markerSize !== value) {
      this._markerSize = value;
      this.update();
    }
  }
  get markerSize() {
    return this._markerSize;
  }
  set spacing(value) {
    if (this._spacing !== value) {
      this._spacing = value;
      this.update();
    }
  }
  get spacing() {
    return this._spacing;
  }
  setSeriesStrokeOffset(xOff) {
    const offset4 = this.marker.size / 2 + xOff;
    this.line.x1 = -offset4;
    this.line.x2 = offset4;
    this.line.y1 = 0;
    this.line.y2 = 0;
    this.line.markDirtyTransform();
    this.update();
  }
  update() {
    this.marker.size = this.markerSize;
    const lineEnd = this.line.visible ? this.line.x2 : -Infinity;
    const markerEnd = this.markerSize / 2;
    this.label.x = Math.max(lineEnd, markerEnd) + this.spacing;
  }
  render(renderCtx) {
    this.marker.opacity = this.opacity;
    this.label.opacity = this.opacity;
    this.line.opacity = this.opacity;
    super.render(renderCtx);
  }
};
MarkerLabel.className = "MarkerLabel";
__decorateClass([
  ProxyPropertyOnWrite("label")
], MarkerLabel.prototype, "text", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], MarkerLabel.prototype, "fontStyle", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], MarkerLabel.prototype, "fontWeight", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], MarkerLabel.prototype, "fontSize", 2);
__decorateClass([
  ProxyPropertyOnWrite("label")
], MarkerLabel.prototype, "fontFamily", 2);
__decorateClass([
  ProxyPropertyOnWrite("label", "fill")
], MarkerLabel.prototype, "color", 2);
__decorateClass([
  ProxyPropertyOnWrite("marker", "fill")
], MarkerLabel.prototype, "markerFill", 2);
__decorateClass([
  ProxyPropertyOnWrite("marker", "stroke")
], MarkerLabel.prototype, "markerStroke", 2);
__decorateClass([
  ProxyPropertyOnWrite("marker", "strokeWidth")
], MarkerLabel.prototype, "markerStrokeWidth", 2);
__decorateClass([
  ProxyPropertyOnWrite("marker", "fillOpacity")
], MarkerLabel.prototype, "markerFillOpacity", 2);
__decorateClass([
  ProxyPropertyOnWrite("marker", "strokeOpacity")
], MarkerLabel.prototype, "markerStrokeOpacity", 2);
__decorateClass([
  ProxyPropertyOnWrite("marker", "visible")
], MarkerLabel.prototype, "markerVisible", 2);
__decorateClass([
  ProxyPropertyOnWrite("line", "stroke")
], MarkerLabel.prototype, "lineStroke", 2);
__decorateClass([
  ProxyPropertyOnWrite("line", "strokeWidth")
], MarkerLabel.prototype, "lineStrokeWidth", 2);
__decorateClass([
  ProxyPropertyOnWrite("line", "strokeOpacity")
], MarkerLabel.prototype, "lineStrokeOpacity", 2);
__decorateClass([
  ProxyPropertyOnWrite("line", "lineDash")
], MarkerLabel.prototype, "lineLineDash", 2);
__decorateClass([
  ProxyPropertyOnWrite("line", "visible")
], MarkerLabel.prototype, "lineVisible", 2);

// packages/ag-charts-community/src/chart/pagination/pagination.ts
var PaginationLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 12;
    this.fontFamily = "Verdana, sans-serif";
  }
};
__decorateClass([
  Validate(COLOR_STRING)
], PaginationLabel.prototype, "color", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], PaginationLabel.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT2, { optional: true })
], PaginationLabel.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationLabel.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], PaginationLabel.prototype, "fontFamily", 2);
var PaginationMarkerStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.size = 15;
    this.fill = void 0;
    this.fillOpacity = void 0;
    this.stroke = void 0;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationMarkerStyle.prototype, "size", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], PaginationMarkerStyle.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], PaginationMarkerStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], PaginationMarkerStyle.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationMarkerStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], PaginationMarkerStyle.prototype, "strokeOpacity", 2);
var PaginationMarker = class extends BaseProperties {
  constructor(parent) {
    super();
    this.parent = parent;
    this.shape = Triangle;
    this.size = 15;
    this.padding = 8;
  }
};
__decorateClass([
  ActionOnSet({
    changeValue() {
      if (this.parent.marker === this) {
        this.parent.onMarkerShapeChange();
      }
    }
  })
], PaginationMarker.prototype, "shape", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationMarker.prototype, "size", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PaginationMarker.prototype, "padding", 2);
var Pagination = class extends BaseProperties {
  constructor(chartUpdateCallback, pageUpdateCallback, regionManager, cursorManager) {
    super();
    this.chartUpdateCallback = chartUpdateCallback;
    this.pageUpdateCallback = pageUpdateCallback;
    this.regionManager = regionManager;
    this.cursorManager = cursorManager;
    this.id = createId(this);
    this.marker = new PaginationMarker(this);
    this.activeStyle = new PaginationMarkerStyle();
    this.inactiveStyle = new PaginationMarkerStyle();
    this.highlightStyle = new PaginationMarkerStyle();
    this.label = new PaginationLabel();
    this.group = new Group({ name: "pagination" });
    this.labelNode = new Text();
    this.destroyFns = [];
    this.totalPages = 0;
    this.currentPage = 0;
    this.translationX = 0;
    this.translationY = 0;
    this.nextButtonDisabled = false;
    this.previousButtonDisabled = false;
    this._visible = true;
    this._enabled = true;
    this._orientation = "vertical";
    this._nextButton = new Triangle();
    this._previousButton = new Triangle();
    this.labelNode.setProperties({
      textBaseline: "middle",
      fontSize: 12,
      fontFamily: "Verdana, sans-serif",
      fill: "black",
      y: HdpiCanvas.has.textMetrics ? 1 : 0
    });
    this.group.append([this.nextButton, this.previousButton, this.labelNode]);
    const region = this.regionManager.addRegion("pagination", this.group);
    this.destroyFns.push(
      region.addListener("click", (event) => this.onPaginationClick(event)),
      region.addListener("hover", (event) => this.onPaginationMouseMove(event))
    );
    this.update();
    this.updateMarkers();
  }
  destroy() {
    this.destroyFns.forEach((f) => f());
  }
  set visible(value) {
    this._visible = value;
    this.updateGroupVisibility();
  }
  get visible() {
    return this._visible;
  }
  set enabled(value) {
    this._enabled = value;
    this.updateGroupVisibility();
  }
  get enabled() {
    return this._enabled;
  }
  updateGroupVisibility() {
    this.group.visible = this.enabled && this.visible;
  }
  set orientation(value) {
    this._orientation = value;
    switch (value) {
      case "horizontal": {
        this.previousButton.rotation = -Math.PI / 2;
        this.nextButton.rotation = Math.PI / 2;
        break;
      }
      case "vertical":
      default: {
        this.previousButton.rotation = 0;
        this.nextButton.rotation = Math.PI;
      }
    }
  }
  get orientation() {
    return this._orientation;
  }
  set nextButton(value) {
    if (this._nextButton !== value) {
      this.group.removeChild(this._nextButton);
      this._nextButton = value;
      this.group.appendChild(value);
    }
  }
  get nextButton() {
    return this._nextButton;
  }
  set previousButton(value) {
    if (this._previousButton !== value) {
      this.group.removeChild(this._previousButton);
      this._previousButton = value;
      this.group.appendChild(value);
    }
  }
  get previousButton() {
    return this._previousButton;
  }
  update() {
    this.updateLabel();
    this.updatePositions();
    this.enableOrDisableButtons();
  }
  updatePositions() {
    this.group.translationX = this.translationX;
    this.group.translationY = this.translationY;
    this.updateLabelPosition();
    this.updateNextButtonPosition();
  }
  updateLabelPosition() {
    const { size: markerSize, padding: markerPadding } = this.marker;
    this.nextButton.size = markerSize;
    this.previousButton.size = markerSize;
    this.labelNode.x = markerSize / 2 + markerPadding;
  }
  updateNextButtonPosition() {
    const labelBBox = this.labelNode.computeBBox();
    this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;
  }
  updateLabel() {
    const {
      currentPage,
      totalPages: pages,
      labelNode,
      label: { color, fontStyle, fontWeight, fontSize, fontFamily }
    } = this;
    labelNode.text = `${currentPage + 1} / ${pages}`;
    labelNode.fill = color;
    labelNode.fontStyle = fontStyle;
    labelNode.fontWeight = fontWeight;
    labelNode.fontSize = fontSize;
    labelNode.fontFamily = fontFamily;
  }
  updateMarkers() {
    const {
      nextButton,
      previousButton,
      nextButtonDisabled,
      previousButtonDisabled,
      activeStyle,
      inactiveStyle,
      highlightStyle,
      highlightActive
    } = this;
    const buttonStyle = (button, disabled) => {
      if (disabled) {
        return inactiveStyle;
      } else if (button === highlightActive) {
        return highlightStyle;
      }
      return activeStyle;
    };
    this.updateMarker(nextButton, buttonStyle("next", nextButtonDisabled));
    this.updateMarker(previousButton, buttonStyle("previous", previousButtonDisabled));
  }
  updateMarker(marker, style) {
    var _a;
    const { size } = this.marker;
    marker.size = size;
    marker.fill = style.fill;
    marker.fillOpacity = (_a = style.fillOpacity) != null ? _a : 1;
    marker.stroke = style.stroke;
    marker.strokeWidth = style.strokeWidth;
    marker.strokeOpacity = style.strokeOpacity;
  }
  enableOrDisableButtons() {
    const { currentPage, totalPages } = this;
    const zeroPagesToDisplay = totalPages === 0;
    const onLastPage = currentPage === totalPages - 1;
    const onFirstPage = currentPage === 0;
    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;
  }
  nextButtonContainsPoint(offsetX, offsetY) {
    return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);
  }
  previousButtonContainsPoint(offsetX, offsetY) {
    return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);
  }
  onPaginationClick(event) {
    const { offsetX, offsetY } = event;
    if (this.nextButtonContainsPoint(offsetX, offsetY)) {
      this.incrementPage();
      this.onPaginationChanged();
      event.consume();
    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {
      this.decrementPage();
      this.onPaginationChanged();
      event.consume();
    }
  }
  onPaginationMouseMove(event) {
    const { offsetX, offsetY } = event;
    if (this.nextButtonContainsPoint(offsetX, offsetY)) {
      this.cursorManager.updateCursor(this.id, "pointer");
      this.highlightActive = "next";
    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {
      this.cursorManager.updateCursor(this.id, "pointer");
      this.highlightActive = "previous";
    } else {
      this.cursorManager.updateCursor(this.id);
      this.highlightActive = void 0;
    }
    this.updateMarkers();
    this.chartUpdateCallback(6 /* SCENE_RENDER */);
  }
  onPaginationChanged() {
    this.pageUpdateCallback(this.currentPage);
  }
  incrementPage() {
    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);
  }
  decrementPage() {
    this.currentPage = Math.max(this.currentPage - 1, 0);
  }
  onMarkerShapeChange() {
    const Marker2 = getMarker(this.marker.shape || Triangle);
    this.previousButton = new Marker2();
    this.nextButton = new Marker2();
    this.updatePositions();
    this.updateMarkers();
    this.chartUpdateCallback(6 /* SCENE_RENDER */);
  }
  attachPagination(node) {
    node.append(this.group);
  }
  computeBBox() {
    return this.group.computeBBox();
  }
};
Pagination.className = "Pagination";
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "activeStyle", 2);
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "inactiveStyle", 2);
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "highlightStyle", 2);
__decorateClass([
  Validate(OBJECT)
], Pagination.prototype, "label", 2);

// packages/ag-charts-community/src/chart/legend.ts
var LegendLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.maxLength = void 0;
    this.color = "black";
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 12;
    this.fontFamily = "Verdana, sans-serif";
    this.formatter = void 0;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendLabel.prototype, "maxLength", 2);
__decorateClass([
  Validate(COLOR_STRING)
], LegendLabel.prototype, "color", 2);
__decorateClass([
  Validate(FONT_STYLE, { optional: true })
], LegendLabel.prototype, "fontStyle", 2);
__decorateClass([
  Validate(FONT_WEIGHT2, { optional: true })
], LegendLabel.prototype, "fontWeight", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendLabel.prototype, "fontSize", 2);
__decorateClass([
  Validate(STRING)
], LegendLabel.prototype, "fontFamily", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], LegendLabel.prototype, "formatter", 2);
var LegendMarker = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.size = 15;
    this.padding = 8;
    this.enabled = true;
  }
};
__decorateClass([
  ObserveChanges((target) => {
    var _a;
    return (_a = target.parent) == null ? void 0 : _a.onMarkerShapeChange();
  })
], LegendMarker.prototype, "shape", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendMarker.prototype, "size", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendMarker.prototype, "padding", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendMarker.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(BOOLEAN)
], LegendMarker.prototype, "enabled", 2);
var LegendLine = class extends BaseProperties {
};
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendLine.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendLine.prototype, "length", 2);
var LegendItem = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.paddingX = 16;
    this.paddingY = 8;
    this.toggleSeriesVisible = true;
    this.showSeriesStroke = false;
    this.marker = new LegendMarker();
    this.label = new LegendLabel();
    this.line = new LegendLine();
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], LegendItem.prototype, "maxWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendItem.prototype, "paddingX", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LegendItem.prototype, "paddingY", 2);
__decorateClass([
  Validate(BOOLEAN)
], LegendItem.prototype, "toggleSeriesVisible", 2);
__decorateClass([
  Validate(BOOLEAN)
], LegendItem.prototype, "showSeriesStroke", 2);
__decorateClass([
  Validate(OBJECT)
], LegendItem.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], LegendItem.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], LegendItem.prototype, "line", 2);
var LegendListeners = class extends BaseProperties {
};
__decorateClass([
  Validate(FUNCTION, { optional: true })
], LegendListeners.prototype, "legendItemClick", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], LegendListeners.prototype, "legendItemDoubleClick", 2);
var Legend = class extends BaseProperties {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.id = createId(this);
    this.group = new Group({ name: "legend", layer: true, zIndex: 9 /* LEGEND_ZINDEX */ });
    this.itemSelection = Selection.select(this.group, MarkerLabel);
    this.oldSize = [0, 0];
    this.pages = [];
    this.maxPageSize = [0, 0];
    /** Item index to track on re-pagination, so current page updates appropriately. */
    this.paginationTrackingIndex = 0;
    this.truncatedItems = /* @__PURE__ */ new Set();
    this._data = [];
    this.item = new LegendItem();
    this.listeners = new LegendListeners();
    this.enabled = true;
    this.position = "bottom";
    this.spacing = 20;
    this.characterWidths = /* @__PURE__ */ new Map();
    this.destroyFns = [];
    this.size = [0, 0];
    this._visible = true;
    this.item.marker.parent = this;
    this.pagination = new Pagination(
      (type) => ctx.updateService.update(type),
      (page) => this.updatePageNumber(page),
      ctx.regionManager,
      ctx.cursorManager
    );
    this.pagination.attachPagination(this.group);
    this.item.marker.parent = this;
    const animationState = 8 /* Default */ | 1 /* Animation */;
    const region = ctx.regionManager.addRegion("legend", this.group);
    this.destroyFns.push(
      region.addListener("click", (e) => this.checkLegendClick(e), animationState),
      region.addListener("dblclick", (e) => this.checkLegendDoubleClick(e), animationState),
      region.addListener("hover", (e) => this.handleLegendMouseMove(e)),
      region.addListener("leave", (e) => this.handleLegendMouseExit(e)),
      ctx.layoutService.addListener("start-layout", (e) => this.positionLegend(e.shrinkRect)),
      () => this.detachLegend()
    );
  }
  set data(value) {
    this._data = value;
    this.updateGroupVisibility();
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.destroyFns.forEach((f) => f());
    this.pagination.destroy();
  }
  onMarkerShapeChange() {
    this.itemSelection.clear();
    this.group.markDirty(this.group, 2 /* MINOR */);
  }
  getOrientation() {
    if (this.orientation !== void 0) {
      return this.orientation;
    }
    switch (this.position) {
      case "right":
      case "left":
        return "vertical";
      case "bottom":
      case "top":
        return "horizontal";
    }
  }
  getCharacterWidths(font) {
    const { characterWidths } = this;
    if (characterWidths.has(font)) {
      return characterWidths.get(font);
    }
    const cw = {
      "...": HdpiCanvas.getTextSize("...", font).width
    };
    characterWidths.set(font, cw);
    return cw;
  }
  set visible(value) {
    this._visible = value;
    this.updateGroupVisibility();
  }
  get visible() {
    return this._visible;
  }
  updateGroupVisibility() {
    this.group.visible = this.enabled && this.visible && this.data.length > 0;
  }
  attachLegend(node) {
    node.append(this.group);
  }
  detachLegend() {
    var _a;
    (_a = this.group.parent) == null ? void 0 : _a.removeChild(this.group);
  }
  getItemLabel(datum) {
    const {
      ctx: { callbackCache }
    } = this;
    const { formatter } = this.item.label;
    if (formatter) {
      return callbackCache.call(formatter, {
        itemId: datum.itemId,
        value: datum.label.text,
        seriesId: datum.seriesId
      });
    }
    return datum.label.text;
  }
  /**
   * The method is given the desired size of the legend, which only serves as a hint.
   * The vertically oriented legend will take as much horizontal space as needed, but will
   * respect the height constraints, and the horizontal legend will take as much vertical
   * space as needed in an attempt not to exceed the given width.
   * After the layout is done, the {@link size} will contain the actual size of the legend.
   * If the actual size is not the same as the previous actual size, the legend will fire
   * the 'layoutChange' event to communicate that another layout is needed, and the above
   * process should be repeated.
   * @param width
   * @param height
   */
  performLayout(width, height) {
    const {
      paddingX,
      paddingY,
      label,
      maxWidth,
      marker: { size: markerSize, padding: markerPadding, shape: markerShape },
      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily },
      line: itemLine,
      showSeriesStroke
    } = this.item;
    const data = [...this.data];
    if (this.reverseOrder) {
      data.reverse();
    }
    this.itemSelection.update(data);
    const bboxes = [];
    const font = getFont(label);
    const itemMaxWidthPercentage = 0.8;
    const maxItemWidth = maxWidth != null ? maxWidth : width * itemMaxWidthPercentage;
    const paddedMarkerWidth = markerSize + markerPadding + paddingX;
    this.itemSelection.each((markerLabel, datum) => {
      var _a, _b, _c;
      const Marker2 = getMarker(markerShape != null ? markerShape : datum.marker.shape);
      const markerEnabled = (_a = datum.marker.enabled) != null ? _a : this.item.marker.enabled;
      if (!(markerLabel.marker && markerLabel.marker instanceof Marker2)) {
        markerLabel.marker = new Marker2();
      }
      markerLabel.markerSize = markerSize;
      markerLabel.spacing = markerPadding;
      markerLabel.fontStyle = fontStyle;
      markerLabel.fontWeight = fontWeight;
      markerLabel.fontSize = fontSize;
      markerLabel.fontFamily = fontFamily;
      const id = (_b = datum.itemId) != null ? _b : datum.id;
      const labelText = this.getItemLabel(datum);
      const text = (labelText != null ? labelText : "<unknown>").replace(/\r?\n/g, " ");
      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedMarkerWidth, font, id);
      if (showSeriesStroke && datum.line !== void 0) {
        markerLabel.lineVisible = true;
        markerLabel.markerVisible = markerEnabled;
        markerLabel.setSeriesStrokeOffset((_c = itemLine.length) != null ? _c : 5);
      } else {
        markerLabel.lineVisible = false;
        markerLabel.markerVisible = true;
      }
      bboxes.push(markerLabel.computeBBox());
    });
    width = Math.max(1, width);
    height = Math.max(1, height);
    if (!isFinite(width)) {
      return false;
    }
    const size = this.size;
    const oldSize = this.oldSize;
    size[0] = width;
    size[1] = height;
    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
      oldSize[0] = size[0];
      oldSize[1] = size[1];
    }
    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width, height);
    this.pages = pages;
    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];
    const pageNumber = this.pagination.currentPage;
    const page = this.pages[pageNumber];
    if (this.pages.length < 1 || !page) {
      this.visible = false;
      return;
    }
    this.visible = true;
    this.updatePositions(pageNumber);
    this.update();
  }
  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {
    const ellipsis2 = `...`;
    const textChars = text.split("");
    let addEllipsis = false;
    if (text.length > maxCharLength) {
      text = `${text.substring(0, maxCharLength)}`;
      addEllipsis = true;
    }
    const labelWidth = Math.floor(paddedMarkerWidth + HdpiCanvas.getTextSize(text, font).width);
    if (labelWidth > maxItemWidth) {
      let truncatedText = "";
      const characterWidths = this.getCharacterWidths(font);
      let cumulativeWidth = paddedMarkerWidth + characterWidths[ellipsis2];
      for (const char of textChars) {
        if (!characterWidths[char]) {
          characterWidths[char] = HdpiCanvas.getTextSize(char, font).width;
        }
        cumulativeWidth += characterWidths[char];
        if (cumulativeWidth > maxItemWidth) {
          break;
        }
        truncatedText += char;
      }
      text = truncatedText;
      addEllipsis = true;
    }
    if (addEllipsis) {
      text += ellipsis2;
      this.truncatedItems.add(id);
    } else {
      this.truncatedItems.delete(id);
    }
    return text;
  }
  updatePagination(bboxes, width, height) {
    const orientation = this.getOrientation();
    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);
    this.pagination.orientation = orientation;
    this.pagination.translationX = 0;
    this.pagination.translationY = 0;
    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(
      bboxes,
      width,
      height
    );
    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);
    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);
    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
    const paginationComponentPadding = 8;
    const legendItemsWidth = maxPageWidth - itemPaddingX;
    const legendItemsHeight = maxPageHeight - itemPaddingY;
    let paginationX = 0;
    let paginationY = -paginationBBox.y - this.item.marker.size / 2;
    if (paginationVertical) {
      paginationY += legendItemsHeight + paginationComponentPadding;
    } else {
      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;
      paginationY += (legendItemsHeight - paginationBBox.height) / 2;
    }
    this.pagination.translationX = paginationX;
    this.pagination.translationY = paginationY;
    this.pagination.update();
    this.pagination.updateMarkers();
    return {
      maxPageHeight,
      maxPageWidth,
      pages
    };
  }
  calculatePagination(bboxes, width, height) {
    var _a, _b, _c;
    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
    const orientation = this.getOrientation();
    const paginationVertical = ["left", "right"].includes(this.position);
    let paginationBBox = this.pagination.computeBBox();
    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);
    let pages = [];
    let maxPageWidth = 0;
    let maxPageHeight = 0;
    let count2 = 0;
    const stableOutput = (lastPassPaginationBBox2) => {
      const { width: width2, height: height2 } = lastPassPaginationBBox2;
      return width2 === paginationBBox.width && height2 === paginationBBox.height;
    };
    const forceResult = this.maxWidth !== void 0 || this.maxHeight !== void 0;
    do {
      if (count2++ > 10) {
        Logger.warn("unable to find stable legend layout.");
        break;
      }
      paginationBBox = lastPassPaginationBBox;
      const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);
      const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);
      const layout = gridLayout({
        orientation,
        bboxes,
        maxHeight,
        maxWidth,
        itemPaddingY,
        itemPaddingX,
        forceResult
      });
      pages = (_a = layout == null ? void 0 : layout.pages) != null ? _a : [];
      maxPageWidth = (_b = layout == null ? void 0 : layout.maxPageWidth) != null ? _b : 0;
      maxPageHeight = (_c = layout == null ? void 0 : layout.maxPageHeight) != null ? _c : 0;
      const totalPages = pages.length;
      this.pagination.visible = totalPages > 1;
      this.pagination.totalPages = totalPages;
      this.pagination.update();
      lastPassPaginationBBox = this.pagination.computeBBox();
      if (!this.pagination.visible) {
        break;
      }
    } while (!stableOutput(lastPassPaginationBBox));
    return { maxPageWidth, maxPageHeight, pages, paginationBBox, paginationVertical };
  }
  updatePositions(pageNumber = 0) {
    const {
      item: { paddingY },
      itemSelection,
      pages
    } = this;
    if (pages.length < 1 || !pages[pageNumber]) {
      return;
    }
    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];
    let x = 0;
    let y = 0;
    const columnCount = columns.length;
    const rowCount = columns[0].indices.length;
    const horizontal = this.getOrientation() === "horizontal";
    const itemHeight = columns[0].bboxes[0].height + paddingY;
    const rowSumColumnWidths = [];
    itemSelection.each((markerLabel, _, i) => {
      var _a, _b;
      if (i < visibleStart || i > visibleEnd) {
        markerLabel.visible = false;
        return;
      }
      const pageIndex = i - visibleStart;
      let columnIndex = 0;
      let rowIndex = 0;
      if (horizontal) {
        columnIndex = pageIndex % columnCount;
        rowIndex = Math.floor(pageIndex / columnCount);
      } else {
        columnIndex = Math.floor(pageIndex / rowCount);
        rowIndex = pageIndex % rowCount;
      }
      markerLabel.visible = true;
      const column = columns[columnIndex];
      if (!column) {
        return;
      }
      y = itemHeight * rowIndex;
      x = (_a = rowSumColumnWidths[rowIndex]) != null ? _a : 0;
      rowSumColumnWidths[rowIndex] = ((_b = rowSumColumnWidths[rowIndex]) != null ? _b : 0) + column.columnWidth;
      markerLabel.translationX = Math.floor(x);
      markerLabel.translationY = Math.floor(y);
    });
  }
  updatePageNumber(pageNumber) {
    const { pages } = this;
    const { startIndex, endIndex } = pages[pageNumber];
    if (startIndex === 0) {
      this.paginationTrackingIndex = 0;
    } else if (pageNumber === pages.length - 1) {
      this.paginationTrackingIndex = endIndex;
    } else {
      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);
    }
    this.pagination.update();
    this.pagination.updateMarkers();
    this.updatePositions(pageNumber);
    this.ctx.updateService.update(6 /* SCENE_RENDER */);
  }
  update() {
    const {
      label: { color },
      marker: itemMarker,
      line: itemLine,
      showSeriesStroke
    } = this.item;
    this.itemSelection.each((markerLabel, datum) => {
      var _a, _b;
      const marker = datum.marker;
      markerLabel.markerFill = marker.fill;
      markerLabel.markerStroke = marker.stroke;
      markerLabel.markerStrokeWidth = (_a = itemMarker.strokeWidth) != null ? _a : Math.min(2, marker.strokeWidth);
      markerLabel.markerFillOpacity = marker.fillOpacity;
      markerLabel.markerStrokeOpacity = marker.strokeOpacity;
      markerLabel.opacity = datum.enabled ? 1 : 0.5;
      markerLabel.color = color;
      const { line } = datum;
      if (showSeriesStroke && line !== void 0) {
        markerLabel.lineStroke = line.stroke;
        markerLabel.lineStrokeOpacity = line.strokeOpacity;
        markerLabel.lineStrokeWidth = (_b = itemLine.strokeWidth) != null ? _b : Math.min(2, line.strokeWidth);
        markerLabel.lineLineDash = line.lineDash;
      }
    });
  }
  getDatumForPoint(x, y) {
    const visibleChildBBoxes = [];
    const closestLeftTop = { dist: Infinity, datum: void 0 };
    for (const child of this.group.children) {
      if (!child.visible)
        continue;
      if (!(child instanceof MarkerLabel))
        continue;
      const childBBox = child.computeBBox();
      childBBox.grow(this.item.paddingX / 2, "horizontal");
      childBBox.grow(this.item.paddingY / 2, "vertical");
      if (childBBox.containsPoint(x, y)) {
        return child.datum;
      }
      const distX = x - childBBox.x - this.item.paddingX / 2;
      const distY = y - childBBox.y - this.item.paddingY / 2;
      const dist = __pow(distX, 2) + __pow(distY, 2);
      const toTheLeftTop = distX >= 0 && distY >= 0;
      if (toTheLeftTop && dist < closestLeftTop.dist) {
        closestLeftTop.dist = dist;
        closestLeftTop.datum = child.datum;
      }
      visibleChildBBoxes.push(childBBox);
    }
    const pageBBox = BBox.merge(visibleChildBBoxes);
    if (!pageBBox.containsPoint(x, y)) {
      return void 0;
    }
    return closestLeftTop.datum;
  }
  computePagedBBox() {
    const actualBBox = this.group.computeBBox();
    if (this.pages.length <= 1) {
      return actualBBox;
    }
    const [maxPageWidth, maxPageHeight] = this.maxPageSize;
    actualBBox.height = Math.max(maxPageHeight, actualBBox.height);
    actualBBox.width = Math.max(maxPageWidth, actualBBox.width);
    return actualBBox;
  }
  checkLegendClick(event) {
    const {
      listeners: { legendItemClick },
      ctx: { chartService, highlightManager },
      item: { toggleSeriesVisible },
      preventHidingAll
    } = this;
    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);
    if (!datum) {
      return;
    }
    const { id, itemId, enabled } = datum;
    const series = chartService.series.find((s) => s.id === id);
    if (!series) {
      return;
    }
    event.consume();
    let newEnabled = enabled;
    if (toggleSeriesVisible) {
      newEnabled = !enabled;
      if (preventHidingAll && !newEnabled) {
        const numVisibleItems = chartService.series.flatMap((series2) => series2.getLegendData("category")).filter((datum2) => datum2.enabled).length;
        if (numVisibleItems < 2) {
          newEnabled = true;
        }
      }
      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);
    }
    if (!newEnabled) {
      highlightManager.updateHighlight(this.id);
    } else {
      highlightManager.updateHighlight(this.id, {
        series,
        itemId,
        datum: void 0
      });
    }
    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });
    legendItemClick == null ? void 0 : legendItemClick({ type: "click", enabled: newEnabled, itemId, seriesId: series.id });
  }
  checkLegendDoubleClick(event) {
    var _a;
    const {
      listeners: { legendItemDoubleClick },
      ctx: { chartService },
      item: { toggleSeriesVisible }
    } = this;
    if (chartService.mode === "integrated") {
      return;
    }
    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);
    if (!datum) {
      return;
    }
    const { id, itemId, seriesId } = datum;
    const series = chartService.series.find((s) => s.id === id);
    if (!series) {
      return;
    }
    event.consume();
    if (toggleSeriesVisible) {
      const legendData = chartService.series.flatMap((series2) => series2.getLegendData("category"));
      const numVisibleItems = legendData.filter((datum2) => datum2.enabled).length;
      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);
      this.ctx.chartEventManager.legendItemDoubleClick(
        series,
        itemId,
        (_a = clickedItem == null ? void 0 : clickedItem.enabled) != null ? _a : false,
        numVisibleItems,
        clickedItem == null ? void 0 : clickedItem.legendItemName
      );
    }
    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });
    legendItemDoubleClick == null ? void 0 : legendItemDoubleClick({ type: "dblclick", enabled: true, itemId, seriesId: series.id });
  }
  handleLegendMouseMove(event) {
    var _a;
    const {
      enabled,
      item: { toggleSeriesVisible },
      listeners
    } = this;
    if (!enabled) {
      return;
    }
    const { offsetX, offsetY } = event;
    event.consume();
    const datum = this.getDatumForPoint(offsetX, offsetY);
    if (datum === void 0) {
      this.ctx.cursorManager.updateCursor(this.id);
      this.ctx.highlightManager.updateHighlight(this.id);
      return;
    }
    const series = datum ? this.ctx.chartService.series.find((series2) => series2.id === (datum == null ? void 0 : datum.id)) : void 0;
    if (datum && this.truncatedItems.has((_a = datum.itemId) != null ? _a : datum.id)) {
      this.ctx.tooltipManager.updateTooltip(
        this.id,
        { offsetX, offsetY, lastPointerEvent: event, showArrow: false, addCustomClass: false },
        toTooltipHtml({ content: this.getItemLabel(datum) })
      );
    } else {
      this.ctx.tooltipManager.removeTooltip(this.id);
    }
    if (toggleSeriesVisible || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {
      this.ctx.cursorManager.updateCursor(this.id, "pointer");
    }
    if ((datum == null ? void 0 : datum.enabled) && series) {
      this.ctx.highlightManager.updateHighlight(this.id, {
        series,
        itemId: datum == null ? void 0 : datum.itemId,
        datum: void 0
      });
    } else {
      this.ctx.highlightManager.updateHighlight(this.id);
    }
  }
  handleLegendMouseExit(_event) {
    this.ctx.cursorManager.updateCursor(this.id);
    this.ctx.highlightManager.updateHighlight(this.id);
    this.ctx.tooltipManager.removeTooltip(this.id);
  }
  positionLegend(shrinkRect) {
    const newShrinkRect = shrinkRect.clone();
    if (!this.enabled || !this.data.length) {
      return { shrinkRect: newShrinkRect };
    }
    const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);
    this.group.translationX = 0;
    this.group.translationY = 0;
    this.performLayout(legendWidth, legendHeight);
    const legendBBox = this.computePagedBBox();
    const calculateTranslationPerpendicularDimension = () => {
      switch (this.position) {
        case "top":
        case "left":
          return 0;
        case "bottom":
          return shrinkRect.height - legendBBox.height;
        case "right":
        default:
          return shrinkRect.width - legendBBox.width;
      }
    };
    if (this.visible) {
      let translationX;
      let translationY;
      switch (this.position) {
        case "top":
        case "bottom":
          translationX = (shrinkRect.width - legendBBox.width) / 2;
          translationY = calculateTranslationPerpendicularDimension();
          newShrinkRect.shrink(legendBBox.height, this.position);
          break;
        case "left":
        case "right":
        default:
          translationX = calculateTranslationPerpendicularDimension();
          translationY = (shrinkRect.height - legendBBox.height) / 2;
          newShrinkRect.shrink(legendBBox.width, this.position);
      }
      this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);
      this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);
    }
    if (this.visible && this.enabled && this.data.length) {
      const legendPadding = this.spacing;
      newShrinkRect.shrink(legendPadding, this.position);
      const legendPositionedBBox = legendBBox.clone();
      legendPositionedBBox.x += this.group.translationX;
      legendPositionedBBox.y += this.group.translationY;
      this.ctx.tooltipManager.updateExclusiveRect(this.id, legendPositionedBBox);
    } else {
      this.ctx.tooltipManager.updateExclusiveRect(this.id);
    }
    return { shrinkRect: newShrinkRect };
  }
  calculateLegendDimensions(shrinkRect) {
    const { width, height } = shrinkRect;
    const aspectRatio = width / height;
    const maxCoefficient = 0.5;
    const minHeightCoefficient = 0.2;
    const minWidthCoefficient = 0.25;
    let legendWidth, legendHeight;
    switch (this.position) {
      case "top":
      case "bottom":
        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;
        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;
        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : Math.round(height * heightCoefficient);
        break;
      case "left":
      case "right":
      default:
        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;
        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);
        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;
    }
    return [legendWidth, legendHeight];
  }
};
Legend.className = "Legend";
__decorateClass([
  Validate(OBJECT)
], Legend.prototype, "pagination", 2);
__decorateClass([
  Validate(OBJECT)
], Legend.prototype, "item", 2);
__decorateClass([
  Validate(OBJECT)
], Legend.prototype, "listeners", 2);
__decorateClass([
  ObserveChanges((target) => target.updateGroupVisibility()),
  Validate(BOOLEAN)
], Legend.prototype, "enabled", 2);
__decorateClass([
  Validate(POSITION2)
], Legend.prototype, "position", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Legend.prototype, "maxWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], Legend.prototype, "maxHeight", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], Legend.prototype, "reverseOrder", 2);
__decorateClass([
  Validate(UNION(["horizontal", "vertical"], "an orientation"), { optional: true })
], Legend.prototype, "orientation", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], Legend.prototype, "preventHidingAll", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Legend.prototype, "spacing", 2);

// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts
var CARTESIAN_AXIS_POSITIONS = ["top", "right", "bottom", "left"];
var CARTESIAN_AXIS_TYPES = ["category", "grouped-category", "number", "log", "time"];
function hasCartesianAxisPosition(axis) {
  const allowedTypes = CARTESIAN_AXIS_TYPES;
  return allowedTypes.includes(axis.type);
}
function isCartesianAxisOptions(options) {
  const allowedTypes = CARTESIAN_AXIS_TYPES;
  return allowedTypes.includes(options.type);
}
function isAxisPosition(position) {
  const allowedPositions = CARTESIAN_AXIS_POSITIONS;
  return typeof position === "string" && allowedPositions.includes(position);
}
var AxisPositionGuesser = class {
  constructor() {
    this.result = [];
    this.valid = [];
    this.invalid = [];
  }
  push(axis, options) {
    const { result, valid, invalid } = this;
    if (isCartesianAxisOptions(options)) {
      if (isAxisPosition(options.position)) {
        valid.push(axis);
      } else {
        invalid.push(axis);
      }
    }
    result.push(axis);
  }
  guessInvalidPositions() {
    const takenPosition = this.valid.filter((v) => hasCartesianAxisPosition(v)).map((v) => v.position).filter((v) => v !== void 0);
    const guesses = ["top", "right", "bottom", "left"];
    for (const invalidAxis of this.invalid) {
      let nextGuess = guesses.pop();
      while (takenPosition.includes(nextGuess) && nextGuess !== void 0) {
        nextGuess = guesses.pop();
      }
      if (nextGuess === void 0)
        break;
      invalidAxis.position = nextGuess;
    }
    return this.result;
  }
};

// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts
function matchSeriesOptions(series, optSeries, oldOptsSeries) {
  var _a, _b, _c;
  const keysToConsider = ["direction", "xKey", "yKey", "sizeKey", "angleKey", "radiusKey", "normalizedTo"];
  const generateKey = (type, i) => {
    const result = [type];
    for (const key of keysToConsider) {
      if (key in i && i[key] != null)
        result.push(`${key}=${i[key]}`);
    }
    return result.join(";");
  };
  const seriesMap = /* @__PURE__ */ new Map();
  let idx = 0;
  for (const s of series) {
    const key = generateKey(s.type, s.properties);
    if (!seriesMap.has(key)) {
      seriesMap.set(key, []);
    }
    (_a = seriesMap.get(key)) == null ? void 0 : _a.push([s, idx++]);
  }
  const optsMap = /* @__PURE__ */ new Map();
  for (const o of optSeries) {
    const key = generateKey(o.type, o);
    if (!optsMap.has(key)) {
      optsMap.set(key, []);
    }
    (_b = optsMap.get(key)) == null ? void 0 : _b.push(o);
  }
  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));
  if (!overlap) {
    return { status: "no-overlap", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };
  }
  const changes = [];
  let targetIdx = -1;
  for (const [key, optArray] of optsMap.entries()) {
    for (const opts of optArray) {
      targetIdx++;
      const seriesArray = seriesMap.get(key);
      if (seriesArray == null || seriesArray.length < 1) {
        changes.push({ opts, idx: targetIdx, status: "add" });
        seriesMap.delete(key);
        continue;
      }
      const [series2, idx2] = seriesArray.shift();
      const previousOpts = (_c = oldOptsSeries == null ? void 0 : oldOptsSeries[idx2]) != null ? _c : {};
      const diff2 = jsonDiff(previousOpts, opts != null ? opts : {});
      if (diff2) {
        changes.push({ opts, series: series2, diff: diff2, idx: idx2, status: "update" });
      } else {
        changes.push({ opts, series: series2, idx: idx2, status: "no-op" });
      }
      if (seriesArray.length === 0) {
        seriesMap.delete(key);
      }
    }
  }
  for (const seriesArray of seriesMap.values()) {
    for (const [series2, idx2] of seriesArray) {
      changes.push({ series: series2, idx: idx2, status: "remove" });
    }
  }
  return { status: "overlap", changes };
}

// packages/ag-charts-community/src/chart/overlay/overlay.ts
var DEFAULT_OVERLAY_CLASS = "ag-chart-overlay";
var DEFAULT_OVERLAY_DARK_CLASS = "ag-chart-dark-overlay";
var Overlay = class {
  constructor(className, parentElement, animationManager) {
    this.className = className;
    this.parentElement = parentElement;
    this.animationManager = animationManager;
    this.darkTheme = false;
  }
  show(rect) {
    var _a, _b;
    if (!this.element) {
      this.element = this.createElement("div");
      this.element.classList.add(this.className, DEFAULT_OVERLAY_CLASS);
    }
    this.element.classList.toggle(DEFAULT_OVERLAY_DARK_CLASS, this.darkTheme);
    const { element: element2 } = this;
    element2.style.position = "absolute";
    element2.style.left = `${rect.x}px`;
    element2.style.top = `${rect.y}px`;
    element2.style.width = `${rect.width}px`;
    element2.style.height = `${rect.height}px`;
    if (this.renderer) {
      element2.innerHTML = this.renderer();
    } else {
      const content = this.createElement("div");
      content.style.alignItems = "center";
      content.style.boxSizing = "border-box";
      content.style.display = "flex";
      content.style.justifyContent = "center";
      content.style.margin = "8px";
      content.style.height = "100%";
      content.style.font = "12px Verdana, sans-serif";
      content.innerText = (_a = this.text) != null ? _a : "No data to display";
      element2.replaceChildren(content);
      this.animationManager.animate({
        from: 0,
        to: 1,
        phase: "add",
        id: "overlay",
        groupId: "opacity",
        onUpdate(value) {
          element2.style.opacity = String(value);
        },
        onStop() {
          element2.style.opacity = "1";
        }
      });
    }
    (_b = this.parentElement) == null ? void 0 : _b.append(element2);
  }
  hide() {
    if (!this.element)
      return;
    const element2 = this.element;
    this.animationManager.animate({
      from: 1,
      to: 0,
      phase: "remove",
      id: "overlay",
      groupId: "opacity",
      onUpdate(value) {
        element2.style.opacity = String(value);
      },
      onStop() {
        element2.remove();
      }
    });
    this.element = void 0;
  }
  createElement(tagName, options) {
    return this.parentElement.ownerDocument.createElement(tagName, options);
  }
};
__decorateClass([
  Validate(FUNCTION, { optional: true })
], Overlay.prototype, "renderer", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], Overlay.prototype, "text", 2);
__decorateClass([
  Validate(BOOLEAN)
], Overlay.prototype, "darkTheme", 2);

// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts
var defaultOverlayCss = `
.${DEFAULT_OVERLAY_CLASS} {
    color: #181d1f;
}

.${DEFAULT_OVERLAY_CLASS}.${DEFAULT_OVERLAY_DARK_CLASS} {
    color: #ffffff;
}

.${DEFAULT_OVERLAY_CLASS}--loading {
    color: rgb(140, 140, 140); /* DEFAULT_MUTED_LABEL_COLOUR */
}

.${DEFAULT_OVERLAY_CLASS}__loading-background {
    background: white; /* DEFAULT_BACKGROUND_FILL */
}

.${DEFAULT_OVERLAY_CLASS}.${DEFAULT_OVERLAY_DARK_CLASS} .${DEFAULT_OVERLAY_CLASS}__loading-background {
    background: #192232; /* DEFAULT_DARK_BACKGROUND_FILL */
}
`;
var _ChartOverlays = class _ChartOverlays {
  constructor(parent, animationManager) {
    this.loading = new Overlay("ag-chart-loading-overlay", parent, animationManager);
    this.loading.text = "Loading data...";
    this.loading.renderer = () => this.renderLoadingSpinner(parent, animationManager);
    this.noData = new Overlay("ag-chart-no-data-overlay", parent, animationManager);
    this.noVisibleSeries = new Overlay("ag-chart-no-visible-series", parent, animationManager);
    this.noVisibleSeries.text = "No visible series";
    if (_ChartOverlays.overlayDocuments.indexOf(parent.ownerDocument) < 0) {
      injectStyle(parent.ownerDocument, defaultOverlayCss);
      _ChartOverlays.overlayDocuments.push(parent.ownerDocument);
    }
  }
  destroy() {
    this.loading.hide();
    this.noData.hide();
    this.noVisibleSeries.hide();
  }
  renderLoadingSpinner(parent, animationManager) {
    var _a;
    const container = this.createElement(parent, "div");
    container.className = `${DEFAULT_OVERLAY_CLASS}--loading`;
    container.style.display = "flex";
    container.style.alignItems = "center";
    container.style.justifyContent = "center";
    container.style.flexDirection = "column";
    container.style.height = "100%";
    container.style.boxSizing = "border-box";
    container.style.font = "13px Verdana, sans-serif";
    container.style.userSelect = "none";
    container.style.animation = `ag-charts-loading ${ADD_PHASE.animationDuration * animationManager.defaultDuration}ms linear 50ms both`;
    const matrix = this.createElement(container, "span");
    matrix.style.width = "45px";
    matrix.style.height = "40px";
    matrix.style.backgroundImage = `${[
      "linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)"
    ].join("")}`;
    matrix.style.backgroundSize = "10px 400%";
    matrix.style.backgroundRepeat = "no-repeat";
    matrix.style.animation = "ag-charts-loading-matrix 1s infinite linear";
    const label = this.createElement(container, "p");
    label.style.marginTop = "1em";
    label.innerText = (_a = this.loading.text) != null ? _a : "Loading data...";
    const background = this.createElement(parent, "div");
    background.className = `${DEFAULT_OVERLAY_CLASS}__loading-background`;
    background.style.position = "absolute";
    background.style.top = "0";
    background.style.right = "0";
    background.style.bottom = "0";
    background.style.left = "0";
    background.style.opacity = "0.5";
    background.style.zIndex = "-1";
    const animationStyles = this.createElement(container, "style");
    animationStyles.innerText = [
      "@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }",
      "@keyframes ag-charts-loading-matrix {",
      "0% { background-position: 0% 0%, 50% 0%, 100% 0%; }",
      "100% { background-position: 0% 100%, 50% 100%, 100% 100%; }",
      "}"
    ].join(" ");
    container.replaceChildren(animationStyles, matrix, label, background);
    return container.outerHTML;
  }
  createElement(parent, tagName, options) {
    return parent.ownerDocument.createElement(tagName, options);
  }
};
_ChartOverlays.overlayDocuments = [];
var ChartOverlays = _ChartOverlays;

// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts
function sumValues(values, accumulator = [0, 0]) {
  for (const value of values) {
    if (typeof value !== "number") {
      continue;
    }
    if (value < 0) {
      accumulator[0] += value;
    }
    if (value > 0) {
      accumulator[1] += value;
    }
  }
  return accumulator;
}
function sum(scope, id, matchGroupId) {
  const result = {
    id,
    scopes: [scope.id],
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values)
  };
  return result;
}
function groupSum(scope, id, matchGroupId) {
  return {
    id,
    scopes: [scope.id],
    type: "aggregate",
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0]) => {
      var _a, _b;
      acc[0] += (_a = next == null ? void 0 : next[0]) != null ? _a : 0;
      acc[1] += (_b = next == null ? void 0 : next[1]) != null ? _b : 0;
      return acc;
    }
  };
}
function range2(scope, id, matchGroupId) {
  const result = {
    id,
    scopes: [scope.id],
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => extendDomain(values)
  };
  return result;
}
function count(scope, id) {
  const result = {
    id,
    scopes: [scope.id],
    type: "aggregate",
    aggregateFunction: () => [0, 1]
  };
  return result;
}
function groupCount(scope, id) {
  return {
    id,
    scopes: [scope.id],
    type: "aggregate",
    aggregateFunction: () => [0, 1],
    groupAggregateFunction: (next, acc = [0, 0]) => {
      var _a, _b;
      acc[0] += (_a = next == null ? void 0 : next[0]) != null ? _a : 0;
      acc[1] += (_b = next == null ? void 0 : next[1]) != null ? _b : 0;
      return acc;
    }
  };
}
function average(scope, id, matchGroupId) {
  const result = {
    id,
    scopes: [scope.id],
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values).map((v) => v / values.length)
  };
  return result;
}
function groupAverage(scope, id, matchGroupId) {
  const result = {
    id,
    scopes: [scope.id],
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0, -1]) => {
      var _a, _b;
      acc[0] += (_a = next == null ? void 0 : next[0]) != null ? _a : 0;
      acc[1] += (_b = next == null ? void 0 : next[1]) != null ? _b : 0;
      acc[2]++;
      return acc;
    },
    finalFunction: (acc = [0, 0, 0]) => {
      const result2 = acc[0] + acc[1];
      if (result2 >= 0) {
        return [0, result2 / acc[2]];
      }
      return [result2 / acc[2], 0];
    }
  };
  return result;
}
function area(scope, id, aggFn, matchGroupId) {
  const result = {
    id,
    scopes: [scope.id],
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values, keyRange = []) => {
      const keyWidth = keyRange[1] - keyRange[0];
      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);
    }
  };
  if (aggFn.groupAggregateFunction) {
    result.groupAggregateFunction = aggFn.groupAggregateFunction;
  }
  return result;
}
function accumulatedValue(onlyPositive) {
  return () => {
    let value = 0;
    return (datum) => {
      if (!isFiniteNumber(datum))
        return datum;
      value += onlyPositive ? Math.max(0, datum) : datum;
      return value;
    };
  };
}
function trailingAccumulatedValue() {
  return () => {
    let value = 0;
    return (datum) => {
      if (!isFiniteNumber(datum))
        return datum;
      const trailingValue2 = value;
      value += datum;
      return trailingValue2;
    };
  };
}

// packages/ag-charts-community/src/util/memo.ts
var memorizedFns = /* @__PURE__ */ new Map();
function memo(params, fnGenerator) {
  var _a, _b, _c;
  const serialisedParams = JSON.stringify(params, null, 0);
  if (!memorizedFns.has(fnGenerator)) {
    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());
  }
  if (!((_a = memorizedFns.get(fnGenerator)) == null ? void 0 : _a.has(serialisedParams))) {
    (_b = memorizedFns.get(fnGenerator)) == null ? void 0 : _b.set(serialisedParams, fnGenerator(params));
  }
  return (_c = memorizedFns.get(fnGenerator)) == null ? void 0 : _c.get(serialisedParams);
}

// packages/ag-charts-community/src/chart/data/processors.ts
var SMALLEST_KEY_INTERVAL = {
  type: "reducer",
  property: "smallestKeyInterval",
  initialValue: Infinity,
  reducer: () => {
    let prevX = NaN;
    return (smallestSoFar = Infinity, next) => {
      const nextX = next.keys[0];
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {
        return interval;
      }
      return smallestSoFar;
    };
  }
};
var AGG_VALUES_EXTENT = {
  type: "processor",
  property: "aggValuesExtent",
  calculate: (processedData) => {
    var _a, _b, _c, _d;
    const result = [...(_b = (_a = processedData.domain.aggValues) == null ? void 0 : _a[0]) != null ? _b : [0, 0]];
    for (const [min, max] of (_d = (_c = processedData.domain.aggValues) == null ? void 0 : _c.slice(1)) != null ? _d : []) {
      if (min < result[0]) {
        result[0] = min;
      }
      if (max > result[1]) {
        result[1] = max;
      }
    }
    return result;
  }
};
var SORT_DOMAIN_GROUPS = {
  type: "processor",
  property: "sortedGroupDomain",
  calculate: ({ domain: { groups } }) => {
    if (groups == null)
      return void 0;
    return [...groups].sort((a, b) => {
      for (let i = 0; i < a.length; i++) {
        const result = a[i] - b[i];
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
  }
};
function normaliseFnBuilder({ normaliseTo, mode }) {
  const normalise = (val, extent2) => {
    const result = val * normaliseTo / extent2;
    if (result >= 0) {
      return Math.min(normaliseTo, result);
    }
    return Math.max(-normaliseTo, result);
  };
  return () => () => (values, valueIndexes) => {
    const valuesExtent = [0, 0];
    for (const valueIdx of valueIndexes) {
      const value = values[valueIdx];
      const valIdx = value < 0 ? 0 : 1;
      if (mode === "sum") {
        valuesExtent[valIdx] += value;
      } else if (valIdx === 0) {
        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], value);
      } else {
        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], value);
      }
    }
    const extent2 = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);
    for (const valueIdx of valueIndexes) {
      values[valueIdx] = normalise(values[valueIdx], extent2);
    }
  };
}
function normaliseGroupTo(scope, matchGroupIds, normaliseTo, mode = "sum") {
  return {
    scopes: [scope.id],
    type: "group-value-processor",
    matchGroupIds,
    adjust: memo({ normaliseTo, mode }, normaliseFnBuilder)
  };
}
function normalisePropertyFnBuilder({
  normaliseTo,
  zeroDomain,
  rangeMin,
  rangeMax
}) {
  const normaliseSpan = normaliseTo[1] - normaliseTo[0];
  const normalise = (val, start, span) => {
    const result = normaliseTo[0] + (val - start) / span * normaliseSpan;
    if (span === 0)
      return zeroDomain;
    if (result >= normaliseTo[1])
      return normaliseTo[1];
    if (result < normaliseTo[0])
      return normaliseTo[0];
    return result;
  };
  return () => (pData, pIdx) => {
    let [start, end] = pData.domain.values[pIdx];
    if (rangeMin != null)
      start = rangeMin;
    if (rangeMax != null)
      end = rangeMax;
    const span = end - start;
    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];
    for (const group2 of pData.data) {
      let groupValues = group2.values;
      if (pData.type === "ungrouped") {
        groupValues = [groupValues];
      }
      for (const values of groupValues) {
        values[pIdx] = normalise(values[pIdx], start, span);
      }
    }
  };
}
function normalisePropertyTo(scope, property, normaliseTo, zeroDomain, rangeMin, rangeMax) {
  return {
    scopes: [scope.id],
    type: "property-value-processor",
    property,
    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)
  };
}
function animationValidation(scope, valueKeyIds = []) {
  return {
    type: "processor",
    scopes: [scope.id],
    property: "animationValidation",
    calculate(result) {
      var _a;
      const { keys, values } = result.defs;
      const { input, data } = result;
      let uniqueKeys = true;
      let orderedKeys = true;
      const valueKeys = [];
      for (let k = 0; k < values.length; k++) {
        if (!((_a = values[k].scopes) == null ? void 0 : _a.some((s) => s === scope.id)))
          continue;
        if (!valueKeyIds.some((v) => values[k].id === v))
          continue;
        valueKeys.push([k, values[k]]);
      }
      const processKey = (idx, def, type) => {
        var _a2;
        if (def.valueType === "category") {
          const keyValues = result.domain[type][idx];
          uniqueKeys && (uniqueKeys = keyValues.length === input.count);
          return;
        }
        let lastValue = (_a2 = data[0]) == null ? void 0 : _a2[type][idx];
        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {
          const keyValue = data[d][type][idx];
          orderedKeys && (orderedKeys = lastValue <= keyValue);
          uniqueKeys && (uniqueKeys = lastValue !== keyValue);
          lastValue = keyValue;
        }
      };
      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {
        processKey(k, keys[k], "keys");
      }
      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {
        const [idx, key] = valueKeys[k];
        processKey(idx, key, "values");
      }
      return { uniqueKeys, orderedKeys };
    }
  };
}
function buildGroupAccFn({ mode, separateNegative }) {
  return () => () => (values, valueIndexes) => {
    const acc = [0, 0];
    for (const valueIdx of valueIndexes) {
      const currentVal = values[valueIdx];
      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;
      if (!isFiniteNumber(currentVal))
        continue;
      if (mode === "normal")
        acc[accIndex] += currentVal;
      values[valueIdx] = acc[accIndex];
      if (mode === "trailing")
        acc[accIndex] += currentVal;
    }
  };
}
function buildGroupWindowAccFn({ mode, sum: sum2 }) {
  return () => {
    const lastValues = [];
    let firstRow = true;
    return () => {
      return (values, valueIndexes) => {
        let acc = 0;
        for (const valueIdx of valueIndexes) {
          const currentVal = values[valueIdx];
          const lastValue = firstRow && sum2 === "current" ? 0 : lastValues[valueIdx];
          lastValues[valueIdx] = currentVal;
          const sumValue = sum2 === "current" ? currentVal : lastValue;
          if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {
            values[valueIdx] = acc;
            continue;
          }
          if (mode === "normal")
            acc += sumValue;
          values[valueIdx] = acc;
          if (mode === "trailing")
            acc += sumValue;
        }
        firstRow = false;
      };
    };
  };
}
function accumulateGroup(scope, matchGroupId, mode, sum2, separateNegative = false) {
  let adjust;
  if (mode.startsWith("window")) {
    const modeParam = mode.endsWith("-trailing") ? "trailing" : "normal";
    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);
  } else {
    adjust = memo({ mode, separateNegative }, buildGroupAccFn);
  }
  return {
    scopes: [scope.id],
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust
  };
}
function diff(previousData, updateMovedDatums = true) {
  return {
    type: "processor",
    property: "diff",
    calculate: (processedData) => {
      const diff2 = {
        changed: false,
        moved: [],
        added: [],
        updated: [],
        removed: [],
        addedIndices: [],
        updatedIndices: [],
        removedIndices: []
      };
      const moved = /* @__PURE__ */ new Map();
      const added = /* @__PURE__ */ new Map();
      const updated = /* @__PURE__ */ new Map();
      const removed = /* @__PURE__ */ new Map();
      const addedIndices = /* @__PURE__ */ new Map();
      const updatedIndices = /* @__PURE__ */ new Map();
      const removedIndices = /* @__PURE__ */ new Map();
      for (let i = 0; i < Math.max(previousData.data.length, processedData.data.length); i++) {
        const prev = previousData.data[i];
        const datum = processedData.data[i];
        const prevId = prev ? createDatumId(prev.keys) : "";
        const datumId = datum ? createDatumId(datum.keys) : "";
        if (prevId === datumId) {
          if (!arraysEqual(prev.values, datum.values)) {
            updated.set(datumId, datum);
            updatedIndices.set(datumId, i);
          }
          continue;
        }
        if (removed.has(datumId)) {
          if (updateMovedDatums || !arraysEqual(removed.get(datumId).values, datum.values)) {
            updated.set(datumId, datum);
            updatedIndices.set(datumId, i);
            moved.set(datumId, datum);
          }
          removed.delete(datumId);
          removedIndices.delete(datumId);
        } else if (datum) {
          added.set(datumId, datum);
          addedIndices.set(datumId, i);
        }
        if (added.has(prevId)) {
          if (updateMovedDatums || !arraysEqual(added.get(prevId).values, prev.values)) {
            updated.set(prevId, prev);
            updatedIndices.set(prevId, i);
            moved.set(prevId, prev);
          }
          added.delete(prevId);
          addedIndices.delete(prevId);
        } else if (prev) {
          updated.delete(prevId);
          updatedIndices.delete(prevId);
          removed.set(prevId, prev);
          removedIndices.set(prevId, i);
        }
      }
      diff2.added = Array.from(added.keys());
      diff2.updated = Array.from(updated.keys());
      diff2.removed = Array.from(removed.keys());
      diff2.moved = Array.from(moved.keys());
      diff2.addedIndices = Array.from(addedIndices.values());
      diff2.updatedIndices = Array.from(updatedIndices.values());
      diff2.removedIndices = Array.from(removedIndices.values());
      diff2.changed = diff2.added.length > 0 || diff2.updated.length > 0 || diff2.removed.length > 0;
      return diff2;
    }
  };
}
function createDatumId(keys) {
  if (isArray(keys)) {
    return keys.map((key) => transformIntegratedCategoryValue(key)).join("___");
  }
  return transformIntegratedCategoryValue(keys);
}

// packages/ag-charts-community/src/chart/series/series.ts
var SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode2) => {
  SeriesNodePickMode2[SeriesNodePickMode2["EXACT_SHAPE_MATCH"] = 0] = "EXACT_SHAPE_MATCH";
  SeriesNodePickMode2[SeriesNodePickMode2["NEAREST_BY_MAIN_AXIS_FIRST"] = 1] = "NEAREST_BY_MAIN_AXIS_FIRST";
  SeriesNodePickMode2[SeriesNodePickMode2["NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST"] = 2] = "NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST";
  SeriesNodePickMode2[SeriesNodePickMode2["NEAREST_NODE"] = 3] = "NEAREST_NODE";
  return SeriesNodePickMode2;
})(SeriesNodePickMode || {});
function basicContinuousCheckDatumValidation(v) {
  return checkDatum(v, true) != null;
}
function basicDiscreteCheckDatumValidation(v) {
  return checkDatum(v, false) != null;
}
function keyProperty(scope, propName, continuous, opts = {}) {
  const result = __spreadValues({
    scopes: [scope.id],
    property: propName,
    type: "key",
    valueType: continuous ? "range" : "category",
    validation: continuous ? basicContinuousCheckDatumValidation : basicDiscreteCheckDatumValidation
  }, opts);
  return result;
}
function valueProperty(scope, propName, continuous, opts = {}) {
  const result = __spreadValues({
    scopes: [scope.id],
    property: propName,
    type: "value",
    valueType: continuous ? "range" : "category",
    validation: continuous ? basicContinuousCheckDatumValidation : basicDiscreteCheckDatumValidation
  }, opts);
  return result;
}
function rangedValueProperty(scope, propName, opts = {}) {
  const _a = opts, { min = -Infinity, max = Infinity } = _a, defOpts = __objRest(_a, ["min", "max"]);
  return __spreadValues({
    scopes: [scope.id],
    type: "value",
    property: propName,
    valueType: "range",
    validation: basicContinuousCheckDatumValidation,
    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum
  }, defOpts);
}
function trailingValueProperty(scope, propName, continuous, opts = {}) {
  const result = __spreadProps(__spreadValues({}, valueProperty(scope, propName, continuous, opts)), {
    processor: trailingValue()
  });
  return result;
}
function trailingValue() {
  return () => {
    let value = 0;
    return (datum) => {
      const trailingValue2 = value;
      value = datum;
      return trailingValue2;
    };
  };
}
function accumulativeValueProperty(scope, propName, continuous, opts = {}) {
  const _a = opts, { onlyPositive } = _a, defOpts = __objRest(_a, ["onlyPositive"]);
  const result = __spreadProps(__spreadValues({}, valueProperty(scope, propName, continuous, defOpts)), {
    processor: accumulatedValue(onlyPositive)
  });
  return result;
}
function trailingAccumulatedValueProperty(scope, propName, continuous, opts = {}) {
  const result = __spreadProps(__spreadValues({}, valueProperty(scope, propName, continuous, opts)), {
    processor: trailingAccumulatedValue()
  });
  return result;
}
function groupAccumulativeValueProperty(scope, propName, continuous, mode, sum2 = "current", opts) {
  return [
    valueProperty(scope, propName, continuous, opts),
    accumulateGroup(scope, opts.groupId, mode, sum2, opts.separateNegative),
    ...opts.rangeId != null ? [range2(scope, opts.rangeId, opts.groupId)] : []
  ];
}
var SeriesNodeClickEvent = class {
  constructor(type, event, { datum }, series) {
    this.type = type;
    this.event = event;
    this.datum = datum;
    this.seriesId = series.id;
  }
};
var SeriesGroupingChangedEvent = class {
  constructor(series, seriesGrouping, oldGrouping) {
    this.series = series;
    this.seriesGrouping = seriesGrouping;
    this.oldGrouping = oldGrouping;
    this.type = "groupingChanged";
  }
};
var Series = class extends Observable {
  constructor(seriesOpts) {
    super();
    this.destroyFns = [];
    this.seriesGrouping = void 0;
    this.NodeClickEvent = SeriesNodeClickEvent;
    this.internalId = createId(this);
    // The group node that contains all the nodes used to render this series.
    this.rootGroup = new Group({ name: "seriesRoot", isVirtual: true });
    this.axes = {
      ["x" /* X */]: void 0,
      ["y" /* Y */]: void 0
    };
    this.directions = ["x" /* X */, "y" /* Y */];
    // Flag to determine if we should recalculate node data.
    this.nodeDataRefresh = true;
    this.moduleMap = new ModuleMap();
    this._declarationOrder = -1;
    this.seriesListeners = new Listeners();
    const {
      moduleCtx,
      useLabelLayer = false,
      pickModes = [1 /* NEAREST_BY_MAIN_AXIS_FIRST */],
      directionKeys = {},
      directionNames = {},
      contentGroupVirtual = true,
      canHaveAxes = false
    } = seriesOpts;
    this.ctx = moduleCtx;
    this.directionKeys = directionKeys;
    this.directionNames = directionNames;
    this.canHaveAxes = canHaveAxes;
    this.contentGroup = this.rootGroup.appendChild(
      new Group({
        name: `${this.internalId}-content`,
        layer: !contentGroupVirtual,
        isVirtual: contentGroupVirtual,
        zIndex: 4 /* SERIES_LAYER_ZINDEX */,
        zIndexSubOrder: this.getGroupZIndexSubOrder("data")
      })
    );
    this.highlightGroup = new Group({
      name: `${this.internalId}-highlight`,
      layer: !contentGroupVirtual,
      isVirtual: contentGroupVirtual,
      zIndex: 4 /* SERIES_LAYER_ZINDEX */,
      zIndexSubOrder: this.getGroupZIndexSubOrder("highlight")
    });
    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: "highlightNode", zIndex: 0 }));
    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: "highlightLabel", zIndex: 10 }));
    this.pickModes = pickModes;
    this.labelGroup = this.rootGroup.appendChild(
      new Group({
        name: `${this.internalId}-series-labels`,
        layer: useLabelLayer,
        zIndex: 7 /* SERIES_LABEL_ZINDEX */
      })
    );
    this.annotationGroup = new Group({
      name: `${this.id}-annotation`,
      layer: !contentGroupVirtual,
      isVirtual: contentGroupVirtual,
      zIndex: 4 /* SERIES_LAYER_ZINDEX */,
      zIndexSubOrder: this.getGroupZIndexSubOrder("annotation")
    });
  }
  get id() {
    var _a, _b;
    return (_b = (_a = this.properties) == null ? void 0 : _a.id) != null ? _b : this.internalId;
  }
  get type() {
    var _a;
    return (_a = this.constructor.type) != null ? _a : "";
  }
  set data(input) {
    this._data = input;
    this.onDataChange();
  }
  get data() {
    var _a;
    return (_a = this._data) != null ? _a : this._chartData;
  }
  set visible(value) {
    this.properties.visible = value;
    this.visibleChanged();
  }
  get visible() {
    return this.properties.visible;
  }
  onDataChange() {
    this.nodeDataRefresh = true;
  }
  setChartData(input) {
    this._chartData = input;
    if (this.data === input) {
      this.onDataChange();
    }
  }
  onSeriesGroupingChange(prev, next) {
    const { internalId, type, visible } = this;
    if (prev) {
      this.ctx.seriesStateManager.deregisterSeries({ id: internalId, type });
    }
    if (next) {
      this.ctx.seriesStateManager.registerSeries({ id: internalId, type, visible, seriesGrouping: next });
    }
    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0 };
  }
  getGroupZIndexSubOrder(type, subIndex = 0) {
    let mainAdjust = 0;
    switch (type) {
      case "data":
      case "paths":
        break;
      case "labels":
        mainAdjust += 2e4;
        break;
      case "marker":
        mainAdjust += 1e4;
        break;
      case "highlight":
        subIndex += 15e3;
        break;
      case "annotation":
        mainAdjust += 15e3;
        break;
    }
    const main = () => this._declarationOrder + mainAdjust;
    return [main, subIndex];
  }
  addListener(type, listener) {
    return this.seriesListeners.addListener(type, listener);
  }
  dispatch(type, event) {
    this.seriesListeners.dispatch(type, event);
  }
  addChartEventListeners() {
    return;
  }
  destroy() {
    this.destroyFns.forEach((f) => f());
    this.destroyFns = [];
    this.ctx.seriesStateManager.deregisterSeries(this);
  }
  getDirectionValues(direction, properties) {
    const resolvedDirection = this.resolveKeyDirection(direction);
    const keys = properties == null ? void 0 : properties[resolvedDirection];
    const values = [];
    if (!keys)
      return values;
    const addValues = (...items) => {
      for (const value of items) {
        if (Array.isArray(value)) {
          addValues(...value);
        } else if (typeof value === "object") {
          addValues(...Object.values(value));
        } else {
          values.push(value);
        }
      }
    };
    addValues(...keys.map((key) => this.properties[key]));
    return values;
  }
  getKeys(direction) {
    return this.getDirectionValues(direction, this.directionKeys);
  }
  getNames(direction) {
    return this.getDirectionValues(direction, this.directionNames);
  }
  resolveKeyDirection(direction) {
    return direction;
  }
  // The union of the series domain ('community') and series-option domains ('enterprise').
  getDomain(direction) {
    const seriesDomain = this.getSeriesDomain(direction);
    const moduleDomains = this.moduleMap.mapValues((module) => module.getDomain(direction));
    return seriesDomain.concat(moduleDomains.flat());
  }
  // Indicate that something external changed and we should recalculate nodeData.
  markNodeDataDirty() {
    this.nodeDataRefresh = true;
  }
  visibleChanged() {
    this.ctx.seriesStateManager.registerSeries(this);
  }
  getOpacity() {
    const defaultOpacity = 1;
    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;
    if (!enabled || dimOpacity === defaultOpacity) {
      return defaultOpacity;
    }
    switch (this.isItemIdHighlighted()) {
      case 0 /* None */:
      case 1 /* This */:
        return defaultOpacity;
      case 2 /* Other */:
      default:
        return dimOpacity;
    }
  }
  getStrokeWidth(defaultStrokeWidth) {
    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;
    if (!enabled || strokeWidth === void 0) {
      return defaultStrokeWidth;
    }
    switch (this.isItemIdHighlighted()) {
      case 1 /* This */:
        return strokeWidth;
      case 0 /* None */:
      case 2 /* Other */:
        return defaultStrokeWidth;
    }
  }
  isItemIdHighlighted() {
    var _a, _b;
    const { series } = (_b = (_a = this.ctx.highlightManager) == null ? void 0 : _a.getActiveHighlight()) != null ? _b : {};
    if (series == null) {
      return 0 /* None */;
    }
    if (series !== this) {
      return 2 /* Other */;
    }
    return 1 /* This */;
  }
  getModuleTooltipParams() {
    const params = this.moduleMap.mapValues((module) => module.getTooltipParams());
    return params.reduce((total, current) => __spreadValues(__spreadValues({}, current), total), {});
  }
  pickNode(point, limitPickModes) {
    const { pickModes, visible, rootGroup } = this;
    if (!visible || !rootGroup.visible) {
      return;
    }
    for (const pickMode of pickModes) {
      if (limitPickModes && !limitPickModes.includes(pickMode)) {
        continue;
      }
      let match;
      switch (pickMode) {
        case 0 /* EXACT_SHAPE_MATCH */:
          match = this.pickNodeExactShape(point);
          break;
        case 1 /* NEAREST_BY_MAIN_AXIS_FIRST */:
        case 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */:
          match = this.pickNodeMainAxisFirst(
            point,
            pickMode === 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */
          );
          break;
        case 3 /* NEAREST_NODE */:
          match = this.pickNodeClosestDatum(point);
          break;
      }
      if (match) {
        return { pickMode, match: match.datum, distance: match.distance };
      }
    }
  }
  pickNodeExactShape(point) {
    const match = this.contentGroup.pickNode(point.x, point.y);
    return match && { datum: match.datum, distance: 0 };
  }
  pickNodeClosestDatum(_point) {
    throw new Error("AG Charts - Series.pickNodeClosestDatum() not implemented");
  }
  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {
    throw new Error("AG Charts - Series.pickNodeMainAxisFirst() not implemented");
  }
  fireNodeClickEvent(event, datum) {
    this.fireEvent(new this.NodeClickEvent("nodeClick", event, datum, this));
  }
  fireNodeDoubleClickEvent(event, datum) {
    this.fireEvent(new this.NodeClickEvent("nodeDoubleClick", event, datum, this));
  }
  toggleSeriesItem(itemId, enabled) {
    this.visible = enabled;
    this.nodeDataRefresh = true;
    this.dispatch("visibility-changed", { itemId, enabled });
  }
  isEnabled() {
    return this.visible;
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    return __spreadProps(__spreadValues({}, this.ctx), { series: this });
  }
  getLabelText(label, params, defaultFormatter = String) {
    var _a;
    if (label.formatter) {
      return (_a = this.ctx.callbackCache.call(label.formatter, __spreadValues({ seriesId: this.id }, params))) != null ? _a : defaultFormatter(params.value);
    }
    return defaultFormatter(params.value);
  }
  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {
    var _a, _b;
    const defaultSize = { size: (_b = (_a = params.datum.point) == null ? void 0 : _a.size) != null ? _b : 0 };
    const markerStyle = mergeDefaults(defaultSize, defaultStyle);
    if (marker.formatter) {
      const style = this.ctx.callbackCache.call(marker.formatter, __spreadProps(__spreadValues(__spreadValues({
        seriesId: this.id
      }, markerStyle), params), {
        datum: params.datum.datum
      }));
      return mergeDefaults(style, markerStyle);
    }
    return markerStyle;
  }
  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true } = {}) {
    const { point } = params.datum;
    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);
    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);
    if (applyTranslation) {
      markerNode.setProperties(__spreadProps(__spreadValues({ visible }, activeStyle), { translationX: point == null ? void 0 : point.x, translationY: point == null ? void 0 : point.y }));
    } else {
      markerNode.setProperties(__spreadValues({ visible }, activeStyle));
    }
    if (typeof marker.shape === "function" && !markerNode.dirtyPath) {
      markerNode.path.clear({ trackChanges: true });
      markerNode.updatePath();
      markerNode.checkPathDirty();
    }
  }
  getMinRect() {
    return void 0;
  }
  get nodeDataDependencies() {
    var _a;
    return (_a = this._nodeDataDependencies) != null ? _a : { seriesRectWidth: NaN, seriesRectHeight: NaN };
  }
  checkResize(newSeriesRect) {
    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect != null ? newSeriesRect : { width: NaN, height: NaN };
    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
      this.markNodeDataDirty();
    }
    return resize;
  }
};
Series.highlightedZIndex = 1e12;
__decorateClass([
  ActionOnSet({
    changeValue: function(newVal, oldVal) {
      this.onSeriesGroupingChange(oldVal, newVal);
    }
  })
], Series.prototype, "seriesGrouping", 2);

// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts
var SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;
var SeriesLayerManager = class {
  constructor(rootGroup) {
    this.groups = {};
    this.series = {};
    this.expectedSeriesCount = 1;
    this.mode = "normal";
    this.rootGroup = rootGroup;
  }
  setSeriesCount(count2) {
    this.expectedSeriesCount = count2;
  }
  requestGroup(seriesConfig) {
    var _a, _b, _c, _d;
    const {
      internalId,
      type,
      rootGroup: seriesRootGroup,
      highlightGroup: seriesHighlightGroup,
      annotationGroup: seriesAnnotationGroup,
      seriesGrouping
    } = seriesConfig;
    const { groupIndex = internalId } = seriesGrouping != null ? seriesGrouping : {};
    if (this.series[internalId] != null) {
      throw new Error(`AG Charts - series already has an allocated layer: ${this.series[internalId]}`);
    }
    if (Object.keys(this.series).length === 0) {
      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? "aggressive-grouping" : "normal";
    }
    (_b = (_a = this.groups)[type]) != null ? _b : _a[type] = {};
    const lookupIndex = this.lookupIdx(groupIndex);
    let groupInfo = this.groups[type][lookupIndex];
    if (!groupInfo) {
      groupInfo = (_d = (_c = this.groups[type])[lookupIndex]) != null ? _d : _c[lookupIndex] = {
        seriesIds: [],
        group: this.rootGroup.appendChild(
          new Group({
            name: `${type}-content`,
            layer: true,
            zIndex: 4 /* SERIES_LAYER_ZINDEX */,
            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder("data")
          })
        ),
        highlight: this.rootGroup.appendChild(
          new Group({
            name: `${type}-highlight`,
            layer: true,
            zIndex: 4 /* SERIES_LAYER_ZINDEX */,
            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder("highlight")
          })
        ),
        annotation: this.rootGroup.appendChild(
          new Group({
            name: `${type}-annotation`,
            layer: true,
            zIndex: 4 /* SERIES_LAYER_ZINDEX */,
            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder("annotation")
          })
        )
      };
    }
    this.series[internalId] = { layerState: groupInfo, seriesConfig };
    groupInfo.seriesIds.push(internalId);
    groupInfo.group.appendChild(seriesRootGroup);
    groupInfo.highlight.appendChild(seriesHighlightGroup);
    groupInfo.annotation.appendChild(seriesAnnotationGroup);
    return groupInfo.group;
  }
  changeGroup(seriesConfig) {
    var _a, _b;
    const { internalId, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;
    const { groupIndex = internalId } = seriesGrouping != null ? seriesGrouping : {};
    if ((_b = (_a = this.groups[type]) == null ? void 0 : _a[groupIndex]) == null ? void 0 : _b.seriesIds.includes(internalId)) {
      return;
    }
    if (this.series[internalId] != null) {
      this.releaseGroup({
        internalId,
        seriesGrouping: oldGrouping,
        type,
        rootGroup,
        highlightGroup,
        annotationGroup
      });
    }
    this.requestGroup(seriesConfig);
  }
  releaseGroup(seriesConfig) {
    var _a, _b, _c, _d, _e;
    const { internalId, seriesGrouping, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;
    const { groupIndex = internalId } = seriesGrouping != null ? seriesGrouping : {};
    if (this.series[internalId] == null) {
      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);
    }
    const lookupIndex = this.lookupIdx(groupIndex);
    const groupInfo = (_c = (_a = this.groups[type]) == null ? void 0 : _a[lookupIndex]) != null ? _c : (_b = this.series[internalId]) == null ? void 0 : _b.layerState;
    if (groupInfo) {
      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);
      groupInfo.group.removeChild(rootGroup);
      groupInfo.highlight.removeChild(highlightGroup);
      groupInfo.annotation.removeChild(annotationGroup);
    }
    if ((groupInfo == null ? void 0 : groupInfo.seriesIds.length) === 0) {
      this.rootGroup.removeChild(groupInfo.group);
      this.rootGroup.removeChild(groupInfo.highlight);
      this.rootGroup.removeChild(groupInfo.annotation);
      delete this.groups[type][lookupIndex];
      delete this.groups[type][internalId];
    } else if ((groupInfo == null ? void 0 : groupInfo.seriesIds.length) > 0) {
      const leadSeriesConfig = (_e = this.series[(_d = groupInfo == null ? void 0 : groupInfo.seriesIds) == null ? void 0 : _d[0]]) == null ? void 0 : _e.seriesConfig;
      groupInfo.group.zIndexSubOrder = leadSeriesConfig == null ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder("data");
      groupInfo.highlight.zIndexSubOrder = leadSeriesConfig == null ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder("highlight");
      groupInfo.annotation.zIndexSubOrder = leadSeriesConfig == null ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder("annotation");
    }
    delete this.series[internalId];
  }
  lookupIdx(groupIndex) {
    if (this.mode === "normal") {
      return groupIndex;
    }
    if (typeof groupIndex === "string") {
      groupIndex = Number(groupIndex.split("-").slice(-1)[0]);
      if (!groupIndex)
        return 0;
    }
    return Math.floor(
      Math.max(Math.min(groupIndex / this.expectedSeriesCount, 1), 0) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION
    );
  }
  destroy() {
    for (const groups of Object.values(this.groups)) {
      for (const groupInfo of Object.values(groups)) {
        this.rootGroup.removeChild(groupInfo.group);
        this.rootGroup.removeChild(groupInfo.highlight);
        this.rootGroup.removeChild(groupInfo.annotation);
      }
    }
    this.groups = {};
    this.series = {};
  }
};

// packages/ag-charts-community/src/chart/series/seriesStateManager.ts
var SeriesStateManager = class {
  constructor() {
    this.groups = {};
  }
  registerSeries({
    id,
    seriesGrouping,
    visible,
    type
  }) {
    var _a, _b;
    if (!seriesGrouping)
      return;
    (_b = (_a = this.groups)[type]) != null ? _b : _a[type] = {};
    this.groups[type][id] = { grouping: seriesGrouping, visible };
  }
  deregisterSeries({ id, type }) {
    if (this.groups[type]) {
      delete this.groups[type][id];
    }
    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {
      delete this.groups[type];
    }
  }
  getVisiblePeerGroupIndex({
    type,
    seriesGrouping,
    visible
  }) {
    var _a;
    if (!seriesGrouping)
      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };
    const visibleGroupsSet = /* @__PURE__ */ new Set();
    const visibleSameStackSet = /* @__PURE__ */ new Set();
    for (const [_, entry] of Object.entries((_a = this.groups[type]) != null ? _a : {})) {
      if (!entry.visible)
        continue;
      visibleGroupsSet.add(entry.grouping.groupIndex);
      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {
        visibleSameStackSet.add(entry.grouping.stackIndex);
      }
    }
    const visibleGroups = [...visibleGroupsSet.values()];
    visibleGroups.sort((a, b) => a - b);
    return {
      visibleGroupCount: visibleGroups.length,
      visibleSameStackCount: visibleSameStackSet.size,
      index: visibleGroups.indexOf(seriesGrouping.groupIndex)
    };
  }
};

// packages/ag-charts-community/src/chart/update/baseLayoutProcessor.ts
var BaseLayoutProcessor = class {
  constructor(chartLike, layoutService) {
    this.chartLike = chartLike;
    this.layoutService = layoutService;
    this.destroyFns = [];
    this.destroyFns.push(
      // eslint-disable-next-line sonarjs/no-duplicate-string
      this.layoutService.addListener("layout-complete", (e) => this.layoutComplete(e)),
      this.layoutService.addListener("start-layout", (e) => this.positionPadding(e.shrinkRect)),
      this.layoutService.addListener("start-layout", (e) => this.positionCaptions(e.shrinkRect))
    );
  }
  destroy() {
    this.destroyFns.forEach((cb) => cb());
  }
  layoutComplete({ clipSeries, series: { paddedRect } }) {
    const { seriesArea, seriesRoot } = this.chartLike;
    if (seriesArea.clip || clipSeries) {
      seriesRoot.setClipRectInGroupCoordinateSpace(paddedRect);
    } else {
      seriesRoot.setClipRectInGroupCoordinateSpace();
    }
  }
  positionPadding(shrinkRect) {
    const { padding } = this.chartLike;
    shrinkRect.shrink(padding.left, "left");
    shrinkRect.shrink(padding.top, "top");
    shrinkRect.shrink(padding.right, "right");
    shrinkRect.shrink(padding.bottom, "bottom");
    return { shrinkRect };
  }
  positionCaptions(shrinkRect) {
    var _a, _b, _c, _d;
    const { title, subtitle, footnote } = this.chartLike;
    const newShrinkRect = shrinkRect.clone();
    const updateCaption = (caption) => {
      var _a2;
      const defaultCaptionHeight = shrinkRect.height / 10;
      const captionLineHeight = (_a2 = caption.lineHeight) != null ? _a2 : caption.fontSize * Text.defaultLineHeightRatio;
      const maxWidth = shrinkRect.width;
      const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);
      caption.computeTextWrap(maxWidth, maxHeight);
    };
    const computeX = (align) => {
      if (align === "left") {
        return newShrinkRect.x;
      } else if (align === "right") {
        return newShrinkRect.x + newShrinkRect.width;
      } else if (align !== "center") {
        Logger.error(`invalid textAlign value: ${align}`);
      }
      return newShrinkRect.x + newShrinkRect.width / 2;
    };
    const positionTopAndShrinkBBox = (caption, spacing) => {
      const baseY = newShrinkRect.y;
      caption.node.x = computeX(caption.textAlign);
      caption.node.y = baseY;
      caption.node.textBaseline = "top";
      updateCaption(caption);
      const bbox = caption.node.computeBBox();
      const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + spacing);
      newShrinkRect.shrink(bboxHeight, "top");
    };
    const positionBottomAndShrinkBBox = (caption, spacing) => {
      const baseY = newShrinkRect.y + newShrinkRect.height;
      caption.node.x = computeX(caption.textAlign);
      caption.node.y = baseY;
      caption.node.textBaseline = "bottom";
      updateCaption(caption);
      const bbox = caption.node.computeBBox();
      const bboxHeight = Math.ceil(baseY - bbox.y + spacing);
      newShrinkRect.shrink(bboxHeight, "bottom");
    };
    if (subtitle) {
      subtitle.node.visible = (_a = subtitle.enabled) != null ? _a : false;
    }
    if (title) {
      title.node.visible = title.enabled;
      if (title.node.visible) {
        const defaultTitleSpacing = (subtitle == null ? void 0 : subtitle.node.visible) ? Caption.SMALL_PADDING : Caption.LARGE_PADDING;
        const spacing = (_b = title.spacing) != null ? _b : defaultTitleSpacing;
        positionTopAndShrinkBBox(title, spacing);
      }
    }
    if (subtitle && subtitle.node.visible) {
      positionTopAndShrinkBBox(subtitle, (_c = subtitle.spacing) != null ? _c : 0);
    }
    if (footnote) {
      footnote.node.visible = footnote.enabled;
      if (footnote.node.visible) {
        positionBottomAndShrinkBBox(footnote, (_d = footnote.spacing) != null ? _d : 0);
      }
    }
    return { shrinkRect: newShrinkRect };
  }
};

// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts
var DataWindowProcessor = class {
  constructor(chart, dataService, updateService, zoomManager) {
    this.chart = chart;
    this.dataService = dataService;
    this.updateService = updateService;
    this.zoomManager = zoomManager;
    this.dirtyZoom = false;
    this.dirtyDataSource = false;
    this.lastAxisZooms = /* @__PURE__ */ new Map();
    this.destroyFns = [];
    this.destroyFns.push(
      this.dataService.addListener("data-source-change", () => this.onDataSourceChange()),
      this.dataService.addListener("data-load", () => this.onDataLoad()),
      this.dataService.addListener("data-error", () => this.onDataError()),
      this.updateService.addListener("update-complete", () => this.onUpdateComplete()),
      this.zoomManager.addListener("zoom-change", () => this.onZoomChange())
    );
  }
  destroy() {
    this.destroyFns.forEach((cb) => cb());
  }
  onDataLoad() {
    this.updateService.update(1 /* UPDATE_DATA */);
  }
  onDataError() {
    this.updateService.update(3 /* PERFORM_LAYOUT */);
  }
  onDataSourceChange() {
    this.dirtyDataSource = true;
  }
  onUpdateComplete() {
    if (!this.dirtyZoom && !this.dirtyDataSource)
      return;
    this.updateWindow();
  }
  onZoomChange() {
    this.dirtyZoom = true;
  }
  updateWindow() {
    return __async(this, null, function* () {
      if (!this.dataService.isLazy())
        return;
      const axis = this.getValidAxis();
      let window2;
      let shouldRefresh = true;
      if (axis) {
        const zoom = this.zoomManager.getAxisZoom(axis.id);
        window2 = this.getAxisWindow(axis, zoom);
        shouldRefresh = this.shouldRefresh(axis, zoom);
      }
      this.dirtyZoom = false;
      this.dirtyDataSource = false;
      if (!shouldRefresh)
        return;
      this.dataService.load({ windowStart: window2 == null ? void 0 : window2.min, windowEnd: window2 == null ? void 0 : window2.max });
    });
  }
  getValidAxis() {
    return this.chart.axes.find((axis) => axis.type === "time");
  }
  shouldRefresh(axis, zoom) {
    if (this.dirtyDataSource)
      return true;
    if (!this.dirtyZoom)
      return false;
    const lastZoom = this.lastAxisZooms.get(axis.id);
    if (lastZoom && zoom.min === lastZoom.min && zoom.max === lastZoom.max) {
      return false;
    }
    this.lastAxisZooms.set(axis.id, zoom);
    return true;
  }
  getAxisWindow(axis, zoom) {
    var _a, _b;
    const domain = (_b = (_a = axis.scale).getDomain) == null ? void 0 : _b.call(_a);
    if (!zoom || !domain || domain.length === 0 || isNaN(Number(domain[0])))
      return;
    const diff2 = Number(domain[1]) - Number(domain[0]);
    const min = new Date(Number(domain[0]) + diff2 * zoom.min);
    const max = new Date(Number(domain[0]) + diff2 * zoom.max);
    return { min, max };
  }
};

// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts
var OverlaysProcessor = class {
  constructor(chartLike, overlays, dataService, layoutService) {
    this.chartLike = chartLike;
    this.overlays = overlays;
    this.dataService = dataService;
    this.layoutService = layoutService;
    this.destroyFns = [];
    this.destroyFns.push(this.layoutService.addListener("layout-complete", (ctx) => this.onLayoutComplete(ctx)));
  }
  destroy() {
    this.destroyFns.forEach((cb) => cb());
  }
  onLayoutComplete({ series: { rect } }) {
    const isLoading = this.dataService.isLoading();
    const hasData = this.chartLike.series.some((s) => {
      var _a;
      return (_a = s.data) == null ? void 0 : _a.length;
    });
    const anySeriesVisible = this.chartLike.series.some((s) => s.visible);
    this.toggleOverlay(this.overlays.loading, rect, isLoading);
    this.toggleOverlay(this.overlays.noData, rect, !isLoading && !hasData);
    this.toggleOverlay(this.overlays.noVisibleSeries, rect, hasData && !anySeriesVisible);
  }
  toggleOverlay(overlay, seriesRect, visible) {
    if (visible && seriesRect) {
      overlay.show(seriesRect);
    } else {
      overlay.hide();
    }
  }
};

// packages/ag-charts-community/src/chart/updateService.ts
var UpdateService = class extends Listeners {
  constructor(updateCallback) {
    super();
    this.updateCallback = updateCallback;
  }
  update(type = 0 /* FULL */, options) {
    this.updateCallback(type, options);
  }
  dispatchUpdateComplete(minRect) {
    this.dispatch("update-complete", { type: "update-complete", minRect });
  }
};

// packages/ag-charts-community/src/chart/chart.ts
var debug = Debug.create(true, "opts");
var SeriesArea = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.padding = new Padding(0);
  }
};
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], SeriesArea.prototype, "clip", 2);
__decorateClass([
  Validate(OBJECT)
], SeriesArea.prototype, "padding", 2);
var _Chart = class _Chart extends Observable {
  constructor(options, resources) {
    var _a;
    super();
    this.id = createId(this);
    this.seriesRoot = new Group({ name: `${this.id}-Series-root` });
    this.debug = Debug.create();
    this.extraDebugStats = {};
    this.data = [];
    this._firstAutoSize = true;
    this.padding = new Padding(20);
    this.seriesArea = new SeriesArea();
    this.mode = "standalone";
    this.destroyed = false;
    this._skipSync = false;
    this._destroyFns = [];
    this.chartAnimationPhase = "initial";
    this.highlightManager = new HighlightManager();
    this.syncManager = new SyncManager(this);
    this.zoomManager = new ZoomManager();
    this.modules = /* @__PURE__ */ new Map();
    this.legends = /* @__PURE__ */ new Map();
    this.processors = [];
    this.processedOptions = {};
    this.userOptions = {};
    this.queuedUserOptions = [];
    this._pendingFactoryUpdatesCount = 0;
    this._performUpdateNoRenderCount = 0;
    this._performUpdateSkipAnimations = false;
    this.performUpdateType = 7 /* NONE */;
    this.updateShortcutCount = 0;
    this.seriesToUpdate = /* @__PURE__ */ new Set();
    this.updateMutex = new Mutex();
    this.updateRequestors = {};
    this.performUpdateTrigger = debouncedCallback((_0) => __async(this, [_0], function* ({ count: count2 }) {
      if (this.destroyed)
        return;
      this.updateMutex.acquire(() => __async(this, null, function* () {
        try {
          yield this.performUpdate(count2);
        } catch (error) {
          Logger.error("update error", error);
        }
      }));
    }));
    this.axes = [];
    this.series = [];
    this.lastInteractionEvent = void 0;
    this.pointerScheduler = debouncedAnimationFrame(() => {
      if (this.lastInteractionEvent) {
        this.handlePointer(this.lastInteractionEvent, false);
        this.lastInteractionEvent = void 0;
      }
    });
    this.onSeriesNodeClick = (event) => {
      const seriesNodeClickEvent = __spreadProps(__spreadValues({}, event), {
        type: "seriesNodeClick"
      });
      Object.defineProperty(seriesNodeClickEvent, "series", {
        enumerable: false,
        // Should display the deprecation warning
        get: () => event.series
      });
      this.fireEvent(seriesNodeClickEvent);
    };
    this.onSeriesNodeDoubleClick = (event) => {
      const seriesNodeDoubleClick = __spreadProps(__spreadValues({}, event), {
        type: "seriesNodeDoubleClick"
      });
      this.fireEvent(seriesNodeDoubleClick);
    };
    this.seriesGroupingChanged = (event) => {
      if (!(event instanceof SeriesGroupingChangedEvent))
        return;
      const { series, seriesGrouping, oldGrouping } = event;
      if (series.rootGroup.parent == null)
        return;
      this.seriesLayerManager.changeGroup({
        internalId: series.internalId,
        type: series.type,
        rootGroup: series.rootGroup,
        highlightGroup: series.highlightGroup,
        annotationGroup: series.annotationGroup,
        getGroupZIndexSubOrder: (type) => series.getGroupZIndexSubOrder(type),
        seriesGrouping,
        oldGrouping
      });
    };
    this.chartOptions = options;
    const { window: window2, document: document2 } = options.specialOverrides;
    const scene = resources == null ? void 0 : resources.scene;
    const element2 = (_a = resources == null ? void 0 : resources.element) != null ? _a : document2.createElement("div");
    const container = resources == null ? void 0 : resources.container;
    const root = new Group({ name: "root" });
    root.visible = false;
    root.append(this.seriesRoot);
    this.axisGridGroup = new Group({ name: "Axes-Grids", layer: true, zIndex: 1 /* AXIS_GRID_ZINDEX */ });
    root.appendChild(this.axisGridGroup);
    this.axisGroup = new Group({ name: "Axes", layer: true, zIndex: 2 /* AXIS_ZINDEX */ });
    root.appendChild(this.axisGroup);
    this.element = element2;
    element2.classList.add("ag-chart-wrapper");
    element2.style.position = "relative";
    this.scene = scene != null ? scene : new Scene(this.chartOptions.specialOverrides);
    this.scene.root = root;
    this.scene.container = element2;
    this.autoSize = true;
    this.chartEventManager = new ChartEventManager();
    this.contextMenuRegistry = new ContextMenuRegistry();
    this.cursorManager = new CursorManager(element2);
    this.highlightManager = new HighlightManager();
    this.interactionManager = new InteractionManager(element2, document2, window2);
    this.regionManager = new RegionManager(this.interactionManager);
    this.gestureDetector = new GestureDetector(element2);
    this.layoutService = new LayoutService();
    this.updateService = new UpdateService((type = 0 /* FULL */, options2) => this.update(type, options2));
    this.seriesStateManager = new SeriesStateManager();
    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot);
    this.callbackCache = new CallbackCache();
    this.animationManager = new AnimationManager(this.interactionManager, this.updateMutex);
    this.animationManager.skip();
    this.animationManager.play();
    this.dataService = new DataService(this.animationManager);
    this.overlays = new ChartOverlays(this.element, this.animationManager);
    this.processors = [
      new BaseLayoutProcessor(this, this.layoutService),
      new DataWindowProcessor(this, this.dataService, this.updateService, this.zoomManager),
      new OverlaysProcessor(this, this.overlays, this.dataService, this.layoutService)
    ];
    this.tooltip = new Tooltip(this.scene.canvas.element, document2, window2, document2.body);
    this.tooltipManager = new TooltipManager(this.tooltip, this.interactionManager);
    this.highlight = new ChartHighlight();
    this.container = container;
    this.attachLegend("category", Legend);
    this.legend = this.legends.get("category");
    const { All } = InteractionState;
    SizeMonitor.observe(this.element, (size) => this.rawResize(size));
    this._destroyFns.push(
      this.dataService.addListener("data-load", (event) => {
        this.data = event.data;
      }),
      this.interactionManager.addListener("click", (event) => this.onClick(event)),
      this.interactionManager.addListener("dblclick", (event) => this.onDoubleClick(event)),
      this.interactionManager.addListener("hover", (event) => this.onMouseMove(event)),
      this.interactionManager.addListener("leave", (event) => this.onLeave(event)),
      this.interactionManager.addListener("page-left", () => this.destroy()),
      this.interactionManager.addListener("wheel", () => this.resetPointer()),
      this.interactionManager.addListener("drag", () => this.resetPointer()),
      this.interactionManager.addListener("contextmenu", (event) => this.onContextMenu(event), All),
      this.animationManager.addListener("animation-frame", () => {
        this.update(6 /* SCENE_RENDER */);
      }),
      this.highlightManager.addListener("highlight-change", (event) => this.changeHighlightDatum(event)),
      this.zoomManager.addListener(
        "zoom-change",
        () => this.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true, skipAnimations: true })
      )
    );
  }
  static getInstance(element2) {
    return _Chart.chartsInstances.get(element2);
  }
  onAutoSizeChange(value) {
    const { style } = this.element;
    if (value) {
      style.display = "block";
      style.width = "100%";
      style.height = "100%";
      if (!this._lastAutoSize) {
        return;
      }
      this.resize(void 0, void 0, "autoSize option");
    } else {
      style.display = "inline-block";
      style.width = "auto";
      style.height = "auto";
    }
  }
  download(fileName, fileFormat) {
    this.scene.download(fileName, fileFormat);
  }
  getOptions() {
    var _a;
    return (_a = this.queuedUserOptions.at(-1)) != null ? _a : this.userOptions;
  }
  addModule(module) {
    if (this.modules.has(module.optionsKey)) {
      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);
    }
    const moduleInstance = new module.instanceConstructor(this.getModuleContext());
    if (module.type === "legend") {
      const legend = moduleInstance;
      this.legends.set(module.identifier, legend);
      legend.attachLegend(this.scene.root);
    }
    this.modules.set(module.optionsKey, moduleInstance);
  }
  removeModule(module) {
    var _a;
    if (module.type === "legend") {
      this.legends.delete(module.identifier);
    }
    (_a = this.modules.get(module.optionsKey)) == null ? void 0 : _a.destroy();
    this.modules.delete(module.optionsKey);
  }
  attachLegend(legendType, legendConstructor) {
    const legend = new legendConstructor(this.getModuleContext());
    this.legends.set(legendType, legend);
    legend.attachLegend(this.scene.root);
  }
  isModuleEnabled(module) {
    return this.modules.has(module.optionsKey);
  }
  getModuleContext() {
    return {
      window: this.chartOptions.specialOverrides.window,
      document: this.chartOptions.specialOverrides.document,
      scene: this.scene,
      animationManager: this.animationManager,
      chartEventManager: this.chartEventManager,
      contextMenuRegistry: this.contextMenuRegistry,
      cursorManager: this.cursorManager,
      highlightManager: this.highlightManager,
      interactionManager: this.interactionManager,
      regionManager: this.regionManager,
      gestureDetector: this.gestureDetector,
      tooltipManager: this.tooltipManager,
      syncManager: this.syncManager,
      zoomManager: this.zoomManager,
      chartService: this,
      dataService: this.dataService,
      layoutService: this.layoutService,
      updateService: this.updateService,
      seriesStateManager: this.seriesStateManager,
      callbackCache: this.callbackCache
    };
  }
  resetAnimations() {
    var _a;
    this.chartAnimationPhase = "initial";
    for (const series of this.series) {
      series.resetAnimation(this.chartAnimationPhase);
    }
    for (const axis of this.axes) {
      axis.resetAnimation(this.chartAnimationPhase);
    }
    this.animationRect = void 0;
    (_a = this.animationManager) == null ? void 0 : _a.reset();
  }
  skipAnimations() {
    this.animationManager.skipCurrentBatch();
    this._performUpdateSkipAnimations = true;
  }
  destroy(opts) {
    if (this.destroyed) {
      return;
    }
    const keepTransferableResources = opts == null ? void 0 : opts.keepTransferableResources;
    let result;
    this.performUpdateType = 7 /* NONE */;
    this._destroyFns.forEach((fn) => fn());
    this.processors.forEach((p) => p.destroy());
    this.tooltipManager.destroy();
    this.tooltip.destroy();
    this.legends.forEach((legend) => legend.destroy());
    this.legends.clear();
    this.overlays.destroy();
    SizeMonitor.unobserve(this.element);
    for (const moduleInstance of this.modules.values()) {
      moduleInstance == null ? void 0 : moduleInstance.destroy();
    }
    this.modules.clear();
    this.regionManager.destroy();
    this.interactionManager.destroy();
    this.animationManager.stop();
    this.animationManager.destroy();
    this.chartEventManager.destroy();
    this.highlightManager.destroy();
    this.zoomManager.destroy();
    if (keepTransferableResources) {
      this.scene.strip();
      result = { container: this.container, scene: this.scene, element: this.element };
    } else {
      this.scene.destroy();
      this.container = void 0;
    }
    this.destroySeries(this.series);
    this.seriesLayerManager.destroy();
    this.axes.forEach((a) => a.destroy());
    this.axes = [];
    this.callbackCache.invalidateCache();
    this.animationRect = void 0;
    this.animationManager.reset();
    this.syncManager.destroy();
    this.destroyed = true;
    Object.freeze(this);
    return result;
  }
  resetPointer(highlightOnly = false) {
    if (!highlightOnly) {
      this.tooltipManager.removeTooltip(this.id);
    }
    this.highlightManager.updateHighlight(this.id);
    this.lastInteractionEvent = void 0;
  }
  requestFactoryUpdate(cb) {
    if (this.destroyed)
      return;
    this._pendingFactoryUpdatesCount++;
    this.updateMutex.acquire(() => __async(this, null, function* () {
      if (this.destroyed)
        return;
      yield cb(this);
      if (this.destroyed)
        return;
      this._pendingFactoryUpdatesCount--;
    }));
  }
  update(type = 0 /* FULL */, opts) {
    var _a, _b;
    const {
      forceNodeDataRefresh = false,
      skipAnimations,
      seriesToUpdate = this.series,
      newAnimationBatch
    } = opts != null ? opts : {};
    if (forceNodeDataRefresh) {
      this.series.forEach((series) => series.markNodeDataDirty());
    }
    for (const series of seriesToUpdate) {
      this.seriesToUpdate.add(series);
    }
    if (skipAnimations) {
      this.animationManager.skipCurrentBatch();
      this._performUpdateSkipAnimations = true;
    }
    if (newAnimationBatch && this.animationManager.isActive()) {
      this._performUpdateSkipAnimations = true;
    }
    this._skipSync = (_a = opts == null ? void 0 : opts.skipSync) != null ? _a : false;
    if (this.debug.check()) {
      let stack = (_b = new Error().stack) != null ? _b : "<unknown>";
      stack = stack.replace(/\([^)]*/g, "");
      this.updateRequestors[stack] = type;
    }
    if (type < this.performUpdateType) {
      this.performUpdateType = type;
      this.performUpdateTrigger.schedule(opts == null ? void 0 : opts.backOffMs);
    }
  }
  performUpdate(count2) {
    return __async(this, null, function* () {
      const { performUpdateType, extraDebugStats } = this;
      const seriesToUpdate = [...this.seriesToUpdate];
      this.performUpdateType = 7 /* NONE */;
      this.seriesToUpdate.clear();
      if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {
        this.animationManager.startBatch(this._performUpdateSkipAnimations);
        this.animationManager.onBatchStop(() => this.chartAnimationPhase = "ready");
      }
      this.debug("Chart.performUpdate() - start", ChartUpdateType[performUpdateType]);
      const splits = { start: performance.now() };
      switch (performUpdateType) {
        case 0 /* FULL */:
        case 1 /* UPDATE_DATA */:
          yield this.updateData();
          splits["\u2B07\uFE0F"] = performance.now();
        case 2 /* PROCESS_DATA */:
          yield this.processData();
          this.resetPointer(true);
          splits["\u{1F3ED}"] = performance.now();
        case 3 /* PERFORM_LAYOUT */:
          if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))
            break;
          if (!this.checkFirstAutoSize(seriesToUpdate))
            break;
          yield this.processLayout();
          splits["\u2316"] = performance.now();
        case 4 /* SERIES_UPDATE */:
          if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))
            break;
          const { seriesRect } = this;
          yield Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));
          splits["\u{1F914}"] = performance.now();
        case 5 /* TOOLTIP_RECALCULATION */:
          if (this.checkUpdateShortcut(5 /* TOOLTIP_RECALCULATION */))
            break;
          const tooltipMeta = this.tooltipManager.getTooltipMeta(this.id);
          if (performUpdateType <= 4 /* SERIES_UPDATE */ && tooltipMeta !== void 0) {
            this.handlePointer(tooltipMeta.lastPointerEvent, true);
          }
          splits["\u2196"] = performance.now();
        case 6 /* SCENE_RENDER */:
          if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))
            break;
          extraDebugStats["updateShortcutCount"] = this.updateShortcutCount;
          yield this.scene.render({ debugSplitTimes: splits, extraDebugStats });
          this.extraDebugStats = {};
        case 7 /* NONE */:
          this.updateShortcutCount = 0;
          this.updateRequestors = {};
          this._performUpdateSkipAnimations = false;
          this.animationManager.endBatch();
      }
      this.updateService.dispatchUpdateComplete(this.getMinRect());
      const end = performance.now();
      this.debug("Chart.performUpdate() - end", {
        chart: this,
        durationMs: Math.round((end - splits["start"]) * 100) / 100,
        count: count2,
        performUpdateType: ChartUpdateType[performUpdateType]
      });
    });
  }
  checkUpdateShortcut(checkUpdateType) {
    const maxShortcuts = 3;
    if (this.updateShortcutCount > maxShortcuts) {
      Logger.warn(
        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,
        this.updateRequestors
      );
      return false;
    }
    if (this.performUpdateType <= checkUpdateType) {
      this.updateShortcutCount++;
      return true;
    }
    return false;
  }
  checkFirstAutoSize(seriesToUpdate) {
    if (this.autoSize && !this._lastAutoSize) {
      const count2 = this._performUpdateNoRenderCount++;
      const backOffMs = __pow(count2, 2) * 10;
      if (count2 < 8) {
        this.update(3 /* PERFORM_LAYOUT */, { seriesToUpdate, backOffMs });
        this.debug("Chart.checkFirstAutoSize() - backing off until first size update", backOffMs);
        return false;
      }
      this.debug("Chart.checkFirstAutoSize() - timeout for first size update.");
    }
    this._performUpdateNoRenderCount = 0;
    return true;
  }
  onSeriesChange(newValue, oldValue) {
    var _a, _b;
    const seriesToDestroy = (_a = oldValue == null ? void 0 : oldValue.filter((series) => !newValue.includes(series))) != null ? _a : [];
    this.destroySeries(seriesToDestroy);
    (_b = this.seriesLayerManager) == null ? void 0 : _b.setSeriesCount(newValue.length);
    for (const series of newValue) {
      if (oldValue == null ? void 0 : oldValue.includes(series))
        continue;
      if (series.rootGroup.parent == null) {
        this.seriesLayerManager.requestGroup(series);
      }
      const chart = this;
      series.chart = {
        get mode() {
          return chart.mode;
        },
        get isMiniChart() {
          return false;
        },
        get seriesRect() {
          return chart.seriesRect;
        },
        placeLabels() {
          return chart.placeLabels();
        }
      };
      series.resetAnimation(this.chartAnimationPhase);
      this.addSeriesListeners(series);
      series.addChartEventListeners();
    }
  }
  destroySeries(series) {
    series == null ? void 0 : series.forEach((series2) => {
      series2.removeEventListener("nodeClick", this.onSeriesNodeClick);
      series2.removeEventListener("nodeDoubleClick", this.onSeriesNodeDoubleClick);
      series2.removeEventListener("groupingChanged", this.seriesGroupingChanged);
      series2.destroy();
      this.seriesLayerManager.releaseGroup(series2);
      series2.chart = void 0;
    });
  }
  addSeriesListeners(series) {
    if (this.hasEventListener("seriesNodeClick")) {
      series.addEventListener("nodeClick", this.onSeriesNodeClick);
    }
    if (this.hasEventListener("seriesNodeDoubleClick")) {
      series.addEventListener("nodeDoubleClick", this.onSeriesNodeDoubleClick);
    }
    series.addEventListener("groupingChanged", this.seriesGroupingChanged);
  }
  updateAllSeriesListeners() {
    this.series.forEach((series) => {
      series.removeEventListener("nodeClick", this.onSeriesNodeClick);
      series.removeEventListener("nodeDoubleClick", this.onSeriesNodeDoubleClick);
      this.addSeriesListeners(series);
    });
  }
  assignSeriesToAxes() {
    this.axes.forEach((axis) => {
      axis.boundSeries = this.series.filter((s) => {
        const seriesAxis = s.axes[axis.direction];
        return seriesAxis === axis;
      });
    });
  }
  assignAxesToSeries() {
    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);
    this.series.forEach((series) => {
      series.directions.forEach((direction) => {
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          Logger.warnOnce(
            `no available axis for direction [${direction}]; check series and axes configuration.`
          );
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = this.findMatchingAxis(directionAxes, seriesKeys);
        if (!newAxis) {
          Logger.warnOnce(
            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
          );
          return;
        }
        series.axes[direction] = newAxis;
      });
    });
  }
  findMatchingAxis(directionAxes, directionKeys) {
    for (const axis of directionAxes) {
      if (!axis.keys.length) {
        return axis;
      }
      if (!directionKeys) {
        continue;
      }
      for (const directionKey of directionKeys) {
        if (axis.keys.includes(directionKey)) {
          return axis;
        }
      }
    }
  }
  rawResize(size) {
    var _a;
    let { width, height } = size;
    width = Math.floor(width);
    height = Math.floor(height);
    if (!this.autoSize) {
      return;
    }
    if (width === 0 && height === 0) {
      return;
    }
    const [autoWidth = 0, authHeight = 0] = (_a = this._lastAutoSize) != null ? _a : [];
    if (autoWidth === width && authHeight === height) {
      return;
    }
    this._lastAutoSize = [width, height];
    this.resize(void 0, void 0, "SizeMonitor");
  }
  resize(width, height, source) {
    var _a, _b, _c, _d;
    width != null ? width : width = (_b = this.width) != null ? _b : this.autoSize ? (_a = this._lastAutoSize) == null ? void 0 : _a[0] : this.scene.canvas.width;
    height != null ? height : height = (_d = this.height) != null ? _d : this.autoSize ? (_c = this._lastAutoSize) == null ? void 0 : _c[1] : this.scene.canvas.height;
    this.debug(`Chart.resize() from ${source}`, { width, height, stack: new Error().stack });
    if (!width || !height || !isFiniteNumber(width) || !isFiniteNumber(height))
      return;
    if (this.scene.resize(width, height)) {
      this.resetPointer();
      this.animationManager.reset();
      let skipAnimations = true;
      if (this.autoSize && this._firstAutoSize) {
        skipAnimations = false;
        this._firstAutoSize = false;
      }
      this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
    }
  }
  updateData() {
    return __async(this, null, function* () {
      this.series.forEach((s) => s.setChartData(this.data));
      const modulePromises = Array.from(this.modules.values(), (m) => {
        var _a;
        return (_a = m.updateData) == null ? void 0 : _a.call(m, { data: this.data });
      });
      yield Promise.all(modulePromises);
    });
  }
  processData() {
    return __async(this, null, function* () {
      if (this.series.some((s) => s.canHaveAxes)) {
        this.assignAxesToSeries();
        this.assignSeriesToAxes();
        const syncModule = this.modules.get("sync");
        if (syncModule == null ? void 0 : syncModule.enabled) {
          syncModule.syncAxes(this._skipSync);
        }
      }
      const dataController = new DataController(this.mode);
      const seriesPromises = this.series.map((s) => s.processData(dataController));
      const modulePromises = Array.from(this.modules.values(), (m) => {
        var _a;
        return (_a = m.processData) == null ? void 0 : _a.call(m, { dataController });
      });
      dataController.execute();
      yield Promise.all([...seriesPromises, ...modulePromises]);
      yield this.updateLegend();
    });
  }
  placeLabels() {
    const visibleSeries = [];
    const data = [];
    for (const series of this.series) {
      if (!series.visible)
        continue;
      const labelData = series.getLabelData();
      if (isPointLabelDatum(labelData == null ? void 0 : labelData[0])) {
        data.push(labelData);
        visibleSeries.push(series);
      }
    }
    const { seriesRect } = this;
    const { top, right, bottom, left } = this.seriesArea.padding;
    const labels = seriesRect && data.length > 0 ? placeLabels(data, {
      x: -left,
      y: -top,
      width: seriesRect.width + left + right,
      height: seriesRect.height + top + bottom
    }) : [];
    return new Map(labels.map((l, i) => [visibleSeries[i], l]));
  }
  updateLegend() {
    return __async(this, null, function* () {
      this.legends.forEach((legend, legendType) => {
        const isCategoryLegendData = (data) => data.every((d) => d.legendType === "category");
        const legendData = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));
        if (isCategoryLegendData(legendData) && this.mode !== "integrated") {
          this.validateCategoryLegendData(legendData);
        }
        legend.data = legendData;
      });
    });
  }
  validateCategoryLegendData(legendData) {
    const labelMarkerFills = {};
    legendData.forEach((d) => {
      var _a, _b, _c, _d, _e;
      const seriesType = (_a = this.series.find((s) => s.id === d.seriesId)) == null ? void 0 : _a.type;
      if (!seriesType)
        return;
      (_b = labelMarkerFills[seriesType]) != null ? _b : labelMarkerFills[seriesType] = {};
      (_e = (_c = labelMarkerFills[seriesType])[_d = d.label.text]) != null ? _e : _c[_d] = /* @__PURE__ */ new Set();
      if (d.marker.fill != null) {
        labelMarkerFills[seriesType][d.label.text].add(d.marker.fill);
      }
    });
    for (const seriesMarkers of Object.values(labelMarkerFills)) {
      for (const [name, fills] of Object.entries(seriesMarkers)) {
        if (fills.size > 1) {
          Logger.warnOnce(
            `legend item '${name}' has multiple fill colors, this may cause unexpected behaviour.`
          );
        }
      }
    }
  }
  processLayout() {
    return __async(this, null, function* () {
      var _a;
      const oldRect = this.animationRect;
      yield this.performLayout();
      if (oldRect && !((_a = this.animationRect) == null ? void 0 : _a.equals(oldRect))) {
        this.animationManager.skipCurrentBatch();
      }
      this.debug("Chart.performUpdate() - seriesRect", this.seriesRect);
    });
  }
  performLayout() {
    return __async(this, null, function* () {
      if (this.scene.root) {
        this.scene.root.visible = true;
      }
      const { width, height } = this.scene;
      let ctx = { shrinkRect: new BBox(0, 0, width, height) };
      ctx = this.layoutService.dispatchPerformLayout("start-layout", ctx);
      ctx = this.layoutService.dispatchPerformLayout("before-series", ctx);
      const modulePromises = Array.from(this.modules.values(), (m) => __async(this, null, function* () {
        var _a;
        if (m.performLayout != null) {
          ctx = yield (_a = m.performLayout) == null ? void 0 : _a.call(m, ctx);
        }
      }));
      yield Promise.all(modulePromises);
      return ctx.shrinkRect;
    });
  }
  // x/y are local canvas coordinates in CSS pixels, not actual pixels
  pickSeriesNode(point, exactMatchOnly, maxDistance) {
    var _a, _b;
    const start = performance.now();
    const pickModes = exactMatchOnly ? [0 /* EXACT_SHAPE_MATCH */] : void 0;
    const reverseSeries = [...this.series].reverse();
    let result;
    for (const series of reverseSeries) {
      if (!series.visible || !series.rootGroup.visible) {
        continue;
      }
      const { match, distance: distance2 } = (_a = series.pickNode(point, pickModes)) != null ? _a : {};
      if (!match || distance2 == null) {
        continue;
      }
      if ((!result || result.distance > distance2) && distance2 <= (maxDistance != null ? maxDistance : Infinity)) {
        result = { series, distance: distance2, datum: match };
      }
      if (distance2 === 0) {
        break;
      }
    }
    this.extraDebugStats["pickSeriesNode"] = Math.round(
      ((_b = this.extraDebugStats["pickSeriesNode"]) != null ? _b : 0) + (performance.now() - start)
    );
    return result;
  }
  onMouseMove(event) {
    this.lastInteractionEvent = event;
    this.pointerScheduler.schedule();
    this.extraDebugStats["mouseX"] = event.offsetX;
    this.extraDebugStats["mouseY"] = event.offsetY;
    this.update(6 /* SCENE_RENDER */);
  }
  onLeave(event) {
    if (!this.tooltip.pointerLeftOntoTooltip(event)) {
      this.resetPointer();
      this.update(6 /* SCENE_RENDER */);
    }
  }
  onContextMenu(event) {
    this.tooltipManager.removeTooltip(this.id);
    const { Default: Default2, ContextMenu } = InteractionState;
    if (this.interactionManager.getState() & (Default2 | ContextMenu)) {
      this.checkSeriesNodeRange(event, (_series, datum) => {
        this.highlightManager.updateHighlight(this.id, datum);
      });
    }
  }
  handlePointer(event, redisplay) {
    if (this.interactionManager.getState() !== 8 /* Default */) {
      return;
    }
    const { lastPick, hoverRect } = this;
    const { offsetX, offsetY } = event;
    const disablePointer = (highlightOnly = false) => {
      if (lastPick) {
        this.resetPointer(highlightOnly);
      }
    };
    if (redisplay && this.animationManager.isActive()) {
      disablePointer();
      return;
    }
    if (!(hoverRect == null ? void 0 : hoverRect.containsPoint(offsetX, offsetY))) {
      disablePointer();
      return;
    }
    this.handlePointerTooltip(event, disablePointer);
    this.handlePointerNode(event);
  }
  handlePointerTooltip(event, disablePointer) {
    const { lastPick, tooltip } = this;
    const { range: range3 } = tooltip;
    const { offsetX, offsetY } = event;
    let pixelRange;
    if (isFiniteNumber(range3)) {
      pixelRange = range3;
    }
    const pick = this.pickSeriesNode({ x: offsetX, y: offsetY }, range3 === "exact", pixelRange);
    if (!pick) {
      this.tooltipManager.removeTooltip(this.id);
      if (this.highlight.range === "tooltip")
        disablePointer(true);
      return;
    }
    const isNewDatum = this.highlight.range === "node" || !lastPick || lastPick !== pick.datum;
    let html;
    if (isNewDatum) {
      html = pick.series.getTooltipHtml(pick.datum);
      if (this.highlight.range === "tooltip") {
        this.highlightManager.updateHighlight(this.id, pick.datum);
      }
    }
    const isPixelRange = pixelRange != null;
    const tooltipEnabled = this.tooltip.enabled && pick.series.properties.tooltip.enabled;
    const exactlyMatched = range3 === "exact" && pick.distance === 0;
    const rangeMatched = range3 === "nearest" || isPixelRange || exactlyMatched;
    const shouldUpdateTooltip = tooltipEnabled && rangeMatched && (!isNewDatum || html !== void 0);
    const meta = TooltipManager.makeTooltipMeta(event, pick.datum);
    if (shouldUpdateTooltip) {
      this.tooltipManager.updateTooltip(this.id, meta, html);
    }
  }
  handlePointerNode(event) {
    const found = this.checkSeriesNodeRange(event, (series, datum) => {
      if (series.hasEventListener("nodeClick") || series.hasEventListener("nodeDoubleClick")) {
        this.cursorManager.updateCursor("chart", "pointer");
      }
      if (this.highlight.range === "node") {
        this.highlightManager.updateHighlight(this.id, datum);
      }
    });
    if (!found) {
      this.cursorManager.updateCursor("chart");
      if (this.highlight.range === "node") {
        this.highlightManager.updateHighlight(this.id);
      }
    }
  }
  onClick(event) {
    if (this.checkSeriesNodeClick(event)) {
      this.update(4 /* SERIES_UPDATE */);
      return;
    }
    this.fireEvent({
      type: "click",
      event: event.sourceEvent
    });
  }
  onDoubleClick(event) {
    if (this.checkSeriesNodeDoubleClick(event)) {
      this.update(4 /* SERIES_UPDATE */);
      return;
    }
    this.fireEvent({
      type: "doubleClick",
      event: event.sourceEvent
    });
  }
  checkSeriesNodeClick(event) {
    return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeClickEvent(event.sourceEvent, datum));
  }
  checkSeriesNodeDoubleClick(event) {
    return this.checkSeriesNodeRange(
      event,
      (series, datum) => series.fireNodeDoubleClickEvent(event.sourceEvent, datum)
    );
  }
  checkSeriesNodeRange(event, callback) {
    const nearestNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false);
    const datum = nearestNode == null ? void 0 : nearestNode.datum;
    const nodeClickRange = datum == null ? void 0 : datum.series.properties.nodeClickRange;
    let pixelRange;
    if (isFiniteNumber(nodeClickRange)) {
      pixelRange = nodeClickRange;
    }
    let pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, true);
    if (pickedNode) {
      this.highlightManager.updatePicked(this.id, pickedNode.datum);
    } else {
      this.highlightManager.updatePicked(this.id);
    }
    if (datum && nodeClickRange === "nearest") {
      callback(datum.series, datum);
      return true;
    }
    if (nodeClickRange !== "exact") {
      pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false, pixelRange);
    }
    if (!pickedNode)
      return false;
    const isPixelRange = pixelRange != null;
    const exactlyMatched = nodeClickRange === "exact" && pickedNode.distance === 0;
    if (isPixelRange || exactlyMatched) {
      callback(pickedNode.series, pickedNode.datum);
      return true;
    }
    return false;
  }
  changeHighlightDatum(event) {
    var _a, _b;
    const seriesToUpdate = /* @__PURE__ */ new Set();
    const { series: newSeries = void 0, datum: newDatum } = (_a = event.currentHighlight) != null ? _a : {};
    const { series: lastSeries = void 0, datum: lastDatum } = (_b = event.previousHighlight) != null ? _b : {};
    if (lastSeries) {
      seriesToUpdate.add(lastSeries);
    }
    if (newSeries) {
      seriesToUpdate.add(newSeries);
    }
    if ((lastSeries == null ? void 0 : lastSeries.properties.cursor) && lastDatum) {
      this.cursorManager.updateCursor(lastSeries.id);
    }
    if ((newSeries == null ? void 0 : newSeries.properties.cursor) && newDatum) {
      this.cursorManager.updateCursor(newSeries.id, newSeries.properties.cursor);
    }
    this.lastPick = event.currentHighlight;
    const updateAll = newSeries == null || lastSeries == null;
    if (updateAll) {
      this.update(4 /* SERIES_UPDATE */);
    } else {
      this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });
    }
  }
  waitForUpdate(timeoutMs = 5e3) {
    return __async(this, null, function* () {
      const start = performance.now();
      if (this._pendingFactoryUpdatesCount > 0) {
        yield this.updateMutex.waitForClearAcquireQueue();
      }
      while (this.performUpdateType !== 7 /* NONE */) {
        if (performance.now() - start > timeoutMs) {
          throw new Error("waitForUpdate() timeout reached.");
        }
        yield sleep(5);
      }
      yield this.updateMutex.waitForClearAcquireQueue();
    });
  }
  getMinRect() {
    const minRects = this.series.map((series) => series.getMinRect()).filter((rect) => rect !== void 0);
    if (!minRects.length)
      return void 0;
    return new BBox(
      0,
      0,
      minRects.reduce((max, rect) => Math.max(max, rect.width), 0),
      minRects.reduce((max, rect) => Math.max(max, rect.height), 0)
    );
  }
  filterMiniChartSeries(series) {
    if (series != null) {
      return series.filter((s) => s.showInMiniChart !== false);
    } else {
      return series;
    }
  }
  applyOptions(chartOptions) {
    var _a, _b, _c, _d, _e, _f;
    const oldOpts = this.processedOptions;
    const deltaOptions = chartOptions.diffOptions(oldOpts);
    const userOptions = chartOptions.userOptions;
    if (deltaOptions == null)
      return;
    debug("AgChartV2.updateDelta() - applying delta", deltaOptions);
    const completeOptions = mergeDefaults(deltaOptions, oldOpts);
    const modulesChanged = this.applyModules(completeOptions);
    const skip = ["type", "data", "series", "listeners", "theme", "legend.listeners", "navigator.miniChart.label"];
    if (isAgCartesianChartOptions(deltaOptions) || isAgPolarChartOptions(deltaOptions)) {
      skip.push("axes");
    }
    if (deltaOptions.listeners) {
      this.registerListeners(this, deltaOptions.listeners);
    }
    this.applyOptionValues(this, deltaOptions, { skip });
    let forceNodeDataRefresh = false;
    let seriesStatus = "no-op";
    if (deltaOptions.series && deltaOptions.series.length > 0) {
      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts == null ? void 0 : oldOpts.series);
      forceNodeDataRefresh = true;
    }
    if (seriesStatus === "replaced") {
      this.resetAnimations();
    }
    if (this.applyAxes(this, completeOptions, oldOpts, seriesStatus)) {
      forceNodeDataRefresh = true;
    }
    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === "data-change" || seriesStatus === "replaced";
    const legendKeys = getLegendKeys();
    const optionsHaveLegend = Object.values(legendKeys).some(
      (legendKey) => deltaOptions[legendKey] != null
    );
    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;
    forceNodeDataRefresh = forceNodeDataRefresh || seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;
    if (deltaOptions.data) {
      this.data = deltaOptions.data;
    }
    if ((_a = deltaOptions.legend) == null ? void 0 : _a.listeners) {
      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);
    }
    if (deltaOptions.listeners) {
      this.updateAllSeriesListeners();
    }
    this.chartOptions = chartOptions;
    this.processedOptions = completeOptions;
    this.userOptions = mergeDefaults(userOptions, this.userOptions);
    const navigatorModule = this.modules.get("navigator");
    const zoomModule = this.modules.get("zoom");
    if (!(navigatorModule == null ? void 0 : navigatorModule.enabled) && !(zoomModule == null ? void 0 : zoomModule.enabled)) {
      this.zoomManager.updateZoom();
    }
    const miniChart = navigatorModule == null ? void 0 : navigatorModule.miniChart;
    if ((miniChart == null ? void 0 : miniChart.enabled) === true && (deltaOptions == null ? void 0 : deltaOptions.series) != null) {
      const seriesStatus2 = this.applySeries(
        miniChart,
        this.filterMiniChartSeries(deltaOptions.series),
        this.filterMiniChartSeries(oldOpts == null ? void 0 : oldOpts.series)
      );
      this.applyAxes(miniChart, deltaOptions, oldOpts, seriesStatus2, [
        "axes[].tick",
        "axes[].thickness",
        "axes[].title",
        "axes[].crosshair",
        "axes[].gridLine",
        "axes[].label"
      ]);
      const axes = miniChart.axes;
      const horizontalAxis = axes.find((axis) => axis.direction === "x" /* X */);
      for (const axis of axes) {
        axis.gridLine.enabled = false;
        axis.label.enabled = axis === horizontalAxis;
        axis.tick.enabled = false;
        axis.interactionEnabled = false;
      }
      if (horizontalAxis != null) {
        const labelOptions = (_c = (_b = deltaOptions.navigator) == null ? void 0 : _b.miniChart) == null ? void 0 : _c.label;
        const intervalOptions = (_f = (_e = (_d = deltaOptions.navigator) == null ? void 0 : _d.miniChart) == null ? void 0 : _e.label) == null ? void 0 : _f.interval;
        jsonApply(horizontalAxis.label, labelOptions, {
          path: "navigator.miniChart.label",
          skip: [
            "navigator.miniChart.label.interval",
            "navigator.miniChart.label.rotation",
            "navigator.miniChart.label.minSpacing",
            "navigator.miniChart.label.autoRotate",
            "navigator.miniChart.label.autoRotateAngle"
          ]
        });
        jsonApply(horizontalAxis.tick, intervalOptions, {
          path: "navigator.miniChart.interval",
          skip: [
            "navigator.miniChart.interval.enabled",
            "navigator.miniChart.interval.width",
            "navigator.miniChart.interval.size",
            "navigator.miniChart.interval.color",
            "navigator.miniChart.interval.interval",
            "navigator.miniChart.interval.step"
          ]
        });
        const step = intervalOptions == null ? void 0 : intervalOptions.step;
        if (step != null) {
          horizontalAxis.tick.interval = step;
        }
      }
    } else if ((miniChart == null ? void 0 : miniChart.enabled) === false) {
      miniChart.series = [];
      miniChart.axes = [];
    }
    const majorChange = forceNodeDataRefresh || modulesChanged;
    const updateType = majorChange ? 1 /* UPDATE_DATA */ : 3 /* PERFORM_LAYOUT */;
    debug("AgChartV2.applyChartOptions() - update type", ChartUpdateType[updateType]);
    this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });
  }
  applyModules(options) {
    let modulesChanged = false;
    for (const module of REGISTERED_MODULES) {
      if (module.type !== "root" && module.type !== "legend") {
        continue;
      }
      const optionsValue = options[module.optionsKey];
      const shouldBeEnabled = module.chartTypes.includes(this.constructor.type) && optionsValue != null;
      const isEnabled = this.isModuleEnabled(module);
      if (shouldBeEnabled === isEnabled) {
        continue;
      }
      if (shouldBeEnabled) {
        this.addModule(module);
        this[module.optionsKey] = this.modules.get(module.optionsKey);
      } else {
        this.removeModule(module);
        delete this[module.optionsKey];
      }
      modulesChanged = true;
    }
    return modulesChanged;
  }
  applySeries(chart, optSeries, oldOptSeries) {
    if (!optSeries) {
      return "no-change";
    }
    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);
    if (matchResult.status === "no-overlap") {
      debug(
        `AgChartV2.applySeries() - creating new series instances, status: ${matchResult.status}`,
        matchResult
      );
      chart.series = this.createSeries(optSeries);
      return "replaced";
    }
    debug(`AgChartV2.applySeries() - matchResult`, matchResult);
    const seriesInstances = [];
    for (const change of matchResult.changes) {
      if (change.status === "add") {
        const newSeries = this.createSeries([change.opts])[0];
        seriesInstances.push(newSeries);
        debug(`AgChartV2.applySeries() - created new series`, newSeries);
        continue;
      } else if (change.status === "remove") {
        debug(`AgChartV2.applySeries() - removing series at previous idx ${change.idx}`, change.series);
        continue;
      } else if (change.status === "no-op") {
        seriesInstances.push(change.series);
        debug(`AgChartV2.applySeries() - no change to series at previous idx ${change.idx}`, change.series);
        continue;
      }
      const { series, diff: diff2, idx } = change;
      debug(`AgChartV2.applySeries() - applying series diff previous idx ${idx}`, diff2, series);
      this.applySeriesValues(series, diff2);
      series.markNodeDataDirty();
      seriesInstances.push(series);
    }
    for (let idx = 0; idx < seriesInstances.length; idx++) {
      seriesInstances[idx]._declarationOrder = idx;
    }
    debug(`AgChartV2.applySeries() - final series instances`, seriesInstances);
    chart.series = seriesInstances;
    const dataChanged = matchResult.changes.some(({ diff: diff2 }) => {
      return diff2 && (diff2.seriesGrouping != null || diff2.data != null);
    });
    const noop = matchResult.changes.every((c) => c.status === "no-op");
    return dataChanged ? "data-change" : noop ? "no-op" : "updated";
  }
  applyAxes(chart, options, oldOpts, seriesStatus, skip = []) {
    if (!("axes" in options) || !options.axes) {
      return false;
    }
    skip = ["axes[].type", ...skip];
    const { axes } = options;
    const forceRecreate = seriesStatus === "replaced";
    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);
    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {
      chart.axes.forEach((axis, index) => {
        var _a, _b;
        const previousOpts = (_b = (_a = oldOpts.axes) == null ? void 0 : _a[index]) != null ? _b : {};
        const axisDiff = jsonDiff(previousOpts, axes[index]);
        debug(`AgChartV2.applyAxes() - applying axis diff idx ${index}`, axisDiff);
        const path = `axes[${index}]`;
        this.applyOptionValues(axis, axisDiff, { path, skip });
      });
      return true;
    }
    debug(`AgChartV2.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);
    chart.axes = this.createAxis(axes, skip);
    return true;
  }
  createSeries(options) {
    var _a;
    const series = [];
    const moduleContext = this.getModuleContext();
    for (const seriesOptions of options != null ? options : []) {
      const type = (_a = seriesOptions.type) != null ? _a : "unknown";
      if (isEnterpriseSeriesType(type) && !isEnterpriseSeriesTypeLoaded(type)) {
        continue;
      }
      const seriesInstance = createSeries(type, moduleContext);
      this.applySeriesOptionModules(seriesInstance, seriesOptions);
      this.applySeriesValues(seriesInstance, seriesOptions);
      series.push(seriesInstance);
    }
    return series;
  }
  applySeriesOptionModules(series, options) {
    const moduleContext = series.createModuleContext();
    const moduleMap = series.getModuleMap();
    for (const module of REGISTERED_MODULES) {
      if (module.type !== "series-option")
        continue;
      if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {
        moduleMap.addModule(module, (module2) => new module2.instanceConstructor(moduleContext));
      }
    }
  }
  applySeriesValues(target, options) {
    const moduleMap = target.getModuleMap();
    const _a = options, {
      type,
      data,
      errorBar,
      listeners,
      seriesGrouping,
      showInMiniChart: _showInMiniChart
    } = _a, seriesOptions = __objRest(_a, [
      "type",
      "data",
      "errorBar",
      "listeners",
      "seriesGrouping",
      "showInMiniChart"
    ]);
    target.properties.set(seriesOptions);
    if ("data" in options) {
      target.data = options.data;
    }
    if ("errorBar" in options && moduleMap.isModuleEnabled("errorBar")) {
      moduleMap.getModule("errorBar").properties.set(options.errorBar);
    }
    if (options == null ? void 0 : options.listeners) {
      this.registerListeners(target, options.listeners);
    }
    if (seriesGrouping) {
      target.seriesGrouping = __spreadValues(__spreadValues({}, target.seriesGrouping), seriesGrouping);
    }
  }
  createAxis(options, skip) {
    const guesser = new AxisPositionGuesser();
    const moduleContext = this.getModuleContext();
    let index = 0;
    for (const axisOptions of options != null ? options : []) {
      const axis = getAxis(axisOptions.type, moduleContext);
      const path = `axes[${index++}]`;
      this.applyAxisModules(axis, axisOptions);
      this.applyOptionValues(axis, axisOptions, { path, skip });
      guesser.push(axis, axisOptions);
    }
    return guesser.guessInvalidPositions();
  }
  applyAxisModules(axis, options) {
    let modulesChanged = false;
    const rootModules = REGISTERED_MODULES.filter((m) => m.type === "axis-option");
    const moduleContext = axis.createModuleContext();
    for (const module of rootModules) {
      const shouldBeEnabled = options[module.optionsKey] != null;
      const moduleMap = axis.getModuleMap();
      const isEnabled = moduleMap.isModuleEnabled(module);
      if (shouldBeEnabled === isEnabled)
        continue;
      modulesChanged = true;
      if (shouldBeEnabled) {
        moduleMap.addModule(module, (module2) => new module2.instanceConstructor(moduleContext));
        axis[module.optionsKey] = moduleMap.getModule(module);
      } else {
        moduleMap.removeModule(module);
        delete axis[module.optionsKey];
      }
    }
    return modulesChanged;
  }
  applyOptionValues(target, options, { skip, path } = {}) {
    const moduleContext = this.getModuleContext();
    class CaptionWithContext extends Caption {
      constructor() {
        super();
        this.registerInteraction(moduleContext);
      }
    }
    return jsonApply(target, options, {
      constructors: __spreadProps(__spreadValues({}, JSON_APPLY_OPTIONS.constructors), {
        title: CaptionWithContext,
        subtitle: CaptionWithContext,
        footnote: CaptionWithContext
      }),
      constructedArrays: JSON_APPLY_PLUGINS.constructedArrays,
      allowedTypes: __spreadValues({}, JSON_APPLY_OPTIONS.allowedTypes),
      skip,
      path
    });
  }
  registerListeners(source, listeners) {
    source.clearEventListeners();
    for (const [property, listener] of Object.entries(listeners)) {
      if (isFunction(listener)) {
        source.addEventListener(property, listener);
      }
    }
  }
};
_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();
_Chart.NodeValueChangeOptions = {
  newValue(value) {
    var _a;
    (_a = this.scene.root) == null ? void 0 : _a.appendChild(value.node);
  },
  oldValue(oldValue) {
    var _a;
    (_a = this.scene.root) == null ? void 0 : _a.removeChild(oldValue.node);
  }
};
__decorateClass([
  ActionOnSet({
    newValue(value) {
      if (this.destroyed)
        return;
      value.setAttribute("data-ag-charts", "");
      value.appendChild(this.element);
      _Chart.chartsInstances.set(value, this);
    },
    oldValue(value) {
      value.removeAttribute("data-ag-charts");
      value.removeChild(this.element);
      _Chart.chartsInstances.delete(value);
    }
  })
], _Chart.prototype, "container", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize(value, void 0, "width option");
    }
  })
], _Chart.prototype, "width", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize(void 0, value, "height option");
    }
  })
], _Chart.prototype, "height", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.onAutoSizeChange(value);
    }
  }),
  Validate(BOOLEAN)
], _Chart.prototype, "autoSize", 2);
__decorateClass([
  Validate(OBJECT)
], _Chart.prototype, "padding", 2);
__decorateClass([
  Validate(OBJECT)
], _Chart.prototype, "seriesArea", 2);
__decorateClass([
  ActionOnSet(_Chart.NodeValueChangeOptions)
], _Chart.prototype, "title", 2);
__decorateClass([
  ActionOnSet(_Chart.NodeValueChangeOptions)
], _Chart.prototype, "subtitle", 2);
__decorateClass([
  ActionOnSet(_Chart.NodeValueChangeOptions)
], _Chart.prototype, "footnote", 2);
__decorateClass([
  Validate(UNION(["standalone", "integrated"], "a chart mode"))
], _Chart.prototype, "mode", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue = []) {
      for (const axis of oldValue) {
        if (newValue.includes(axis))
          continue;
        axis.detachAxis(this.axisGroup, this.axisGridGroup);
        axis.destroy();
      }
      for (const axis of newValue) {
        if (oldValue == null ? void 0 : oldValue.includes(axis))
          continue;
        axis.attachAxis(this.axisGroup, this.axisGridGroup);
      }
      this.zoomManager.updateAxes(newValue);
    }
  })
], _Chart.prototype, "axes", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue) {
      this.onSeriesChange(newValue, oldValue);
    }
  })
], _Chart.prototype, "series", 2);
var Chart = _Chart;

// packages/ag-charts-community/src/chart/series/dataModelSeries.ts
var DataModelSeries = class extends Series {
  isContinuous() {
    var _a, _b;
    const isContinuousX = ContinuousScale.is((_a = this.axes["x" /* X */]) == null ? void 0 : _a.scale);
    const isContinuousY = ContinuousScale.is((_b = this.axes["y" /* Y */]) == null ? void 0 : _b.scale);
    return { isContinuousX, isContinuousY };
  }
  getModulePropertyDefinitions() {
    return this.moduleMap.mapValues((mod2) => mod2.getPropertyDefinitions(this.isContinuous())).flat();
  }
  // Request data, but with message dispatching to series-options (modules).
  requestDataModel(dataController, data, opts) {
    return __async(this, null, function* () {
      opts.props.push(...this.getModulePropertyDefinitions());
      const { dataModel, processedData } = yield dataController.request(this.id, data != null ? data : [], opts);
      this.dataModel = dataModel;
      this.processedData = processedData;
      this.dispatch("data-processed", { dataModel, processedData });
      return { dataModel, processedData };
    });
  }
  isProcessedDataAnimatable() {
    var _a, _b;
    const validationResults = (_b = (_a = this.processedData) == null ? void 0 : _a.reduced) == null ? void 0 : _b.animationValidation;
    if (!validationResults) {
      return true;
    }
    const { orderedKeys, uniqueKeys } = validationResults;
    return orderedKeys && uniqueKeys;
  }
  checkProcessedDataAnimatable() {
    if (!this.isProcessedDataAnimatable()) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
};

// packages/ag-charts-community/src/chart/series/seriesProperties.ts
var SeriesItemHighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fill = "rgba(255,255,255, 0.33)";
    this.stroke = `rgba(0, 0, 0, 0.4)`;
    this.strokeWidth = 2;
  }
};
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], SeriesItemHighlightStyle.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], SeriesItemHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], SeriesItemHighlightStyle.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], SeriesItemHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], SeriesItemHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH, { optional: true })
], SeriesItemHighlightStyle.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], SeriesItemHighlightStyle.prototype, "lineDashOffset", 2);
var SeriesHighlightStyle = class extends BaseProperties {
};
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], SeriesHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], SeriesHighlightStyle.prototype, "dimOpacity", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], SeriesHighlightStyle.prototype, "enabled", 2);
var TextHighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
  }
};
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], TextHighlightStyle.prototype, "color", 2);
var HighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.item = new SeriesItemHighlightStyle();
    this.series = new SeriesHighlightStyle();
    this.text = new TextHighlightStyle();
  }
};
__decorateClass([
  Validate(OBJECT)
], HighlightStyle.prototype, "item", 2);
__decorateClass([
  Validate(OBJECT)
], HighlightStyle.prototype, "series", 2);
__decorateClass([
  Validate(OBJECT)
], HighlightStyle.prototype, "text", 2);
var SeriesProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.visible = true;
    this.showInLegend = true;
    this.cursor = "default";
    this.nodeClickRange = "exact";
    this.highlightStyle = new HighlightStyle();
  }
};
__decorateClass([
  Validate(STRING, { optional: true })
], SeriesProperties.prototype, "id", 2);
__decorateClass([
  Validate(BOOLEAN)
], SeriesProperties.prototype, "visible", 2);
__decorateClass([
  Validate(BOOLEAN)
], SeriesProperties.prototype, "showInLegend", 2);
__decorateClass([
  Validate(STRING)
], SeriesProperties.prototype, "cursor", 2);
__decorateClass([
  Validate(INTERACTION_RANGE)
], SeriesProperties.prototype, "nodeClickRange", 2);
__decorateClass([
  Validate(OBJECT)
], SeriesProperties.prototype, "highlightStyle", 2);

// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts
var DEFAULT_DIRECTION_KEYS = {
  ["x" /* X */]: ["xKey"],
  ["y" /* Y */]: ["yKey"]
};
var DEFAULT_DIRECTION_NAMES = {
  ["x" /* X */]: ["xName"],
  ["y" /* Y */]: ["yName"]
};
var CartesianSeriesNodeClickEvent = class extends SeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yKey = series.properties.yKey;
  }
};
var CartesianSeriesProperties = class extends SeriesProperties {
};
__decorateClass([
  Validate(STRING, { optional: true })
], CartesianSeriesProperties.prototype, "legendItemName", 2);
var CartesianSeries = class extends DataModelSeries {
  constructor(_a) {
    var _b = _a, {
      pathsPerSeries = 1,
      hasMarkers = false,
      hasHighlightedLabels = false,
      pathsZIndexSubOrderOffset = [],
      directionKeys = DEFAULT_DIRECTION_KEYS,
      directionNames = DEFAULT_DIRECTION_NAMES,
      datumSelectionGarbageCollection = true,
      markerSelectionGarbageCollection = true,
      animationAlwaysUpdateSelections = false,
      animationResetFns
    } = _b, otherOpts = __objRest(_b, [
      "pathsPerSeries",
      "hasMarkers",
      "hasHighlightedLabels",
      "pathsZIndexSubOrderOffset",
      "directionKeys",
      "directionNames",
      "datumSelectionGarbageCollection",
      "markerSelectionGarbageCollection",
      "animationAlwaysUpdateSelections",
      "animationResetFns"
    ]);
    super(__spreadValues({
      directionKeys,
      directionNames,
      useSeriesGroupLayer: true,
      canHaveAxes: true
    }, otherOpts));
    this._contextNodeData = [];
    this.NodeClickEvent = CartesianSeriesNodeClickEvent;
    this.highlightSelection = Selection.select(
      this.highlightNode,
      () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory()
    );
    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);
    this.annotationSelections = /* @__PURE__ */ new Set();
    this.subGroups = [];
    this.subGroupId = 0;
    this.debug = Debug.create();
    this.opts = {
      pathsPerSeries,
      hasMarkers,
      hasHighlightedLabels,
      pathsZIndexSubOrderOffset,
      directionKeys,
      directionNames,
      animationResetFns,
      animationAlwaysUpdateSelections,
      datumSelectionGarbageCollection,
      markerSelectionGarbageCollection
    };
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => this.animateWaitingUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  get contextNodeData() {
    return this._contextNodeData.slice();
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.chartEventManager.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  destroy() {
    super.destroy();
    this._contextNodeData.splice(0, this._contextNodeData.length);
    this.subGroups.splice(0, this.subGroups.length);
  }
  update(_0) {
    return __async(this, arguments, function* ({ seriesRect }) {
      var _a, _b;
      const { visible, _contextNodeData: previousContextData } = this;
      const { series } = (_b = (_a = this.ctx.highlightManager) == null ? void 0 : _a.getActiveHighlight()) != null ? _b : {};
      const seriesHighlighted = series ? series === this : void 0;
      const resize = this.checkResize(seriesRect);
      const highlightItems = yield this.updateHighlightSelection(seriesHighlighted);
      yield this.updateSelections(visible);
      yield this.updateNodes(highlightItems, seriesHighlighted, visible);
      const animationData = this.getAnimationData(seriesRect, previousContextData);
      if (resize) {
        this.animationState.transition("resize", animationData);
      }
      this.animationState.transition("update", animationData);
    });
  }
  updateSelections(anySeriesItemEnabled) {
    return __async(this, null, function* () {
      const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();
      if (!anySeriesItemEnabled && animationSkipUpdate) {
        return;
      }
      if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {
        return;
      }
      if (this.nodeDataRefresh) {
        this.nodeDataRefresh = false;
        this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);
        this._contextNodeData = yield this.createNodeData();
        const animationValid = this.isProcessedDataAnimatable();
        this._contextNodeData.forEach((nodeData) => {
          var _a;
          (_a = nodeData.animationValid) != null ? _a : nodeData.animationValid = animationValid;
        });
        yield this.updateSeriesGroups();
        const { dataModel, processedData } = this;
        if (dataModel !== void 0 && processedData !== void 0) {
          this.dispatch("data-update", { dataModel, processedData });
        }
      }
      yield Promise.all(this.subGroups.map((g, i) => this.updateSeriesGroupSelections(g, i)));
    });
  }
  updateSeriesGroupSelections(subGroup, seriesIdx, seriesHighlighted) {
    return __async(this, null, function* () {
      const { datumSelection, labelSelection, markerSelection, paths } = subGroup;
      const contextData = this._contextNodeData[seriesIdx];
      const { nodeData, labelData, itemId } = contextData;
      yield this.updatePaths({ seriesHighlighted, itemId, contextData, paths, seriesIdx });
      subGroup.datumSelection = yield this.updateDatumSelection({ nodeData, datumSelection, seriesIdx });
      subGroup.labelSelection = yield this.updateLabelSelection({ labelData, labelSelection, seriesIdx });
      if (markerSelection) {
        subGroup.markerSelection = yield this.updateMarkerSelection({ nodeData, markerSelection, seriesIdx });
      }
    });
  }
  markerFactory() {
    const MarkerShape = getMarker();
    return new MarkerShape();
  }
  updateSeriesGroups() {
    return __async(this, null, function* () {
      const {
        _contextNodeData: contextNodeData,
        contentGroup,
        subGroups,
        opts: { pathsPerSeries, hasMarkers, datumSelectionGarbageCollection, markerSelectionGarbageCollection }
      } = this;
      if (contextNodeData.length === subGroups.length) {
        return;
      }
      if (contextNodeData.length < subGroups.length) {
        subGroups.splice(contextNodeData.length).forEach(({ dataNodeGroup, markerGroup, labelGroup, paths }) => {
          contentGroup.removeChild(dataNodeGroup);
          if (markerGroup) {
            contentGroup.removeChild(markerGroup);
          }
          if (labelGroup) {
            contentGroup.removeChild(labelGroup);
          }
          for (const path of paths) {
            contentGroup.removeChild(path);
          }
        });
      }
      const totalGroups = contextNodeData.length;
      while (totalGroups > subGroups.length) {
        const layer = false;
        const subGroupId = this.subGroupId++;
        const dataNodeGroup = new Group({
          name: `${this.id}-series-sub${subGroupId}-dataNodes`,
          layer,
          zIndex: 4 /* SERIES_LAYER_ZINDEX */,
          zIndexSubOrder: this.getGroupZIndexSubOrder("data", subGroupId)
        });
        const markerGroup = hasMarkers ? new Group({
          name: `${this.id}-series-sub${this.subGroupId++}-markers`,
          layer,
          zIndex: 4 /* SERIES_LAYER_ZINDEX */,
          zIndexSubOrder: this.getGroupZIndexSubOrder("marker", subGroupId)
        }) : void 0;
        const labelGroup = new Group({
          name: `${this.id}-series-sub${this.subGroupId++}-labels`,
          layer,
          zIndex: 7 /* SERIES_LABEL_ZINDEX */,
          zIndexSubOrder: this.getGroupZIndexSubOrder("labels", subGroupId)
        });
        contentGroup.appendChild(dataNodeGroup);
        contentGroup.appendChild(labelGroup);
        if (markerGroup) {
          contentGroup.appendChild(markerGroup);
        }
        const paths = [];
        for (let index = 0; index < pathsPerSeries; index++) {
          paths[index] = new Path();
          paths[index].zIndex = 4 /* SERIES_LAYER_ZINDEX */;
          paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder("paths", index);
          contentGroup.appendChild(paths[index]);
        }
        subGroups.push({
          paths,
          dataNodeGroup,
          markerGroup,
          labelGroup,
          labelSelection: Selection.select(labelGroup, Text),
          datumSelection: Selection.select(
            dataNodeGroup,
            () => this.nodeFactory(),
            datumSelectionGarbageCollection
          ),
          markerSelection: markerGroup ? Selection.select(markerGroup, () => this.markerFactory(), markerSelectionGarbageCollection) : void 0
        });
      }
    });
  }
  getGroupZIndexSubOrder(type, subIndex = 0) {
    var _a;
    const result = super.getGroupZIndexSubOrder(type, subIndex);
    if (type === "paths") {
      const pathOffset = (_a = this.opts.pathsZIndexSubOrderOffset[subIndex]) != null ? _a : 0;
      const superFn = result[0];
      if (typeof superFn === "function") {
        result[0] = () => +superFn() + pathOffset;
      } else {
        result[0] = +superFn + pathOffset;
      }
    }
    return result;
  }
  updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {
    return __async(this, null, function* () {
      var _a;
      const {
        highlightSelection,
        highlightLabelSelection,
        opts: { hasMarkers, hasHighlightedLabels }
      } = this;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const visible = this.visible && ((_a = this._contextNodeData) == null ? void 0 : _a.length) > 0 && anySeriesItemEnabled;
      this.rootGroup.visible = animationEnabled || visible;
      this.contentGroup.visible = animationEnabled || visible;
      this.highlightGroup.visible = (animationEnabled || visible) && !!seriesHighlighted;
      const subGroupOpacity = this.getOpacity();
      if (hasMarkers) {
        yield this.updateMarkerNodes({
          markerSelection: highlightSelection,
          isHighlight: true,
          seriesIdx: -1
        });
        this.animationState.transition("highlightMarkers", highlightSelection);
      } else {
        yield this.updateDatumNodes({
          datumSelection: highlightSelection,
          isHighlight: true,
          seriesIdx: -1
        });
        this.animationState.transition("highlight", highlightSelection);
      }
      if (hasHighlightedLabels) {
        yield this.updateLabelNodes({ labelSelection: highlightLabelSelection, seriesIdx: -1 });
      }
      yield Promise.all(
        this.subGroups.map((subGroup, seriesIdx) => __async(this, null, function* () {
          const {
            dataNodeGroup,
            markerGroup,
            datumSelection,
            labelSelection,
            markerSelection,
            paths,
            labelGroup
          } = subGroup;
          const { itemId } = this.contextNodeData[seriesIdx];
          const subGroupVisible = visible;
          dataNodeGroup.opacity = subGroupOpacity;
          dataNodeGroup.visible = animationEnabled || subGroupVisible;
          labelGroup.visible = subGroupVisible;
          if (markerGroup) {
            markerGroup.opacity = subGroupOpacity;
            markerGroup.zIndex = dataNodeGroup.zIndex >= 4 /* SERIES_LAYER_ZINDEX */ ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;
            markerGroup.visible = subGroupVisible;
          }
          if (labelGroup) {
            labelGroup.opacity = subGroupOpacity;
          }
          yield this.updatePathNodes({
            seriesHighlighted,
            itemId,
            paths,
            seriesIdx,
            opacity: subGroupOpacity,
            visible: subGroupVisible,
            animationEnabled
          });
          if (!dataNodeGroup.visible) {
            return;
          }
          yield this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false, seriesIdx });
          yield this.updateLabelNodes({ labelSelection, seriesIdx });
          if (hasMarkers && markerSelection) {
            yield this.updateMarkerNodes({ markerSelection, isHighlight: false, seriesIdx });
          }
        }))
      );
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter(
      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId
    );
    return labelItems.length !== 0 ? labelItems : void 0;
  }
  getHighlightData(_nodeData, highlightedItem) {
    return highlightedItem ? [highlightedItem] : void 0;
  }
  updateHighlightSelection(seriesHighlighted) {
    return __async(this, null, function* () {
      var _a;
      const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;
      const highlightedDatum = (_a = this.ctx.highlightManager) == null ? void 0 : _a.getActiveHighlight();
      const item = seriesHighlighted && (highlightedDatum == null ? void 0 : highlightedDatum.datum) ? highlightedDatum : void 0;
      let labelItems;
      let highlightItems;
      if (item != null) {
        const labelsEnabled = this.isLabelEnabled();
        for (const { labelData, nodeData } of contextNodeData) {
          highlightItems = this.getHighlightData(nodeData, item);
          labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;
          if ((!labelsEnabled || labelItems != null) && highlightItems != null) {
            break;
          }
        }
      }
      this.highlightSelection = yield this.updateHighlightSelectionItem({
        items: highlightItems,
        highlightSelection
      });
      this.highlightLabelSelection = yield this.updateHighlightSelectionLabel({
        items: labelItems,
        highlightLabelSelection
      });
      return highlightItems;
    });
  }
  pickNodeExactShape(point) {
    var _a;
    const result = super.pickNodeExactShape(point);
    if (result) {
      return result;
    }
    const { x, y } = point;
    const {
      opts: { hasMarkers }
    } = this;
    for (const { dataNodeGroup, markerGroup } of this.subGroups) {
      let match2 = dataNodeGroup.pickNode(x, y);
      if (!match2 && hasMarkers) {
        match2 = markerGroup == null ? void 0 : markerGroup.pickNode(x, y);
      }
      if (match2) {
        break;
      }
    }
    {
      for (const mod2 of this.moduleMap.modules) {
        const { datum } = (_a = mod2.pickNodeExact(point)) != null ? _a : {};
        if (datum !== void 0) {
          return { datum, distance: 0 };
        }
      }
    }
  }
  pickNodeClosestDatum(point) {
    var _a, _b;
    const { x, y } = point;
    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const hitPoint = rootGroup.transformPoint(x, y);
    let minDistance = Infinity;
    let closestDatum;
    for (const context of contextNodeData) {
      for (const datum of context.nodeData) {
        const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
        if (isNaN(datumX) || isNaN(datumY)) {
          continue;
        }
        const isInRange = (xAxis == null ? void 0 : xAxis.inRange(datumX)) && (yAxis == null ? void 0 : yAxis.inRange(datumY));
        if (!isInRange) {
          continue;
        }
        const distance2 = Math.max(__pow(hitPoint.x - datumX, 2) + __pow(hitPoint.y - datumY, 2), 0);
        if (distance2 < minDistance) {
          minDistance = distance2;
          closestDatum = datum;
        }
      }
    }
    for (const mod2 of this.moduleMap.modules) {
      const modPick = mod2.pickNodeNearest(point);
      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {
        minDistance = modPick.distanceSquared;
        closestDatum = modPick.datum;
        break;
      }
    }
    if (closestDatum) {
      const distance2 = Math.max(Math.sqrt(minDistance) - ((_b = (_a = closestDatum.point) == null ? void 0 : _a.size) != null ? _b : 0), 0);
      return { datum: closestDatum, distance: distance2 };
    }
  }
  pickNodeMainAxisFirst(point, requireCategoryAxis) {
    var _a, _b;
    const { x, y } = point;
    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const directions2 = [xAxis, yAxis].filter((a) => a instanceof CategoryAxis).map((a) => a.direction);
    if (requireCategoryAxis && directions2.length === 0) {
      return;
    }
    const [primaryDirection = "x" /* X */] = directions2;
    const hitPoint = rootGroup.transformPoint(x, y);
    const hitPointCoords = primaryDirection === "x" /* X */ ? [hitPoint.x, hitPoint.y] : [hitPoint.y, hitPoint.x];
    const minDistance = [Infinity, Infinity];
    let closestDatum;
    for (const context of contextNodeData) {
      for (const datum of context.nodeData) {
        const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
        if (isNaN(datumX) || isNaN(datumY)) {
          continue;
        }
        const isInRange = (xAxis == null ? void 0 : xAxis.inRange(datumX)) && (yAxis == null ? void 0 : yAxis.inRange(datumY));
        if (!isInRange) {
          continue;
        }
        const point2 = primaryDirection === "x" /* X */ ? [datumX, datumY] : [datumY, datumX];
        let newMinDistance = true;
        for (let i = 0; i < point2.length; i++) {
          const dist = Math.abs(point2[i] - hitPointCoords[i]);
          if (dist > minDistance[i]) {
            newMinDistance = false;
            break;
          }
          if (dist < minDistance[i]) {
            minDistance[i] = dist;
            minDistance.fill(Infinity, i + 1, minDistance.length);
          }
        }
        if (newMinDistance) {
          closestDatum = datum;
        }
      }
    }
    if (closestDatum) {
      let closestDistanceSquared = Math.max(
        __pow(minDistance[0], 2) + __pow(minDistance[1], 2) - ((_b = (_a = closestDatum.point) == null ? void 0 : _a.size) != null ? _b : 0),
        0
      );
      for (const mod2 of this.moduleMap.modules) {
        const modPick = mod2.pickNodeMainAxisFirst(point);
        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {
          closestDatum = modPick.datum;
          closestDistanceSquared = modPick.distanceSquared;
          break;
        }
      }
      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };
    }
  }
  onLegendItemClick(event) {
    const { legendItemName } = this.properties;
    const { enabled, itemId, series } = event;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const { legendItemName } = this.properties;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, true);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(itemId, true);
    } else {
      this.toggleSeriesItem(itemId, false);
    }
  }
  isPathOrSelectionDirty() {
    return false;
  }
  getLabelData() {
    return [];
  }
  shouldFlipXY() {
    return false;
  }
  /**
   * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this
   * may not represent the same two points for both directions. The dimensions represent the greatest distance
   * between any two adjacent nodes.
   */
  getMinRect() {
    const [context] = this._contextNodeData;
    if (!(context == null ? void 0 : context.nodeData.length)) {
      return;
    }
    const width = context.nodeData.map(({ midPoint }) => {
      var _a;
      return (_a = midPoint == null ? void 0 : midPoint.x) != null ? _a : 0;
    }).sort((a, b) => a - b).reduce((max, x, i, array) => i > 0 ? Math.max(max, x - array[i - 1]) : max, 0);
    const height = context.nodeData.map(({ midPoint }) => {
      var _a;
      return (_a = midPoint == null ? void 0 : midPoint.y) != null ? _a : 0;
    }).sort((a, b) => a - b).reduce((max, y, i, array) => i > 0 ? Math.max(max, y - array[i - 1]) : max, 0);
    return new BBox(0, 0, width, height);
  }
  updateHighlightSelectionItem(opts) {
    return __async(this, null, function* () {
      const {
        opts: { hasMarkers }
      } = this;
      const { items, highlightSelection } = opts;
      const nodeData = items != null ? items : [];
      if (hasMarkers) {
        const markerSelection = highlightSelection;
        return this.updateMarkerSelection({ nodeData, markerSelection, seriesIdx: -1 });
      } else {
        return this.updateDatumSelection({
          nodeData,
          datumSelection: highlightSelection,
          seriesIdx: -1
        });
      }
    });
  }
  updateHighlightSelectionLabel(opts) {
    return __async(this, null, function* () {
      var _a;
      return this.updateLabelSelection({
        labelData: (_a = opts.items) != null ? _a : [],
        labelSelection: opts.highlightLabelSelection,
        seriesIdx: -1
      });
    });
  }
  updateDatumSelection(opts) {
    return __async(this, null, function* () {
      return opts.datumSelection;
    });
  }
  updateDatumNodes(_opts) {
    return __async(this, null, function* () {
    });
  }
  updateMarkerSelection(opts) {
    return __async(this, null, function* () {
      return opts.markerSelection;
    });
  }
  updateMarkerNodes(_opts) {
    return __async(this, null, function* () {
    });
  }
  updatePaths(opts) {
    return __async(this, null, function* () {
      opts.paths.forEach((p) => p.visible = false);
    });
  }
  updatePathNodes(opts) {
    return __async(this, null, function* () {
      const { paths, opacity, visible } = opts;
      for (const path of paths) {
        path.opacity = opacity;
        path.visible = visible;
      }
    });
  }
  resetAllAnimation(data) {
    var _a, _b;
    const { path, datum, label, marker } = (_b = (_a = this.opts) == null ? void 0 : _a.animationResetFns) != null ? _b : {};
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    if (path) {
      data.paths.forEach((paths) => {
        resetMotion(paths, path);
      });
    }
    if (datum) {
      resetMotion(data.datumSelections, datum);
    }
    if (label) {
      resetMotion(data.labelSelections, label);
    }
    if (marker) {
      resetMotion(data.markerSelections, marker);
    }
    if (data.contextData.some((d) => d.animationValid === false)) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  animateEmptyUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateWaitingUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateReadyHighlight(data) {
    var _a, _b;
    const { datum } = (_b = (_a = this.opts) == null ? void 0 : _a.animationResetFns) != null ? _b : {};
    if (datum) {
      resetMotion([data], datum);
    }
  }
  animateReadyHighlightMarkers(data) {
    var _a, _b;
    const { marker } = (_b = (_a = this.opts) == null ? void 0 : _a.animationResetFns) != null ? _b : {};
    if (marker) {
      resetMotion([data], marker);
    }
  }
  animateReadyResize(data) {
    this.resetAllAnimation(data);
  }
  animateClearingUpdateEmpty(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animationTransitionClear() {
    this.animationState.transition("clear", this.getAnimationData());
  }
  getAnimationData(seriesRect, previousContextData) {
    const animationData = {
      datumSelections: this.subGroups.map(({ datumSelection }) => datumSelection),
      markerSelections: this.subGroups.filter(({ markerSelection }) => markerSelection !== void 0).map(({ markerSelection }) => markerSelection),
      labelSelections: this.subGroups.map(({ labelSelection }) => labelSelection),
      annotationSelections: [...this.annotationSelections],
      contextData: this._contextNodeData,
      previousContextData,
      paths: this.subGroups.map(({ paths }) => paths),
      seriesRect
    };
    return animationData;
  }
  calculateScaling() {
    const result = {};
    const addScale = (direction) => {
      const axis = this.axes[direction];
      if (!axis)
        return;
      if (axis.scale instanceof LogScale) {
        const { range: range3, domain } = axis.scale;
        result[direction] = {
          type: "log",
          convert: (domain2) => axis.scale.convert(domain2),
          domain: [domain[0], domain[1]],
          range: [range3[0], range3[1]]
        };
      } else if (axis.scale instanceof ContinuousScale) {
        const { range: range3 } = axis.scale;
        const domain = axis.scale.getDomain();
        result[direction] = {
          type: "continuous",
          domain: [domain[0], domain[1]],
          range: [range3[0], range3[1]]
        };
      } else if (axis.scale) {
        const { domain } = axis.scale;
        result[direction] = {
          type: "category",
          domain,
          range: domain.map((d) => axis.scale.convert(d))
        };
      }
    };
    addScale("x" /* X */);
    addScale("y" /* Y */);
    return result;
  }
};

// packages/ag-charts-community/src/chart/cartesianChart.ts
var directions = ["top", "right", "bottom", "left"];
var _CartesianChart = class _CartesianChart extends Chart {
  constructor(options, resources) {
    super(options, resources);
    /** Integrated Charts feature state - not used in Standalone Charts. */
    this.paired = true;
    this.firstSeriesTranslation = true;
    this._lastCrossLineIds = void 0;
    this._lastAxisWidths = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    this._lastVisibility = {
      crossLines: true,
      series: true
    };
  }
  destroySeries(series) {
    super.destroySeries(series);
    this.firstSeriesTranslation = true;
  }
  performLayout() {
    return __async(this, null, function* () {
      const shrinkRect = yield __superGet(_CartesianChart.prototype, this, "performLayout").call(this);
      const { firstSeriesTranslation, seriesRoot } = this;
      const { animationRect, seriesRect, visibility, clipSeries } = this.updateAxes(shrinkRect);
      this.seriesRoot.visible = visibility.series;
      this.seriesRect = seriesRect;
      this.animationRect = animationRect;
      const { x, y } = seriesRect;
      if (firstSeriesTranslation) {
        seriesRoot.translationX = Math.floor(x);
        seriesRoot.translationY = Math.floor(y);
        this.firstSeriesTranslation = false;
      } else {
        const { translationX, translationY } = seriesRoot;
        staticFromToMotion(
          this.id,
          "seriesRect",
          this.animationManager,
          [this.seriesRoot],
          { translationX, translationY },
          { translationX: Math.floor(x), translationY: Math.floor(y) },
          { phase: "update" }
        );
      }
      const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);
      this.hoverRect = seriesPaddedRect;
      this.layoutService.dispatchLayoutComplete({
        type: "layout-complete",
        chart: { width: this.scene.width, height: this.scene.height },
        clipSeries,
        series: {
          rect: seriesRect,
          paddedRect: seriesPaddedRect,
          visible: visibility.series,
          shouldFlipXY: this.shouldFlipXY()
        },
        axes: this.axes.map((axis) => __spreadValues({ id: axis.id }, axis.getLayoutState()))
      });
      const modulePromises = Array.from(this.modules.values(), (m) => {
        var _a;
        return (_a = m.performCartesianLayout) == null ? void 0 : _a.call(m, { seriesRect });
      });
      yield Promise.all(modulePromises);
      return shrinkRect;
    });
  }
  updateAxes(inputShrinkRect) {
    var _a;
    const crossLineIds = this.axes.flatMap((axis) => {
      var _a2;
      return (_a2 = axis.crossLines) != null ? _a2 : [];
    }).map((crossLine) => crossLine.id);
    const axesValid = this._lastCrossLineIds != null && this._lastCrossLineIds.length === crossLineIds.length && this._lastCrossLineIds.every((id, index) => crossLineIds[index] === id);
    let axisWidths;
    let visibility;
    if (axesValid) {
      axisWidths = __spreadValues({}, this._lastAxisWidths);
      visibility = __spreadValues({}, this._lastVisibility);
    } else {
      axisWidths = { top: 0, bottom: 0, left: 0, right: 0 };
      visibility = { crossLines: true, series: true };
      this._lastCrossLineIds = crossLineIds;
    }
    const liveAxisWidths = new Set(this.axes.map((a) => a.position));
    for (const position of Object.keys(axisWidths)) {
      if (!liveAxisWidths.has(position)) {
        delete axisWidths[position];
      }
    }
    const stableOutputs = (otherAxisWidths, otherVisibility) => {
      if (Object.keys(otherAxisWidths).some((k) => axisWidths[k] == null)) {
        return false;
      }
      return visibility.crossLines === otherVisibility.crossLines && visibility.series === otherVisibility.series && // Check for existing axis positions and equality.
      Object.entries(axisWidths).every(([p, w]) => {
        const otherW = otherAxisWidths[p];
        if (w != null || otherW != null) {
          return w === otherW;
        }
        return true;
      });
    };
    const ceilValues = (records) => mapValues(records, (value) => {
      if (value && Math.abs(value) === Infinity) {
        return 0;
      }
      return value != null ? Math.ceil(value) : value;
    });
    let lastPassAxisWidths = {};
    let lastPassVisibility = {};
    let clipSeries = false;
    let seriesRect = (_a = this.seriesRect) == null ? void 0 : _a.clone();
    let count2 = 0;
    let primaryTickCounts = {};
    do {
      Object.assign(axisWidths, lastPassAxisWidths);
      Object.assign(visibility, lastPassVisibility);
      const result = this.updateAxesPass(axisWidths, inputShrinkRect.clone(), seriesRect);
      lastPassAxisWidths = ceilValues(result.axisWidths);
      lastPassVisibility = result.visibility;
      clipSeries = result.clipSeries;
      seriesRect = result.seriesRect;
      primaryTickCounts = result.primaryTickCounts;
      if (count2++ > 10) {
        Logger.warn("unable to find stable axis layout.");
        break;
      }
    } while (!stableOutputs(lastPassAxisWidths, lastPassVisibility));
    this.axes.forEach((axis) => {
      axis.update(primaryTickCounts[axis.direction]);
    });
    const clipRectPadding = 5;
    this.axes.forEach((axis) => {
      axis.setCrossLinesVisible(visibility.crossLines);
      if (!seriesRect) {
        return;
      }
      axis.clipGrid(
        seriesRect.x,
        seriesRect.y,
        seriesRect.width + clipRectPadding,
        seriesRect.height + clipRectPadding
      );
      switch (axis.position) {
        case "left":
        case "right":
          axis.clipTickLines(
            inputShrinkRect.x,
            seriesRect.y,
            inputShrinkRect.width + clipRectPadding,
            seriesRect.height + clipRectPadding
          );
          break;
        case "top":
        case "bottom":
          axis.clipTickLines(
            seriesRect.x,
            inputShrinkRect.y,
            seriesRect.width + clipRectPadding,
            inputShrinkRect.height + clipRectPadding
          );
          break;
      }
    });
    this._lastAxisWidths = axisWidths;
    this._lastVisibility = visibility;
    return { seriesRect, animationRect: inputShrinkRect, visibility, clipSeries };
  }
  updateAxesPass(axisWidths, bounds, lastPassSeriesRect) {
    const visited = {};
    const newAxisWidths = {};
    const visibility = {
      series: true,
      crossLines: true
    };
    let clipSeries = false;
    const primaryTickCounts = {};
    const paddedBounds = this.applySeriesPadding(bounds);
    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisWidths) : {};
    const axisBound = this.buildAxisBound(paddedBounds, axisWidths, crossLinePadding, visibility);
    const seriesRect = this.buildSeriesRect(axisBound, axisWidths);
    this.axes.forEach((axis) => {
      var _a, _b;
      const { position = "left" } = axis;
      const {
        clipSeries: newClipSeries,
        axisThickness,
        axisOffset
      } = this.calculateAxisDimensions({
        axis,
        seriesRect,
        paddedBounds,
        axisWidths,
        newAxisWidths,
        primaryTickCounts,
        clipSeries,
        addInterAxisPadding: ((_a = visited[position]) != null ? _a : 0) > 0
      });
      visited[position] = ((_b = visited[position]) != null ? _b : 0) + 1;
      clipSeries = clipSeries || newClipSeries;
      this.positionAxis({
        axis,
        axisBound,
        axisOffset,
        axisThickness,
        axisWidths,
        primaryTickCounts,
        seriesRect
      });
    });
    return { clipSeries, seriesRect, axisWidths: newAxisWidths, visibility, primaryTickCounts };
  }
  buildCrossLinePadding(axisWidths) {
    var _a;
    const crossLinePadding = {};
    this.axes.forEach((axis) => {
      if (axis.crossLines) {
        axis.crossLines.forEach((crossLine) => {
          crossLine.calculatePadding(crossLinePadding);
        });
      }
    });
    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {
      crossLinePadding[side] = Math.max(padding - ((_a = axisWidths[side]) != null ? _a : 0), 0);
    }
    return crossLinePadding;
  }
  applySeriesPadding(bounds) {
    const paddedRect = bounds.clone();
    const reversedAxes = this.axes.slice().reverse();
    directions.forEach((dir) => {
      const padding = this.seriesArea.padding[dir];
      const axis = reversedAxes.find((axis2) => axis2.position === dir);
      if (axis) {
        axis.seriesAreaPadding = padding;
      } else {
        paddedRect.shrink(padding, dir);
      }
    });
    return paddedRect;
  }
  buildAxisBound(bounds, axisWidths, crossLinePadding, visibility) {
    var _a, _b, _c, _d;
    const result = bounds.clone();
    const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;
    const horizontalPadding = left + right;
    const verticalPadding = top + bottom;
    const totalWidth = ((_a = axisWidths.left) != null ? _a : 0) + ((_b = axisWidths.right) != null ? _b : 0) + horizontalPadding;
    const totalHeight = ((_c = axisWidths.top) != null ? _c : 0) + ((_d = axisWidths.bottom) != null ? _d : 0) + verticalPadding;
    if (result.width <= totalWidth || result.height <= totalHeight) {
      visibility.crossLines = false;
      visibility.series = false;
      return result;
    }
    result.x += left;
    result.y += top;
    result.width -= horizontalPadding;
    result.height -= verticalPadding;
    return result;
  }
  buildSeriesRect(axisBound, axisWidths) {
    const result = axisBound.clone();
    const { top, bottom, left, right } = axisWidths;
    result.x += left != null ? left : 0;
    result.y += top != null ? top : 0;
    result.width -= (left != null ? left : 0) + (right != null ? right : 0);
    result.height -= (top != null ? top : 0) + (bottom != null ? bottom : 0);
    result.width = Math.max(0, result.width);
    result.height = Math.max(0, result.height);
    return result;
  }
  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {
    const { x, y, width, height } = seriesRect;
    const clampBounds = [x, y, x + width, y + height];
    const compareTo = clampBounds[(dimension === "x" ? 0 : 1) + (direction === 1 ? 0 : 2)];
    const clampFn = direction === 1 ? Math.min : Math.max;
    return clampFn(value, compareTo);
  }
  calculateAxisDimensions(opts) {
    var _a, _b, _c, _d, _e;
    const { axis, seriesRect, paddedBounds, axisWidths, newAxisWidths, primaryTickCounts, addInterAxisPadding } = opts;
    let { clipSeries } = opts;
    const { position = "left", direction } = axis;
    const axisLeftRightRange = (axis2) => {
      if (axis2 instanceof CategoryAxis || axis2 instanceof GroupedCategoryAxis) {
        return [0, seriesRect.height];
      }
      return [seriesRect.height, 0];
    };
    const axisOffset = (_a = newAxisWidths[position]) != null ? _a : 0;
    switch (position) {
      case "top":
      case "bottom":
        axis.range = [0, seriesRect.width];
        axis.gridLength = seriesRect.height;
        break;
      case "right":
      case "left":
        axis.range = axisLeftRightRange(axis);
        axis.gridLength = seriesRect.width;
        break;
    }
    const { min, max } = this.zoomManager.getAxisZoom(axis.id);
    axis.visibleRange = [min, max];
    clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);
    let primaryTickCount = axis.nice ? primaryTickCounts[direction] : void 0;
    const isVertical = direction === "y" /* Y */;
    const paddedBoundsCoefficient = 0.3;
    axis.maxThickness = axis.thickness || (isVertical ? paddedBounds.width : paddedBounds.height) * paddedBoundsCoefficient;
    const layout = axis.calculateLayout(primaryTickCount);
    primaryTickCount = layout.primaryTickCount;
    (_b = primaryTickCounts[direction]) != null ? _b : primaryTickCounts[direction] = primaryTickCount;
    let axisThickness;
    if (axis.thickness != null && axis.thickness > 0) {
      axisThickness = axis.thickness;
    } else {
      const { bbox } = layout;
      axisThickness = isVertical ? bbox.width : bbox.height;
    }
    const axisPadding = 15;
    if (addInterAxisPadding) {
      axisThickness += axisPadding;
    }
    axisThickness = Math.ceil(axisThickness);
    newAxisWidths[position] = ((_c = newAxisWidths[position]) != null ? _c : 0) + axisThickness;
    axis.gridPadding = ((_d = axisWidths[position]) != null ? _d : 0) - ((_e = newAxisWidths[position]) != null ? _e : 0);
    return { clipSeries, axisThickness, axisOffset, primaryTickCount };
  }
  positionAxis(opts) {
    var _a, _b, _c, _d;
    const { axis, axisBound, axisWidths, seriesRect, axisOffset, axisThickness } = opts;
    const { position } = axis;
    switch (position) {
      case "top":
        axis.translation.x = axisBound.x + ((_a = axisWidths.left) != null ? _a : 0);
        axis.translation.y = this.clampToOutsideSeriesRect(
          seriesRect,
          axisBound.y + 1 + axisOffset + axisThickness,
          "y",
          1
        );
        break;
      case "bottom":
        axis.translation.x = axisBound.x + ((_b = axisWidths.left) != null ? _b : 0);
        axis.translation.y = this.clampToOutsideSeriesRect(
          seriesRect,
          axisBound.y + axisBound.height + 1 - axisThickness - axisOffset,
          "y",
          -1
        );
        break;
      case "left":
        axis.translation.y = axisBound.y + ((_c = axisWidths.top) != null ? _c : 0);
        axis.translation.x = this.clampToOutsideSeriesRect(
          seriesRect,
          axisBound.x + axisOffset + axisThickness,
          "x",
          1
        );
        break;
      case "right":
        axis.translation.y = axisBound.y + ((_d = axisWidths.top) != null ? _d : 0);
        axis.translation.x = this.clampToOutsideSeriesRect(
          seriesRect,
          axisBound.x + axisBound.width - axisThickness - axisOffset,
          "x",
          -1
        );
        break;
    }
    axis.updatePosition({ rotation: toRadians(axis.rotation), sideFlag: axis.label.getSideFlag() });
  }
  shouldFlipXY() {
    return !this.series.some((series) => !(series instanceof CartesianSeries && series.shouldFlipXY()));
  }
};
_CartesianChart.className = "CartesianChart";
_CartesianChart.type = "cartesian";
var CartesianChart = _CartesianChart;

// packages/ag-charts-community/src/chart/chartProxy.ts
var _AgChartInstanceProxy = class _AgChartInstanceProxy {
  static isInstance(x) {
    var _a;
    if (x instanceof _AgChartInstanceProxy) {
      return true;
    }
    if (((_a = x.constructor) == null ? void 0 : _a.name) === "AgChartInstanceProxy" && x.chart != null) {
      return true;
    }
    return x.chart != null && this.validateImplementation(x);
  }
  static validateImplementation(x) {
    var _a;
    const chartProps = ["getOptions", "destroy"];
    const signatureProps = Object.keys((_a = Object.getPrototypeOf(x)) != null ? _a : {});
    return chartProps.every((prop) => signatureProps.includes(prop));
  }
  constructor(chart) {
    this.chart = chart;
  }
  getOptions() {
    return deepClone(this.chart.getOptions());
  }
  resetAnimations() {
    this.chart.resetAnimations();
  }
  skipAnimations() {
    this.chart.skipAnimations();
  }
  destroy() {
    this.chart.destroy();
  }
};
_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();
__decorateClass([
  ActionOnSet({
    oldValue(chart) {
      _AgChartInstanceProxy.chartInstances.delete(chart);
    },
    newValue(chart) {
      _AgChartInstanceProxy.chartInstances.set(chart, this);
    }
  })
], _AgChartInstanceProxy.prototype, "chart", 2);
var AgChartInstanceProxy = _AgChartInstanceProxy;

// packages/ag-charts-community/src/scale/linearScale.ts
var LinearScale = class extends ContinuousScale {
  constructor() {
    super([0, 1], [0, 1]);
    this.type = "linear";
  }
  toDomain(d) {
    return d;
  }
  ticks() {
    var _a;
    const count2 = (_a = this.tickCount) != null ? _a : ContinuousScale.defaultTickCount;
    if (!this.domain || this.domain.length < 2 || count2 < 1 || this.domain.some((d) => !isFinite(d))) {
      return [];
    }
    this.refresh();
    const [d0, d1] = this.getDomain();
    const { interval } = this;
    if (interval) {
      const step = Math.abs(interval);
      if (!this.isDenseInterval({ start: d0, stop: d1, interval: step })) {
        return range(d0, d1, step);
      }
    }
    return ticks_default(d0, d1, count2, this.minTickCount, this.maxTickCount);
  }
  update() {
    if (!this.domain || this.domain.length < 2) {
      return;
    }
    if (this.nice) {
      this.updateNiceDomain();
    }
  }
  getTickStep(start, stop) {
    var _a, _b;
    const count2 = (_a = this.tickCount) != null ? _a : ContinuousScale.defaultTickCount;
    return (_b = this.interval) != null ? _b : tickStep(start, stop, count2, this.minTickCount, this.maxTickCount);
  }
  /**
   * Extends the domain so that it starts and ends on nice round values.
   */
  updateNiceDomain() {
    var _a;
    const count2 = (_a = this.tickCount) != null ? _a : ContinuousScale.defaultTickCount;
    if (count2 < 1) {
      this.niceDomain = [...this.domain];
      return;
    }
    let [start, stop] = this.domain;
    if (count2 === 1) {
      [start, stop] = singleTickDomain(start, stop);
    } else {
      const roundStart = start > stop ? Math.ceil : Math.floor;
      const roundStop = stop < start ? Math.floor : Math.ceil;
      const maxAttempts = 4;
      for (let i = 0; i < maxAttempts; i++) {
        const prev0 = start;
        const prev1 = stop;
        const step = this.getTickStep(start, stop);
        const [d0, d1] = this.domain;
        if (step >= 1) {
          start = roundStart(d0 / step) * step;
          stop = roundStop(d1 / step) * step;
        } else {
          const s = 1 / step;
          start = roundStart(d0 * s) / s;
          stop = roundStop(d1 * s) / s;
        }
        if (start === prev0 && stop === prev1) {
          break;
        }
      }
    }
    this.niceDomain = [start, stop];
  }
  tickFormat({ ticks, specifier }) {
    return tickFormat(ticks != null ? ticks : this.ticks(), specifier);
  }
};

// packages/ag-charts-community/src/util/secondaryAxisTicks.ts
function calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {
  let [start, stop] = findMinMax(domain);
  start = calculateNiceStart(Math.floor(start), stop, primaryTickCount);
  const step = getTickStep(start, stop, primaryTickCount);
  const segments = primaryTickCount - 1;
  stop = start + segments * step;
  const d = reverse ? [stop, start] : [start, stop];
  const ticks = getTicks(start, step, primaryTickCount);
  return [d, ticks];
}
function calculateNiceStart(a, b, count2) {
  const rawStep = Math.abs(b - a) / (count2 - 1);
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  return Math.floor(a / magnitude) * magnitude;
}
function getTicks(start, step, count2) {
  const stepPower = Math.floor(Math.log10(step));
  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;
  const f = Math.pow(10, fractionDigits);
  const ticks = createNumericTicks(fractionDigits);
  for (let i = 0; i < count2; i++) {
    const tick = start + step * i;
    ticks[i] = Math.round(tick * f) / f;
  }
  return ticks;
}
function getTickStep(start, stop, count2) {
  const segments = count2 - 1;
  const rawStep = (stop - start) / segments;
  return calculateNextNiceStep(rawStep);
}
function calculateNextNiceStep(rawStep) {
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  const step = rawStep / magnitude * 10;
  if (step > 0 && step <= 1) {
    return magnitude / 10;
  }
  if (step > 1 && step <= 2) {
    return 2 * magnitude / 10;
  }
  if (step > 1 && step <= 5) {
    return 5 * magnitude / 10;
  }
  if (step > 5 && step <= 10) {
    return 10 * magnitude / 10;
  }
  if (step > 10 && step <= 20) {
    return 20 * magnitude / 10;
  }
  if (step > 20 && step <= 40) {
    return 40 * magnitude / 10;
  }
  if (step > 40 && step <= 50) {
    return 50 * magnitude / 10;
  }
  if (step > 50 && step <= 100) {
    return 100 * magnitude / 10;
  }
  return step;
}

// packages/ag-charts-community/src/chart/axis/numberAxis.ts
var NumberAxisTick = class extends AxisTick {
  constructor() {
    super(...arguments);
    this.maxSpacing = NaN;
  }
};
__decorateClass([
  Validate(MAX_SPACING),
  Default(NaN)
], NumberAxisTick.prototype, "maxSpacing", 2);
var NumberAxis = class extends CartesianAxis {
  constructor(moduleCtx, scale2 = new LinearScale()) {
    super(moduleCtx, scale2);
    this.min = NaN;
    this.max = NaN;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
    return { domain: extent2, clipped };
  }
  formatDatum(datum) {
    if (typeof datum === "number") {
      return datum.toFixed(2);
    } else {
      Logger.warnOnce(
        "data contains Date objects which are being plotted against a number axis, please only use a number axis for numbers."
      );
      return String(datum);
    }
  }
  createTick() {
    return new NumberAxisTick();
  }
  updateSecondaryAxisTicks(primaryTickCount) {
    if (this.dataDomain == null) {
      throw new Error("AG Charts - dataDomain not calculated, cannot perform tick calculation.");
    }
    if (this.dataDomain.domain.length === 0)
      return [];
    const [d, ticks] = calculateNiceSecondaryAxis(this.dataDomain.domain, primaryTickCount != null ? primaryTickCount : 0, this.reverse);
    this.scale.nice = false;
    this.scale.domain = d;
    this.scale.update();
    return ticks;
  }
};
NumberAxis.className = "NumberAxis";
NumberAxis.type = "number";
__decorateClass([
  Validate(AND(NUMBER_OR_NAN, LESS_THAN("max"))),
  Default(NaN)
], NumberAxis.prototype, "min", 2);
__decorateClass([
  Validate(AND(NUMBER_OR_NAN, GREATER_THAN("min"))),
  Default(NaN)
], NumberAxis.prototype, "max", 2);

// packages/ag-charts-community/src/chart/axis/logAxis.ts
var NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, "a non-zero number");
var LogAxis = class extends NumberAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LogScale());
    this.min = NaN;
    this.max = NaN;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
    const isInverted = extent2[0] > extent2[1];
    const crossesZero = extent2[0] < 0 && extent2[1] > 0;
    const hasZeroExtent = extent2[0] === 0 && extent2[1] === 0;
    const invalidDomain = isInverted || crossesZero || hasZeroExtent;
    if (invalidDomain) {
      d = [];
      if (crossesZero) {
        Logger.warn(
          `the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`
        );
      } else if (hasZeroExtent) {
        Logger.warn(`the data domain has 0 extent, no data is rendered.`);
      }
    }
    if (extent2[0] === 0) {
      extent2[0] = 1;
    }
    if (extent2[1] === 0) {
      extent2[1] = -1;
    }
    return { domain: extent2, clipped };
  }
  set base(value) {
    this.scale.base = value;
  }
  get base() {
    return this.scale.base;
  }
};
LogAxis.className = "LogAxis";
LogAxis.type = "log";
__decorateClass([
  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN("max"))),
  Default(NaN)
], LogAxis.prototype, "min", 2);
__decorateClass([
  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN("min"))),
  Default(NaN)
], LogAxis.prototype, "max", 2);

// packages/ag-charts-community/src/chart/axis/timeAxis.ts
var TimeAxisTick = class extends AxisTick {
  constructor() {
    super(...arguments);
    this.maxSpacing = NaN;
  }
};
__decorateClass([
  Validate(MAX_SPACING),
  Default(NaN)
], TimeAxisTick.prototype, "maxSpacing", 2);
var TimeAxis = class extends CartesianAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new TimeScale());
    this.datumFormat = "%m/%d/%y, %H:%M:%S";
    this.min = void 0;
    this.max = void 0;
    const { scale: scale2 } = this;
    this.refreshScale();
    this.datumFormatter = scale2.tickFormat({
      specifier: this.datumFormat
    });
  }
  normaliseDataDomain(d) {
    var _a;
    let { min, max } = this;
    let clipped = false;
    if (typeof min === "number") {
      min = new Date(min);
    }
    if (typeof max === "number") {
      max = new Date(max);
    }
    if (d.length > 2) {
      d = ((_a = extent(d)) != null ? _a : [0, 1e3]).map((x) => new Date(x));
    }
    if (min instanceof Date) {
      clipped || (clipped = min > d[0]);
      d = [min, d[1]];
    }
    if (max instanceof Date) {
      clipped || (clipped = max < d[1]);
      d = [d[0], max];
    }
    if (d[0] > d[1]) {
      d = [];
    }
    return { domain: d, clipped };
  }
  createTick() {
    return new TimeAxisTick();
  }
  onLabelFormatChange(ticks, format2) {
    if (format2) {
      super.onLabelFormatChange(ticks, format2);
    } else {
      this.labelFormatter = this.scale.tickFormat({ ticks });
    }
  }
  formatDatum(datum) {
    var _a;
    return (_a = this.moduleCtx.callbackCache.call(this.datumFormatter, datum)) != null ? _a : String(datum);
  }
  calculatePadding(_min, _max, reverse) {
    return reverse ? [1, 0] : [0, 1];
  }
};
TimeAxis.className = "TimeAxis";
TimeAxis.type = "time";
__decorateClass([
  Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN("max")), { optional: true })
], TimeAxis.prototype, "min", 2);
__decorateClass([
  Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN("min")), { optional: true })
], TimeAxis.prototype, "max", 2);

// packages/ag-charts-community/src/scene/shape/rect.ts
var epsilon = 1e-6;
var cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {
  let leadingClipped = false;
  let trailingClipped = false;
  let leading0 = trailingInset - Math.sqrt(Math.max(__pow(cornerRadius, 2) - __pow(leadingInset, 2), 0));
  let leading1 = 0;
  let trailing0 = 0;
  let trailing1 = leadingInset - Math.sqrt(Math.max(__pow(cornerRadius, 2) - __pow(trailingInset, 2), 0));
  if (leading0 > leadingEdge) {
    leadingClipped = true;
    leading0 = leadingEdge;
    leading1 = leadingInset - Math.sqrt(Math.max(__pow(cornerRadius, 2) - __pow(trailingInset - leadingEdge, 2)));
  } else if (leading0 < epsilon) {
    leading0 = 0;
  }
  if (trailing1 > trailingEdge) {
    trailingClipped = true;
    trailing0 = trailingInset - Math.sqrt(Math.max(__pow(cornerRadius, 2) - __pow(leadingInset - trailingEdge, 2)));
    trailing1 = trailingEdge;
  } else if (trailing1 < epsilon) {
    trailing1 = 0;
  }
  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };
};
var drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {
  if (move) {
    path.moveTo(x0, y0);
  }
  if (x0 !== x1 || y0 !== y1) {
    const r0 = Math.atan2(y0 - cy, x0 - cx);
    const r1 = Math.atan2(y1 - cy, x1 - cx);
    path.arc(cx, cy, cornerRadius, r0, r1);
  } else {
    path.lineTo(x0, y0);
  }
};
var insetCornerRadiusRect = (path, x, y, width, height, cornerRadii, cornerRadiusBbox) => {
  let {
    topLeft: topLeftCornerRadius,
    topRight: topRightCornerRadius,
    bottomRight: bottomRightCornerRadius,
    bottomLeft: bottomLeftCornerRadius
  } = cornerRadii;
  const maxVerticalCornerRadius = Math.max(
    topLeftCornerRadius + bottomLeftCornerRadius,
    topRightCornerRadius + bottomRightCornerRadius
  );
  const maxHorizontalCornerRadius = Math.max(
    topLeftCornerRadius + topRightCornerRadius,
    bottomLeftCornerRadius + bottomRightCornerRadius
  );
  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {
    path.rect(x, y, width, height);
    return;
  } else if (cornerRadiusBbox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {
    path.roundRect(x, y, width, height, topLeftCornerRadius);
    return;
  }
  if (width < 0) {
    x += width;
    width = Math.abs(width);
  }
  if (height < 0) {
    y += height;
    height = Math.abs(height);
  }
  if (cornerRadiusBbox != null) {
    const x0 = Math.max(x, cornerRadiusBbox.x);
    const x1 = Math.min(x + width, cornerRadiusBbox.x + cornerRadiusBbox.width);
    const y0 = Math.max(y, cornerRadiusBbox.y);
    const y1 = Math.min(y + height, cornerRadiusBbox.y + cornerRadiusBbox.height);
    x = x0;
    y = y0;
    width = x1 - x0;
    height = y1 - y0;
  }
  if (width <= 0 || height <= 0)
    return;
  cornerRadiusBbox != null ? cornerRadiusBbox : cornerRadiusBbox = new BBox(x, y, width, height);
  const borderScale = Math.max(
    maxVerticalCornerRadius / cornerRadiusBbox.height,
    maxHorizontalCornerRadius / cornerRadiusBbox.width,
    1
  );
  if (borderScale > 1) {
    topLeftCornerRadius /= borderScale;
    topRightCornerRadius /= borderScale;
    bottomRightCornerRadius /= borderScale;
    bottomLeftCornerRadius /= borderScale;
  }
  let drawTopLeftCorner = true;
  let drawTopRightCorner = true;
  let drawBottomRightCorner = true;
  let drawBottomLeftCorner = true;
  let topLeftCorner;
  let topRightCorner;
  let bottomRightCorner;
  let bottomLeftCorner;
  if (drawTopLeftCorner) {
    const nodes = cornerEdges(
      height,
      width,
      Math.max(cornerRadiusBbox.x + topLeftCornerRadius - x, 0),
      Math.max(cornerRadiusBbox.y + topLeftCornerRadius - y, 0),
      topLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomLeftCorner = false;
    if (nodes.trailingClipped)
      drawTopRightCorner = false;
    const x0 = Math.max(x + nodes.leading1, x);
    const y0 = Math.max(y + nodes.leading0, y);
    const x1 = Math.max(x + nodes.trailing1, x);
    const y1 = Math.max(y + nodes.trailing0, y);
    const cx = cornerRadiusBbox.x + topLeftCornerRadius;
    const cy = cornerRadiusBbox.y + topLeftCornerRadius;
    topLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawTopRightCorner) {
    const nodes = cornerEdges(
      width,
      height,
      Math.max(cornerRadiusBbox.y + topRightCornerRadius - y, 0),
      Math.max(x + width - (cornerRadiusBbox.x + cornerRadiusBbox.width - topRightCornerRadius), 0),
      topRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopLeftCorner = false;
    if (nodes.trailingClipped)
      drawBottomRightCorner = false;
    const x0 = Math.min(x + width - nodes.leading0, x + width);
    const y0 = Math.max(y + nodes.leading1, y);
    const x1 = Math.min(x + width - nodes.trailing0, x + width);
    const y1 = Math.max(y + nodes.trailing1, y);
    const cx = cornerRadiusBbox.x + cornerRadiusBbox.width - topRightCornerRadius;
    const cy = cornerRadiusBbox.y + topRightCornerRadius;
    topRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomRightCorner) {
    const nodes = cornerEdges(
      height,
      width,
      Math.max(x + width - (cornerRadiusBbox.x + cornerRadiusBbox.width - bottomRightCornerRadius), 0),
      Math.max(y + height - (cornerRadiusBbox.y + cornerRadiusBbox.height - bottomRightCornerRadius), 0),
      bottomRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopRightCorner = false;
    if (nodes.trailingClipped)
      drawBottomLeftCorner = false;
    const x0 = Math.min(x + width - nodes.leading1, x + width);
    const y0 = Math.min(y + height - nodes.leading0, y + height);
    const x1 = Math.min(x + width - nodes.trailing1, x + width);
    const y1 = Math.min(y + height - nodes.trailing0, y + height);
    const cx = cornerRadiusBbox.x + cornerRadiusBbox.width - bottomRightCornerRadius;
    const cy = cornerRadiusBbox.y + cornerRadiusBbox.height - bottomRightCornerRadius;
    bottomRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomLeftCorner) {
    const nodes = cornerEdges(
      width,
      height,
      Math.max(y + height - (cornerRadiusBbox.y + cornerRadiusBbox.height - bottomLeftCornerRadius), 0),
      Math.max(cornerRadiusBbox.x + bottomLeftCornerRadius - x, 0),
      bottomLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomRightCorner = false;
    if (nodes.trailingClipped)
      drawTopLeftCorner = false;
    const x0 = Math.max(x + nodes.leading0, x);
    const y0 = Math.min(y + height - nodes.leading1, y + height);
    const x1 = Math.max(x + nodes.trailing0, x);
    const y1 = Math.min(y + height - nodes.trailing1, y + height);
    const cx = cornerRadiusBbox.x + bottomLeftCornerRadius;
    const cy = cornerRadiusBbox.y + cornerRadiusBbox.height - bottomLeftCornerRadius;
    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  let didMove = false;
  if (drawTopLeftCorner && topLeftCorner != null) {
    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawTopRightCorner && topRightCorner != null) {
    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomRightCorner && bottomRightCorner != null) {
    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomLeftCorner && bottomLeftCorner != null) {
    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  path.closePath();
};
var Rect = class extends Path {
  constructor() {
    super(...arguments);
    this.borderPath = new Path2D();
    this.x = 0;
    this.y = 0;
    this.width = 10;
    this.height = 10;
    this.topLeftCornerRadius = 0;
    this.topRightCornerRadius = 0;
    this.bottomRightCornerRadius = 0;
    this.bottomLeftCornerRadius = 0;
    this.cornerRadiusBbox = void 0;
    this.crisp = false;
    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;
    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;
    /**
     * When the rectangle's width or height is less than a pixel
     * and crisp mode is on, the rectangle will still fit into the pixel,
     * but will be less opaque to make an effect of holding less space.
     */
    this.microPixelEffectOpacity = 1;
  }
  set cornerRadius(cornerRadius) {
    this.topLeftCornerRadius = cornerRadius;
    this.topRightCornerRadius = cornerRadius;
    this.bottomRightCornerRadius = cornerRadius;
    this.bottomLeftCornerRadius = cornerRadius;
  }
  isDirtyPath() {
    if (this.lastUpdatePathStrokeWidth !== this.strokeWidth) {
      return true;
    }
    return !!(this.path.isDirty() || this.borderPath.isDirty());
  }
  updatePath() {
    var _a, _b, _c;
    const {
      path,
      borderPath,
      crisp,
      topLeftCornerRadius,
      topRightCornerRadius,
      bottomRightCornerRadius,
      bottomLeftCornerRadius
    } = this;
    let { x, y, width: w, height: h, strokeWidth, cornerRadiusBbox } = this;
    const pixelRatio = (_b = (_a = this.layerManager) == null ? void 0 : _a.canvas.pixelRatio) != null ? _b : 1;
    const pixelSize = 1 / pixelRatio;
    let microPixelEffectOpacity = 1;
    path.clear({ trackChanges: true });
    borderPath.clear({ trackChanges: true });
    if (crisp) {
      if (w <= pixelSize) {
        microPixelEffectOpacity *= w / pixelSize;
      }
      if (h <= pixelSize) {
        microPixelEffectOpacity *= h / pixelSize;
      }
      w = this.align(x, w);
      h = this.align(y, h);
      x = this.align(x);
      y = this.align(y);
      cornerRadiusBbox = cornerRadiusBbox != null ? new BBox(
        this.align(cornerRadiusBbox.x),
        this.align(cornerRadiusBbox.y),
        this.align(cornerRadiusBbox.x, cornerRadiusBbox.width),
        this.align(cornerRadiusBbox.y, cornerRadiusBbox.height)
      ) : void 0;
    }
    if (strokeWidth) {
      if (w < pixelSize) {
        const lx = x + pixelSize / 2;
        borderPath.moveTo(lx, y);
        borderPath.lineTo(lx, y + h);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (h < pixelSize) {
        const ly = y + pixelSize / 2;
        borderPath.moveTo(x, ly);
        borderPath.lineTo(x + w, ly);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (strokeWidth < w && strokeWidth < h) {
        const halfStrokeWidth = strokeWidth / 2;
        x += halfStrokeWidth;
        y += halfStrokeWidth;
        w -= strokeWidth;
        h -= strokeWidth;
        const adjustedCornerRadiusBbox = cornerRadiusBbox == null ? void 0 : cornerRadiusBbox.clone().shrink(halfStrokeWidth);
        const cornerRadii = {
          topLeft: topLeftCornerRadius > 0 ? topLeftCornerRadius - strokeWidth : 0,
          topRight: topRightCornerRadius > 0 ? topRightCornerRadius - strokeWidth : 0,
          bottomRight: bottomRightCornerRadius > 0 ? bottomRightCornerRadius - strokeWidth : 0,
          bottomLeft: bottomLeftCornerRadius > 0 ? bottomLeftCornerRadius - strokeWidth : 0
        };
        this.borderClipPath = void 0;
        insetCornerRadiusRect(path, x, y, w, h, cornerRadii, adjustedCornerRadiusBbox);
        insetCornerRadiusRect(borderPath, x, y, w, h, cornerRadii, adjustedCornerRadiusBbox);
      } else {
        this.borderClipPath = (_c = this.borderClipPath) != null ? _c : new Path2D();
        this.borderClipPath.clear({ trackChanges: true });
        this.borderClipPath.rect(x, y, w, h);
        borderPath.rect(x, y, w, h);
      }
    } else {
      const cornerRadii = {
        topLeft: topLeftCornerRadius,
        topRight: topRightCornerRadius,
        bottomRight: bottomRightCornerRadius,
        bottomLeft: bottomLeftCornerRadius
      };
      this.borderClipPath = void 0;
      insetCornerRadiusRect(path, x, y, w, h, cornerRadii, cornerRadiusBbox);
    }
    this.effectiveStrokeWidth = strokeWidth;
    this.lastUpdatePathStrokeWidth = strokeWidth;
    this.microPixelEffectOpacity = microPixelEffectOpacity;
  }
  computeBBox() {
    const { x, y, width, height } = this;
    return new BBox(x, y, width, height);
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    const bbox = this.computeBBox();
    return bbox.containsPoint(point.x, point.y);
  }
  applyFillAlpha(ctx) {
    const { fillOpacity, microPixelEffectOpacity, opacity } = this;
    const { globalAlpha } = ctx;
    ctx.globalAlpha = globalAlpha * opacity * fillOpacity * microPixelEffectOpacity;
  }
  renderStroke(ctx) {
    const { stroke, effectiveStrokeWidth, borderPath, borderClipPath, opacity, microPixelEffectOpacity } = this;
    const borderActive = !!stroke && !!effectiveStrokeWidth;
    if (borderActive) {
      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;
      if (borderClipPath) {
        borderClipPath.draw(ctx);
        ctx.clip();
      }
      borderPath.draw(ctx);
      const { globalAlpha } = ctx;
      ctx.strokeStyle = stroke;
      ctx.globalAlpha = globalAlpha * opacity * strokeOpacity * microPixelEffectOpacity;
      ctx.lineWidth = effectiveStrokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.stroke();
      ctx.globalAlpha = globalAlpha;
    }
  }
};
Rect.className = "Rect";
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "x", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "y", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "width", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "height", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "topLeftCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "topRightCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "bottomRightCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "bottomLeftCornerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "cornerRadiusBbox", 2);
__decorateClass([
  ScenePathChangeDetection()
], Rect.prototype, "crisp", 2);

// packages/ag-charts-community/src/chart/background/background.ts
var Background = class extends BaseModuleInstance {
  constructor(ctx) {
    var _a;
    super();
    this.node = new Group({ name: "background", zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */ });
    this.rectNode = new Rect();
    this.visible = true;
    this.fill = "white";
    this.image = void 0;
    this.node.appendChild(this.rectNode);
    (_a = ctx.scene.root) == null ? void 0 : _a.appendChild(this.node);
    this.destroyFns.push(
      () => {
        var _a2;
        return (_a2 = ctx.scene.root) == null ? void 0 : _a2.removeChild(this.node);
      },
      ctx.layoutService.addListener("layout-complete", (e) => this.onLayoutComplete(e))
    );
  }
  onLayoutComplete(e) {
    const { width, height } = e.chart;
    this.rectNode.width = width;
    this.rectNode.height = height;
  }
};
__decorateClass([
  Validate(BOOLEAN),
  ProxyPropertyOnWrite("node", "visible")
], Background.prototype, "visible", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true }),
  ProxyPropertyOnWrite("rectNode", "fill")
], Background.prototype, "fill", 2);
__decorateClass([
  Validate(OBJECT, { optional: true })
], Background.prototype, "image", 2);

// packages/ag-charts-community/src/chart/background/backgroundModule.ts
var BackgroundModule = {
  type: "root",
  optionsKey: "background",
  packageType: "community",
  chartTypes: ["cartesian", "polar", "hierarchy"],
  instanceConstructor: Background
};

// packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts
var RangeHandle = class extends Path {
  constructor() {
    super(...arguments);
    this._fill = "#f2f2f2";
    this._stroke = "#999999";
    this._strokeWidth = 1;
    this._lineCap = "square";
    this._centerX = 0;
    this._centerY = 0;
    this._width = 8;
    this._gripLineGap = 2;
    this._gripLineLength = 8;
    this._height = 16;
  }
  set centerX(value) {
    if (this._centerX !== value) {
      this._centerX = value;
      this.dirtyPath = true;
    }
  }
  get centerX() {
    return this._centerX;
  }
  set centerY(value) {
    if (this._centerY !== value) {
      this._centerY = value;
      this.dirtyPath = true;
    }
  }
  get centerY() {
    return this._centerY;
  }
  set width(value) {
    if (this._width !== value) {
      this._width = value;
      this.dirtyPath = true;
    }
  }
  get width() {
    return this._width;
  }
  set gripLineGap(value) {
    if (this._gripLineGap !== value) {
      this._gripLineGap = value;
      this.dirtyPath = true;
    }
  }
  get gripLineGap() {
    return this._gripLineGap;
  }
  set gripLineLength(value) {
    if (this._gripLineLength !== value) {
      this._gripLineLength = value;
      this.dirtyPath = true;
    }
  }
  get gripLineLength() {
    return this._gripLineLength;
  }
  set height(value) {
    if (this._height !== value) {
      this._height = value;
      this.dirtyPath = true;
    }
  }
  get height() {
    return this._height;
  }
  computeBBox() {
    const { centerX, centerY, width, height } = this;
    const x = centerX - width / 2;
    const y = centerY - height / 2;
    return new BBox(x, y, width, height);
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    const bbox = this.computeBBox();
    return bbox.containsPoint(point.x, point.y);
  }
  updatePath() {
    const { path, centerX, centerY, width, height } = this;
    path.clear();
    const x = centerX - width / 2;
    const y = centerY - height / 2;
    const ax = this.align(x);
    const ay = this.align(y);
    const axw = ax + this.align(x, width);
    const ayh = ay + this.align(y, height);
    path.moveTo(ax, ay);
    path.lineTo(axw, ay);
    path.lineTo(axw, ayh);
    path.lineTo(ax, ayh);
    path.closePath();
    const dx = this.gripLineGap / 2;
    const dy = this.gripLineLength / 2;
    path.moveTo(this.align(centerX - dx), this.align(centerY - dy));
    path.lineTo(this.align(centerX - dx), this.align(centerY + dy));
    path.moveTo(this.align(centerX + dx), this.align(centerY - dy));
    path.lineTo(this.align(centerX + dx), this.align(centerY + dy));
  }
};
RangeHandle.className = "RangeHandle";
__decorateClass([
  Validate(COLOR_STRING)
], RangeHandle.prototype, "_fill", 2);
__decorateClass([
  Validate(COLOR_STRING)
], RangeHandle.prototype, "_stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], RangeHandle.prototype, "_strokeWidth", 2);
__decorateClass([
  Validate(LINE_CAP)
], RangeHandle.prototype, "_lineCap", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], RangeHandle.prototype, "_width", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], RangeHandle.prototype, "_gripLineGap", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], RangeHandle.prototype, "_gripLineLength", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], RangeHandle.prototype, "_height", 2);

// packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts
function markDirtyOnChange(newValue, oldValue) {
  if (newValue !== oldValue) {
    this.dirtyPath = true;
  }
}
var RangeMask = class extends Path {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.width = 200;
    this.height = 30;
    this.minRange = 1e-3;
    this._min = 0;
    this._max = 1;
  }
  set min(value) {
    var _a;
    value = clamp(0, value, this.max - this.minRange);
    if (this._min !== value && !isNaN(value)) {
      this._min = value;
      this.dirtyPath = true;
      (_a = this.onRangeChange) == null ? void 0 : _a.call(this);
    }
  }
  get min() {
    return this._min;
  }
  set max(value) {
    var _a;
    value = clamp(this.min + this.minRange, value, 1);
    if (this._max !== value && !isNaN(value)) {
      this._max = value;
      this.dirtyPath = true;
      (_a = this.onRangeChange) == null ? void 0 : _a.call(this);
    }
  }
  get max() {
    return this._max;
  }
  computeBBox() {
    const { x, y, width, height } = this;
    return new BBox(x, y, width, height);
  }
  computeVisibleRangeBBox() {
    const { x, y, width, height, min, max } = this;
    const minX = x + width * min;
    const maxX = x + width * max;
    return new BBox(minX, y, maxX - minX, height);
  }
  updatePath() {
    const { path, x, y, width, height, min, max } = this;
    path.clear();
    const ax = this.align(x);
    const ay = this.align(y);
    const axw = ax + this.align(x, width);
    const ayh = ay + this.align(y, height);
    path.moveTo(ax, ay);
    path.lineTo(axw, ay);
    path.lineTo(axw, ayh);
    path.lineTo(ax, ayh);
    path.lineTo(ax, ay);
    const minX = this.align(x + width * min);
    const maxX = this.align(x + width * max);
    path.moveTo(minX, ay);
    path.lineTo(minX, ayh);
    path.lineTo(maxX, ayh);
    path.lineTo(maxX, ay);
    path.lineTo(minX, ay);
  }
};
RangeMask.className = "RangeMask";
__decorateClass([
  ActionOnSet({ changeValue: markDirtyOnChange }),
  Validate(POSITIVE_NUMBER)
], RangeMask.prototype, "x", 2);
__decorateClass([
  ActionOnSet({ changeValue: markDirtyOnChange }),
  Validate(POSITIVE_NUMBER)
], RangeMask.prototype, "y", 2);
__decorateClass([
  ActionOnSet({ changeValue: markDirtyOnChange }),
  Validate(POSITIVE_NUMBER)
], RangeMask.prototype, "width", 2);
__decorateClass([
  ActionOnSet({ changeValue: markDirtyOnChange }),
  Validate(POSITIVE_NUMBER)
], RangeMask.prototype, "height", 2);
__decorateClass([
  Validate(NUMBER)
], RangeMask.prototype, "_min", 2);
__decorateClass([
  Validate(NUMBER)
], RangeMask.prototype, "_max", 2);

// packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts
var _RangeSelector = class _RangeSelector extends Group {
  constructor() {
    super({ name: "rangeSelectorGroup", layer: true });
    this.minHandle = new RangeHandle();
    this.maxHandle = new RangeHandle();
    this.background = (() => {
      const background = new Group({ name: "navigator-background" });
      background.zIndex = 1;
      this.appendChild(background);
      return background;
    })();
    this.mask = (() => {
      const { x, y, width, height, min, max } = _RangeSelector.defaults;
      const mask = new RangeMask();
      mask.x = x;
      mask.y = y;
      mask.width = width;
      mask.height = height;
      mask.min = min;
      mask.max = max;
      mask.zIndex = 2;
      const { minHandle, maxHandle } = this;
      minHandle.centerX = x;
      maxHandle.centerX = x + width;
      minHandle.centerY = maxHandle.centerY = y + height / 2;
      minHandle.zIndex = 4;
      maxHandle.zIndex = 3;
      this.append([mask, minHandle, maxHandle]);
      mask.onRangeChange = () => {
        var _a;
        this.updateHandles();
        (_a = this.onRangeChange) == null ? void 0 : _a.call(this);
      };
      return mask;
    })();
    this.isContainerNode = true;
  }
  layout(x, y, width, height) {
    this.mask.x = x;
    this.mask.y = y;
    this.mask.width = width;
    this.mask.height = height;
    this.updateHandles();
    this.background.translationX = x;
    this.background.translationY = y;
  }
  updateHandles() {
    const { x, y, width, height } = this.mask;
    const { minHandle, maxHandle, min, max } = this;
    minHandle.centerX = x + width * min;
    maxHandle.centerX = x + width * max;
    minHandle.centerY = maxHandle.centerY = y + height / 2;
    if (min + (max - min) / 2 < 0.5) {
      minHandle.zIndex = 3;
      maxHandle.zIndex = 4;
    } else {
      minHandle.zIndex = 4;
      maxHandle.zIndex = 3;
    }
  }
  computeBBox() {
    return this.mask.computeBBox();
  }
  computeVisibleRangeBBox() {
    return this.mask.computeVisibleRangeBBox();
  }
};
_RangeSelector.className = "Range";
_RangeSelector.defaults = {
  x: 0,
  y: 0,
  width: 200,
  height: 30,
  min: 0,
  max: 1
};
__decorateClass([
  ProxyProperty("mask.min")
], _RangeSelector.prototype, "min", 2);
__decorateClass([
  ProxyProperty("mask.max")
], _RangeSelector.prototype, "max", 2);
var RangeSelector = _RangeSelector;

// packages/ag-charts-community/src/chart/navigator/navigator.ts
var Navigator = class extends BaseModuleInstance {
  constructor(ctx) {
    var _a;
    super();
    this.ctx = ctx;
    this.rs = new RangeSelector();
    this.miniChart = void 0;
    this.minHandleDragging = false;
    this.maxHandleDragging = false;
    this.panHandleOffset = NaN;
    this.enabled = false;
    this.height = 30;
    this.margin = 10;
    this.visible = true;
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.rs.onRangeChange = debounce(() => this.onRangeChange());
    (_a = ctx.scene.root) == null ? void 0 : _a.appendChild(this.rs);
    const dragStates = 8 /* Default */ | 1 /* Animation */ | 4 /* ZoomDrag */;
    this.destroyFns.push(
      ctx.interactionManager.addListener("drag-start", (event) => this.onDragStart(event), dragStates),
      ctx.interactionManager.addListener("drag", (event) => this.onDrag(event), dragStates),
      ctx.interactionManager.addListener("hover", (event) => this.onDrag(event), dragStates),
      ctx.interactionManager.addListener("drag-end", () => this.onDragStop(), dragStates),
      ctx.zoomManager.addListener("zoom-change", () => this.onZoomChange()),
      () => {
        var _a2;
        return (_a2 = ctx.scene.root) == null ? void 0 : _a2.removeChild(this.rs);
      },
      () => delete this.rs.onRangeChange
    );
    this.updateGroupVisibility();
  }
  updateGroupVisibility() {
    const visible = Boolean(this.enabled && this.visible);
    if (visible === this.rs.visible)
      return;
    this.rs.visible = visible;
    if (visible) {
      this.onRangeChange();
    }
  }
  performLayout(_0) {
    return __async(this, arguments, function* ({ shrinkRect }) {
      if (this.enabled) {
        const navigatorTotalHeight = this.height + this.margin;
        shrinkRect.shrink(navigatorTotalHeight, "bottom");
        this.y = shrinkRect.y + shrinkRect.height + this.margin;
      } else {
        this.y = 0;
      }
      return { shrinkRect };
    });
  }
  performCartesianLayout(opts) {
    return __async(this, null, function* () {
      const { x, width } = opts.seriesRect;
      const visible = true;
      if (this.enabled && visible) {
        const { y, height } = this;
        this.rs.layout(x, y, width, height);
      }
      this.visible = visible;
      this.x = x;
      this.width = width;
    });
  }
  onRangeChange() {
    var _a, _b;
    const { min, max } = this.rs;
    const zoom = this.ctx.zoomManager.getZoom();
    if (((_a = zoom == null ? void 0 : zoom.x) == null ? void 0 : _a.min) !== min || ((_b = zoom == null ? void 0 : zoom.x) == null ? void 0 : _b.max) !== max) {
      this.ctx.zoomManager.updateZoom({ x: { min, max }, y: zoom == null ? void 0 : zoom.y });
    }
  }
  onZoomChange() {
    const currentZoom = this.ctx.zoomManager.getZoom();
    if (currentZoom && currentZoom.x) {
      this.min = currentZoom.x.min;
      this.max = currentZoom.x.max;
    }
  }
  onDragStart(offset4) {
    if (!this.enabled) {
      return;
    }
    const { offsetX, offsetY } = offset4;
    const { rs } = this;
    const { minHandle, maxHandle, min } = rs;
    const { x, width } = this;
    const visibleRange = rs.computeVisibleRangeBBox();
    if (this.minHandleDragging || this.maxHandleDragging)
      return;
    if (minHandle.zIndex < maxHandle.zIndex) {
      if (maxHandle.containsPoint(offsetX, offsetY)) {
        this.maxHandleDragging = true;
      } else if (minHandle.containsPoint(offsetX, offsetY)) {
        this.minHandleDragging = true;
      }
    } else if (minHandle.containsPoint(offsetX, offsetY)) {
      this.minHandleDragging = true;
    } else if (maxHandle.containsPoint(offsetX, offsetY)) {
      this.maxHandleDragging = true;
    }
    if (!this.minHandleDragging && !this.maxHandleDragging && visibleRange.containsPoint(offsetX, offsetY)) {
      this.panHandleOffset = (offsetX - x) / width - min;
    }
  }
  onDrag(offset4) {
    if (!this.enabled) {
      return;
    }
    const { rs, panHandleOffset } = this;
    const { minHandle, maxHandle } = rs;
    const { x, y, width, height } = this;
    const { offsetX, offsetY } = offset4;
    const minX = x + width * rs.min;
    const maxX = x + width * rs.max;
    const visibleRange = new BBox(minX, y, maxX - minX, height);
    const getRatio = () => clamp(0, (offsetX - x) / width, 1);
    if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {
      this.ctx.cursorManager.updateCursor("navigator", "ew-resize");
    } else if (visibleRange.containsPoint(offsetX, offsetY)) {
      this.ctx.cursorManager.updateCursor("navigator", "grab");
    } else {
      this.ctx.cursorManager.updateCursor("navigator");
    }
    if (this.minHandleDragging) {
      rs.min = getRatio();
    } else if (this.maxHandleDragging) {
      rs.max = getRatio();
    } else if (!isNaN(panHandleOffset)) {
      const span = rs.max - rs.min;
      const min = Math.min(getRatio() - panHandleOffset, 1 - span);
      if (min <= rs.min) {
        rs.min = min;
        rs.max = rs.min + span;
      } else {
        rs.max = min + span;
        rs.min = rs.max - span;
      }
    }
  }
  onDragStop() {
    this.stopHandleDragging();
  }
  stopHandleDragging() {
    this.minHandleDragging = this.maxHandleDragging = false;
    this.panHandleOffset = NaN;
  }
};
__decorateClass([
  Validate(OBJECT, { optional: true })
], Navigator.prototype, "miniChart", 2);
__decorateClass([
  Validate(BOOLEAN),
  ObserveChanges((target) => target.updateGroupVisibility())
], Navigator.prototype, "enabled", 2);
__decorateClass([
  ProxyProperty("rs.mask")
], Navigator.prototype, "mask", 2);
__decorateClass([
  ProxyProperty("rs.minHandle")
], Navigator.prototype, "minHandle", 2);
__decorateClass([
  ProxyProperty("rs.maxHandle")
], Navigator.prototype, "maxHandle", 2);
__decorateClass([
  ProxyProperty("rs.min")
], Navigator.prototype, "min", 2);
__decorateClass([
  ProxyProperty("rs.max")
], Navigator.prototype, "max", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], Navigator.prototype, "margin", 2);
__decorateClass([
  Validate(BOOLEAN),
  ObserveChanges((target) => target.updateGroupVisibility())
], Navigator.prototype, "visible", 2);

// packages/ag-charts-community/src/chart/navigator/navigatorModule.ts
var NavigatorModule = {
  type: "root",
  optionsKey: "navigator",
  packageType: "community",
  chartTypes: ["cartesian"],
  instanceConstructor: Navigator,
  themeTemplate: {
    navigator: {
      enabled: false,
      height: 30,
      mask: {
        fill: "#999999",
        stroke: "#999999",
        strokeWidth: 1,
        fillOpacity: 0.2
      },
      minHandle: {
        fill: "#f2f2f2",
        stroke: "#999999",
        strokeWidth: 1,
        width: 8,
        height: 16,
        gripLineGap: 2,
        gripLineLength: 8
      },
      maxHandle: {
        fill: "#f2f2f2",
        stroke: "#999999",
        strokeWidth: 1,
        width: 8,
        height: 16,
        gripLineGap: 2,
        gripLineLength: 8
      }
    }
  }
};

// packages/ag-charts-community/src/module/theme.ts
var singleSeriesPaletteFactory = ({ takeColors }) => {
  const {
    fills: [fill],
    strokes: [stroke]
  } = takeColors(1);
  return { fill, stroke };
};
var markerPaletteFactory = (params) => {
  const { fill, stroke } = singleSeriesPaletteFactory(params);
  return { marker: { fill, stroke } };
};

// packages/ag-charts-community/src/motion/pathMotion.ts
function pathMotion(groupId, subId, animationManager, paths, fns) {
  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;
  const animate = (phase, path, updateFn) => {
    animationManager.animate({
      id: `${groupId}_${subId}_${path.id}_${phase}`,
      groupId,
      from: 0,
      to: 1,
      ease: easeOut,
      onUpdate(ratio, preInit) {
        if (preInit && phase !== "removed")
          return;
        path.path.clear({ trackChanges: true });
        updateFn(ratio, path);
        path.checkPathDirty();
      },
      onStop() {
        if (phase !== "added")
          return;
        path.path.clear({ trackChanges: true });
        updateFn(1, path);
        path.checkPathDirty();
      },
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]
    });
  };
  for (const path of paths) {
    if (!animationManager.isSkipped()) {
      animate("removed", path, removePhaseFn);
      animate("updated", path, updatePhaseFn);
    }
    animate("added", path, addPhaseFn);
  }
}

// packages/ag-charts-community/src/util/sanitize.ts
var element = null;
function sanitizeHtml(text) {
  if (text == null) {
    return;
  } else if (text === "") {
    return "";
  }
  element != null ? element : element = document.createElement("div");
  element.textContent = String(text);
  return element.innerHTML;
}

// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts
function seriesLabelFadeInAnimation({ id }, subId, animationManager, labelSelections) {
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 0 },
    { opacity: 1 },
    { phase: "trailing" }
  );
}
function seriesLabelFadeOutAnimation({ id }, subId, animationManager, labelSelections) {
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 1 },
    { opacity: 0 },
    { phase: "remove" }
  );
}
function resetLabelFn(_node) {
  return { opacity: 1 };
}

// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts
var ChangeDetectableProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this._dirty = 3 /* MAJOR */;
  }
  markDirty(_source, type = 1 /* TRIVIAL */) {
    if (this._dirty < type) {
      this._dirty = type;
    }
  }
  markClean(_opts) {
    this._dirty = 0 /* NONE */;
  }
  isDirty() {
    return this._dirty > 0 /* NONE */;
  }
};

// packages/ag-charts-community/src/scene/dropShadow.ts
var DropShadow = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.color = "rgba(0, 0, 0, 0.5)";
    this.xOffset = 0;
    this.yOffset = 0;
    this.blur = 5;
  }
};
__decorateClass([
  Validate(BOOLEAN),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "enabled", 2);
__decorateClass([
  Validate(COLOR_STRING),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "color", 2);
__decorateClass([
  Validate(NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "xOffset", 2);
__decorateClass([
  Validate(NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "yOffset", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], DropShadow.prototype, "blur", 2);

// packages/ag-charts-community/src/chart/series/seriesMarker.ts
var MARKER_SHAPE = predicateWithMessage(
  (value) => isMarkerShape(value) || Object.getPrototypeOf(value) === Marker,
  `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`
);
var SeriesMarker = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.shape = Circle;
    this.size = 6;
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
  }
  getStyle() {
    const { size, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;
    return { size, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };
  }
  getDiameter() {
    return this.size + this.strokeWidth;
  }
};
__decorateClass([
  Validate(BOOLEAN),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "enabled", 2);
__decorateClass([
  Validate(MARKER_SHAPE),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "shape", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "size", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true }),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true }),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true }),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], SeriesMarker.prototype, "formatter", 2);

// packages/ag-charts-community/src/chart/series/seriesTooltip.ts
var SeriesTooltipInteraction = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], SeriesTooltipInteraction.prototype, "enabled", 2);
var SeriesTooltip = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.interaction = new SeriesTooltipInteraction();
    this.position = new TooltipPosition();
  }
  toTooltipHtml(defaults, params) {
    if (this.renderer) {
      return toTooltipHtml(this.renderer(params), defaults);
    }
    return toTooltipHtml(defaults);
  }
};
__decorateClass([
  Validate(BOOLEAN)
], SeriesTooltip.prototype, "enabled", 2);
__decorateClass([
  Validate(BOOLEAN, { optional: true })
], SeriesTooltip.prototype, "showArrow", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], SeriesTooltip.prototype, "renderer", 2);
__decorateClass([
  Validate(OBJECT)
], SeriesTooltip.prototype, "interaction", 2);
__decorateClass([
  Validate(OBJECT)
], SeriesTooltip.prototype, "position", 2);

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts
var AreaSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.xName = void 0;
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.shadow = new DropShadow();
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
    this.connectMissingData = false;
  }
};
__decorateClass([
  Validate(STRING)
], AreaSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], AreaSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING)
], AreaSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], AreaSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], AreaSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Validate(COLOR_STRING)
], AreaSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO)
], AreaSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING)
], AreaSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AreaSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], AreaSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], AreaSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], AreaSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(OBJECT)
], AreaSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], AreaSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], AreaSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], AreaSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate(BOOLEAN)
], AreaSeriesProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts
function markerFadeInAnimation({ id }, animationManager, markerSelections, status) {
  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : "trailing" };
  staticFromToMotion(id, "markers", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);
  markerSelections.forEach((s) => s.cleanup());
}
function markerScaleInAnimation({ id }, animationManager, markerSelections) {
  staticFromToMotion(
    id,
    "markers",
    animationManager,
    markerSelections,
    { scalingX: 0, scalingY: 0 },
    { scalingX: 1, scalingY: 1 },
    { phase: "initial" }
  );
  markerSelections.forEach((s) => s.cleanup());
}
function markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, markerSelections) {
  const seriesWidth = nodeDataDependencies.seriesRectWidth;
  const fromFn = (_, datum) => {
    var _a, _b;
    const x = (_b = (_a = datum.midPoint) == null ? void 0 : _a.x) != null ? _b : seriesWidth;
    const delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);
    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: "initial" };
  };
  const toFn = () => {
    return { scalingX: 1, scalingY: 1 };
  };
  fromToMotion(id, "markers", animationManager, markerSelections, { fromFn, toFn });
}
function resetMarkerFn(_node) {
  return { opacity: 1, scalingX: 1, scalingY: 1 };
}
function resetMarkerPositionFn(_node, datum) {
  var _a, _b, _c, _d;
  return {
    translationX: (_b = (_a = datum.point) == null ? void 0 : _a.x) != null ? _b : NaN,
    translationY: (_d = (_c = datum.point) == null ? void 0 : _c.y) != null ? _d : NaN
  };
}
function prepareMarkerAnimation(pairMap, parentStatus) {
  const readFirstPair = (xValue, type) => {
    const val = pairMap[type][xValue];
    return Array.isArray(val) ? val[0] : val;
  };
  const markerStatus = (datum) => {
    const { xValue } = datum;
    if (pairMap.moved[xValue]) {
      return { point: readFirstPair(xValue, "moved"), status: "updated" };
    } else if (pairMap.removed[xValue]) {
      return { point: readFirstPair(xValue, "removed"), status: "removed" };
    } else if (pairMap.added[xValue]) {
      return { point: readFirstPair(xValue, "added"), status: "added" };
    }
    return { status: "unknown" };
  };
  const fromFn = (marker, datum) => {
    var _a, _b, _c, _d, _e, _f;
    const { status, point } = markerStatus(datum);
    if (status === "unknown")
      return { opacity: 0 };
    const defaults = {
      translationX: (_b = (_a = point == null ? void 0 : point.from) == null ? void 0 : _a.x) != null ? _b : marker.translationX,
      translationY: (_d = (_c = point == null ? void 0 : point.from) == null ? void 0 : _c.y) != null ? _d : marker.translationY,
      opacity: marker.opacity,
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
    };
    if (parentStatus === "added") {
      return __spreadProps(__spreadValues({}, defaults), {
        opacity: 0,
        translationX: (_e = point == null ? void 0 : point.to) == null ? void 0 : _e.x,
        translationY: (_f = point == null ? void 0 : point.to) == null ? void 0 : _f.y,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["added"]
      });
    }
    if (status === "added") {
      defaults.opacity = 0;
    }
    return defaults;
  };
  const toFn = (_marker, datum) => {
    var _a, _b;
    const { status, point } = markerStatus(datum);
    if (status === "unknown")
      return { opacity: 0 };
    const defaults = {
      translationX: datum.point.x,
      translationY: datum.point.y,
      opacity: 1,
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
    };
    if (status === "removed" || parentStatus === "removed") {
      return __spreadProps(__spreadValues({}, defaults), {
        translationX: (_a = point == null ? void 0 : point.to) == null ? void 0 : _a.x,
        translationY: (_b = point == null ? void 0 : point.to) == null ? void 0 : _b.y,
        opacity: 0,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["removed"]
      });
    }
    return defaults;
  };
  return { fromFn, toFn };
}

// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts
function minMax(nodeData) {
  return nodeData.reduce(
    ({ min, max }, node) => {
      if (min == null || min.point.x > node.point.x) {
        min = node;
      }
      if (max == null || max.point.x < node.point.x) {
        max = node;
      }
      return { min, max };
    },
    {}
  );
}
function intersectionOnLine(a, b, targetX) {
  const m = (b.y - a.y) / (b.x - a.x);
  const y = (targetX - a.x) * m + a.y;
  return { x: targetX, y };
}
function backfillPathPoint(results, process, skip, processFn) {
  let prevMarkerIdx = -1, nextMarkerIdx = 0;
  const toProcess = [];
  while (nextMarkerIdx < results.length) {
    if (results[nextMarkerIdx].change === process) {
      toProcess.push(results[nextMarkerIdx]);
      nextMarkerIdx++;
      continue;
    }
    if (results[nextMarkerIdx].change === skip) {
      nextMarkerIdx++;
      continue;
    }
    if (toProcess.length > 0) {
      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);
      toProcess.length = 0;
    }
    prevMarkerIdx = nextMarkerIdx;
    nextMarkerIdx++;
  }
  if (toProcess.length > 0) {
    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);
  }
}
function backfillPathPointData(result, splitMode) {
  backfillPathPoint(result, "out", "in", (toProcess, sIdx, eIdx) => {
    var _a, _b;
    if (sIdx === -1 && result[eIdx]) {
      toProcess.forEach((d) => d.to = result[eIdx].from);
    } else if (eIdx === result.length && result[sIdx]) {
      toProcess.forEach((d) => d.to = result[sIdx].from);
    } else if (splitMode === "intersect" && ((_a = result[sIdx]) == null ? void 0 : _a.from) && ((_b = result[eIdx]) == null ? void 0 : _b.from)) {
      toProcess.forEach((d) => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));
    } else {
      toProcess.forEach((d) => d.to = d.from);
    }
  });
  backfillPathPoint(result, "in", "out", (toProcess, sIdx, eIdx) => {
    var _a, _b;
    if (sIdx === -1 && result[eIdx]) {
      toProcess.forEach((d) => d.from = result[eIdx].to);
    } else if (eIdx === result.length && result[sIdx]) {
      toProcess.forEach((d) => d.from = result[sIdx].to);
    } else if (splitMode === "intersect" && ((_a = result[sIdx]) == null ? void 0 : _a.to) && ((_b = result[eIdx]) == null ? void 0 : _b.to)) {
      toProcess.forEach((d) => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));
    } else {
      toProcess.forEach((d) => d.from = d.to);
    }
  });
}
function calculatePoint(from, to, ratio) {
  const x1 = isNaN(from.x) ? to.x : from.x;
  const y1 = isNaN(from.y) ? to.y : from.y;
  const xd = to.x - from.x;
  const yd = to.y - from.y;
  const xr = isNaN(xd) ? 0 : xd * ratio;
  const yr = isNaN(yd) ? 0 : yd * ratio;
  return {
    x: x1 + xr,
    y: y1 + yr
  };
}
function renderPartialPath(pairData, ratios, path) {
  const { path: linePath } = path;
  let previousTo;
  for (const data of pairData) {
    const { from, to } = data;
    const ratio = ratios[data.change];
    if (ratio == null || from == null || to == null)
      continue;
    const { x, y } = calculatePoint(from, to, ratio);
    if (data.moveTo === false) {
      linePath.lineTo(x, y);
    } else if (data.moveTo === true || !previousTo) {
      linePath.moveTo(x, y);
    } else if (previousTo) {
      const moveToRatio = data.moveTo === "in" ? ratio : 1 - ratio;
      const { x: midPointX, y: midPointY } = calculatePoint(previousTo, { x, y }, moveToRatio);
      linePath.lineTo(midPointX, midPointY);
      linePath.moveTo(x, y);
    }
    previousTo = { x, y };
  }
}
function pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, paths) {
  const { seriesRectWidth: width, seriesRectHeight: height } = nodeDataDependencies;
  staticFromToMotion(
    id,
    "path_properties",
    animationManager,
    paths,
    { clipX: 0 },
    { clipX: width },
    {
      phase: "initial",
      start: { clipMode: "normal", clipY: height, visible },
      finish: { clipMode: void 0, visible }
    }
  );
}
function pathFadeInAnimation({ id }, subId, animationManager, selection, phase = "add") {
  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });
}
function pathFadeOutAnimation({ id }, subId, animationManager, selection) {
  staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, { phase: "remove" });
}
function buildResetPathFn(opts) {
  return (_node) => {
    return { opacity: opts.getOpacity(), clipScalingX: 1, clipMode: void 0 };
  };
}
function updateClipPath({ nodeDataDependencies }, path) {
  const toFinite = (value) => isFinite(value) ? value : 0;
  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);
  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);
}

// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts
function isContinuousScaling(scaling) {
  return scaling.type === "continuous" || scaling.type === "log";
}
function isCategoryScaling(scaling) {
  return scaling.type === "category";
}
function areEqual(a, b) {
  return a.domain.length === b.domain.length && a.range.length === b.range.length && a.domain.every((val, index) => val === b.domain[index]) && a.range.every((val, index) => val === b.range[index]);
}
function areScalingEqual(a, b) {
  if (a === void 0 || b === void 0) {
    return a !== void 0 || b !== void 0;
  }
  if (isContinuousScaling(a) && isContinuousScaling(b)) {
    return a.type === b.type && areEqual(a, b);
  }
  if (isCategoryScaling(a) && isCategoryScaling(b)) {
    return areEqual(a, b);
  }
  return false;
}

// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts
function scale(val, scaling) {
  if (!scaling)
    return NaN;
  if (val instanceof Date) {
    val = val.getTime();
  }
  if (scaling.type === "continuous" && typeof val === "number") {
    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);
    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];
  }
  if (scaling.type === "log" && typeof val === "number") {
    return scaling.convert(val);
  }
  const matchingIndex = scaling.domain.findIndex((d) => d === val);
  if (matchingIndex >= 0) {
    return scaling.range[matchingIndex];
  }
  return NaN;
}
function scalesChanged(newData, oldData) {
  return !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y);
}
function closeMatch(a, b) {
  const an = Number(a);
  const bn = Number(b);
  if (!isNaN(an) && !isNaN(bn)) {
    return Math.abs(bn - an) < 0.25;
  }
  return a === b;
}
function calculateMoveTo(from = false, to = false) {
  if (from === to) {
    return !!from;
  }
  return from ? "in" : "out";
}
function pairContinuousData(newData, oldData, opts = {}) {
  var _a, _b, _c, _d;
  const { backfillSplitMode = "intersect" } = opts;
  const toNewScale = (oldDatum) => {
    var _a2, _b2;
    return {
      x: scale((_a2 = oldDatum.xValue) != null ? _a2 : NaN, newData.scales.x),
      y: scale((_b2 = oldDatum.yValue) != null ? _b2 : NaN, newData.scales.y)
    };
  };
  const toOldScale = (newDatum) => {
    var _a2, _b2;
    return {
      x: scale((_a2 = newDatum.xValue) != null ? _a2 : NaN, oldData.scales.x),
      y: scale((_b2 = newDatum.yValue) != null ? _b2 : NaN, oldData.scales.y)
    };
  };
  const result = [];
  const resultMap = {
    added: {},
    moved: {},
    removed: {}
  };
  const pairUp = (from, to, xValue, change = "move") => {
    if (from && (isNaN(from.point.x) || isNaN(from.point.y))) {
      from = to;
    }
    const resultPoint = {
      from: from == null ? void 0 : from.point,
      to: to == null ? void 0 : to.point,
      moveTo: calculateMoveTo(from == null ? void 0 : from.point.moveTo, to == null ? void 0 : to.point.moveTo),
      change
    };
    if (change === "move") {
      resultMap.moved[xValue] = resultPoint;
      oldIdx++;
      newIdx++;
    } else if (change === "in") {
      resultMap.added[xValue] = resultPoint;
      newIdx++;
    } else if (change === "out") {
      resultMap.removed[xValue] = resultPoint;
      oldIdx++;
    }
    result.push(resultPoint);
  };
  const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);
  const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);
  let oldIdx = 0;
  let newIdx = 0;
  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {
    const from = oldData.nodeData[oldIdx];
    const to = newData.nodeData[newIdx];
    const fromShifted = from ? toNewScale(from) : void 0;
    const toUnshifted = to ? toOldScale(to) : void 0;
    const NA = void 0;
    if (fromShifted && closeMatch(fromShifted.x, to == null ? void 0 : to.point.x)) {
      pairUp(from, to, to.xValue, "move");
    } else if (fromShifted && fromShifted.x < ((_a = minToNode == null ? void 0 : minToNode.point.x) != null ? _a : -Infinity)) {
      pairUp(from, NA, from.xValue, "out");
    } else if (fromShifted && fromShifted.x > ((_b = maxToNode == null ? void 0 : maxToNode.point.x) != null ? _b : Infinity)) {
      pairUp(from, NA, from.xValue, "out");
    } else if (toUnshifted && toUnshifted.x < ((_c = minFromNode == null ? void 0 : minFromNode.point.x) != null ? _c : -Infinity)) {
      pairUp(NA, to, to.xValue, "in");
    } else if (toUnshifted && toUnshifted.x > ((_d = maxFromNode == null ? void 0 : maxFromNode.point.x) != null ? _d : Infinity)) {
      pairUp(NA, to, to.xValue, "in");
    } else if (fromShifted && fromShifted.x < (to == null ? void 0 : to.point.x)) {
      pairUp(from, NA, from.xValue, "out");
    } else if (toUnshifted && toUnshifted.x < (from == null ? void 0 : from.point.x)) {
      pairUp(NA, to, to.xValue, "in");
    } else if (from) {
      pairUp(from, NA, from.xValue, "out");
    } else if (to) {
      pairUp(NA, to, to.xValue, "in");
    } else {
      throw new Error("Unable to process points");
    }
  }
  backfillPathPointData(result, backfillSplitMode);
  return { result, resultMap };
}
function pairCategoryData(newData, oldData, diff2, opts = {}) {
  var _a, _b, _c;
  const { backfillSplitMode = "intersect", multiDatum = false } = opts;
  const result = [];
  const resultMapSingle = {
    added: {},
    moved: {},
    removed: {}
  };
  const resultMapMulti = {
    added: {},
    moved: {},
    removed: {}
  };
  let previousResultPoint = void 0;
  let previousXValue = void 0;
  const addToResultMap = (xValue, result2) => {
    var _a2, _b2;
    const type = result2.change === "move" ? "moved" : result2.change === "in" ? "added" : "removed";
    if (multiDatum) {
      (_b2 = (_a2 = resultMapMulti[type])[xValue]) != null ? _b2 : _a2[xValue] = [];
      resultMapMulti[type][xValue].push(result2);
    } else {
      resultMapSingle[type][xValue] = result2;
    }
    previousResultPoint = result2;
    previousXValue = transformIntegratedCategoryValue(xValue);
  };
  let oldIndex = 0;
  let newIndex = 0;
  let isXUnordered = false;
  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {
    const before = oldData.nodeData[oldIndex];
    const after = newData.nodeData[newIndex];
    const bXValue = transformIntegratedCategoryValue(before == null ? void 0 : before.xValue);
    const aXValue = transformIntegratedCategoryValue(after == null ? void 0 : after.xValue);
    let resultPoint;
    if (bXValue === aXValue) {
      resultPoint = {
        change: "move",
        moveTo: calculateMoveTo((_a = before.point.moveTo) != null ? _a : false, after.point.moveTo),
        from: before.point,
        to: after.point
      };
      addToResultMap(before == null ? void 0 : before.xValue, resultPoint);
      oldIndex++;
      newIndex++;
    } else if (diff2 !== void 0 && diff2.removed.indexOf(String(bXValue)) >= 0) {
      resultPoint = {
        change: "out",
        moveTo: (_b = before.point.moveTo) != null ? _b : false,
        from: before.point
      };
      addToResultMap(before == null ? void 0 : before.xValue, resultPoint);
      oldIndex++;
    } else if (diff2 !== void 0 && diff2.added.indexOf(String(aXValue)) >= 0) {
      resultPoint = {
        change: "in",
        moveTo: (_c = after.point.moveTo) != null ? _c : false,
        to: after.point
      };
      addToResultMap(after == null ? void 0 : after.xValue, resultPoint);
      newIndex++;
    } else if (multiDatum && previousResultPoint && previousXValue === bXValue) {
      resultPoint = __spreadValues({}, previousResultPoint);
      addToResultMap(before == null ? void 0 : before.xValue, resultPoint);
      oldIndex++;
    } else if (multiDatum && previousResultPoint && previousXValue === aXValue) {
      resultPoint = __spreadValues({}, previousResultPoint);
      addToResultMap(after == null ? void 0 : after.xValue, resultPoint);
      newIndex++;
    } else {
      isXUnordered = true;
      break;
    }
    result.push(resultPoint);
  }
  let previousX = -Infinity;
  isXUnordered || (isXUnordered = result.some((pathPoint) => {
    const { change: marker, to: { x = -Infinity } = {} } = pathPoint;
    if (marker === "out")
      return;
    const result2 = x < previousX;
    previousX = x;
    return result2;
  }));
  if (isXUnordered) {
    return { result: void 0, resultMap: void 0 };
  }
  backfillPathPointData(result, backfillSplitMode);
  if (multiDatum) {
    return { result, resultMap: resultMapMulti };
  }
  return { result, resultMap: resultMapSingle };
}
function determinePathStatus(newData, oldData) {
  let status = "updated";
  const visible = (data) => {
    return data.visible;
  };
  if (!visible(oldData) && visible(newData)) {
    status = "added";
  } else if (visible(oldData) && !visible(newData)) {
    status = "removed";
  }
  return status;
}
function prepareLinePathPropertyAnimation(status, visibleToggleMode) {
  const phase = visibleToggleMode === "none" ? "updated" : status;
  const result = {
    fromFn: (_path) => {
      let mixin;
      if (status === "removed") {
        mixin = { finish: { visible: false } };
      } else if (status === "added") {
        mixin = { start: { visible: true } };
      } else {
        mixin = {};
      }
      return __spreadValues({ phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] }, mixin);
    },
    toFn: (_path) => {
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };
    }
  };
  if (visibleToggleMode === "fade") {
    return {
      fromFn: (path) => {
        const opacity = status === "added" ? 0 : path.opacity;
        return __spreadValues({ opacity }, result.fromFn(path));
      },
      toFn: (path) => {
        const opacity = status === "removed" ? 0 : 1;
        return __spreadValues({ opacity }, result.toFn(path));
      }
    };
  }
  return result;
}
function prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, render) {
  const status = determinePathStatus(newData, oldData);
  const removePhaseFn = (ratio, path) => {
    render(pairData, { move: 0, out: ratio }, path);
  };
  const updatePhaseFn = (ratio, path) => {
    render(pairData, { move: ratio }, path);
  };
  const addPhaseFn = (ratio, path) => {
    render(pairData, { move: 1, in: ratio }, path);
  };
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareLinePathAnimation(newData, oldData, diff2) {
  var _a, _b, _c;
  const isCategoryBased = ((_a = newData.scales.x) == null ? void 0 : _a.type) === "category";
  const wasCategoryBased = ((_b = oldData.scales.x) == null ? void 0 : _b.type) === "category";
  if (isCategoryBased !== wasCategoryBased) {
    return;
  }
  const { result: pairData, resultMap: pairMap } = isCategoryBased ? pairCategoryData(newData, oldData, diff2) : pairContinuousData(newData, oldData);
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  if (pairData === void 0 || pairMap === void 0) {
    return;
  }
  const hasMotion = ((_c = diff2 == null ? void 0 : diff2.changed) != null ? _c : true) || scalesChanged(newData, oldData) || status !== "updated";
  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, "fade", renderPartialPath);
  const marker = prepareMarkerAnimation(pairMap, status);
  return __spreadProps(__spreadValues({}, pathFns), { marker, hasMotion });
}

// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts
var AreaSeriesTag = /* @__PURE__ */ ((AreaSeriesTag2) => {
  AreaSeriesTag2[AreaSeriesTag2["Fill"] = 0] = "Fill";
  AreaSeriesTag2[AreaSeriesTag2["Stroke"] = 1] = "Stroke";
  AreaSeriesTag2[AreaSeriesTag2["Marker"] = 2] = "Marker";
  AreaSeriesTag2[AreaSeriesTag2["Label"] = 3] = "Label";
  return AreaSeriesTag2;
})(AreaSeriesTag || {});
function splitFillPoints(context) {
  const { points } = context.fillData;
  return { top: points.slice(0, points.length / 2), bottom: points.slice(points.length / 2).reverse() };
}
function prepPoints(key, ctx, points) {
  return {
    scales: ctx.scales,
    nodeData: points[key],
    visible: ctx.visible
  };
}
function pairFillCategoryData(newData, oldData, diff2) {
  const oldPoints = splitFillPoints(oldData);
  const newPoints = splitFillPoints(newData);
  const pairOpts = { multiDatum: true };
  return {
    top: pairCategoryData(
      prepPoints("top", newData, newPoints),
      prepPoints("top", oldData, oldPoints),
      diff2,
      pairOpts
    ),
    bottom: pairCategoryData(
      prepPoints("bottom", newData, newPoints),
      prepPoints("bottom", oldData, oldPoints),
      diff2,
      pairOpts
    )
  };
}
function pairFillContinuousData(newData, oldData) {
  const oldPoints = splitFillPoints(oldData);
  const newPoints = splitFillPoints(newData);
  return {
    top: pairContinuousData(prepPoints("top", newData, newPoints), prepPoints("top", oldData, oldPoints)),
    bottom: pairContinuousData(prepPoints("bottom", newData, newPoints), prepPoints("bottom", oldData, oldPoints))
  };
}
function prepareAreaPathAnimation(newData, oldData, diff2) {
  var _a, _b;
  const isCategoryBased = ((_a = newData.scales.x) == null ? void 0 : _a.type) === "category";
  const wasCategoryBased = ((_b = oldData.scales.x) == null ? void 0 : _b.type) === "category";
  if (isCategoryBased !== wasCategoryBased) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const prepareMarkerPairs = () => {
    if (isCategoryBased) {
      return pairCategoryData(newData, oldData, diff2, { backfillSplitMode: "static", multiDatum: true });
    }
    return pairContinuousData(newData, oldData, { backfillSplitMode: "static" });
  };
  const prepareFillPairs = () => {
    if (isCategoryBased) {
      return pairFillCategoryData(newData, oldData, diff2);
    }
    return pairFillContinuousData(newData, oldData);
  };
  const { resultMap: markerPairMap } = prepareMarkerPairs();
  const { top, bottom } = prepareFillPairs();
  if (markerPairMap === void 0 || top.result === void 0 || bottom.result === void 0) {
    return;
  }
  const pairData = [...top.result, ...bottom.result.reverse()];
  const stackVisible = oldData.stackVisible ? newData.stackVisible : false;
  const fadeMode = stackVisible ? "none" : "fade";
  const fill = prepareLinePathAnimationFns(newData, oldData, pairData, fadeMode, renderPartialPath);
  const marker = prepareMarkerAnimation(markerPairMap, status);
  return { fill, marker };
}

// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts
var _AreaSeries = class _AreaSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pathsPerSeries: 2,
      pathsZIndexSubOrderOffset: [0, 1e3],
      hasMarkers: true,
      markerSelectionGarbageCollection: false,
      pickModes: [1 /* NEAREST_BY_MAIN_AXIS_FIRST */, 0 /* EXACT_SHAPE_MATCH */],
      animationResetFns: {
        path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        marker: (node, datum) => __spreadValues(__spreadValues({}, resetMarkerFn()), resetMarkerPositionFn(node, datum))
      }
    });
    this.properties = new AreaSeriesProperties();
  }
  processData(dataController) {
    return __async(this, null, function* () {
      if (this.data == null || !this.properties.isValid()) {
        return;
      }
      const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;
      const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const { isContinuousX, isContinuousY } = this.isContinuous();
      const ids = [
        `area-stack-${groupIndex}-yValues`,
        `area-stack-${groupIndex}-yValues-trailing`,
        `area-stack-${groupIndex}-yValues-prev`,
        `area-stack-${groupIndex}-yValues-trailing-prev`,
        `area-stack-${groupIndex}-yValues-marker`
      ];
      const extraProps = [];
      if (isDefined(normalizedTo)) {
        extraProps.push(normaliseGroupTo(this, [ids[0], ids[1], ids[4]], normalizedTo, "range"));
        extraProps.push(normaliseGroupTo(this, [ids[2], ids[3]], normalizedTo, "range"));
      }
      if (!isContinuousX && animationEnabled && this.processedData) {
        extraProps.push(diff(this.processedData));
      }
      if (animationEnabled) {
        extraProps.push(animationValidation(this));
      }
      const common = { invalidValue: null };
      if (connectMissingData && stackCount > 1) {
        common.invalidValue = 0;
      }
      if (!visible) {
        common.forceValue = 0;
      }
      yield this.requestDataModel(dataController, data, {
        props: [
          keyProperty(this, xKey, isContinuousX, { id: "xValue" }),
          valueProperty(this, yKey, isContinuousY, __spreadValues({ id: `yValueRaw` }, common)),
          ...groupAccumulativeValueProperty(this, yKey, isContinuousY, "window", "current", __spreadProps(__spreadValues({
            id: `yValueEnd`
          }, common), {
            groupId: ids[0]
          })),
          ...groupAccumulativeValueProperty(this, yKey, isContinuousY, "window-trailing", "current", __spreadProps(__spreadValues({
            id: `yValueStart`
          }, common), {
            groupId: ids[1]
          })),
          ...groupAccumulativeValueProperty(this, yKey, isContinuousY, "window", "last", __spreadProps(__spreadValues({
            id: `yValuePreviousEnd`
          }, common), {
            groupId: ids[2]
          })),
          ...groupAccumulativeValueProperty(this, yKey, isContinuousY, "window-trailing", "last", __spreadProps(__spreadValues({
            id: `yValuePreviousStart`
          }, common), {
            groupId: ids[3]
          })),
          ...groupAccumulativeValueProperty(this, yKey, isContinuousY, "normal", "current", __spreadProps(__spreadValues({
            id: `yValueCumulative`
          }, common), {
            groupId: ids[4]
          })),
          ...extraProps
        ],
        groupByKeys: true,
        groupByData: false
      });
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel, axes } = this;
    if (!processedData || !dataModel || processedData.data.length === 0)
      return [];
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
    const yExtent = dataModel.getDomain(this, `yValueEnd`, "value", processedData);
    if (direction === "x" /* X */) {
      if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return fixNumericExtent(extent(keys), xAxis);
    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {
      return fixNumericExtent(yExtent, yAxis);
    } else {
      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];
      return fixNumericExtent(fixedYExtent, yAxis);
    }
  }
  createNodeData() {
    return __async(this, null, function* () {
      var _a;
      const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;
      const xAxis = axes["x" /* X */];
      const yAxis = axes["y" /* Y */];
      if (!xAxis || !yAxis || !data || !dataModel || !this.properties.isValid()) {
        return [];
      }
      const {
        yKey,
        xKey,
        marker,
        label,
        fill: seriesFill,
        stroke: seriesStroke,
        connectMissingData
      } = this.properties;
      const { scale: xScale } = xAxis;
      const { scale: yScale } = yAxis;
      const continuousY = ContinuousScale.is(yScale);
      const xOffset = ((_a = xScale.bandwidth) != null ? _a : 0) / 2;
      const defs = dataModel.resolveProcessedDataDefsByIds(this, [
        `yValueStart`,
        `yValueEnd`,
        `yValueRaw`,
        `yValuePreviousStart`,
        `yValuePreviousEnd`,
        `yValueCumulative`
      ]);
      const createMovePoint = (plainPoint) => {
        const _a2 = plainPoint, { point } = _a2, stroke = __objRest(_a2, ["point"]);
        return __spreadProps(__spreadValues({}, stroke), { point: __spreadProps(__spreadValues({}, point), { moveTo: true }) });
      };
      const createPathCoordinates = (xValue, lastYEnd, yEnd) => {
        const x = xScale.convert(xValue) + xOffset;
        const prevYCoordinate = yScale.convert(lastYEnd);
        const currYCoordinate = yScale.convert(yEnd);
        return [
          { point: { x, y: currYCoordinate }, yValue: yEnd, xValue },
          { point: { x, y: prevYCoordinate }, yValue: lastYEnd, xValue }
        ];
      };
      const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {
        let currY;
        if (isDefined(this.properties.normalizedTo) ? continuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {
          currY = yEnd;
        }
        return {
          x: xScale.convert(xDatum) + xOffset,
          y: yScale.convert(currY),
          size: marker.size
        };
      };
      const itemId = yKey;
      const labelData = [];
      const markerData = [];
      const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
      const context = {
        itemId,
        fillData: { itemId, points: [] },
        strokeData: { itemId, points: [] },
        labelData,
        nodeData: markerData,
        scales: __superGet(_AreaSeries.prototype, this, "calculateScaling").call(this),
        visible: this.visible,
        stackVisible: visibleSameStackCount > 0
      };
      const fillPoints = context.fillData.points;
      const fillPhantomPoints = [];
      const strokePoints = context.strokeData.points;
      let datumIdx = -1;
      let lastXDatum;
      let lastYDatum = -Infinity;
      groupedData == null ? void 0 : groupedData.forEach((datumGroup) => {
        const {
          keys,
          keys: [xDatum],
          datum: datumArray,
          values: valuesArray
        } = datumGroup;
        valuesArray.forEach((values, valueIdx) => {
          var _a2, _b, _c;
          datumIdx++;
          const seriesDatum = datumArray[valueIdx];
          const dataValues = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });
          const { yValueRaw: yDatum, yValueCumulative } = dataValues;
          let { yValueStart, yValueEnd, yValuePreviousStart, yValuePreviousEnd } = dataValues;
          const validPoint = yDatum != null;
          const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);
          if (validPoint && marker) {
            markerData.push({
              index: datumIdx,
              series: this,
              itemId,
              datum: seriesDatum,
              midPoint: { x: point.x, y: point.y },
              cumulativeValue: yValueEnd,
              yValue: yDatum,
              xValue: xDatum,
              yKey,
              xKey,
              point,
              fill: (_a2 = marker.fill) != null ? _a2 : seriesFill,
              stroke: (_b = marker.stroke) != null ? _b : seriesStroke,
              strokeWidth: (_c = marker.strokeWidth) != null ? _c : this.getStrokeWidth(this.properties.strokeWidth)
            });
          }
          if (validPoint && label) {
            const labelText = this.getLabelText(
              label,
              {
                value: yDatum,
                datum: seriesDatum,
                xKey,
                yKey,
                xName: this.properties.xName,
                yName: this.properties.yName
              },
              (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)
            );
            labelData.push({
              index: datumIdx,
              series: this,
              itemId: yKey,
              datum: seriesDatum,
              x: point.x,
              y: point.y,
              label: labelText ? {
                text: labelText,
                fontStyle: label.fontStyle,
                fontWeight: label.fontWeight,
                fontSize: label.fontSize,
                fontFamily: label.fontFamily,
                textAlign: "center",
                textBaseline: "bottom",
                fill: label.color
              } : void 0
            });
          }
          const xValid = lastXDatum != null && xDatum != null;
          const yValid = lastYDatum != null && validPoint;
          if (!yValid) {
            yValueStart = yValueStart != null ? yValueStart : 0;
            yValueEnd = yValueStart != null ? yValueStart : 0;
            yValuePreviousStart = yValuePreviousStart != null ? yValuePreviousStart : 0;
            yValuePreviousEnd = yValuePreviousStart != null ? yValuePreviousStart : 0;
          }
          const [prevTop, prevBottom] = createPathCoordinates(lastXDatum, yValuePreviousStart, yValuePreviousEnd);
          const [top, bottom] = createPathCoordinates(xDatum, yValueStart, yValueEnd);
          if (xValid && (!connectMissingData || yValid)) {
            fillPoints.push(prevTop);
            fillPhantomPoints.push(prevBottom);
            fillPoints.push(top);
            fillPhantomPoints.push(bottom);
          }
          if (yValid && datumIdx > 0) {
            strokePoints.push(createMovePoint(prevTop));
            strokePoints.push(top);
          }
          lastXDatum = xDatum;
          lastYDatum = yDatum;
        });
      });
      if (strokePoints.length > 0) {
        strokePoints[0] = createMovePoint(strokePoints[0]);
      }
      fillPhantomPoints.reverse();
      fillPoints.push(...fillPhantomPoints);
      return [context];
    });
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  updatePathNodes(opts) {
    return __async(this, null, function* () {
      const { opacity, visible, animationEnabled } = opts;
      const [fill, stroke] = opts.paths;
      const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
      stroke.setProperties({
        tag: 1 /* Stroke */,
        fill: void 0,
        lineJoin: stroke.lineCap = "round",
        pointerEvents: 1 /* None */,
        stroke: this.properties.stroke,
        strokeWidth,
        strokeOpacity: this.properties.strokeOpacity,
        lineDash: this.properties.lineDash,
        lineDashOffset: this.properties.lineDashOffset,
        opacity,
        visible
      });
      fill.setProperties({
        tag: 0 /* Fill */,
        stroke: void 0,
        lineJoin: "round",
        pointerEvents: 1 /* None */,
        fill: this.properties.fill,
        fillOpacity: this.properties.fillOpacity,
        lineDash: this.properties.lineDash,
        lineDashOffset: this.properties.lineDashOffset,
        strokeOpacity: this.properties.strokeOpacity,
        fillShadow: this.properties.shadow,
        opacity,
        visible: visible || animationEnabled,
        strokeWidth
      });
      updateClipPath(this, stroke);
      updateClipPath(this, fill);
    });
  }
  updatePaths(opts) {
    return __async(this, null, function* () {
      this.updateAreaPaths([opts.paths], [opts.contextData]);
    });
  }
  updateAreaPaths(paths, contextData) {
    this.updateFillPath(paths, contextData);
    this.updateStrokePath(paths, contextData);
  }
  updateFillPath(paths, contextData) {
    contextData.forEach(({ fillData }, contextDataIndex) => {
      const [fill] = paths[contextDataIndex];
      const { path: fillPath } = fill;
      fillPath.clear({ trackChanges: true });
      for (const { point } of fillData.points) {
        if (point.moveTo) {
          fillPath.moveTo(point.x, point.y);
        } else {
          fillPath.lineTo(point.x, point.y);
        }
      }
      fillPath.closePath();
      fill.checkPathDirty();
    });
  }
  updateStrokePath(paths, contextData) {
    contextData.forEach(({ strokeData }, contextDataIndex) => {
      const [, stroke] = paths[contextDataIndex];
      const { path: strokePath } = stroke;
      strokePath.clear({ trackChanges: true });
      for (const { point } of strokeData.points) {
        if (point.moveTo) {
          strokePath.moveTo(point.x, point.y);
        } else {
          strokePath.lineTo(point.x, point.y);
        }
      }
      stroke.checkPathDirty();
    });
  }
  updateMarkerSelection(opts) {
    return __async(this, null, function* () {
      const { nodeData, markerSelection } = opts;
      if (this.properties.marker.isDirty()) {
        markerSelection.clear();
        markerSelection.cleanup();
      }
      return markerSelection.update(this.properties.marker.enabled ? nodeData : []);
    });
  }
  updateMarkerNodes(opts) {
    return __async(this, null, function* () {
      const { markerSelection, isHighlight: highlighted } = opts;
      const { xKey, yKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;
      const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {
        fill,
        stroke,
        strokeWidth,
        fillOpacity,
        strokeOpacity
      });
      markerSelection.each((node, datum) => {
        this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle);
      });
      if (!highlighted) {
        this.properties.marker.markClean();
      }
    });
  }
  updateLabelSelection(opts) {
    return __async(this, null, function* () {
      const { labelData, labelSelection } = opts;
      return labelSelection.update(labelData, (text) => {
        text.tag = 3 /* Label */;
      });
    });
  }
  updateLabelNodes(opts) {
    return __async(this, null, function* () {
      const { labelSelection } = opts;
      const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;
      labelSelection.each((text, datum) => {
        const { x, y, label } = datum;
        if (label && labelEnabled && this.visible) {
          text.fontStyle = fontStyle;
          text.fontWeight = fontWeight;
          text.fontSize = fontSize;
          text.fontFamily = fontFamily;
          text.textAlign = label.textAlign;
          text.textBaseline = label.textBaseline;
          text.text = label.text;
          text.x = x;
          text.y = y - 10;
          text.fill = color;
          text.visible = true;
        } else {
          text.visible = false;
        }
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    const { id: seriesId, axes, dataModel } = this;
    const { xKey, xName, yName, tooltip, marker } = this.properties;
    const { yKey, xValue, yValue, datum } = nodeDatum;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!this.properties.isValid() || !(xAxis && yAxis && isFiniteNumber(yValue)) || !dataModel) {
      return "";
    }
    const xString = xAxis.formatDatum(xValue);
    const yString = yAxis.formatDatum(yValue);
    const title = sanitizeHtml(yName);
    const content = sanitizeHtml(xString + ": " + yString);
    const baseStyle = mergeDefaults({ fill: this.properties.fill }, marker.getStyle(), {
      stroke: this.properties.stroke,
      strokeWidth: this.properties.strokeWidth
    });
    const { fill: color } = this.getMarkerStyle(
      marker,
      { datum: nodeDatum, xKey, yKey, highlighted: false },
      baseStyle
    );
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        datum,
        xKey,
        xName,
        yKey,
        yName,
        color,
        title,
        seriesId
      }
    );
  }
  getLegendData(legendType) {
    var _a, _b, _c, _d;
    if (!((_a = this.data) == null ? void 0 : _a.length) || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { yKey, yName, fill, stroke, fillOpacity, strokeOpacity, strokeWidth, lineDash, marker, visible } = this.properties;
    const useAreaFill = !marker.enabled || marker.fill === void 0;
    return [
      {
        legendType,
        id: this.id,
        itemId: yKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: yName != null ? yName : yKey
        },
        marker: {
          shape: marker.shape,
          fill: useAreaFill ? fill : marker.fill,
          fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,
          stroke: (_b = marker.stroke) != null ? _b : stroke,
          strokeOpacity: (_c = marker.strokeOpacity) != null ? _c : strokeOpacity,
          strokeWidth: (_d = marker.strokeWidth) != null ? _d : 0,
          enabled: marker.enabled || strokeWidth <= 0
        },
        line: {
          stroke,
          strokeOpacity,
          strokeWidth,
          lineDash
        }
      }
    ];
  }
  animateEmptyUpdateReady(animationData) {
    const { markerSelections, labelSelections, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateAreaPaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, paths.flat());
    resetMotion(markerSelections, resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, markerSelections);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateAreaPaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    var _a, _b;
    const { animationManager } = this.ctx;
    const { markerSelections, labelSelections, contextData, paths, previousContextData } = animationData;
    const [[fill, stroke]] = paths;
    super.resetAllAnimation(animationData);
    const update = () => {
      this.updateAreaPaths(paths, contextData);
      this.updateStrokePath(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData.length === 0 || (previousContextData == null ? void 0 : previousContextData.length) === 0) {
      update();
      markerFadeInAnimation(this, animationManager, markerSelections, "added");
      pathFadeInAnimation(this, "fill_path_properties", animationManager, [fill]);
      pathFadeInAnimation(this, "stroke", animationManager, [stroke], "trailing");
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      return;
    }
    const [newData] = contextData;
    const [oldData] = previousContextData != null ? previousContextData : [];
    const fns = prepareAreaPathAnimation(newData, oldData, (_b = (_a = this.processedData) == null ? void 0 : _a.reduced) == null ? void 0 : _b.diff);
    if (fns === void 0) {
      skip();
      return;
    }
    markerFadeInAnimation(this, animationManager, markerSelections);
    fromToMotion(this.id, "fill_path_properties", animationManager, [fill], fns.fill.pathProperties);
    pathMotion(this.id, "fill_path_update", animationManager, [fill], fns.fill.path);
    this.updateStrokePath(paths, contextData);
    pathFadeInAnimation(this, "stroke", animationManager, [stroke], "trailing");
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Group();
  }
};
_AreaSeries.className = "AreaSeries";
_AreaSeries.type = "area";
var AreaSeries = _AreaSeries;

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts
var AreaSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "area",
  instanceConstructor: AreaSeries,
  stackable: true,
  seriesDefaults: {
    axes: [
      {
        type: "number" /* NUMBER */,
        position: "left" /* LEFT */
      },
      {
        type: "category" /* CATEGORY */,
        position: "bottom" /* BOTTOM */
      }
    ]
  },
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS,
      nodeClickRange: "nearest",
      tooltip: {
        position: {
          type: "node"
        }
      },
      fillOpacity: 0.8,
      strokeOpacity: 1,
      strokeWidth: 0,
      lineDash: [0],
      lineDashOffset: 0,
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      marker: {
        __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,
        enabled: false,
        fillOpacity: 1,
        strokeOpacity: 1,
        strokeWidth: 0
      },
      label: {
        enabled: false,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR,
        formatter: void 0
      }
    }
  },
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory(params);
    return {
      fill: marker.fill,
      stroke: marker.stroke,
      marker
    };
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts
var AbstractBarSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.direction = "vertical";
  }
};
__decorateClass([
  Validate(DIRECTION)
], AbstractBarSeriesProperties.prototype, "direction", 2);
var AbstractBarSeries = class extends CartesianSeries {
  getBandScalePadding() {
    return { inner: 0.2, outer: 0.1 };
  }
  shouldFlipXY() {
    return !this.isVertical();
  }
  isVertical() {
    return this.properties.direction === "vertical";
  }
  getBarDirection() {
    return this.shouldFlipXY() ? "x" /* X */ : "y" /* Y */;
  }
  getCategoryDirection() {
    return this.shouldFlipXY() ? "y" /* Y */ : "x" /* X */;
  }
  getValueAxis() {
    const direction = this.getBarDirection();
    return this.axes[direction];
  }
  getCategoryAxis() {
    const direction = this.getCategoryDirection();
    return this.axes[direction];
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts
var BarSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "inside";
  }
};
__decorateClass([
  Validate(PLACEMENT)
], BarSeriesLabel.prototype, "placement", 2);
var BarSeriesProperties = class extends AbstractBarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.shadow = new DropShadow();
    this.label = new BarSeriesLabel();
    this.tooltip = new SeriesTooltip();
  }
};
__decorateClass([
  Validate(STRING)
], BarSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BarSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING)
], BarSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BarSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Validate(NUMBER, { optional: true })
], BarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Validate(COLOR_STRING)
], BarSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO)
], BarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING)
], BarSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], BarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], BarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], BarSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], BarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], BarSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], BarSeriesProperties.prototype, "formatter", 2);
__decorateClass([
  Validate(OBJECT, { optional: true })
], BarSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], BarSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], BarSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts
function updateRect({ rect, config }) {
  const {
    crisp = true,
    fill,
    stroke,
    strokeWidth,
    fillOpacity,
    strokeOpacity,
    lineDash,
    lineDashOffset,
    fillShadow,
    cornerRadius = 0,
    topLeftCornerRadius,
    topRightCornerRadius,
    bottomRightCornerRadius,
    bottomLeftCornerRadius,
    cornerRadiusBbox,
    visible = true
  } = config;
  rect.crisp = crisp;
  rect.fill = fill;
  rect.stroke = stroke;
  rect.strokeWidth = strokeWidth;
  rect.fillOpacity = fillOpacity;
  rect.strokeOpacity = strokeOpacity;
  rect.lineDash = lineDash;
  rect.lineDashOffset = lineDashOffset;
  rect.fillShadow = fillShadow;
  rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;
  rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;
  rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;
  rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;
  rect.cornerRadiusBbox = cornerRadiusBbox;
  rect.visible = visible;
}
function getRectConfig(_a) {
  var _b = _a, {
    datum,
    isHighlighted,
    style,
    highlightStyle,
    formatter,
    seriesId,
    ctx: { callbackCache }
  } = _b, opts = __objRest(_b, [
    "datum",
    "isHighlighted",
    "style",
    "highlightStyle",
    "formatter",
    "seriesId",
    "ctx"
  ]);
  var _a2, _b2, _c, _d, _e, _f;
  const { fill, fillOpacity, stroke, strokeWidth } = mergeDefaults(isHighlighted && highlightStyle, style);
  const {
    strokeOpacity,
    fillShadow,
    lineDash,
    lineDashOffset,
    cornerRadius = 0,
    topLeftCornerRadius = true,
    topRightCornerRadius = true,
    bottomRightCornerRadius = true,
    bottomLeftCornerRadius = true,
    cornerRadiusBbox
  } = style;
  let format2;
  if (formatter) {
    format2 = callbackCache.call(formatter, __spreadValues({
      datum: datum.datum,
      xKey: datum.xKey,
      fill,
      stroke,
      strokeWidth,
      cornerRadius,
      highlighted: isHighlighted,
      seriesId
    }, opts));
  }
  return {
    fill: (_a2 = format2 == null ? void 0 : format2.fill) != null ? _a2 : fill,
    stroke: (_b2 = format2 == null ? void 0 : format2.stroke) != null ? _b2 : stroke,
    strokeWidth: (_c = format2 == null ? void 0 : format2.strokeWidth) != null ? _c : strokeWidth,
    fillOpacity: (_d = format2 == null ? void 0 : format2.fillOpacity) != null ? _d : fillOpacity,
    strokeOpacity: (_e = format2 == null ? void 0 : format2.strokeOpacity) != null ? _e : strokeOpacity,
    lineDash,
    lineDashOffset,
    fillShadow,
    // @ts-expect-error Remove once corner radius is officially added
    cornerRadius: (_f = format2 == null ? void 0 : format2.cornerRadius) != null ? _f : cornerRadius,
    topLeftCornerRadius,
    topRightCornerRadius,
    bottomRightCornerRadius,
    bottomLeftCornerRadius,
    cornerRadiusBbox
  };
}
function checkCrisp(visibleRange = []) {
  const [visibleMin, visibleMax] = visibleRange;
  const isZoomed = visibleMin !== 0 || visibleMax !== 1;
  return !isZoomed;
}
var isDatumNegative = (datum) => {
  var _a;
  return isNegative((_a = datum.yValue) != null ? _a : 0);
};
function collapsedStartingBarPosition(isVertical, axes, mode) {
  const { startingX, startingY } = getStartingValues(isVertical, axes);
  const calculate = (datum, prevDatum) => {
    let x = isVertical ? datum.x : startingX;
    let y = isVertical ? startingY : datum.y;
    let width = isVertical ? datum.width : 0;
    let height = isVertical ? 0 : datum.height;
    const opacity = datum.opacity;
    if (prevDatum && (isNaN(x) || isNaN(y))) {
      ({ x, y } = prevDatum);
      width = isVertical ? prevDatum.width : 0;
      height = isVertical ? 0 : prevDatum.height;
      if (isVertical && !isDatumNegative(prevDatum)) {
        y += prevDatum.height;
      } else if (!isVertical && isDatumNegative(prevDatum)) {
        x += prevDatum.width;
      }
    }
    return { x, y, width, height, opacity };
  };
  return { isVertical, calculate, mode };
}
function midpointStartingBarPosition(isVertical, mode) {
  return {
    isVertical,
    calculate: (datum) => {
      return {
        x: isVertical ? datum.x : datum.x + datum.width / 2,
        y: isVertical ? datum.y + datum.height / 2 : datum.y,
        width: isVertical ? datum.width : 0,
        height: isVertical ? 0 : datum.height,
        opacity: datum.opacity
      };
    },
    mode
  };
}
function prepareBarAnimationFunctions(initPos) {
  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);
  const fromFn = (rect, datum, status) => {
    if (status === "updated" && isRemoved(datum)) {
      status = "removed";
    } else if (status === "updated" && isRemoved(rect.previousDatum)) {
      status = "added";
    }
    let source = {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      opacity: rect.opacity
    };
    if (status === "added" && rect.previousDatum == null && initPos.mode === "fade") {
      source = __spreadProps(__spreadValues({}, resetBarSelectionsFn(rect, datum)), { opacity: 0 });
    } else if (status === "unknown" || status === "added") {
      source = initPos.calculate(datum, rect.previousDatum);
    }
    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return __spreadProps(__spreadValues({}, source), { phase });
  };
  const toFn = (rect, datum, status) => {
    if (status === "removed" && rect.datum == null && initPos.mode === "fade") {
      return __spreadProps(__spreadValues({}, resetBarSelectionsFn(rect, datum)), { opacity: 0 });
    } else if (status === "removed" || isRemoved(datum)) {
      return initPos.calculate(datum, rect.previousDatum);
    }
    return { x: datum.x, y: datum.y, width: datum.width, height: datum.height, opacity: datum.opacity };
  };
  return { toFn, fromFn };
}
function getStartingValues(isVertical, axes) {
  const axis = axes[isVertical ? "y" /* Y */ : "x" /* X */];
  let startingX = Infinity;
  let startingY = 0;
  if (!axis) {
    return { startingX, startingY };
  }
  if (isVertical) {
    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));
  } else {
    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));
  }
  return { startingX, startingY };
}
function resetBarSelectionsFn(_node, { x, y, width, height, opacity }) {
  return { x, y, width, height, opacity };
}

// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts
function updateLabelNode(textNode, label, labelDatum) {
  if (label.enabled && labelDatum) {
    const { x, y, text, textAlign, textBaseline } = labelDatum;
    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;
    textNode.setProperties({
      visible: true,
      x,
      y,
      text,
      fill,
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily,
      textAlign,
      textBaseline
    });
  } else {
    textNode.visible = false;
  }
}
function adjustLabelPlacement({
  isPositive,
  isVertical,
  placement,
  padding = 0,
  rect
}) {
  let x = rect.x + rect.width / 2;
  let y = rect.y + rect.height / 2;
  let textAlign = "center";
  let textBaseline = "middle";
  switch (placement) {
    case "start": {
      if (isVertical) {
        y = isPositive ? rect.y + rect.height + padding : rect.y - padding;
        textBaseline = isPositive ? "top" : "bottom";
      } else {
        x = isPositive ? rect.x - padding : rect.x + rect.width + padding;
        textAlign = isPositive ? "start" : "end";
      }
      break;
    }
    case "outside":
    case "end": {
      if (isVertical) {
        y = isPositive ? rect.y - padding : rect.y + rect.height + padding;
        textBaseline = isPositive ? "bottom" : "top";
      } else {
        x = isPositive ? rect.x + rect.width + padding : rect.x - padding;
        textAlign = isPositive ? "start" : "end";
      }
      break;
    }
  }
  return { x, y, textAlign, textBaseline };
}

// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts
var _BarSeries = class _BarSeries extends AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [0 /* EXACT_SHAPE_MATCH */],
      pathsPerSeries: 0,
      hasHighlightedLabels: true,
      datumSelectionGarbageCollection: false,
      animationAlwaysUpdateSelections: true,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new BarSeriesProperties();
    /**
     * Used to get the position of bars within each group.
     */
    this.groupScale = new BandScale();
    this.smallestDataInterval = void 0;
  }
  resolveKeyDirection(direction) {
    if (this.getBarDirection() === "x" /* X */) {
      if (direction === "x" /* X */) {
        return "y" /* Y */;
      }
      return "x" /* X */;
    }
    return direction;
  }
  processData(dataController) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      if (!this.properties.isValid() || !this.data) {
        return;
      }
      const { seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;
      const { xKey, yKey, normalizedTo } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const normalizedToAbs = Math.abs(normalizedTo != null ? normalizedTo : NaN);
      const isContinuousX = ContinuousScale.is((_a = this.getCategoryAxis()) == null ? void 0 : _a.scale);
      const isContinuousY = ContinuousScale.is((_b = this.getValueAxis()) == null ? void 0 : _b.scale);
      const stackGroupName = `bar-stack-${groupIndex}-yValues`;
      const stackGroupTrailingName = `${stackGroupName}-trailing`;
      const normaliseTo = normalizedToAbs && isFinite(normalizedToAbs) ? normalizedToAbs : void 0;
      const extraProps = [];
      if (normaliseTo) {
        extraProps.push(normaliseGroupTo(this, [stackGroupName, stackGroupTrailingName], normaliseTo, "range"));
      }
      if (animationEnabled && this.processedData) {
        extraProps.push(diff(this.processedData));
      }
      if (animationEnabled) {
        extraProps.push(animationValidation(this));
      }
      const visibleProps = !this.visible ? { forceValue: 0 } : {};
      const { processedData } = yield this.requestDataModel(dataController, data, {
        props: [
          keyProperty(this, xKey, isContinuousX, { id: "xValue" }),
          valueProperty(this, yKey, isContinuousY, __spreadValues({ id: `yValue-raw`, invalidValue: null }, visibleProps)),
          ...groupAccumulativeValueProperty(this, yKey, isContinuousY, "normal", "current", __spreadValues({
            id: `yValue-end`,
            rangeId: `yValue-range`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupName,
            separateNegative: true
          }, visibleProps)),
          ...groupAccumulativeValueProperty(this, yKey, isContinuousY, "trailing", "current", __spreadValues({
            id: `yValue-start`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupTrailingName,
            separateNegative: true
          }, visibleProps)),
          ...isContinuousX ? [SMALLEST_KEY_INTERVAL] : [],
          ...extraProps
        ],
        groupByKeys: true,
        groupByData: false
      });
      this.smallestDataInterval = {
        x: (_d = (_c = processedData.reduced) == null ? void 0 : _c.smallestKeyInterval) != null ? _d : Infinity,
        y: Infinity
      };
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    var _a;
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel || processedData.data.length === 0)
      return [];
    const { reduced: { [SMALLEST_KEY_INTERVAL.property]: smallestX } = {} } = processedData;
    const categoryAxis = this.getCategoryAxis();
    const valueAxis = this.getValueAxis();
    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
    const yExtent = dataModel.getDomain(this, `yValue-end`, "value", processedData);
    if (direction === this.getCategoryDirection()) {
      if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && (keyDef == null ? void 0 : keyDef.def.valueType) === "category") {
        return keys;
      }
      const scalePadding = smallestX != null && isFinite(smallestX) ? smallestX : 0;
      const keysExtent = (_a = extent(keys)) != null ? _a : [NaN, NaN];
      const isReversed = categoryAxis == null ? void 0 : categoryAxis.isReversed();
      if (direction === "y" /* Y */) {
        const d02 = keysExtent[0] + (isReversed ? 0 : -scalePadding);
        const d12 = keysExtent[1] + (isReversed ? scalePadding : 0);
        return fixNumericExtent([d02, d12], categoryAxis);
      }
      const d0 = keysExtent[0] + (isReversed ? -scalePadding : 0);
      const d1 = keysExtent[1] + (isReversed ? 0 : scalePadding);
      return fixNumericExtent([d0, d1], categoryAxis);
    } else if (this.getValueAxis() instanceof LogAxis) {
      return fixNumericExtent(yExtent, valueAxis);
    } else {
      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];
      return fixNumericExtent(fixedYExtent, valueAxis);
    }
  }
  createNodeData() {
    return __async(this, null, function* () {
      const { dataModel } = this;
      const xAxis = this.getCategoryAxis();
      const yAxis = this.getValueAxis();
      if (!(dataModel && xAxis && yAxis && this.properties.isValid())) {
        return [];
      }
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const {
        groupScale,
        processedData,
        smallestDataInterval,
        ctx: { seriesStateManager }
      } = this;
      const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius, legendItemName, label } = this.properties;
      const yReversed = yAxis.isReversed();
      const xBandWidth = ContinuousScale.is(xScale) ? xScale.calcBandwidth(smallestDataInterval == null ? void 0 : smallestDataInterval.x) : xScale.bandwidth;
      const domain = [];
      const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);
      for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {
        domain.push(String(groupIdx));
      }
      groupScale.domain = domain;
      groupScale.range = [0, xBandWidth != null ? xBandWidth : 0];
      if (xAxis instanceof CategoryAxis) {
        groupScale.paddingInner = xAxis.groupPaddingInner;
      } else if (xAxis instanceof GroupedCategoryAxis) {
        groupScale.padding = 0.1;
      } else {
        groupScale.padding = 0;
      }
      groupScale.round = groupScale.padding !== 0;
      const barWidth = groupScale.bandwidth >= 1 ? (
        // Pixel-rounded value for low-volume bar charts.
        groupScale.bandwidth
      ) : (
        // Handle high-volume bar charts gracefully.
        groupScale.rawBandwidth
      );
      const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;
      const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`).index;
      const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`).index;
      const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`).index;
      const yRangeIndex = dataModel.resolveProcessedDataDefById(this, `yValue-range`).index;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const contexts = [];
      processedData == null ? void 0 : processedData.data.forEach(({ keys, datum: seriesDatum, values, aggValues }) => {
        values.forEach((value, contextIndex) => {
          var _a, _b;
          (_a = contexts[contextIndex]) != null ? _a : contexts[contextIndex] = {
            itemId: yKey,
            nodeData: [],
            labelData: [],
            scales: __superGet(_BarSeries.prototype, this, "calculateScaling").call(this),
            visible: this.visible || animationEnabled
          };
          const xValue = keys[xIndex];
          const x = xScale.convert(xValue);
          const currY = +value[yEndIndex];
          const prevY = +value[yStartIndex];
          const yRawValue = value[yRawIndex];
          const isPositive = yRawValue >= 0;
          const isUpward = isPositive !== yReversed;
          const yRange = (_b = aggValues == null ? void 0 : aggValues[yRangeIndex][isPositive ? 1 : 0]) != null ? _b : 0;
          const barX = x + groupScale.convert(String(groupIndex));
          if (isNaN(currY)) {
            return;
          }
          const y = yScale.convert(currY);
          const bottomY = yScale.convert(prevY);
          const barAlongX = this.getBarDirection() === "x" /* X */;
          const bboxHeight = yScale.convert(yRange);
          const bboxBottom = yScale.convert(0);
          const cornerRadiusBbox = new BBox(
            barAlongX ? Math.min(bboxBottom, bboxHeight) : barX,
            barAlongX ? barX : Math.min(bboxBottom, bboxHeight),
            barAlongX ? Math.abs(bboxBottom - bboxHeight) : barWidth,
            barAlongX ? barWidth : Math.abs(bboxBottom - bboxHeight)
          );
          const rect = {
            x: barAlongX ? Math.min(y, bottomY) : barX,
            y: barAlongX ? barX : Math.min(y, bottomY),
            width: barAlongX ? Math.abs(bottomY - y) : barWidth,
            height: barAlongX ? barWidth : Math.abs(bottomY - y),
            cornerRadiusBbox
          };
          const {
            fontStyle: labelFontStyle,
            fontWeight: labelFontWeight,
            fontSize: labelFontSize,
            fontFamily: labelFontFamily,
            color: labelColor,
            placement
          } = label;
          const labelText = this.getLabelText(
            this.properties.label,
            {
              datum: seriesDatum[contextIndex],
              value: yRawValue,
              xKey,
              yKey,
              xName,
              yName,
              legendItemName
            },
            (value2) => isFiniteNumber(value2) ? value2.toFixed(2) : ""
          );
          const labelDatum = labelText ? __spreadValues({
            text: labelText,
            fill: labelColor,
            fontStyle: labelFontStyle,
            fontWeight: labelFontWeight,
            fontSize: labelFontSize,
            fontFamily: labelFontFamily
          }, adjustLabelPlacement({
            isPositive,
            isVertical: !barAlongX,
            placement,
            rect
          })) : void 0;
          const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;
          const nodeData = {
            series: this,
            itemId: yKey,
            datum: seriesDatum[contextIndex],
            cumulativeValue: currY,
            xValue,
            yValue: yRawValue,
            yKey,
            xKey,
            capDefaults: {
              lengthRatioMultiplier,
              lengthMax: lengthRatioMultiplier
            },
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height,
            midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },
            fill,
            stroke,
            opacity: 1,
            strokeWidth,
            cornerRadius,
            topLeftCornerRadius: !(barAlongX === isUpward),
            topRightCornerRadius: isUpward,
            bottomRightCornerRadius: barAlongX === isUpward,
            bottomLeftCornerRadius: !isUpward,
            cornerRadiusBbox,
            label: labelDatum
          };
          contexts[contextIndex].nodeData.push(nodeData);
          contexts[contextIndex].labelData.push(nodeData);
        });
      });
      return contexts;
    });
  }
  nodeFactory() {
    return new Rect();
  }
  updateDatumSelection(opts) {
    return __async(this, null, function* () {
      return opts.datumSelection.update(
        opts.nodeData,
        (rect) => {
          rect.tag = 0 /* Bar */;
        },
        (datum) => createDatumId(datum.xValue)
      );
    });
  }
  updateDatumNodes(opts) {
    return __async(this, null, function* () {
      if (!this.properties.isValid()) {
        return;
      }
      const {
        yKey,
        stackGroup,
        fill,
        fillOpacity,
        stroke,
        strokeWidth,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        formatter,
        shadow,
        highlightStyle: { item: itemHighlightStyle }
      } = this.properties;
      const xAxis = this.axes["x" /* X */];
      const crisp = checkCrisp(xAxis == null ? void 0 : xAxis.visibleRange);
      const categoryAlongX = this.getCategoryDirection() === "x" /* X */;
      opts.datumSelection.each((rect, datum) => {
        const style = {
          fill,
          stroke,
          fillOpacity,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          fillShadow: shadow,
          strokeWidth: this.getStrokeWidth(strokeWidth),
          cornerRadius: datum.cornerRadius,
          topLeftCornerRadius: datum.topLeftCornerRadius,
          topRightCornerRadius: datum.topRightCornerRadius,
          bottomRightCornerRadius: datum.bottomRightCornerRadius,
          bottomLeftCornerRadius: datum.bottomLeftCornerRadius,
          cornerRadiusBbox: datum.cornerRadiusBbox
        };
        const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
        const config = getRectConfig({
          datum,
          ctx: this.ctx,
          seriesId: this.id,
          isHighlighted: opts.isHighlight,
          highlightStyle: itemHighlightStyle,
          yKey,
          style,
          formatter,
          stackGroup
        });
        config.crisp = crisp;
        config.visible = visible;
        updateRect({ rect, config });
      });
    });
  }
  updateLabelSelection(opts) {
    return __async(this, null, function* () {
      const data = this.isLabelEnabled() ? opts.labelData : [];
      return opts.labelSelection.update(data, (text) => {
        text.tag = 1 /* Label */;
        text.pointerEvents = 1 /* None */;
      });
    });
  }
  updateLabelNodes(opts) {
    return __async(this, null, function* () {
      opts.labelSelection.each((textNode, datum) => {
        updateLabelNode(textNode, this.properties.label, datum.label);
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a;
    const {
      id: seriesId,
      processedData,
      ctx: { callbackCache }
    } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!processedData || !this.properties.isValid() || !xAxis || !yAxis) {
      return "";
    }
    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, tooltip, formatter, stackGroup } = this.properties;
    const { xValue, yValue, datum } = nodeDatum;
    const xString = xAxis.formatDatum(xValue);
    const yString = yAxis.formatDatum(yValue);
    const title = sanitizeHtml(yName);
    const content = sanitizeHtml(xString + ": " + yString);
    let format2;
    if (formatter) {
      format2 = callbackCache.call(formatter, {
        seriesId,
        datum,
        xKey,
        yKey,
        stackGroup,
        fill,
        stroke,
        strokeWidth: this.getStrokeWidth(strokeWidth),
        highlighted: false
      });
    }
    const color = (_a = format2 == null ? void 0 : format2.fill) != null ? _a : fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      __spreadValues({
        seriesId,
        datum,
        xKey,
        yKey,
        xName,
        yName,
        stackGroup,
        title,
        color
      }, this.getModuleTooltipParams())
    );
  }
  getLegendData(legendType) {
    var _a, _b;
    const { showInLegend } = this.properties;
    if (legendType !== "category" || !((_a = this.data) == null ? void 0 : _a.length) || !this.properties.isValid() || !showInLegend) {
      return [];
    }
    const { yKey, yName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, legendItemName, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: yKey,
        seriesId: this.id,
        enabled: visible,
        label: { text: (_b = legendItemName != null ? legendItemName : yName) != null ? _b : yKey },
        marker: { fill, fillOpacity, stroke, strokeWidth, strokeOpacity },
        legendItemName
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelections, labelSelections, annotationSelections }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, "normal"));
    fromToMotion(this.id, "nodes", this.ctx.animationManager, datumSelections, fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelections);
    seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, annotationSelections);
  }
  animateWaitingUpdateReady(data) {
    var _a, _b, _c;
    const { datumSelections, labelSelections, annotationSelections, previousContextData } = data;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const diff2 = (_b = (_a = this.processedData) == null ? void 0 : _a.reduced) == null ? void 0 : _b.diff;
    const mode = (previousContextData == null ? void 0 : previousContextData.length) === 0 ? "fade" : "normal";
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));
    fromToMotion(
      this.id,
      "nodes",
      this.ctx.animationManager,
      datumSelections,
      fns,
      (_, datum) => createDatumId(datum.xValue),
      diff2
    );
    const hasMotion = (_c = diff2 == null ? void 0 : diff2.changed) != null ? _c : true;
    if (hasMotion) {
      seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, annotationSelections);
    }
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
};
_BarSeries.className = "BarSeries";
_BarSeries.type = "bar";
var BarSeries = _BarSeries;

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts
var BarSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "bar",
  instanceConstructor: BarSeries,
  stackable: true,
  groupable: true,
  seriesDefaults: {
    axes: [
      {
        type: "number" /* NUMBER */,
        position: "left" /* LEFT */
      },
      {
        type: "category" /* CATEGORY */,
        position: "bottom" /* BOTTOM */
      }
    ]
  },
  swapDefaultAxesCondition: (series) => (series == null ? void 0 : series.direction) === "horizontal",
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS,
      direction: "vertical",
      fillOpacity: 1,
      strokeWidth: 0,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        enabled: false,
        fontStyle: void 0,
        fontWeight: "normal" /* NORMAL */,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
        formatter: void 0,
        placement: "inside"
      },
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      }
    }
  },
  enterpriseThemeTemplate: {
    series: {
      errorBar: {
        cap: {
          lengthRatio: 0.3
        }
      }
    }
  },
  paletteFactory: singleSeriesPaletteFactory
};

// packages/ag-charts-community/src/scale/colorScale.ts
var convertColorStringToOklcha = (v) => {
  const color = Color.fromString(v);
  const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);
  return { l, c, h, a: color.a };
};
var interpolateOklch = (x, y, d) => {
  d = clamp(0, d, 1);
  let h;
  let c;
  if (Number.isNaN(x.h) && Number.isNaN(y.h)) {
    h = 0;
    c = 0;
  } else if (Number.isNaN(x.h)) {
    h = y.h;
    c = y.c;
  } else if (Number.isNaN(y.h)) {
    h = x.h;
    c = x.c;
  } else {
    const xH = x.h;
    let yH = y.h;
    const deltaH = y.h - x.h;
    if (deltaH > 180) {
      yH -= 360;
    } else if (deltaH < -180) {
      yH += 360;
    }
    h = xH * (1 - d) + yH * d;
    c = x.c * (1 - d) + y.c * d;
  }
  const l = x.l * (1 - d) + y.l * d;
  const a = x.a * (1 - d) + y.a * d;
  return Color.fromOKLCH(l, c, h, a);
};
var ColorScale = class {
  constructor() {
    this.invalid = true;
    this.domain = [0, 1];
    this.range = ["red", "blue"];
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  update() {
    const { domain, range: range3 } = this;
    if (domain.length < 2) {
      Logger.warnOnce("`colorDomain` should have at least 2 values.");
      if (domain.length === 0) {
        domain.push(0, 1);
      } else if (domain.length === 1) {
        domain.push(domain[0] + 1);
      }
    }
    for (let i = 1; i < domain.length; i++) {
      const a = domain[i - 1];
      const b = domain[i];
      if (a >= b) {
        Logger.warnOnce("`colorDomain` values should be supplied in ascending order.");
        domain.sort((a2, b2) => a2 - b2);
        break;
      }
    }
    if (range3.length < domain.length) {
      for (let i = range3.length; i < domain.length; i++) {
        range3.push(range3.length > 0 ? range3[0] : "black");
      }
    }
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  convert(x) {
    this.refresh();
    const { domain, range: range3, parsedRange } = this;
    const d0 = domain[0];
    const d1 = domain.at(-1);
    const r0 = range3[0];
    const r1 = range3[range3.length - 1];
    if (x <= d0) {
      return r0;
    }
    if (x >= d1) {
      return r1;
    }
    let index;
    let q;
    if (domain.length === 2) {
      const t = (x - d0) / (d1 - d0);
      const step = 1 / (range3.length - 1);
      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);
      q = (t - index * step) / step;
    } else {
      for (index = 0; index < domain.length - 2; index++) {
        if (x < domain[index + 1]) {
          break;
        }
      }
      const a = domain[index];
      const b = domain[index + 1];
      q = (x - a) / (b - a);
    }
    const c0 = parsedRange[index];
    const c1 = parsedRange[index + 1];
    return interpolateOklch(c0, c1, q).toRgbaString();
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      Logger.warnOnce("Expected update to not invalidate scale");
    }
  }
};
__decorateClass([
  Invalidating
], ColorScale.prototype, "domain", 2);
__decorateClass([
  Invalidating
], ColorScale.prototype, "range", 2);

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts
var BubbleSeriesMarker = class extends SeriesMarker {
  constructor() {
    super(...arguments);
    this.maxSize = 30;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], BubbleSeriesMarker.prototype, "maxSize", 2);
__decorateClass([
  Validate(NUMBER_ARRAY, { optional: true }),
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], BubbleSeriesMarker.prototype, "domain", 2);
var BubbleSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.colorRange = ["#ffff00", "#00ff00", "#0000ff"];
    this.marker = new BubbleSeriesMarker();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
  }
};
__decorateClass([
  Validate(STRING)
], BubbleSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING)
], BubbleSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING)
], BubbleSeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Validate(NUMBER_ARRAY, { optional: true })
], BubbleSeriesProperties.prototype, "colorDomain", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], BubbleSeriesProperties.prototype, "colorRange", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], BubbleSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate(OBJECT)
], BubbleSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], BubbleSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], BubbleSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts
var BubbleSeriesNodeClickEvent = class extends CartesianSeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.sizeKey = series.properties.sizeKey;
  }
};
var _BubbleSeries = class _BubbleSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [
        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,
        3 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: 0,
      hasMarkers: true,
      markerSelectionGarbageCollection: false,
      animationResetFns: {
        label: resetLabelFn,
        marker: resetMarkerFn
      }
    });
    this.NodeClickEvent = BubbleSeriesNodeClickEvent;
    this.properties = new BubbleSeriesProperties();
    this.sizeScale = new LinearScale();
    this.colorScale = new ColorScale();
  }
  processData(dataController) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.properties.isValid() || this.data == null) {
        return;
      }
      const { isContinuousX, isContinuousY } = this.isContinuous();
      const { xKey, yKey, sizeKey, labelKey, colorDomain, colorRange, colorKey, marker } = this.properties;
      const { dataModel, processedData } = yield this.requestDataModel(dataController, this.data, {
        props: [
          keyProperty(this, xKey, isContinuousX, { id: "xKey-raw" }),
          keyProperty(this, yKey, isContinuousY, { id: "yKey-raw" }),
          ...labelKey ? [keyProperty(this, labelKey, false, { id: `labelKey-raw` })] : [],
          valueProperty(this, xKey, isContinuousX, { id: `xValue` }),
          valueProperty(this, yKey, isContinuousY, { id: `yValue` }),
          valueProperty(this, sizeKey, true, { id: `sizeValue` }),
          ...colorKey ? [valueProperty(this, colorKey, true, { id: `colorValue` })] : [],
          ...labelKey ? [valueProperty(this, labelKey, false, { id: `labelValue` })] : []
        ],
        dataVisible: this.visible
      });
      const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`).index;
      const processedSize = (_a = processedData.domain.values[sizeKeyIdx]) != null ? _a : [];
      this.sizeScale.domain = marker.domain ? marker.domain : processedSize;
      if (colorKey) {
        const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`).index;
        this.colorScale.domain = (_b = colorDomain != null ? colorDomain : processedData.domain.values[colorKeyIdx]) != null ? _b : [];
        this.colorScale.range = colorRange;
        this.colorScale.update();
      }
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    const id = direction === "x" /* X */ ? `xValue` : `yValue`;
    const dataDef = dataModel.resolveProcessedDataDefById(this, id);
    const domain = dataModel.getDomain(this, id, "value", processedData);
    if ((dataDef == null ? void 0 : dataDef.def.type) === "value" && (dataDef == null ? void 0 : dataDef.def.valueType) === "category") {
      return domain;
    }
    const axis = this.axes[direction];
    return fixNumericExtent(extent(domain), axis);
  }
  createNodeData() {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const { axes, dataModel, processedData, colorScale, sizeScale } = this;
      const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, label, colorKey, marker, visible } = this.properties;
      const xAxis = axes["x" /* X */];
      const yAxis = axes["y" /* Y */];
      if (!(dataModel && processedData && visible && xAxis && yAxis)) {
        return [];
      }
      const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;
      const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;
      const sizeDataIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`).index : -1;
      const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`).index : -1;
      const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`).index : -1;
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const xOffset = ((_a = xScale.bandwidth) != null ? _a : 0) / 2;
      const yOffset = ((_b = yScale.bandwidth) != null ? _b : 0) / 2;
      const nodeData = [];
      sizeScale.range = [marker.size, marker.maxSize];
      const font = label.getFont();
      for (const { values, datum } of (_c = processedData.data) != null ? _c : []) {
        const xDatum = values[xDataIdx];
        const yDatum = values[yDataIdx];
        const x = xScale.convert(xDatum) + xOffset;
        const y = yScale.convert(yDatum) + yOffset;
        const labelText = this.getLabelText(label, {
          value: labelKey ? values[labelDataIdx] : yDatum,
          datum,
          xKey,
          yKey,
          sizeKey,
          labelKey,
          xName,
          yName,
          sizeName,
          labelName
        });
        const size = HdpiCanvas.getTextSize(String(labelText), font);
        const markerSize = sizeKey ? sizeScale.convert(values[sizeDataIdx]) : marker.size;
        const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;
        nodeData.push({
          series: this,
          itemId: yKey,
          yKey,
          xKey,
          datum,
          xValue: xDatum,
          yValue: yDatum,
          sizeValue: values[sizeDataIdx],
          point: { x, y, size: markerSize },
          midPoint: { x, y },
          fill,
          label: __spreadValues({ text: labelText }, size)
        });
      }
      return [
        {
          itemId: yKey,
          nodeData,
          labelData: nodeData,
          scales: __superGet(_BubbleSeries.prototype, this, "calculateScaling").call(this),
          visible: this.visible
        }
      ];
    });
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  getLabelData() {
    var _a;
    return (_a = this.contextNodeData) == null ? void 0 : _a.reduce((r, n) => r.concat(n.labelData), []);
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  updateMarkerSelection(opts) {
    return __async(this, null, function* () {
      const { nodeData, markerSelection } = opts;
      if (this.properties.marker.isDirty()) {
        markerSelection.clear();
        markerSelection.cleanup();
      }
      const data = this.properties.marker.enabled ? nodeData : [];
      return markerSelection.update(
        data,
        void 0,
        (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])
      );
    });
  }
  updateMarkerNodes(opts) {
    return __async(this, null, function* () {
      const { markerSelection, isHighlight: highlighted } = opts;
      const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
      const baseStyle = mergeDefaults(highlighted && this.properties.highlightStyle.item, marker.getStyle());
      this.sizeScale.range = [marker.size, marker.maxSize];
      markerSelection.each((node, datum) => {
        this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle);
      });
      if (!highlighted) {
        this.properties.marker.markClean();
      }
    });
  }
  updateLabelSelection(opts) {
    return __async(this, null, function* () {
      var _a, _b;
      const placedLabels = this.properties.label.enabled ? (_b = (_a = this.chart) == null ? void 0 : _a.placeLabels().get(this)) != null ? _b : [] : [];
      return opts.labelSelection.update(
        placedLabels.map((v) => __spreadProps(__spreadValues({}, v.datum), {
          point: {
            x: v.x,
            y: v.y,
            size: v.datum.point.size
          }
        }))
      );
    });
  }
  updateLabelNodes(opts) {
    return __async(this, null, function* () {
      const { label } = this.properties;
      opts.labelSelection.each((text, datum) => {
        var _a, _b, _c, _d;
        text.text = datum.label.text;
        text.fill = label.color;
        text.x = (_b = (_a = datum.point) == null ? void 0 : _a.x) != null ? _b : 0;
        text.y = (_d = (_c = datum.point) == null ? void 0 : _c.y) != null ? _d : 0;
        text.fontStyle = label.fontStyle;
        text.fontWeight = label.fontWeight;
        text.fontSize = label.fontSize;
        text.fontFamily = label.fontFamily;
        text.textAlign = "left";
        text.textBaseline = "top";
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a;
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return "";
    }
    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, marker, tooltip } = this.properties;
    const title = (_a = this.properties.title) != null ? _a : yName;
    const baseStyle = mergeDefaults(
      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },
      marker.getStyle()
    );
    const { fill: color = "gray" } = this.getMarkerStyle(
      marker,
      { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey },
      baseStyle
    );
    const {
      datum,
      xValue,
      yValue,
      sizeValue,
      label: { text: labelText }
    } = nodeDatum;
    const xString = sanitizeHtml(xAxis.formatDatum(xValue));
    const yString = sanitizeHtml(yAxis.formatDatum(yValue));
    let content = `<b>${sanitizeHtml(xName != null ? xName : xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName != null ? yName : yKey)}</b>: ${yString}`;
    if (sizeKey) {
      content += `<br><b>${sanitizeHtml(sizeName != null ? sizeName : sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;
    }
    if (labelKey) {
      content = `<b>${sanitizeHtml(labelName != null ? labelName : labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;
    }
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        datum,
        xKey,
        xName,
        yKey,
        yName,
        sizeKey,
        sizeName,
        labelKey,
        labelName,
        title,
        color,
        seriesId: this.id
      }
    );
  }
  getLegendData() {
    var _a, _b;
    if (!((_a = this.data) == null ? void 0 : _a.length) || !this.properties.isValid()) {
      return [];
    }
    const { yKey, yName, title, marker, visible } = this.properties;
    const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: yKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: (_b = title != null ? title : yName) != null ? _b : yKey
        },
        marker: {
          shape,
          fill: fill != null ? fill : "rgba(0, 0, 0, 0)",
          stroke: stroke != null ? stroke : "rgba(0, 0, 0, 0)",
          fillOpacity: fillOpacity != null ? fillOpacity : 1,
          strokeOpacity: strokeOpacity != null ? strokeOpacity : 1,
          strokeWidth: strokeWidth != null ? strokeWidth : 0
        }
      }
    ];
  }
  animateEmptyUpdateReady({ markerSelections, labelSelections }) {
    markerScaleInAnimation(this, this.ctx.animationManager, markerSelections);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelections);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Group();
  }
};
_BubbleSeries.className = "BubbleSeries";
_BubbleSeries.type = "bubble";
var BubbleSeries = _BubbleSeries;

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts
var BubbleSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "bubble",
  instanceConstructor: BubbleSeries,
  seriesDefaults: {
    axes: [
      {
        type: "number" /* NUMBER */,
        position: "bottom" /* BOTTOM */
      },
      {
        type: "number" /* NUMBER */,
        position: "left" /* LEFT */
      }
    ]
  },
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS,
      tooltip: {
        position: {
          type: "node"
        }
      },
      marker: {
        __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,
        maxSize: 30,
        fillOpacity: 0.8
      },
      label: {
        enabled: false,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR
      }
    }
  },
  paletteFactory: markerPaletteFactory
};

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts
var HistogramSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.areaPlot = false;
    this.aggregation = "sum";
    this.shadow = new DropShadow();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
  }
};
__decorateClass([
  Validate(STRING)
], HistogramSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], HistogramSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], HistogramSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], HistogramSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], HistogramSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO)
], HistogramSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(COLOR_STRING, { optional: true })
], HistogramSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], HistogramSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], HistogramSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], HistogramSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], HistogramSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(BOOLEAN)
], HistogramSeriesProperties.prototype, "areaPlot", 2);
__decorateClass([
  Validate(ARRAY, { optional: true })
], HistogramSeriesProperties.prototype, "bins", 2);
__decorateClass([
  Validate(UNION(["count", "sum", "mean"], "a histogram aggregation"))
], HistogramSeriesProperties.prototype, "aggregation", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], HistogramSeriesProperties.prototype, "binCount", 2);
__decorateClass([
  Validate(OBJECT)
], HistogramSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], HistogramSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], HistogramSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts
var defaultBinCount = 10;
var _HistogramSeries = class _HistogramSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [0 /* EXACT_SHAPE_MATCH */],
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new HistogramSeriesProperties();
    this.calculatedBins = [];
  }
  // During processData phase, used to unify different ways of the user specifying
  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].
  deriveBins(xDomain) {
    if (this.properties.binCount) {
      return this.calculateNiceBins(xDomain, this.properties.binCount);
    }
    const binStarts = ticks_default(xDomain[0], xDomain[1], defaultBinCount);
    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);
    const [firstBinEnd] = binStarts;
    const expandStartToBin = (n) => [n, n + binSize];
    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];
  }
  calculateNiceBins(domain, binCount) {
    const startGuess = Math.floor(domain[0]);
    const stop = domain[1];
    const segments = binCount || 1;
    const { start, binSize } = this.calculateNiceStart(startGuess, stop, segments);
    return this.getBins(start, stop, binSize, segments);
  }
  getBins(start, stop, step, count2) {
    const bins = [];
    const precision = this.calculatePrecision(step);
    for (let i = 0; i < count2; i++) {
      const a = Math.round((start + i * step) * precision) / precision;
      let b = Math.round((start + (i + 1) * step) * precision) / precision;
      if (i === count2 - 1) {
        b = Math.max(b, stop);
      }
      bins[i] = [a, b];
    }
    return bins;
  }
  calculatePrecision(step) {
    let precision = 10;
    if (isFinite(step) && step > 0) {
      while (step < 1) {
        precision *= 10;
        step *= 10;
      }
    }
    return precision;
  }
  calculateNiceStart(a, b, segments) {
    const binSize = Math.abs(b - a) / segments;
    const order = Math.floor(Math.log10(binSize));
    const magnitude = Math.pow(10, order);
    const start = Math.floor(a / magnitude) * magnitude;
    return {
      start,
      binSize
    };
  }
  processData(dataController) {
    return __async(this, null, function* () {
      var _a;
      const { xKey, yKey, areaPlot, aggregation } = this.properties;
      const props = [keyProperty(this, xKey, true), SORT_DOMAIN_GROUPS];
      if (yKey) {
        let aggProp = groupCount(this, "groupCount");
        if (aggregation === "count") ; else if (aggregation === "sum") {
          aggProp = groupSum(this, "groupAgg");
        } else if (aggregation === "mean") {
          aggProp = groupAverage(this, "groupAgg");
        }
        if (areaPlot) {
          aggProp = area(this, "groupAgg", aggProp);
        }
        props.push(valueProperty(this, yKey, true, { invalidValue: void 0 }), aggProp);
      } else {
        let aggProp = groupCount(this, "groupAgg");
        if (areaPlot) {
          aggProp = area(this, "groupAgg", aggProp);
        }
        props.push(aggProp);
      }
      const groupByFn = (dataSet) => {
        var _a2;
        const xExtent = fixNumericExtent(dataSet.domain.keys[0]);
        if (xExtent.length === 0) {
          dataSet.domain.groups = [];
          return () => [];
        }
        const bins = (_a2 = this.properties.bins) != null ? _a2 : this.deriveBins(xExtent);
        const binCount = bins.length;
        this.calculatedBins = [...bins];
        return (item) => {
          const xValue = item.keys[0];
          for (let i = 0; i < binCount; i++) {
            const nextBin = bins[i];
            if (xValue >= nextBin[0] && xValue < nextBin[1]) {
              return nextBin;
            }
            if (i === binCount - 1 && xValue <= nextBin[1]) {
              return nextBin;
            }
          }
          return [];
        };
      };
      if (!this.ctx.animationManager.isSkipped() && this.processedData) {
        props.push(diff(this.processedData, false));
      }
      yield this.requestDataModel(dataController, (_a = this.data) != null ? _a : [], {
        props,
        dataVisible: this.visible,
        groupByFn
      });
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    var _a, _b, _c, _d;
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel || !this.calculatedBins.length)
      return [];
    const yDomain = dataModel.getDomain(this, `groupAgg`, "aggregate", processedData);
    const xDomainMin = (_a = this.calculatedBins) == null ? void 0 : _a[0][0];
    const xDomainMax = (_d = this.calculatedBins) == null ? void 0 : _d[((_c = (_b = this.calculatedBins) == null ? void 0 : _b.length) != null ? _c : 0) - 1][1];
    if (direction === "x" /* X */) {
      return fixNumericExtent([xDomainMin, xDomainMax]);
    }
    return fixNumericExtent(yDomain);
  }
  createNodeData() {
    return __async(this, null, function* () {
      var _a;
      const {
        id: seriesId,
        axes,
        processedData,
        ctx: { callbackCache }
      } = this;
      const xAxis = axes["x" /* X */];
      const yAxis = axes["y" /* Y */];
      if (!this.visible || !xAxis || !yAxis || !processedData || processedData.type !== "grouped") {
        return [];
      }
      const { scale: xScale } = xAxis;
      const { scale: yScale } = yAxis;
      const { xKey, yKey, xName, yName, fill, stroke, strokeWidth } = this.properties;
      const {
        formatter: labelFormatter = (params) => String(params.value),
        fontStyle: labelFontStyle,
        fontWeight: labelFontWeight,
        fontSize: labelFontSize,
        fontFamily: labelFontFamily,
        color: labelColor
      } = this.properties.label;
      const nodeData = [];
      processedData.data.forEach((group2) => {
        var _a2;
        const {
          aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],
          datum,
          datum: { length: frequency },
          keys: domain,
          keys: [xDomainMin, xDomainMax]
        } = group2;
        const xMinPx = xScale.convert(xDomainMin);
        const xMaxPx = xScale.convert(xDomainMax);
        const total = negativeAgg + positiveAgg;
        const yZeroPx = yScale.convert(0);
        const yMaxPx = yScale.convert(total);
        const w = Math.abs(xMaxPx - xMinPx);
        const h = Math.abs(yMaxPx - yZeroPx);
        const x = Math.min(xMinPx, xMaxPx);
        const y = Math.min(yZeroPx, yMaxPx);
        const selectionDatumLabel = total !== 0 ? {
          text: (_a2 = callbackCache.call(labelFormatter, {
            value: total,
            datum,
            seriesId,
            xKey,
            yKey,
            xName,
            yName
          })) != null ? _a2 : String(total),
          fontStyle: labelFontStyle,
          fontWeight: labelFontWeight,
          fontSize: labelFontSize,
          fontFamily: labelFontFamily,
          fill: labelColor,
          x: x + w / 2,
          y: y + h / 2
        } : void 0;
        const nodeMidPoint = {
          x: x + w / 2,
          y: y + h / 2
        };
        nodeData.push({
          series: this,
          datum,
          // required by SeriesNodeDatum, but might not make sense here
          // since each selection is an aggregation of multiple data.
          aggregatedValue: total,
          frequency,
          domain,
          yKey,
          xKey,
          x,
          y,
          xValue: xMinPx,
          yValue: yMaxPx,
          width: w,
          height: h,
          midPoint: nodeMidPoint,
          fill,
          stroke,
          opacity: 1,
          strokeWidth,
          label: selectionDatumLabel
        });
      });
      return [
        {
          itemId: (_a = this.properties.yKey) != null ? _a : this.id,
          nodeData,
          labelData: nodeData,
          scales: __superGet(_HistogramSeries.prototype, this, "calculateScaling").call(this),
          animationValid: true,
          visible: this.visible
        }
      ];
    });
  }
  nodeFactory() {
    return new Rect();
  }
  updateDatumSelection(opts) {
    return __async(this, null, function* () {
      const { nodeData, datumSelection } = opts;
      return datumSelection.update(
        nodeData,
        (rect) => {
          rect.tag = 0 /* Bin */;
          rect.crisp = true;
        },
        (datum) => datum.domain.join("_")
      );
    });
  }
  updateDatumNodes(opts) {
    return __async(this, null, function* () {
      const { isHighlight: isDatumHighlighted } = opts;
      const {
        fillOpacity: seriesFillOpacity,
        strokeOpacity,
        lineDash,
        lineDashOffset,
        shadow,
        highlightStyle: {
          item: {
            fill: highlightedFill,
            fillOpacity: highlightFillOpacity = seriesFillOpacity,
            stroke: highlightedStroke,
            strokeWidth: highlightedDatumStrokeWidth
          }
        }
      } = this.properties;
      opts.datumSelection.each((rect, datum, index) => {
        var _a, _b;
        const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : datum.strokeWidth;
        const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;
        rect.fill = (_a = isDatumHighlighted ? highlightedFill : void 0) != null ? _a : datum.fill;
        rect.stroke = (_b = isDatumHighlighted ? highlightedStroke : void 0) != null ? _b : datum.stroke;
        rect.fillOpacity = fillOpacity;
        rect.strokeOpacity = strokeOpacity;
        rect.strokeWidth = strokeWidth;
        rect.lineDash = lineDash;
        rect.lineDashOffset = lineDashOffset;
        rect.fillShadow = shadow;
        rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;
        rect.visible = datum.height > 0;
      });
    });
  }
  updateLabelSelection(opts) {
    return __async(this, null, function* () {
      const { labelData, labelSelection } = opts;
      return labelSelection.update(labelData, (text) => {
        text.tag = 1 /* Label */;
        text.pointerEvents = 1 /* None */;
        text.textAlign = "center";
        text.textBaseline = "middle";
      });
    });
  }
  updateLabelNodes(opts) {
    return __async(this, null, function* () {
      const labelEnabled = this.isLabelEnabled();
      opts.labelSelection.each((text, datum) => {
        const label = datum.label;
        if (label && labelEnabled) {
          text.text = label.text;
          text.x = label.x;
          text.y = label.y;
          text.fontStyle = label.fontStyle;
          text.fontWeight = label.fontWeight;
          text.fontSize = label.fontSize;
          text.fontFamily = label.fontFamily;
          text.fill = label.fill;
          text.visible = true;
        } else {
          text.visible = false;
        }
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return "";
    }
    const { xKey, yKey, xName, yName, fill: color, aggregation, tooltip } = this.properties;
    const {
      aggregatedValue,
      frequency,
      domain: [rangeMin, rangeMax]
    } = nodeDatum;
    const title = `${sanitizeHtml(xName != null ? xName : xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;
    let content = yKey ? `<b>${sanitizeHtml(yName != null ? yName : yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : "";
    content += `<b>Frequency</b>: ${frequency}`;
    const defaults = {
      title,
      backgroundColor: color,
      content
    };
    return tooltip.toTooltipHtml(defaults, {
      datum: {
        data: nodeDatum.datum,
        aggregatedValue: nodeDatum.aggregatedValue,
        domain: nodeDatum.domain,
        frequency: nodeDatum.frequency
      },
      xKey,
      xName,
      yKey,
      yName,
      color,
      title,
      seriesId: this.id
    });
  }
  getLegendData(legendType) {
    var _a, _b;
    if (!((_a = this.data) == null ? void 0 : _a.length) || legendType !== "category") {
      return [];
    }
    const { xKey, yName, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: xKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: (_b = yName != null ? yName : xKey) != null ? _b : "Frequency"
        },
        marker: {
          fill: fill != null ? fill : "rgba(0, 0, 0, 0)",
          stroke: stroke != null ? stroke : "rgba(0, 0, 0, 0)",
          fillOpacity,
          strokeOpacity,
          strokeWidth
        }
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelections, labelSelections }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
    fromToMotion(this.id, "datums", this.ctx.animationManager, datumSelections, fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelections);
  }
  animateWaitingUpdateReady(data) {
    var _a, _b;
    const diff2 = (_b = (_a = this.processedData) == null ? void 0 : _a.reduced) == null ? void 0 : _b.diff;
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
    fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      data.datumSelections,
      fns,
      (_, datum) => createDatumId(datum.domain),
      diff2
    );
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, data.labelSelections);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
};
_HistogramSeries.className = "HistogramSeries";
_HistogramSeries.type = "histogram";
var HistogramSeries = _HistogramSeries;

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts
var HistogramSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "histogram",
  instanceConstructor: HistogramSeries,
  seriesDefaults: {
    axes: [
      {
        type: "number" /* NUMBER */,
        position: "bottom" /* BOTTOM */
      },
      {
        type: "number" /* NUMBER */,
        position: "left" /* LEFT */
      }
    ]
  },
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS,
      strokeWidth: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        enabled: false,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
        formatter: void 0
      },
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      }
    }
  },
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return { fill, stroke };
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts
var LineSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
    this.connectMissingData = false;
  }
};
__decorateClass([
  Validate(STRING)
], LineSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING)
], LineSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], LineSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], LineSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], LineSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate(COLOR_STRING)
], LineSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LineSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(RATIO)
], LineSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], LineSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], LineSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(OBJECT)
], LineSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], LineSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], LineSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate(BOOLEAN)
], LineSeriesProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts
var _LineSeries = class _LineSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      hasMarkers: true,
      pickModes: [
        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,
        3 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      markerSelectionGarbageCollection: false,
      animationResetFns: {
        path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        marker: (node, datum) => __spreadValues(__spreadValues({}, resetMarkerFn()), resetMarkerPositionFn(node, datum))
      }
    });
    this.properties = new LineSeriesProperties();
  }
  processData(dataController) {
    return __async(this, null, function* () {
      if (!this.properties.isValid() || this.data == null) {
        return;
      }
      const { xKey, yKey } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const { isContinuousX, isContinuousY } = this.isContinuous();
      const props = [];
      if (!isContinuousX) {
        props.push(keyProperty(this, xKey, isContinuousX, { id: "xKey" }));
        if (animationEnabled && this.processedData) {
          props.push(diff(this.processedData));
        }
      }
      if (animationEnabled) {
        props.push(animationValidation(this, isContinuousX ? ["xValue"] : []));
      }
      props.push(
        valueProperty(this, xKey, isContinuousX, { id: "xValue" }),
        valueProperty(this, yKey, isContinuousY, { id: "yValue", invalidValue: void 0 })
      );
      yield this.requestDataModel(dataController, this.data, { props });
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    const { axes, dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
    if (direction === "x" /* X */) {
      const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
      if ((xDef == null ? void 0 : xDef.def.type) === "value" && xDef.def.valueType === "category") {
        return domain;
      }
      return fixNumericExtent(extent(domain), xAxis);
    } else {
      const domain = dataModel.getDomain(this, `yValue`, "value", processedData);
      return fixNumericExtent(domain, yAxis);
    }
  }
  createNodeData() {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const { processedData, dataModel, axes } = this;
      const xAxis = axes["x" /* X */];
      const yAxis = axes["y" /* Y */];
      if (!processedData || !dataModel || !xAxis || !yAxis) {
        return [];
      }
      const { xKey, yKey, xName, yName, marker, label, connectMissingData } = this.properties;
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const xOffset = ((_a = xScale.bandwidth) != null ? _a : 0) / 2;
      const yOffset = ((_b = yScale.bandwidth) != null ? _b : 0) / 2;
      const nodeData = [];
      const size = marker.enabled ? marker.size : 0;
      const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;
      const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;
      let moveTo = true;
      let nextPoint;
      for (let i = 0; i < processedData.data.length; i++) {
        const { datum, values } = nextPoint != null ? nextPoint : processedData.data[i];
        const xDatum = values[xIdx];
        const yDatum = values[yIdx];
        if (yDatum === void 0) {
          moveTo = !connectMissingData;
        } else {
          const x = xScale.convert(xDatum) + xOffset;
          if (isNaN(x)) {
            moveTo = !connectMissingData;
            nextPoint = void 0;
            continue;
          }
          nextPoint = ((_c = processedData.data[i + 1]) == null ? void 0 : _c.values[yIdx]) === void 0 ? void 0 : processedData.data[i + 1];
          const y = yScale.convert(yDatum) + yOffset;
          const labelText = this.getLabelText(
            label,
            { value: yDatum, datum, xKey, yKey, xName, yName },
            (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)
          );
          nodeData.push({
            series: this,
            datum,
            yKey,
            xKey,
            point: { x, y, moveTo, size },
            midPoint: { x, y },
            yValue: yDatum,
            xValue: xDatum,
            capDefaults: { lengthRatioMultiplier: this.properties.marker.getDiameter(), lengthMax: Infinity },
            label: labelText ? {
              text: labelText,
              fontStyle: label.fontStyle,
              fontWeight: label.fontWeight,
              fontSize: label.fontSize,
              fontFamily: label.fontFamily,
              textAlign: "center",
              textBaseline: "bottom",
              fill: label.color
            } : void 0
          });
          moveTo = false;
        }
      }
      return [
        {
          itemId: yKey,
          nodeData,
          labelData: nodeData,
          scales: __superGet(_LineSeries.prototype, this, "calculateScaling").call(this),
          visible: this.visible
        }
      ];
    });
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  updatePathNodes(opts) {
    return __async(this, null, function* () {
      const {
        paths: [lineNode],
        opacity,
        visible,
        animationEnabled
      } = opts;
      lineNode.setProperties({
        fill: void 0,
        lineJoin: "round",
        pointerEvents: 1 /* None */,
        opacity,
        stroke: this.properties.stroke,
        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
        strokeOpacity: this.properties.strokeOpacity,
        lineDash: this.properties.lineDash,
        lineDashOffset: this.properties.lineDashOffset
      });
      if (!animationEnabled) {
        lineNode.visible = visible;
      }
      updateClipPath(this, lineNode);
    });
  }
  updateMarkerSelection(opts) {
    return __async(this, null, function* () {
      let { nodeData } = opts;
      const { markerSelection } = opts;
      const { shape, enabled } = this.properties.marker;
      nodeData = shape && enabled ? nodeData : [];
      if (this.properties.marker.isDirty()) {
        markerSelection.clear();
        markerSelection.cleanup();
      }
      return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));
    });
  }
  updateMarkerNodes(opts) {
    return __async(this, null, function* () {
      const { markerSelection, isHighlight: highlighted } = opts;
      const { xKey, yKey, stroke, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;
      const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {
        stroke,
        strokeWidth,
        strokeOpacity
      });
      const applyTranslation = this.ctx.animationManager.isSkipped();
      markerSelection.each((node, datum) => {
        this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, { applyTranslation });
      });
      if (!highlighted) {
        marker.markClean();
      }
    });
  }
  updateLabelSelection(opts) {
    return __async(this, null, function* () {
      return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);
    });
  }
  updateLabelNodes(opts) {
    return __async(this, null, function* () {
      const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;
      opts.labelSelection.each((text, datum) => {
        const { point, label } = datum;
        if (datum && label && enabled) {
          text.fontStyle = fontStyle;
          text.fontWeight = fontWeight;
          text.fontSize = fontSize;
          text.fontFamily = fontFamily;
          text.textAlign = label.textAlign;
          text.textBaseline = label.textBaseline;
          text.text = label.text;
          text.x = point.x;
          text.y = point.y - 10;
          text.fill = color;
          text.visible = true;
        } else {
          text.visible = false;
        }
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a;
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return "";
    }
    const { xKey, yKey, xName, yName, strokeWidth, marker, tooltip } = this.properties;
    const { datum, xValue, yValue } = nodeDatum;
    const xString = xAxis.formatDatum(xValue);
    const yString = yAxis.formatDatum(yValue);
    const title = sanitizeHtml((_a = this.properties.title) != null ? _a : yName);
    const content = sanitizeHtml(xString + ": " + yString);
    const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth });
    const { fill: color } = this.getMarkerStyle(
      marker,
      { datum: nodeDatum, xKey, yKey, highlighted: false },
      baseStyle
    );
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      __spreadValues({
        datum,
        xKey,
        xName,
        yKey,
        yName,
        title,
        color,
        seriesId: this.id
      }, this.getModuleTooltipParams())
    );
  }
  getLegendData(legendType) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (!(((_a = this.data) == null ? void 0 : _a.length) && this.properties.isValid() && legendType === "category")) {
      return [];
    }
    const { yKey, yName, stroke, strokeOpacity, strokeWidth, lineDash, title, marker, visible } = this.properties;
    const color0 = "rgba(0, 0, 0, 0)";
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: yKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: (_b = title != null ? title : yName) != null ? _b : yKey
        },
        marker: {
          shape: marker.shape,
          fill: (_c = marker.fill) != null ? _c : color0,
          stroke: (_e = (_d = marker.stroke) != null ? _d : stroke) != null ? _e : color0,
          fillOpacity: (_f = marker.fillOpacity) != null ? _f : 1,
          strokeOpacity: (_h = (_g = marker.strokeOpacity) != null ? _g : strokeOpacity) != null ? _h : 1,
          strokeWidth: (_i = marker.strokeWidth) != null ? _i : 0,
          enabled: marker.enabled
        },
        line: {
          stroke: stroke != null ? stroke : color0,
          strokeOpacity,
          strokeWidth,
          lineDash
        }
      }
    ];
  }
  updatePaths(opts) {
    return __async(this, null, function* () {
      this.updateLinePaths([opts.paths], [opts.contextData]);
    });
  }
  updateLinePaths(paths, contextData) {
    contextData.forEach(({ nodeData }, contextDataIndex) => {
      const [lineNode] = paths[contextDataIndex];
      const { path: linePath } = lineNode;
      linePath.clear({ trackChanges: true });
      for (const data of nodeData) {
        if (data.point.moveTo) {
          linePath.moveTo(data.point.x, data.point.y);
        } else {
          linePath.lineTo(data.point.x, data.point.y);
        }
      }
      lineNode.checkPathDirty();
    });
  }
  animateEmptyUpdateReady(animationData) {
    const { markerSelections, labelSelections, annotationSelections, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateLinePaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, paths.flat());
    resetMotion(markerSelections, resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, markerSelections);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
    seriesLabelFadeInAnimation(this, "annotations", animationManager, annotationSelections);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateLinePaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    var _a, _b;
    const { animationManager } = this.ctx;
    const { markerSelections, labelSelections, annotationSelections, contextData, paths, previousContextData } = animationData;
    const [path] = paths;
    super.resetAllAnimation(animationData);
    const update = () => {
      this.updateLinePaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData.length === 0 || (previousContextData == null ? void 0 : previousContextData.length) === 0) {
      update();
      markerFadeInAnimation(this, animationManager, markerSelections, "added");
      pathFadeInAnimation(this, "path_properties", animationManager, path != null ? path : []);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, annotationSelections);
      return;
    }
    const [newData] = contextData;
    const [oldData] = previousContextData != null ? previousContextData : [];
    const fns = prepareLinePathAnimation(newData, oldData, (_b = (_a = this.processedData) == null ? void 0 : _a.reduced) == null ? void 0 : _b.diff);
    if (fns === void 0) {
      skip();
      return;
    }
    markerFadeInAnimation(this, animationManager, markerSelections);
    fromToMotion(this.id, "path_properties", animationManager, path, fns.pathProperties);
    pathMotion(this.id, "path_update", animationManager, path, fns.path);
    if (fns.hasMotion) {
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, annotationSelections);
    }
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0.1 };
  }
  nodeFactory() {
    return new Group();
  }
};
_LineSeries.className = "LineSeries";
_LineSeries.type = "line";
var LineSeries = _LineSeries;

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts
var LineSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "line",
  instanceConstructor: LineSeries,
  seriesDefaults: {
    axes: [
      {
        type: "number" /* NUMBER */,
        position: "left" /* LEFT */
      },
      {
        type: "category" /* CATEGORY */,
        position: "bottom" /* BOTTOM */
      }
    ]
  },
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS,
      tooltip: {
        position: {
          type: "node"
        }
      },
      strokeWidth: 2,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      marker: {
        __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,
        fillOpacity: 1,
        strokeOpacity: 1,
        strokeWidth: 0
      },
      label: {
        enabled: false,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR,
        formatter: void 0
      }
    }
  },
  enterpriseThemeTemplate: {
    series: {
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      }
    }
  },
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory(params);
    return {
      stroke: marker.fill,
      marker
    };
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts
var ScatterSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.colorRange = ["#ffff00", "#00ff00", "#0000ff"];
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
  }
};
__decorateClass([
  Validate(STRING)
], ScatterSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Validate(STRING)
], ScatterSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Validate(NUMBER_ARRAY, { optional: true })
], ScatterSeriesProperties.prototype, "colorDomain", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], ScatterSeriesProperties.prototype, "colorRange", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], ScatterSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate(OBJECT)
], ScatterSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Validate(OBJECT)
], ScatterSeriesProperties.prototype, "label", 2);
__decorateClass([
  Validate(OBJECT)
], ScatterSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts
var _ScatterSeries = class _ScatterSeries extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [
        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,
        3 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: 0,
      hasMarkers: true,
      markerSelectionGarbageCollection: false,
      animationResetFns: {
        marker: resetMarkerFn,
        label: resetLabelFn
      }
    });
    this.properties = new ScatterSeriesProperties();
    this.colorScale = new ColorScale();
  }
  processData(dataController) {
    return __async(this, null, function* () {
      var _a;
      if (!this.properties.isValid() || this.data == null) {
        return;
      }
      const { isContinuousX, isContinuousY } = this.isContinuous();
      const { xKey, yKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;
      const { dataModel, processedData } = yield this.requestDataModel(dataController, this.data, {
        props: [
          keyProperty(this, xKey, isContinuousX, { id: "xKey-raw" }),
          keyProperty(this, yKey, isContinuousY, { id: "yKey-raw" }),
          ...labelKey ? [keyProperty(this, labelKey, false, { id: `labelKey-raw` })] : [],
          valueProperty(this, xKey, isContinuousX, { id: `xValue` }),
          valueProperty(this, yKey, isContinuousY, { id: `yValue` }),
          ...colorKey ? [valueProperty(this, colorKey, true, { id: `colorValue` })] : [],
          ...labelKey ? [valueProperty(this, labelKey, false, { id: `labelValue` })] : []
        ],
        dataVisible: this.visible
      });
      if (colorKey) {
        const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`).index;
        this.colorScale.domain = (_a = colorDomain != null ? colorDomain : processedData.domain.values[colorKeyIdx]) != null ? _a : [];
        this.colorScale.range = colorRange;
        this.colorScale.update();
      }
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    const id = direction === "x" /* X */ ? `xValue` : `yValue`;
    const dataDef = dataModel.resolveProcessedDataDefById(this, id);
    const domain = dataModel.getDomain(this, id, "value", processedData);
    if ((dataDef == null ? void 0 : dataDef.def.type) === "value" && (dataDef == null ? void 0 : dataDef.def.valueType) === "category") {
      return domain;
    }
    const axis = this.axes[direction];
    return fixNumericExtent(extent(domain), axis);
  }
  createNodeData() {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const { axes, dataModel, processedData, colorScale } = this;
      const { xKey, yKey, labelKey, colorKey, xName, yName, labelName, marker, label, visible } = this.properties;
      const xAxis = axes["x" /* X */];
      const yAxis = axes["y" /* Y */];
      if (!(dataModel && processedData && visible && xAxis && yAxis)) {
        return [];
      }
      const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;
      const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;
      const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`).index : -1;
      const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`).index : -1;
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const xOffset = ((_a = xScale.bandwidth) != null ? _a : 0) / 2;
      const yOffset = ((_b = yScale.bandwidth) != null ? _b : 0) / 2;
      const nodeData = [];
      const font = label.getFont();
      for (const { values, datum } of (_c = processedData.data) != null ? _c : []) {
        const xDatum = values[xDataIdx];
        const yDatum = values[yDataIdx];
        const x = xScale.convert(xDatum) + xOffset;
        const y = yScale.convert(yDatum) + yOffset;
        const labelText = this.getLabelText(label, {
          value: labelKey ? values[labelDataIdx] : yDatum,
          datum,
          xKey,
          yKey,
          labelKey,
          xName,
          yName,
          labelName
        });
        const size = HdpiCanvas.getTextSize(labelText, font);
        const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;
        nodeData.push({
          series: this,
          itemId: yKey,
          yKey,
          xKey,
          datum,
          xValue: xDatum,
          yValue: yDatum,
          capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },
          point: { x, y, size: marker.size },
          midPoint: { x, y },
          fill,
          label: __spreadValues({ text: labelText }, size)
        });
      }
      return [
        {
          itemId: yKey,
          nodeData,
          labelData: nodeData,
          scales: __superGet(_ScatterSeries.prototype, this, "calculateScaling").call(this),
          visible: this.visible
        }
      ];
    });
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  getLabelData() {
    var _a;
    return (_a = this.contextNodeData) == null ? void 0 : _a.reduce((r, n) => r.concat(n.labelData), []);
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker(shape);
    return new MarkerShape();
  }
  updateMarkerSelection(opts) {
    return __async(this, null, function* () {
      const { nodeData, markerSelection } = opts;
      if (this.properties.marker.isDirty()) {
        markerSelection.clear();
        markerSelection.cleanup();
      }
      return markerSelection.update(this.properties.marker.enabled ? nodeData : []);
    });
  }
  updateMarkerNodes(opts) {
    return __async(this, null, function* () {
      const { markerSelection, isHighlight: highlighted } = opts;
      const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;
      const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());
      markerSelection.each((node, datum) => {
        this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle);
      });
      if (!highlighted) {
        marker.markClean();
      }
    });
  }
  updateLabelSelection(opts) {
    return __async(this, null, function* () {
      var _a, _b;
      const placedLabels = this.isLabelEnabled() ? (_b = (_a = this.chart) == null ? void 0 : _a.placeLabels().get(this)) != null ? _b : [] : [];
      return opts.labelSelection.update(
        placedLabels.map(({ datum, x, y }) => __spreadProps(__spreadValues({}, datum), {
          point: { x, y, size: datum.point.size }
        })),
        (text) => {
          text.pointerEvents = 1 /* None */;
        }
      );
    });
  }
  updateLabelNodes(opts) {
    return __async(this, null, function* () {
      const { label } = this.properties;
      opts.labelSelection.each((text, datum) => {
        var _a, _b, _c, _d;
        text.text = datum.label.text;
        text.fill = label.color;
        text.x = (_b = (_a = datum.point) == null ? void 0 : _a.x) != null ? _b : 0;
        text.y = (_d = (_c = datum.point) == null ? void 0 : _c.y) != null ? _d : 0;
        text.fontStyle = label.fontStyle;
        text.fontWeight = label.fontWeight;
        text.fontSize = label.fontSize;
        text.fontFamily = label.fontFamily;
        text.textAlign = "left";
        text.textBaseline = "top";
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes["x" /* X */];
    const yAxis = this.axes["y" /* Y */];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return "";
    }
    const { xKey, yKey, labelKey, xName, yName, labelName, title = yName, marker, tooltip } = this.properties;
    const { datum, xValue, yValue, label } = nodeDatum;
    const baseStyle = mergeDefaults(
      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },
      marker.getStyle()
    );
    const { fill: color = "gray" } = this.getMarkerStyle(
      marker,
      { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey },
      baseStyle
    );
    const xString = sanitizeHtml(xAxis.formatDatum(xValue));
    const yString = sanitizeHtml(yAxis.formatDatum(yValue));
    let content = `<b>${sanitizeHtml(xName != null ? xName : xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName != null ? yName : yKey)}</b>: ${yString}`;
    if (labelKey) {
      content = `<b>${sanitizeHtml(labelName != null ? labelName : labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;
    }
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      __spreadValues({
        datum,
        xKey,
        xName,
        yKey,
        yName,
        labelKey,
        labelName,
        title,
        color,
        seriesId: this.id
      }, this.getModuleTooltipParams())
    );
  }
  getLegendData(legendType) {
    var _a, _b, _c, _d, _e, _f;
    const { yKey, yName, title, marker, visible } = this.properties;
    const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;
    if (!((_a = this.data) == null ? void 0 : _a.length) || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: yKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: (_b = title != null ? title : yName) != null ? _b : yKey
        },
        marker: {
          shape: marker.shape,
          fill: (_d = (_c = marker.fill) != null ? _c : fill) != null ? _d : "rgba(0, 0, 0, 0)",
          stroke: (_f = (_e = marker.stroke) != null ? _e : stroke) != null ? _f : "rgba(0, 0, 0, 0)",
          fillOpacity: fillOpacity != null ? fillOpacity : 1,
          strokeOpacity: strokeOpacity != null ? strokeOpacity : 1,
          strokeWidth: strokeWidth != null ? strokeWidth : 0
        }
      }
    ];
  }
  animateEmptyUpdateReady(data) {
    const { markerSelections, labelSelections, annotationSelections } = data;
    markerScaleInAnimation(this, this.ctx.animationManager, markerSelections);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelections);
    seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, annotationSelections);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Group();
  }
};
_ScatterSeries.className = "ScatterSeries";
_ScatterSeries.type = "scatter";
var ScatterSeries = _ScatterSeries;

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts
var ScatterSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "scatter",
  instanceConstructor: ScatterSeries,
  seriesDefaults: {
    axes: [
      {
        type: "number" /* NUMBER */,
        position: "bottom" /* BOTTOM */
      },
      {
        type: "number" /* NUMBER */,
        position: "left" /* LEFT */
      }
    ]
  },
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS,
      tooltip: {
        position: {
          type: "node"
        }
      },
      marker: {
        __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,
        fillOpacity: 0.8
      },
      label: {
        enabled: false,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY,
        color: DEFAULT_LABEL_COLOUR
      }
    }
  },
  enterpriseThemeTemplate: {
    series: {
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      }
    }
  },
  paletteFactory: markerPaletteFactory
};

// packages/ag-charts-community/src/scene/util/sector.ts
function isPointInSector(x, y, sector) {
  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  const { innerRadius, outerRadius } = sector;
  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {
    return false;
  }
  const startAngle = normalizeAngle180(sector.startAngle);
  const endAngle = normalizeAngle180(sector.endAngle);
  const angle = Math.atan2(y, x);
  return startAngle < endAngle ? angle <= endAngle && angle >= startAngle : angle <= endAngle && angle >= -Math.PI || angle >= startAngle && angle <= Math.PI;
}
function lineCollidesSector(line, sector) {
  const { startAngle, endAngle, innerRadius, outerRadius } = sector;
  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };
  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };
  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };
  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };
  return segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerStart.x,
    outerStart.y,
    innerStart.x,
    innerStart.y
  ) != null || segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerEnd.x,
    outerEnd.y,
    innerEnd.x,
    innerEnd.y
  ) != null || arcIntersections(
    0,
    0,
    outerRadius,
    startAngle,
    endAngle,
    true,
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y
  ).length > 0;
}
function boxCollidesSector(box, sector) {
  const topLeft = { x: box.x, y: box.y };
  const topRight = { x: box.x + box.width, y: box.y };
  const bottomLeft = { x: box.x, y: box.y + box.height };
  const bottomRight = { x: box.x + box.width, y: box.y + box.height };
  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);
}

// packages/ag-charts-community/src/scene/shape/sector.ts
var Sector = class extends Path {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.centerY = 0;
    this.innerRadius = 10;
    this.outerRadius = 20;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.angleOffset = 0;
    this.inset = 0;
  }
  computeBBox() {
    const radius = this.outerRadius;
    return new BBox(this.centerX - radius, this.centerY - radius, radius * 2, radius * 2);
  }
  updatePath() {
    const path = this.path;
    const { angleOffset, inset } = this;
    const startAngle = this.startAngle + angleOffset;
    const endAngle = this.endAngle + angleOffset;
    const sweep = startAngle <= endAngle ? endAngle - startAngle : Math.PI * 2 - (startAngle - endAngle);
    const innerRadius = Math.max(Math.min(this.innerRadius, this.outerRadius) + inset, 0);
    const outerRadius = Math.max(Math.max(this.innerRadius, this.outerRadius) - inset, 0);
    const fullPie = sweep >= 2 * Math.PI;
    const centerX = this.centerX;
    const centerY = this.centerY;
    path.clear();
    if (fullPie) {
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);
      if (innerRadius > inset) {
        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
      }
    } else {
      const innerAngleOffset = innerRadius > 0 ? inset / innerRadius : 0;
      const outerAngleOffset = outerRadius > 0 ? inset / outerRadius : 0;
      const outerAngleExceeded = sweep < 2 * outerAngleOffset;
      if (outerAngleExceeded)
        return;
      const innerAngleExceeded = innerRadius <= inset || sweep < 2 * innerAngleOffset;
      if (innerAngleExceeded) {
        const x = sweep < Math.PI * 0.5 ? inset * (1 + Math.cos(sweep)) / Math.sin(sweep) : NaN;
        let r;
        if (x > 0 && x < outerRadius) {
          r = Math.max(Math.hypot(inset, x), innerRadius);
        } else {
          r = innerRadius;
        }
        const midAngle = startAngle + sweep * 0.5;
        path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));
      } else {
        path.moveTo(
          centerX + innerRadius * Math.cos(startAngle + innerAngleOffset),
          centerY + innerRadius * Math.sin(startAngle + innerAngleOffset)
        );
      }
      path.arc(centerX, centerY, outerRadius, startAngle + outerAngleOffset, endAngle - outerAngleOffset);
      if (innerAngleExceeded) ; else if (innerRadius > 0) {
        path.arc(
          centerX,
          centerY,
          innerRadius,
          endAngle - innerAngleOffset,
          startAngle + innerAngleOffset,
          true
        );
      } else {
        path.lineTo(centerX, centerY);
      }
    }
    path.closePath();
    this.dirtyPath = false;
  }
  isPointInPath(x, y) {
    const { angleOffset } = this;
    const startAngle = this.startAngle + angleOffset;
    const endAngle = this.endAngle + angleOffset;
    const innerRadius = Math.min(this.innerRadius, this.outerRadius);
    const outerRadius = Math.max(this.innerRadius, this.outerRadius);
    const point = this.transformPoint(x, y);
    return isPointInSector(point.x, point.y, { startAngle, endAngle, innerRadius, outerRadius });
  }
};
Sector.className = "Sector";
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "centerX", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "centerY", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "innerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "outerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "startAngle", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "endAngle", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "angleOffset", 2);
__decorateClass([
  ScenePathChangeDetection()
], Sector.prototype, "inset", 2);

// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts
var DonutTitle = class extends Caption {
  constructor() {
    super(...arguments);
    this.showInLegend = false;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], DonutTitle.prototype, "showInLegend", 2);
var DonutInnerLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.margin = 2;
  }
  set(properties, _reset) {
    return super.set(properties);
  }
};
__decorateClass([
  Validate(STRING)
], DonutInnerLabel.prototype, "text", 2);
__decorateClass([
  Validate(NUMBER)
], DonutInnerLabel.prototype, "margin", 2);
var DonutInnerCircle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fill = "transparent";
    this.fillOpacity = 1;
  }
};
__decorateClass([
  Validate(COLOR_STRING)
], DonutInnerCircle.prototype, "fill", 2);
__decorateClass([
  Validate(RATIO)
], DonutInnerCircle.prototype, "fillOpacity", 2);
var DonutSeriesCalloutLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.offset = 3;
    this.minAngle = 0;
    this.minSpacing = 4;
    this.maxCollisionOffset = 50;
    this.avoidCollisions = true;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLabel.prototype, "offset", 2);
__decorateClass([
  Validate(DEGREE)
], DonutSeriesCalloutLabel.prototype, "minAngle", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLabel.prototype, "minSpacing", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
__decorateClass([
  Validate(BOOLEAN)
], DonutSeriesCalloutLabel.prototype, "avoidCollisions", 2);
var DonutSeriesSectorLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.positionOffset = 0;
    this.positionRatio = 0.5;
  }
};
__decorateClass([
  Validate(NUMBER)
], DonutSeriesSectorLabel.prototype, "positionOffset", 2);
__decorateClass([
  Validate(RATIO)
], DonutSeriesSectorLabel.prototype, "positionRatio", 2);
var DonutSeriesCalloutLine = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.length = 10;
    this.strokeWidth = 1;
  }
};
__decorateClass([
  Validate(COLOR_STRING_ARRAY, { optional: true })
], DonutSeriesCalloutLine.prototype, "colors", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLine.prototype, "length", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesCalloutLine.prototype, "strokeWidth", 2);
var DonutSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.fills = Object.values(DEFAULT_FILLS);
    this.strokes = Object.values(DEFAULT_STROKES);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.rotation = 0;
    this.outerRadiusOffset = 0;
    this.outerRadiusRatio = 1;
    this.strokeWidth = 1;
    this.sectorSpacing = void 0;
    this.innerLabels = new PropertiesArray(DonutInnerLabel);
    this.title = new DonutTitle();
    this.innerCircle = new DonutInnerCircle();
    this.shadow = new DropShadow();
    this.calloutLabel = new DonutSeriesCalloutLabel();
    this.sectorLabel = new DonutSeriesSectorLabel();
    this.calloutLine = new DonutSeriesCalloutLine();
    this.tooltip = new SeriesTooltip();
    this.__BACKGROUND_COLOR_DO_NOT_USE = void 0;
  }
  isValid() {
    const superIsValid = super.isValid();
    if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {
      Logger.warnOnce(
        "Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series."
      );
      return false;
    }
    return superIsValid;
  }
};
__decorateClass([
  Validate(STRING)
], DonutSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], DonutSeriesProperties.prototype, "radiusMin", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], DonutSeriesProperties.prototype, "radiusMax", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "calloutLabelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "calloutLabelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "sectorLabelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "sectorLabelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "legendItemKey", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], DonutSeriesProperties.prototype, "fills", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], DonutSeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Validate(RATIO)
], DonutSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(RATIO)
], DonutSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], DonutSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], DonutSeriesProperties.prototype, "formatter", 2);
__decorateClass([
  Validate(DEGREE)
], DonutSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Validate(NUMBER)
], DonutSeriesProperties.prototype, "outerRadiusOffset", 2);
__decorateClass([
  Validate(RATIO)
], DonutSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
  Validate(NUMBER, { optional: true })
], DonutSeriesProperties.prototype, "innerRadiusOffset", 2);
__decorateClass([
  Validate(RATIO, { optional: true })
], DonutSeriesProperties.prototype, "innerRadiusRatio", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], DonutSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], DonutSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
  Validate(OBJECT_ARRAY)
], DonutSeriesProperties.prototype, "innerLabels", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "innerCircle", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "calloutLabel", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "sectorLabel", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "calloutLine", 2);
__decorateClass([
  Validate(OBJECT)
], DonutSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], DonutSeriesProperties.prototype, "__BACKGROUND_COLOR_DO_NOT_USE", 2);

// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts
function preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {
  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];
  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];
  const rotation = Math.PI / -2 + toRadians(rotationDegrees);
  const scaleToNewRadius = ({ radius }) => {
    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };
  };
  const scaleToOldRadius = ({ radius }) => {
    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };
  };
  const fromFn = (sect, datum, status, { prevFromProps }) => {
    var _a, _b, _c, _d, _e, _f;
    let { startAngle, endAngle, innerRadius, outerRadius } = sect;
    let { fill, stroke } = datum.sectorFormat;
    if (status === "unknown" || status === "added" && !prevFromProps) {
      startAngle = rotation;
      endAngle = rotation;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    } else if (status === "added" && prevFromProps) {
      startAngle = (_a = prevFromProps.endAngle) != null ? _a : rotation;
      endAngle = (_b = prevFromProps.endAngle) != null ? _b : rotation;
      innerRadius = (_c = prevFromProps.innerRadius) != null ? _c : datum.innerRadius;
      outerRadius = (_d = prevFromProps.outerRadius) != null ? _d : datum.outerRadius;
    }
    if (status === "added" && !initialLoad) {
      const radii = scaleToOldRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    if (status === "updated") {
      fill = (_e = sect.fill) != null ? _e : fill;
      stroke = (_f = sect.stroke) != null ? _f : stroke;
    }
    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke, phase: "initial" };
  };
  const toFn = (_sect, datum, status, { prevLive }) => {
    var _a, _b;
    let { startAngle, endAngle, innerRadius, outerRadius } = datum;
    const { stroke, fill } = datum.sectorFormat;
    if (status === "removed" && prevLive) {
      startAngle = (_a = prevLive.datum) == null ? void 0 : _a.endAngle;
      endAngle = (_b = prevLive.datum) == null ? void 0 : _b.endAngle;
    } else if (status === "removed" && !prevLive) {
      startAngle = rotation;
      endAngle = rotation;
    }
    if (status === "removed") {
      const radii = scaleToNewRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };
  };
  const innerCircleFromFn = (node, _) => {
    var _a, _b, _c;
    return { size: (_c = (_b = (_a = node.previousDatum) == null ? void 0 : _a.radius) != null ? _b : node.size) != null ? _c : 0, phase: "initial" };
  };
  const innerCircleToFn = (_, datum) => {
    var _a;
    return { size: (_a = datum.radius) != null ? _a : 0 };
  };
  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };
}
function resetPieSelectionsFn(_node, datum) {
  return {
    startAngle: datum.startAngle,
    endAngle: datum.endAngle,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    fill: datum.sectorFormat.fill,
    stroke: datum.sectorFormat.stroke
  };
}

// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts
var PolarSeries = class extends DataModelSeries {
  constructor(_a) {
    var _b = _a, {
      useLabelLayer = false,
      pickModes = [0 /* EXACT_SHAPE_MATCH */],
      canHaveAxes = false,
      animationResetFns
    } = _b, opts = __objRest(_b, [
      "useLabelLayer",
      "pickModes",
      "canHaveAxes",
      "animationResetFns"
    ]);
    super(__spreadProps(__spreadValues({}, opts), {
      useLabelLayer,
      pickModes,
      contentGroupVirtual: false,
      directionKeys: {
        ["x" /* X */]: ["angleKey"],
        ["y" /* Y */]: ["radiusKey"]
      },
      directionNames: {
        ["x" /* X */]: ["angleName"],
        ["y" /* Y */]: ["radiusName"]
      },
      canHaveAxes
    }));
    this.itemGroup = this.contentGroup.appendChild(new Group());
    this.itemSelection = Selection.select(
      this.itemGroup,
      () => this.nodeFactory(),
      false
    );
    this.labelSelection = Selection.select(this.labelGroup, Text, false);
    this.highlightSelection = Selection.select(
      this.highlightGroup,
      () => this.nodeFactory()
    );
    /**
     * The center of the polar series (for example, the center of a pie).
     * If the polar chart has multiple series, all of them will have their
     * center set to the same value as a result of the polar chart layout.
     * The center coordinates are not supposed to be set by the user.
     */
    this.centerX = 0;
    this.centerY = 0;
    /**
     * The maximum radius the series can use.
     * This value is set automatically as a result of the polar chart layout
     * and is not supposed to be set by the user.
     */
    this.radius = 0;
    this.itemGroup.zIndexSubOrder = [() => this._declarationOrder, 1];
    this.animationResetFns = animationResetFns;
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => this.animateWaitingUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  getLabelData() {
    return [];
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
  resetAllAnimation() {
    var _a;
    const { item, label } = (_a = this.animationResetFns) != null ? _a : {};
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    if (item) {
      resetMotion([this.itemSelection, this.highlightSelection], item);
    }
    if (label) {
      resetMotion([this.labelSelection], label);
    }
    this.itemSelection.cleanup();
    this.labelSelection.cleanup();
    this.highlightSelection.cleanup();
  }
  animateEmptyUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateWaitingUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateReadyHighlight(_data) {
    var _a;
    const { item } = (_a = this.animationResetFns) != null ? _a : {};
    if (item) {
      resetMotion([this.highlightSelection], item);
    }
  }
  animateReadyHighlightMarkers(_data) {
  }
  animateReadyResize(_data) {
    this.resetAllAnimation();
  }
  animateClearingUpdateEmpty(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animationTransitionClear() {
    this.animationState.transition("clear", this.getAnimationData());
  }
  getAnimationData(seriesRect) {
    return { seriesRect };
  }
};

// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts
var DonutSeriesNodeClickEvent = class extends SeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
    this.calloutLabelKey = series.properties.calloutLabelKey;
    this.sectorLabelKey = series.properties.sectorLabelKey;
  }
};
var DonutSeries = class extends PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      useLabelLayer: true,
      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
    });
    this.properties = new DonutSeriesProperties();
    this.previousRadiusScale = new LinearScale();
    this.radiusScale = new LinearScale();
    // The group node that contains the background graphics.
    this.backgroundGroup = this.rootGroup.appendChild(
      new Group({
        name: `${this.id}-background`,
        layer: true,
        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */
      })
    );
    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());
    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());
    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));
    this.nodeData = [];
    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.
    this.seriesItemEnabled = [];
    this.surroundingRadius = void 0;
    this.NodeClickEvent = DonutSeriesNodeClickEvent;
    this.angleScale = new LinearScale();
    this.angleScale.domain = [0, 1];
    this.angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);
    const pieCalloutLabels = new Group({ name: "pieCalloutLabels" });
    const pieSectorLabels = new Group({ name: "pieSectorLabels" });
    const innerLabels = new Group({ name: "innerLabels" });
    this.labelGroup.append(pieCalloutLabels);
    this.labelGroup.append(pieSectorLabels);
    this.labelGroup.append(innerLabels);
    this.calloutLabelSelection = Selection.select(pieCalloutLabels, Group);
    this.sectorLabelSelection = Selection.select(pieSectorLabels, Text);
    this.innerLabelsSelection = Selection.select(innerLabels, Text);
    this.innerCircleSelection = Selection.select(this.innerCircleGroup, Circle);
    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {
      circle.fillOpacity = 0;
      circle.stroke = this.properties.calloutLabel.color;
      circle.strokeWidth = 1;
      circle.strokeOpacity = 1;
    }
  }
  addChartEventListeners() {
    var _a;
    this.destroyFns.push(
      (_a = this.ctx.chartEventManager) == null ? void 0 : _a.addListener("legend-item-click", (event) => this.onLegendItemClick(event))
    );
  }
  visibleChanged() {
    this.processSeriesItemEnabled();
  }
  get visible() {
    return this.seriesItemEnabled.length ? this.seriesItemEnabled.some((visible) => visible) : super.visible;
  }
  processSeriesItemEnabled() {
    var _a;
    const { data, visible } = this;
    this.seriesItemEnabled = (_a = data == null ? void 0 : data.map(() => visible)) != null ? _a : [];
  }
  nodeFactory() {
    return new Sector();
  }
  getSeriesDomain(direction) {
    if (direction === "x" /* X */) {
      return this.angleScale.domain;
    } else {
      return this.radiusScale.domain;
    }
  }
  processData(dataController) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      if (this.data == null || !this.properties.isValid()) {
        return;
      }
      let { data } = this;
      const { seriesItemEnabled } = this;
      const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const extraKeyProps = [];
      const extraProps = [];
      if (legendItemKey) {
        extraKeyProps.push(keyProperty(this, legendItemKey, false, { id: `legendItemKey` }));
      } else if (calloutLabelKey) {
        extraKeyProps.push(keyProperty(this, calloutLabelKey, false, { id: `calloutLabelKey` }));
      } else if (sectorLabelKey) {
        extraKeyProps.push(keyProperty(this, sectorLabelKey, false, { id: `sectorLabelKey` }));
      }
      if (radiusKey) {
        extraProps.push(
          rangedValueProperty(this, radiusKey, {
            id: "radiusValue",
            min: (_a = this.properties.radiusMin) != null ? _a : 0,
            max: this.properties.radiusMax
          }),
          valueProperty(this, radiusKey, true, { id: `radiusRaw` }),
          // Raw value pass-through.
          normalisePropertyTo(
            this,
            { id: "radiusValue" },
            [0, 1],
            1,
            (_b = this.properties.radiusMin) != null ? _b : 0,
            this.properties.radiusMax
          )
        );
      }
      if (calloutLabelKey) {
        extraProps.push(valueProperty(this, calloutLabelKey, false, { id: `calloutLabelValue` }));
      }
      if (sectorLabelKey) {
        extraProps.push(valueProperty(this, sectorLabelKey, false, { id: `sectorLabelValue` }));
      }
      if (legendItemKey) {
        extraProps.push(valueProperty(this, legendItemKey, false, { id: `legendItemValue` }));
      }
      if (animationEnabled && this.processedData && extraKeyProps.length > 0) {
        extraProps.push(diff(this.processedData));
      }
      extraProps.push(animationValidation(this));
      data = data.map((d, idx) => seriesItemEnabled[idx] ? d : __spreadProps(__spreadValues({}, d), { [angleKey]: 0 }));
      yield this.requestDataModel(dataController, data, {
        props: [
          ...extraKeyProps,
          accumulativeValueProperty(this, angleKey, true, { id: `angleValue`, onlyPositive: true }),
          valueProperty(this, angleKey, true, { id: `angleRaw` }),
          // Raw value pass-through.
          normalisePropertyTo(this, { id: "angleValue" }, [0, 1], 0, 0),
          ...extraProps
        ]
      });
      for (const valueDef of (_e = (_d = (_c = this.processedData) == null ? void 0 : _c.defs) == null ? void 0 : _d.values) != null ? _e : []) {
        const { id, missing, property } = valueDef;
        const missCount = getMissCount(this, missing);
        if (id !== "angleRaw" && missCount > 0) {
          Logger.warnOnce(
            `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
          );
        }
      }
      this.animationState.transition("updateData");
    });
  }
  maybeRefreshNodeData() {
    return __async(this, null, function* () {
      if (!this.nodeDataRefresh)
        return;
      const [{ nodeData = [] } = {}] = yield this.createNodeData();
      this.nodeData = nodeData;
      this.nodeDataRefresh = false;
    });
  }
  getProcessedDataIndexes(dataModel) {
    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`).index;
    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`).index : -1;
    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`).index : -1;
    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`).index : -1;
    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index : -1;
    return { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx };
  }
  createNodeData() {
    return __async(this, null, function* () {
      const { id: seriesId, processedData, dataModel, angleScale } = this;
      const { rotation, innerRadiusRatio } = this.properties;
      if (!this.properties.isValid()) {
        this.zerosumOuterRing.visible = true;
        this.zerosumInnerRing.visible = true;
        return [{ itemId: seriesId, nodeData: [], labelData: [] }];
      }
      if (!processedData || !dataModel || processedData.type !== "ungrouped")
        return [];
      const { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
      let currentStart = 0;
      let sum2 = 0;
      const nodeData = processedData.data.map((group2, index) => {
        var _a;
        const { datum, values } = group2;
        const currentValue = values[angleIdx];
        const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
        currentStart = currentValue;
        sum2 += currentValue;
        const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
        const span = Math.abs(endAngle - startAngle);
        const midAngle = startAngle + span / 2;
        const angleValue = values[angleIdx + 1];
        const radius = radiusIdx >= 0 ? (_a = values[radiusIdx]) != null ? _a : 1 : 1;
        const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : void 0;
        const legendItemValue = legendItemIdx >= 0 ? values[legendItemIdx] : void 0;
        const labels = this.getLabels(
          datum,
          midAngle,
          span,
          true,
          values[calloutLabelIdx],
          values[sectorLabelIdx],
          legendItemValue
        );
        const sectorFormat = this.getSectorFormat(datum, index, false);
        return __spreadValues({
          itemId: index,
          series: this,
          datum,
          index,
          angleValue,
          midAngle,
          midCos: Math.cos(midAngle),
          midSin: Math.sin(midAngle),
          startAngle,
          endAngle,
          sectorFormat,
          radiusValue,
          radius,
          innerRadius: Math.max(this.radiusScale.convert(0), 0),
          outerRadius: Math.max(this.radiusScale.convert(radius), 0),
          legendItemValue
        }, labels);
      });
      this.zerosumOuterRing.visible = sum2 === 0;
      this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;
      return [{ itemId: seriesId, nodeData, labelData: nodeData }];
    });
  }
  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {
    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;
    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;
    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;
    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {
      return {};
    }
    const labelFormatterParams = {
      datum,
      angleKey: this.properties.angleKey,
      angleName: this.properties.angleName,
      radiusKey: this.properties.radiusKey,
      radiusName: this.properties.radiusName,
      calloutLabelKey: this.properties.calloutLabelKey,
      calloutLabelName: this.properties.calloutLabelName,
      sectorLabelKey: this.properties.sectorLabelKey,
      sectorLabelName: this.properties.sectorLabelName,
      legendItemKey: this.properties.legendItemKey
    };
    const result = {};
    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {
      result.calloutLabel = __spreadProps(__spreadValues({}, this.getTextAlignment(midAngle)), {
        text: this.getLabelText(calloutLabel, __spreadProps(__spreadValues({}, labelFormatterParams), {
          value: calloutLabelValue
        })),
        hidden: false,
        collisionTextAlign: void 0,
        collisionOffsetY: 0,
        box: void 0
      });
    }
    if (sectorLabelKey) {
      result.sectorLabel = {
        text: this.getLabelText(sectorLabel, __spreadProps(__spreadValues({}, labelFormatterParams), {
          value: sectorLabelValue
        }))
      };
    }
    if (legendItemKey != null && legendItemValue != null) {
      result.legendItem = { key: legendItemKey, text: legendItemValue };
    }
    return result;
  }
  getTextAlignment(midAngle) {
    const quadrantTextOpts = [
      { textAlign: "center", textBaseline: "bottom" },
      { textAlign: "left", textBaseline: "middle" },
      { textAlign: "center", textBaseline: "hanging" },
      { textAlign: "right", textBaseline: "middle" }
    ];
    const midAngle180 = normalizeAngle180(midAngle);
    const quadrantStart = -3 * Math.PI / 4;
    const quadrantOffset = midAngle180 - quadrantStart;
    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);
    return quadrantTextOpts[quadrantIndex];
  }
  getSectorFormat(datum, formatIndex, highlight) {
    var _a, _b, _c, _d, _e;
    const { callbackCache, highlightManager } = this.ctx;
    const { angleKey, radiusKey, fills, strokes, formatter, sectorSpacing, __BACKGROUND_COLOR_DO_NOT_USE } = this.properties;
    const highlightedDatum = highlightManager.getActiveHighlight();
    const isDatumHighlighted = highlight && (highlightedDatum == null ? void 0 : highlightedDatum.series) === this && formatIndex === highlightedDatum.itemId;
    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(
      isDatumHighlighted && this.properties.highlightStyle.item,
      {
        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,
        fillOpacity: this.properties.fillOpacity,
        // @todo(AG-10275) Remove sectorSpacing null case
        stroke: sectorSpacing != null ? strokes.length > 0 ? strokes[formatIndex % strokes.length] : void 0 : strokes.length > 0 ? strokes[formatIndex % strokes.length] : __BACKGROUND_COLOR_DO_NOT_USE,
        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
        strokeOpacity: this.getOpacity()
      }
    );
    let format2;
    if (formatter) {
      format2 = callbackCache.call(formatter, {
        datum,
        angleKey,
        radiusKey,
        fill,
        stroke,
        fills,
        strokes,
        strokeWidth,
        highlighted: isDatumHighlighted,
        seriesId: this.id
      });
    }
    return {
      fill: (_a = format2 == null ? void 0 : format2.fill) != null ? _a : fill,
      fillOpacity: (_b = format2 == null ? void 0 : format2.fillOpacity) != null ? _b : fillOpacity,
      stroke: (_c = format2 == null ? void 0 : format2.stroke) != null ? _c : stroke,
      strokeWidth: (_d = format2 == null ? void 0 : format2.strokeWidth) != null ? _d : strokeWidth,
      strokeOpacity: (_e = format2 == null ? void 0 : format2.strokeOpacity) != null ? _e : strokeOpacity
    };
  }
  getInnerRadius() {
    const { radius } = this;
    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;
    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;
    if (innerRadius === radius || innerRadius < 0) {
      return 0;
    }
    return innerRadius;
  }
  getOuterRadius() {
    const { outerRadiusRatio, outerRadiusOffset } = this.properties;
    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);
  }
  updateRadiusScale(resize) {
    const newRange = [this.getInnerRadius(), this.getOuterRadius()];
    this.radiusScale.range = newRange;
    if (resize) {
      this.previousRadiusScale.range = newRange;
    }
    this.nodeData = this.nodeData.map((_a) => {
      var _b = _a, { radius } = _b, d = __objRest(_b, ["radius"]);
      return __spreadProps(__spreadValues({}, d), {
        radius,
        innerRadius: Math.max(this.radiusScale.convert(0), 0),
        outerRadius: Math.max(this.radiusScale.convert(radius), 0)
      });
    });
  }
  getTitleTranslationY() {
    var _a, _b;
    const outerRadius = Math.max(0, this.radiusScale.range[1]);
    if (outerRadius === 0) {
      return NaN;
    }
    const spacing = (_b = (_a = this.properties.title) == null ? void 0 : _a.spacing) != null ? _b : 0;
    const titleOffset = 2 + spacing;
    const dy = Math.max(0, -outerRadius);
    return -outerRadius - titleOffset - dy;
  }
  update(_0) {
    return __async(this, arguments, function* ({ seriesRect }) {
      const { title } = this.properties;
      const newNodeDataDependencies = {
        seriesRectWidth: seriesRect == null ? void 0 : seriesRect.width,
        seriesRectHeight: seriesRect == null ? void 0 : seriesRect.height
      };
      const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
      if (resize) {
        this._nodeDataDependencies = newNodeDataDependencies;
      }
      yield this.maybeRefreshNodeData();
      this.updateTitleNodes();
      this.updateRadiusScale(resize);
      this.contentGroup.translationX = this.centerX;
      this.contentGroup.translationY = this.centerY;
      this.highlightGroup.translationX = this.centerX;
      this.highlightGroup.translationY = this.centerY;
      this.backgroundGroup.translationX = this.centerX;
      this.backgroundGroup.translationY = this.centerY;
      if (this.labelGroup) {
        this.labelGroup.translationX = this.centerX;
        this.labelGroup.translationY = this.centerY;
      }
      if (title) {
        const dy = this.getTitleTranslationY();
        const titleBox = title.node.computeBBox();
        title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);
        title.node.translationY = isFinite(dy) ? dy : 0;
      }
      this.updateNodeMidPoint();
      yield this.updateSelections();
      yield this.updateNodes(seriesRect);
    });
  }
  updateTitleNodes() {
    var _a, _b;
    const { oldTitle } = this;
    const { title } = this.properties;
    if (oldTitle !== title) {
      if (oldTitle) {
        (_a = this.labelGroup) == null ? void 0 : _a.removeChild(oldTitle.node);
      }
      if (title) {
        title.node.textBaseline = "bottom";
        (_b = this.labelGroup) == null ? void 0 : _b.appendChild(title.node);
      }
      this.oldTitle = title;
    }
  }
  updateNodeMidPoint() {
    this.nodeData.forEach((d) => {
      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
      d.midPoint = {
        x: d.midCos * Math.max(0, radius),
        y: d.midSin * Math.max(0, radius)
      };
    });
  }
  updateSelections() {
    return __async(this, null, function* () {
      yield this.updateGroupSelection();
      this.updateInnerCircleSelection();
    });
  }
  updateGroupSelection() {
    return __async(this, null, function* () {
      const { itemSelection, highlightSelection, calloutLabelSelection, sectorLabelSelection, innerLabelsSelection } = this;
      const update = (selection, clone) => {
        let nodeData = this.nodeData;
        if (clone) {
          nodeData = nodeData.map((datum) => __spreadProps(__spreadValues({}, datum), { sectorFormat: __spreadValues({}, datum.sectorFormat) }));
        }
        selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));
        if (this.ctx.animationManager.isSkipped()) {
          selection.cleanup();
        }
      };
      update(itemSelection, false);
      update(highlightSelection, true);
      calloutLabelSelection.update(this.nodeData, (group2) => {
        const line = new Line();
        line.tag = 1 /* Callout */;
        line.pointerEvents = 1 /* None */;
        group2.appendChild(line);
        const text = new Text();
        text.tag = 2 /* Label */;
        text.pointerEvents = 1 /* None */;
        group2.appendChild(text);
      });
      sectorLabelSelection.update(this.nodeData, (node) => {
        node.pointerEvents = 1 /* None */;
      });
      innerLabelsSelection.update(this.properties.innerLabels, (node) => {
        node.pointerEvents = 1 /* None */;
      });
    });
  }
  updateInnerCircleSelection() {
    const { innerCircle } = this.properties;
    let radius = 0;
    const innerRadius = this.getInnerRadius();
    if (innerRadius > 0) {
      const circleRadius = Math.min(innerRadius, this.getOuterRadius());
      const antiAliasingPadding = 1;
      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);
    }
    const datums = innerCircle ? [{ radius }] : [];
    this.innerCircleSelection.update(datums);
  }
  updateNodes(seriesRect) {
    return __async(this, null, function* () {
      const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
      const isVisible = this.seriesItemEnabled.indexOf(true) >= 0;
      this.rootGroup.visible = isVisible;
      this.backgroundGroup.visible = isVisible;
      this.contentGroup.visible = isVisible;
      this.highlightGroup.visible = isVisible && (highlightedDatum == null ? void 0 : highlightedDatum.series) === this;
      if (this.labelGroup) {
        this.labelGroup.visible = isVisible;
      }
      this.contentGroup.opacity = this.getOpacity();
      this.innerCircleSelection.each((node, { radius }) => {
        var _a, _b;
        node.setProperties({
          fill: (_a = this.properties.innerCircle) == null ? void 0 : _a.fill,
          opacity: (_b = this.properties.innerCircle) == null ? void 0 : _b.fillOpacity,
          size: radius
        });
      });
      const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
        const format2 = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);
        datum.sectorFormat.fill = format2.fill;
        datum.sectorFormat.stroke = format2.stroke;
        const animationDisabled = this.ctx.animationManager.isSkipped();
        if (animationDisabled) {
          sector.startAngle = datum.startAngle;
          sector.endAngle = datum.endAngle;
          sector.innerRadius = datum.innerRadius;
          sector.outerRadius = datum.outerRadius;
        }
        if (isDatumHighlighted || animationDisabled) {
          sector.fill = format2.fill;
          sector.stroke = format2.stroke;
        }
        sector.strokeWidth = format2.strokeWidth;
        sector.fillOpacity = format2.fillOpacity;
        sector.strokeOpacity = this.properties.strokeOpacity;
        sector.lineDash = this.properties.lineDash;
        sector.lineDashOffset = this.properties.lineDashOffset;
        sector.fillShadow = this.properties.shadow;
        sector.inset = this.properties.sectorSpacing != null ? (this.properties.sectorSpacing + (format2.stroke != null ? format2.strokeWidth : 0)) / 2 : 0;
        sector.lineJoin = this.properties.sectorSpacing != null ? "miter" : "round";
      };
      this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
      this.highlightSelection.each((node, datum, index) => {
        const isDatumHighlighted = (highlightedDatum == null ? void 0 : highlightedDatum.series) === this && node.datum.itemId === highlightedDatum.itemId;
        updateSectorFn(node, datum, index, true);
        node.visible = isDatumHighlighted;
      });
      this.updateCalloutLineNodes();
      this.updateCalloutLabelNodes(seriesRect);
      this.updateSectorLabelNodes();
      this.updateInnerLabelNodes();
      this.updateZerosumRings();
      this.animationState.transition("update");
    });
  }
  updateCalloutLineNodes() {
    var _a;
    const { calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const calloutStrokeWidth = calloutLine.strokeWidth;
    const calloutColors = (_a = calloutLine.colors) != null ? _a : this.properties.strokes;
    const { offset: offset4 } = this.properties.calloutLabel;
    this.calloutLabelSelection.selectByTag(1 /* Callout */).forEach((line, index) => {
      const datum = line.datum;
      const { calloutLabel: label, outerRadius } = datum;
      if ((label == null ? void 0 : label.text) && !label.hidden && outerRadius !== 0) {
        line.visible = true;
        line.strokeWidth = calloutStrokeWidth;
        line.stroke = calloutColors[index % calloutColors.length];
        line.fill = void 0;
        const x1 = datum.midCos * outerRadius;
        const y1 = datum.midSin * outerRadius;
        let x2 = datum.midCos * (outerRadius + calloutLength);
        let y2 = datum.midSin * (outerRadius + calloutLength);
        const isMoved = label.collisionTextAlign || label.collisionOffsetY !== 0;
        if (isMoved && label.box != null) {
          const box = label.box;
          let cx = x2;
          let cy = y2;
          if (x2 < box.x) {
            cx = box.x;
          } else if (x2 > box.x + box.width) {
            cx = box.x + box.width;
          }
          if (y2 < box.y) {
            cy = box.y;
          } else if (y2 > box.y + box.height) {
            cy = box.y + box.height;
          }
          const dx = cx - x2;
          const dy = cy - y2;
          const length = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          const paddedLength = length - offset4;
          if (paddedLength > 0) {
            x2 = x2 + dx * paddedLength / length;
            y2 = y2 + dy * paddedLength / length;
          }
        }
        line.x1 = x1;
        line.y1 = y1;
        line.x2 = x2;
        line.y2 = y2;
      } else {
        line.visible = false;
      }
    });
  }
  getLabelOverflow(text, box, seriesRect) {
    const seriesLeft = seriesRect.x - this.centerX;
    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;
    const seriesTop = seriesRect.y - this.centerY;
    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;
    const errPx = 1;
    let visibleTextPart = 1;
    if (box.x + errPx < seriesLeft) {
      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
    } else if (box.x + box.width - errPx > seriesRight) {
      visibleTextPart = (seriesRight - box.x) / box.width;
    }
    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
  }
  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {
    const { surroundingRadius } = this;
    if (surroundingRadius == null) {
      return false;
    }
    const corners = [
      { x: box.x + dx, y: box.y + dy },
      { x: box.x + box.width + dx, y: box.y + dy },
      { x: box.x + box.width + dx, y: box.y + box.height + dy },
      { x: box.x + dx, y: box.y + box.height + dy }
    ];
    const sur2 = __pow(surroundingRadius, 2);
    return corners.some((corner) => __pow(corner.x, 2) + __pow(corner.y, 2) > sur2);
  }
  computeCalloutLabelCollisionOffsets() {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const { offset: offset4, minSpacing } = calloutLabel;
    const innerRadius = radiusScale.convert(0);
    const shouldSkip = (datum) => {
      const label = datum.calloutLabel;
      return !label || datum.outerRadius === 0;
    };
    const fullData = this.nodeData;
    const data = this.nodeData.filter((t) => !shouldSkip(t));
    data.forEach((datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return;
      label.hidden = false;
      label.collisionTextAlign = void 0;
      label.collisionOffsetY = 0;
    });
    if (data.length <= 1) {
      return;
    }
    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
    const topLabels = data.filter((d) => {
      var _a;
      return d.midSin < 0 && ((_a = d.calloutLabel) == null ? void 0 : _a.textAlign) === "center";
    }).sort((a, b) => a.midCos - b.midCos);
    const bottomLabels = data.filter((d) => {
      var _a;
      return d.midSin >= 0 && ((_a = d.calloutLabel) == null ? void 0 : _a.textAlign) === "center";
    }).sort((a, b) => a.midCos - b.midCos);
    const tempTextNode = new Text();
    const getTextBBox = (datum) => {
      var _a;
      const label = datum.calloutLabel;
      if (label == null)
        return new BBox(0, 0, 0, 0);
      const labelRadius = datum.outerRadius + calloutLine.length + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(this.properties.calloutLabel);
      tempTextNode.setAlign({
        textAlign: (_a = label.collisionTextAlign) != null ? _a : label.textAlign,
        textBaseline: label.textBaseline
      });
      return tempTextNode.computeBBox();
    };
    const avoidNeighbourYCollision = (label, next, direction) => {
      const box = getTextBBox(label).grow(minSpacing / 2);
      const other = getTextBBox(next).grow(minSpacing / 2);
      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
      if (collidesOrBehind) {
        const dy = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
        next.calloutLabel.collisionOffsetY = dy;
      }
    };
    const avoidYCollisions = (labels) => {
      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
      const midIndex = labels.indexOf(midLabel);
      for (let i = midIndex - 1; i >= 0; i--) {
        const prev = labels[i + 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-top");
      }
      for (let i = midIndex + 1; i < labels.length; i++) {
        const prev = labels[i - 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-bottom");
      }
    };
    const avoidXCollisions = (labels) => {
      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
      const boxes = labels.map((label) => getTextBBox(label));
      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
      let labelsCollideLabelsByX = false;
      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
        const box = paddedBoxes[i];
        for (let j = i + 1; j < labels.length; j++) {
          const other = paddedBoxes[j];
          if (box.collidesBBox(other)) {
            labelsCollideLabelsByX = true;
            break;
          }
        }
      }
      const sectors = fullData.map((datum) => {
        const { startAngle, endAngle, outerRadius } = datum;
        return { startAngle, endAngle, innerRadius, outerRadius };
      });
      const labelsCollideSectors = boxes.some((box) => {
        return sectors.some((sector) => boxCollidesSector(box, sector));
      });
      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
        return;
      }
      labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
        const label = d.calloutLabel;
        if (d.midCos < 0) {
          label.collisionTextAlign = "right";
        } else if (d.midCos > 0) {
          label.collisionTextAlign = "left";
        } else {
          label.collisionTextAlign = "center";
        }
      });
    };
    avoidYCollisions(leftLabels);
    avoidYCollisions(rightLabels);
    avoidXCollisions(topLabels);
    avoidXCollisions(bottomLabels);
  }
  updateCalloutLabelNodes(seriesRect) {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, color } = calloutLabel;
    const tempTextNode = new Text();
    this.calloutLabelSelection.selectByTag(2 /* Label */).forEach((text) => {
      var _a;
      const { datum } = text;
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!(label == null ? void 0 : label.text) || outerRadius === 0 || label.hidden) {
        text.visible = false;
        return;
      }
      const labelRadius = outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const align = {
        textAlign: (_a = label.collisionTextAlign) != null ? _a : label.textAlign,
        textBaseline: label.textBaseline
      };
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(this.properties.calloutLabel);
      tempTextNode.setAlign(align);
      const box = tempTextNode.computeBBox();
      let displayText = label.text;
      let visible = true;
      if (calloutLabel.avoidCollisions) {
        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
        visible = !hasVerticalOverflow;
      }
      text.text = displayText;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign(align);
      text.fill = color;
      text.visible = visible;
    });
  }
  computeLabelsBBox(options, seriesRect) {
    return __async(this, null, function* () {
      const { calloutLabel, calloutLine } = this.properties;
      const calloutLength = calloutLine.length;
      const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;
      if (!calloutLabel.avoidCollisions) {
        return null;
      }
      yield this.maybeRefreshNodeData();
      this.updateRadiusScale(false);
      this.computeCalloutLabelCollisionOffsets();
      const textBoxes = [];
      const text = new Text();
      let titleBox;
      const { title } = this.properties;
      if ((title == null ? void 0 : title.text) && title.enabled) {
        const dy = this.getTitleTranslationY();
        if (isFinite(dy)) {
          text.text = title.text;
          text.x = 0;
          text.y = dy;
          text.setFont(title);
          text.setAlign({
            textBaseline: "bottom",
            textAlign: "center"
          });
          titleBox = text.computeBBox();
          textBoxes.push(titleBox);
        }
      }
      this.nodeData.forEach((datum) => {
        var _a;
        const label = datum.calloutLabel;
        if (!label || datum.outerRadius === 0) {
          return null;
        }
        const labelRadius = datum.outerRadius + calloutLength + offset4;
        const x = datum.midCos * labelRadius;
        const y = datum.midSin * labelRadius + label.collisionOffsetY;
        text.text = label.text;
        text.x = x;
        text.y = y;
        text.setFont(this.properties.calloutLabel);
        text.setAlign({
          textAlign: (_a = label.collisionTextAlign) != null ? _a : label.textAlign,
          textBaseline: label.textBaseline
        });
        const box = text.computeBBox();
        label.box = box;
        if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
          label.hidden = true;
          return;
        }
        if (titleBox) {
          const seriesTop = seriesRect.y - this.centerY;
          const titleCleanArea = new BBox(
            titleBox.x - minSpacing,
            seriesTop,
            titleBox.width + 2 * minSpacing,
            titleBox.y + titleBox.height + minSpacing - seriesTop
          );
          if (box.collidesBBox(titleCleanArea)) {
            label.hidden = true;
            return;
          }
        }
        if (options.hideWhenNecessary) {
          const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
            label.text,
            box,
            seriesRect
          );
          const isTooShort = label.text.length > 2 && textLength < 2;
          if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
            label.hidden = true;
            return;
          }
        }
        label.hidden = false;
        textBoxes.push(box);
      });
      if (textBoxes.length === 0) {
        return null;
      }
      return BBox.merge(textBoxes);
    });
  }
  updateSectorLabelNodes() {
    const { radiusScale } = this;
    const innerRadius = radiusScale.convert(0);
    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;
    this.sectorLabelSelection.each((text, datum) => {
      const { sectorLabel, outerRadius } = datum;
      let isTextVisible = false;
      if (sectorLabel && outerRadius !== 0) {
        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
        text.fill = color;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.text = sectorLabel.text;
        text.x = datum.midCos * labelRadius;
        text.y = datum.midSin * labelRadius;
        text.textAlign = "center";
        text.textBaseline = "middle";
        const bbox = text.computeBBox();
        const corners = [
          [bbox.x, bbox.y],
          [bbox.x + bbox.width, bbox.y],
          [bbox.x + bbox.width, bbox.y + bbox.height],
          [bbox.x, bbox.y + bbox.height]
        ];
        const { startAngle, endAngle } = datum;
        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
          isTextVisible = true;
        }
      }
      text.visible = isTextVisible;
    });
  }
  updateInnerLabelNodes() {
    const textBBoxes = [];
    const margins = [];
    this.innerLabelsSelection.each((text, datum) => {
      const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;
      text.fontStyle = fontStyle;
      text.fontWeight = fontWeight;
      text.fontSize = fontSize;
      text.fontFamily = fontFamily;
      text.text = datum.text;
      text.x = 0;
      text.y = 0;
      text.fill = color;
      text.textAlign = "center";
      text.textBaseline = "alphabetic";
      textBBoxes.push(text.computeBBox());
      margins.push(datum.margin);
    });
    const getMarginTop = (index) => index === 0 ? 0 : margins[index];
    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];
    const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {
      return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);
    }, 0);
    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));
    const innerRadius = this.getInnerRadius();
    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
    const textBottoms = [];
    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {
      const bbox = textBBoxes[i];
      const bottom = bbox.height + prev + getMarginTop(i);
      textBottoms.push(bottom);
      prev = bottom + getMarginBottom(i);
    }
    this.innerLabelsSelection.each((text, _datum, index) => {
      text.y = textBottoms[index];
      text.visible = labelsVisible;
    });
  }
  updateZerosumRings() {
    this.zerosumOuterRing.size = this.getOuterRadius() * 2;
    this.zerosumInnerRing.size = this.getInnerRadius() * 2;
  }
  getDatumLegendName(nodeDatum) {
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;
    if (legendItemKey && legendItem !== void 0) {
      return legendItem.text;
    } else if (calloutLabelKey && calloutLabelKey !== angleKey && (calloutLabel == null ? void 0 : calloutLabel.text) !== void 0) {
      return calloutLabel.text;
    } else if (sectorLabelKey && sectorLabelKey !== angleKey && (sectorLabel == null ? void 0 : sectorLabel.text) !== void 0) {
      return sectorLabel.text;
    }
  }
  getTooltipHtml(nodeDatum) {
    var _a;
    if (!this.properties.isValid()) {
      return "";
    }
    const {
      datum,
      angleValue,
      sectorFormat: { fill: color }
    } = nodeDatum;
    const title = sanitizeHtml((_a = this.properties.title) == null ? void 0 : _a.text);
    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);
    const labelText = this.getDatumLegendName(nodeDatum);
    return this.properties.tooltip.toTooltipHtml(
      {
        title: title != null ? title : labelText,
        content: title && labelText ? `${labelText}: ${content}` : content,
        backgroundColor: color
      },
      {
        datum,
        title,
        color,
        seriesId: this.id,
        angleKey: this.properties.angleKey,
        angleName: this.properties.angleName,
        radiusKey: this.properties.radiusKey,
        radiusName: this.properties.radiusName,
        calloutLabelKey: this.properties.calloutLabelKey,
        calloutLabelName: this.properties.calloutLabelName,
        sectorLabelKey: this.properties.sectorLabelKey,
        sectorLabelName: this.properties.sectorLabelName
      }
    );
  }
  getLegendData(legendType) {
    var _a, _b, _c, _d, _e;
    const { processedData, dataModel } = this;
    if (!dataModel || !(processedData == null ? void 0 : processedData.data.length) || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))
      return [];
    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
    const titleText = ((_a = this.properties.title) == null ? void 0 : _a.showInLegend) && this.properties.title.text;
    const legendData = [];
    for (let index = 0; index < processedData.data.length; index++) {
      const { datum, values } = processedData.data[index];
      const labelParts = [];
      if (titleText) {
        labelParts.push(titleText);
      }
      const labels = this.getLabels(
        datum,
        2 * Math.PI,
        2 * Math.PI,
        false,
        values[calloutLabelIdx],
        values[sectorLabelIdx],
        values[legendItemIdx]
      );
      if (legendItemKey && labels.legendItem !== void 0) {
        labelParts.push(labels.legendItem.text);
      } else if (calloutLabelKey && calloutLabelKey !== angleKey && ((_b = labels.calloutLabel) == null ? void 0 : _b.text) !== void 0) {
        labelParts.push((_c = labels.calloutLabel) == null ? void 0 : _c.text);
      } else if (sectorLabelKey && sectorLabelKey !== angleKey && ((_d = labels.sectorLabel) == null ? void 0 : _d.text) !== void 0) {
        labelParts.push((_e = labels.sectorLabel) == null ? void 0 : _e.text);
      }
      if (labelParts.length === 0)
        continue;
      const sectorFormat = this.getSectorFormat(datum, index, false);
      legendData.push({
        legendType: "category",
        id: this.id,
        itemId: index,
        seriesId: this.id,
        enabled: this.seriesItemEnabled[index],
        label: {
          text: labelParts.join(" - ")
        },
        marker: {
          fill: sectorFormat.fill,
          stroke: sectorFormat.stroke,
          fillOpacity: this.properties.fillOpacity,
          strokeOpacity: this.properties.strokeOpacity,
          strokeWidth: this.properties.strokeWidth
        },
        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0
      });
    }
    return legendData;
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series, legendItemName } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    } else if (legendItemName != null) {
      this.toggleOtherSeriesItems(legendItemName, enabled);
    }
  }
  toggleSeriesItem(itemId, enabled) {
    this.seriesItemEnabled[itemId] = enabled;
    this.nodeDataRefresh = true;
  }
  toggleOtherSeriesItems(legendItemName, enabled) {
    var _a;
    if (!this.properties.legendItemKey || !this.dataModel) {
      return;
    }
    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index;
    (_a = this.processedData) == null ? void 0 : _a.data.forEach(({ values }, datumItemId) => {
      if (values[legendItemIdx] === legendItemName) {
        this.toggleSeriesItem(datumItemId, enabled);
      }
    });
  }
  animateEmptyUpdateReady(_data) {
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      true,
      this.properties.rotation,
      this.radiusScale,
      this.previousRadiusScale
    );
    fromToMotion(this.id, "nodes", animationManager, [this.itemSelection, this.highlightSelection], fns.nodes);
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", animationManager, [this.calloutLabelSelection]);
    seriesLabelFadeInAnimation(this, "sector", animationManager, [this.sectorLabelSelection]);
    seriesLabelFadeInAnimation(this, "inner", animationManager, [this.innerLabelsSelection]);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateWaitingUpdateReady() {
    var _a, _b, _c, _d, _e, _f;
    const { itemSelection, highlightSelection, processedData, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const diff2 = (_a = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _a.diff;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const supportedDiff = ((_b = diff2 == null ? void 0 : diff2.moved.length) != null ? _b : 0) === 0 && (diff2 == null ? void 0 : diff2.addedIndices.every((i) => !diff2.removedIndices.includes(i)));
    const hasKeys = ((_c = processedData == null ? void 0 : processedData.defs.keys.length) != null ? _c : 0) > 0;
    const hasUniqueKeys = (_f = (_e = (_d = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _d.animationValidation) == null ? void 0 : _e.uniqueKeys) != null ? _f : true;
    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum),
      diff2
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, [this.calloutLabelSelection]);
    seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, [this.sectorLabelSelection]);
    seriesLabelFadeInAnimation(this, "inner", this.ctx.animationManager, [this.innerLabelsSelection]);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateClearingUpdateEmpty() {
    const { itemSelection, highlightSelection, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(this.id, "nodes", animationManager, [itemSelection, highlightSelection], fns.nodes);
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, [this.calloutLabelSelection]);
    seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, [this.sectorLabelSelection]);
    seriesLabelFadeOutAnimation(this, "inner", this.ctx.animationManager, [this.innerLabelsSelection]);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  getDatumIdFromData(datum) {
    var _a, _b, _c;
    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    if (!((_c = (_b = (_a = this.processedData) == null ? void 0 : _a.reduced) == null ? void 0 : _b.animationValidation) == null ? void 0 : _c.uniqueKeys)) {
      return;
    }
    if (legendItemKey) {
      return datum[legendItemKey];
    } else if (calloutLabelKey) {
      return datum[calloutLabelKey];
    } else if (sectorLabelKey) {
      return datum[sectorLabelKey];
    }
  }
  getDatumId(datum) {
    var _a;
    const { index } = datum;
    return (_a = this.getDatumIdFromData(datum.datum)) != null ? _a : `${index}`;
  }
  onDataChange() {
    this.processSeriesItemEnabled();
  }
};
DonutSeries.className = "DonutSeries";
DonutSeries.type = "donut";

// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts
var pieTheme = {
  series: {
    __extends__: EXTENDS_SERIES_DEFAULTS,
    title: {
      enabled: true,
      fontStyle: void 0,
      fontWeight: "normal" /* NORMAL */,
      fontSize: 14,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_MUTED_LABEL_COLOUR,
      spacing: 5
    },
    calloutLabel: {
      enabled: true,
      fontStyle: void 0,
      fontWeight: void 0,
      fontSize: 12,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_LABEL_COLOUR,
      offset: 3,
      minAngle: 0
    },
    sectorLabel: {
      enabled: true,
      fontStyle: void 0,
      fontWeight: "normal" /* NORMAL */,
      fontSize: 12,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
      positionOffset: 0,
      positionRatio: 0.5
    },
    calloutLine: {
      length: 10,
      strokeWidth: 2
    },
    fillOpacity: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
    lineDash: [0],
    lineDashOffset: 0,
    rotation: 0,
    // @todo(AG-10275) Uncomment this
    // sectorSpacing: 1,
    shadow: {
      enabled: false,
      color: DEFAULT_SHADOW_COLOUR,
      xOffset: 3,
      yOffset: 3,
      blur: 5
    },
    innerLabels: {
      fontStyle: void 0,
      fontWeight: void 0,
      fontSize: 12,
      fontFamily: DEFAULT_FONT_FAMILY,
      color: DEFAULT_LABEL_COLOUR,
      margin: 2
    },
    // @todo(AG-10275) Remove this
    // @ts-expect-error
    __BACKGROUND_COLOR_DO_NOT_USE: DEFAULT_BACKGROUND_COLOUR
  }
};
var piePaletteFactory = ({ takeColors, colorsCount, userPalette }) => {
  const { fills, strokes } = takeColors(colorsCount);
  return {
    fills,
    strokes: userPalette ? strokes : [],
    calloutLine: {
      colors: strokes
    }
  };
};

// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts
var DonutSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["polar"],
  identifier: "donut",
  instanceConstructor: DonutSeries,
  seriesDefaults: {},
  themeTemplate: pieTheme,
  paletteFactory: piePaletteFactory
};

// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts
var PieTitle = class extends Caption {
  constructor() {
    super(...arguments);
    this.showInLegend = false;
  }
};
__decorateClass([
  Validate(BOOLEAN)
], PieTitle.prototype, "showInLegend", 2);
var DonutInnerLabel2 = class extends Label {
  set(properties, _reset) {
    return super.set(properties);
  }
};
__decorateClass([
  Deprecated("Use a Donut Series instead"),
  Validate(STRING, { optional: true })
], DonutInnerLabel2.prototype, "text", 2);
__decorateClass([
  Deprecated("Use a Donut Series instead"),
  Validate(NUMBER, { optional: true })
], DonutInnerLabel2.prototype, "margin", 2);
var DonutInnerCircle2 = class extends BaseProperties {
};
__decorateClass([
  Deprecated("Use a Donut Series instead"),
  Validate(COLOR_STRING, { optional: true })
], DonutInnerCircle2.prototype, "fill", 2);
__decorateClass([
  Deprecated("Use a Donut Series instead"),
  Validate(RATIO, { optional: true })
], DonutInnerCircle2.prototype, "fillOpacity", 2);
var PieSeriesCalloutLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.offset = 3;
    this.minAngle = 0;
    this.minSpacing = 4;
    this.maxCollisionOffset = 50;
    this.avoidCollisions = true;
  }
};
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLabel.prototype, "offset", 2);
__decorateClass([
  Validate(DEGREE)
], PieSeriesCalloutLabel.prototype, "minAngle", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLabel.prototype, "minSpacing", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
__decorateClass([
  Validate(BOOLEAN)
], PieSeriesCalloutLabel.prototype, "avoidCollisions", 2);
var PieSeriesSectorLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.positionOffset = 0;
    this.positionRatio = 0.5;
  }
};
__decorateClass([
  Validate(NUMBER)
], PieSeriesSectorLabel.prototype, "positionOffset", 2);
__decorateClass([
  Validate(RATIO)
], PieSeriesSectorLabel.prototype, "positionRatio", 2);
var PieSeriesCalloutLine = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.length = 10;
    this.strokeWidth = 1;
  }
};
__decorateClass([
  Validate(COLOR_STRING_ARRAY, { optional: true })
], PieSeriesCalloutLine.prototype, "colors", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLine.prototype, "length", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesCalloutLine.prototype, "strokeWidth", 2);
var PieSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.fills = Object.values(DEFAULT_FILLS);
    this.strokes = Object.values(DEFAULT_STROKES);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.rotation = 0;
    this.outerRadiusOffset = 0;
    this.outerRadiusRatio = 1;
    this.strokeWidth = 1;
    this.sectorSpacing = void 0;
    this.innerLabels = new PropertiesArray(DonutInnerLabel2);
    this.title = new PieTitle();
    this.innerCircle = new DonutInnerCircle2();
    this.shadow = new DropShadow();
    this.calloutLabel = new PieSeriesCalloutLabel();
    this.sectorLabel = new PieSeriesSectorLabel();
    this.calloutLine = new PieSeriesCalloutLine();
    this.tooltip = new SeriesTooltip();
    this.__BACKGROUND_COLOR_DO_NOT_USE = void 0;
  }
};
__decorateClass([
  Validate(STRING)
], PieSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], PieSeriesProperties.prototype, "radiusMin", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], PieSeriesProperties.prototype, "radiusMax", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "calloutLabelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "calloutLabelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "sectorLabelKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "sectorLabelName", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "legendItemKey", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], PieSeriesProperties.prototype, "fills", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], PieSeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Validate(RATIO)
], PieSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Validate(RATIO)
], PieSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Validate(LINE_DASH)
], PieSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Validate(FUNCTION, { optional: true })
], PieSeriesProperties.prototype, "formatter", 2);
__decorateClass([
  Validate(DEGREE)
], PieSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Validate(NUMBER)
], PieSeriesProperties.prototype, "outerRadiusOffset", 2);
__decorateClass([
  Validate(RATIO)
], PieSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
  Deprecated("Use a Donut Series instead"),
  Validate(NUMBER, { optional: true })
], PieSeriesProperties.prototype, "innerRadiusOffset", 2);
__decorateClass([
  Deprecated("Use a Donut Series instead"),
  Validate(RATIO, { optional: true })
], PieSeriesProperties.prototype, "innerRadiusRatio", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER)
], PieSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Validate(POSITIVE_NUMBER, { optional: true })
], PieSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
  Validate(OBJECT_ARRAY)
], PieSeriesProperties.prototype, "innerLabels", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "title", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "innerCircle", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "calloutLabel", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "sectorLabel", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "calloutLine", 2);
__decorateClass([
  Validate(OBJECT)
], PieSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], PieSeriesProperties.prototype, "__BACKGROUND_COLOR_DO_NOT_USE", 2);

// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts
var PieSeriesNodeClickEvent = class extends SeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
    this.calloutLabelKey = series.properties.calloutLabelKey;
    this.sectorLabelKey = series.properties.sectorLabelKey;
  }
};
var PieSeries = class extends PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      useLabelLayer: true,
      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
    });
    this.properties = new PieSeriesProperties();
    this.previousRadiusScale = new LinearScale();
    this.radiusScale = new LinearScale();
    // The group node that contains the background graphics.
    this.backgroundGroup = this.rootGroup.appendChild(
      new Group({
        name: `${this.id}-background`,
        layer: true,
        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */
      })
    );
    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());
    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());
    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));
    this.nodeData = [];
    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.
    this.seriesItemEnabled = [];
    this.surroundingRadius = void 0;
    this.NodeClickEvent = PieSeriesNodeClickEvent;
    this.angleScale = new LinearScale();
    this.angleScale.domain = [0, 1];
    this.angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);
    const pieCalloutLabels = new Group({ name: "pieCalloutLabels" });
    const pieSectorLabels = new Group({ name: "pieSectorLabels" });
    const innerLabels = new Group({ name: "innerLabels" });
    this.labelGroup.append(pieCalloutLabels);
    this.labelGroup.append(pieSectorLabels);
    this.labelGroup.append(innerLabels);
    this.calloutLabelSelection = Selection.select(pieCalloutLabels, Group);
    this.sectorLabelSelection = Selection.select(pieSectorLabels, Text);
    this.innerLabelsSelection = Selection.select(innerLabels, Text);
    this.innerCircleSelection = Selection.select(this.innerCircleGroup, Circle);
    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {
      circle.fillOpacity = 0;
      circle.stroke = this.properties.calloutLabel.color;
      circle.strokeWidth = 1;
      circle.strokeOpacity = 1;
    }
  }
  addChartEventListeners() {
    var _a;
    this.destroyFns.push(
      (_a = this.ctx.chartEventManager) == null ? void 0 : _a.addListener("legend-item-click", (event) => this.onLegendItemClick(event))
    );
  }
  visibleChanged() {
    this.processSeriesItemEnabled();
  }
  get visible() {
    return this.seriesItemEnabled.length ? this.seriesItemEnabled.some((visible) => visible) : super.visible;
  }
  processSeriesItemEnabled() {
    var _a;
    const { data, visible } = this;
    this.seriesItemEnabled = (_a = data == null ? void 0 : data.map(() => visible)) != null ? _a : [];
  }
  nodeFactory() {
    return new Sector();
  }
  getSeriesDomain(direction) {
    if (direction === "x" /* X */) {
      return this.angleScale.domain;
    } else {
      return this.radiusScale.domain;
    }
  }
  processData(dataController) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      if (this.data == null || !this.properties.isValid()) {
        return;
      }
      let { data } = this;
      const { seriesItemEnabled } = this;
      const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const extraKeyProps = [];
      const extraProps = [];
      if (legendItemKey) {
        extraKeyProps.push(keyProperty(this, legendItemKey, false, { id: `legendItemKey` }));
      } else if (calloutLabelKey) {
        extraKeyProps.push(keyProperty(this, calloutLabelKey, false, { id: `calloutLabelKey` }));
      } else if (sectorLabelKey) {
        extraKeyProps.push(keyProperty(this, sectorLabelKey, false, { id: `sectorLabelKey` }));
      }
      if (radiusKey) {
        extraProps.push(
          rangedValueProperty(this, radiusKey, {
            id: "radiusValue",
            min: (_a = this.properties.radiusMin) != null ? _a : 0,
            max: this.properties.radiusMax
          }),
          valueProperty(this, radiusKey, true, { id: `radiusRaw` }),
          // Raw value pass-through.
          normalisePropertyTo(
            this,
            { id: "radiusValue" },
            [0, 1],
            1,
            (_b = this.properties.radiusMin) != null ? _b : 0,
            this.properties.radiusMax
          )
        );
      }
      if (calloutLabelKey) {
        extraProps.push(valueProperty(this, calloutLabelKey, false, { id: `calloutLabelValue` }));
      }
      if (sectorLabelKey) {
        extraProps.push(valueProperty(this, sectorLabelKey, false, { id: `sectorLabelValue` }));
      }
      if (legendItemKey) {
        extraProps.push(valueProperty(this, legendItemKey, false, { id: `legendItemValue` }));
      }
      if (animationEnabled && this.processedData && extraKeyProps.length > 0) {
        extraProps.push(diff(this.processedData));
      }
      extraProps.push(animationValidation(this));
      data = data.map((d, idx) => seriesItemEnabled[idx] ? d : __spreadProps(__spreadValues({}, d), { [angleKey]: 0 }));
      yield this.requestDataModel(dataController, data, {
        props: [
          ...extraKeyProps,
          accumulativeValueProperty(this, angleKey, true, { id: `angleValue`, onlyPositive: true }),
          valueProperty(this, angleKey, true, { id: `angleRaw` }),
          // Raw value pass-through.
          normalisePropertyTo(this, { id: "angleValue" }, [0, 1], 0, 0),
          ...extraProps
        ]
      });
      for (const valueDef of (_e = (_d = (_c = this.processedData) == null ? void 0 : _c.defs) == null ? void 0 : _d.values) != null ? _e : []) {
        const { id, missing, property } = valueDef;
        const missCount = getMissCount(this, missing);
        if (id !== "angleRaw" && missCount > 0) {
          Logger.warnOnce(
            `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
          );
        }
      }
      this.animationState.transition("updateData");
    });
  }
  maybeRefreshNodeData() {
    return __async(this, null, function* () {
      if (!this.nodeDataRefresh)
        return;
      const [{ nodeData = [] } = {}] = yield this.createNodeData();
      this.nodeData = nodeData;
      this.nodeDataRefresh = false;
    });
  }
  getProcessedDataIndexes(dataModel) {
    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`).index;
    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`).index : -1;
    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`).index : -1;
    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`).index : -1;
    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index : -1;
    return { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx };
  }
  createNodeData() {
    return __async(this, null, function* () {
      const { id: seriesId, processedData, dataModel, angleScale } = this;
      const { rotation } = this.properties;
      if (!processedData || !dataModel || processedData.type !== "ungrouped")
        return [];
      const { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
      let currentStart = 0;
      let sum2 = 0;
      const nodeData = processedData.data.map((group2, index) => {
        var _a;
        const { datum, values } = group2;
        const currentValue = values[angleIdx];
        const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
        currentStart = currentValue;
        sum2 += currentValue;
        const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
        const span = Math.abs(endAngle - startAngle);
        const midAngle = startAngle + span / 2;
        const angleValue = values[angleIdx + 1];
        const radius = radiusIdx >= 0 ? (_a = values[radiusIdx]) != null ? _a : 1 : 1;
        const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : void 0;
        const legendItemValue = legendItemIdx >= 0 ? values[legendItemIdx] : void 0;
        const labels = this.getLabels(
          datum,
          midAngle,
          span,
          true,
          values[calloutLabelIdx],
          values[sectorLabelIdx],
          legendItemValue
        );
        const sectorFormat = this.getSectorFormat(datum, index, false);
        return __spreadValues({
          itemId: index,
          series: this,
          datum,
          index,
          angleValue,
          midAngle,
          midCos: Math.cos(midAngle),
          midSin: Math.sin(midAngle),
          startAngle,
          endAngle,
          sectorFormat,
          radiusValue,
          radius,
          innerRadius: Math.max(this.radiusScale.convert(0), 0),
          outerRadius: Math.max(this.radiusScale.convert(radius), 0),
          legendItemValue
        }, labels);
      });
      this.zerosumOuterRing.visible = sum2 === 0;
      const { innerRadiusRatio = 1 } = this.properties;
      this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio !== 1 && innerRadiusRatio > 0;
      return [{ itemId: seriesId, nodeData, labelData: nodeData }];
    });
  }
  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {
    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;
    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;
    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;
    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {
      return {};
    }
    const labelFormatterParams = {
      datum,
      angleKey: this.properties.angleKey,
      angleName: this.properties.angleName,
      radiusKey: this.properties.radiusKey,
      radiusName: this.properties.radiusName,
      calloutLabelKey: this.properties.calloutLabelKey,
      calloutLabelName: this.properties.calloutLabelName,
      sectorLabelKey: this.properties.sectorLabelKey,
      sectorLabelName: this.properties.sectorLabelName,
      legendItemKey: this.properties.legendItemKey
    };
    const result = {};
    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {
      result.calloutLabel = __spreadProps(__spreadValues({}, this.getTextAlignment(midAngle)), {
        text: this.getLabelText(calloutLabel, __spreadProps(__spreadValues({}, labelFormatterParams), {
          value: calloutLabelValue
        })),
        hidden: false,
        collisionTextAlign: void 0,
        collisionOffsetY: 0,
        box: void 0
      });
    }
    if (sectorLabelKey) {
      result.sectorLabel = {
        text: this.getLabelText(sectorLabel, __spreadProps(__spreadValues({}, labelFormatterParams), {
          value: sectorLabelValue
        }))
      };
    }
    if (legendItemKey != null && legendItemValue != null) {
      result.legendItem = { key: legendItemKey, text: legendItemValue };
    }
    return result;
  }
  getTextAlignment(midAngle) {
    const quadrantTextOpts = [
      { textAlign: "center", textBaseline: "bottom" },
      { textAlign: "left", textBaseline: "middle" },
      { textAlign: "center", textBaseline: "hanging" },
      { textAlign: "right", textBaseline: "middle" }
    ];
    const midAngle180 = normalizeAngle180(midAngle);
    const quadrantStart = -3 * Math.PI / 4;
    const quadrantOffset = midAngle180 - quadrantStart;
    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);
    return quadrantTextOpts[quadrantIndex];
  }
  getSectorFormat(datum, formatIndex, highlight) {
    var _a, _b, _c, _d, _e;
    const { callbackCache, highlightManager } = this.ctx;
    const { angleKey, radiusKey, fills, strokes, formatter, sectorSpacing, __BACKGROUND_COLOR_DO_NOT_USE } = this.properties;
    const highlightedDatum = highlightManager.getActiveHighlight();
    const isDatumHighlighted = highlight && (highlightedDatum == null ? void 0 : highlightedDatum.series) === this && formatIndex === highlightedDatum.itemId;
    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(
      isDatumHighlighted && this.properties.highlightStyle.item,
      {
        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,
        fillOpacity: this.properties.fillOpacity,
        // @todo(AG-10275) Remove sectorSpacing null case
        stroke: sectorSpacing != null ? strokes.length > 0 ? strokes[formatIndex % strokes.length] : void 0 : strokes.length > 0 ? strokes[formatIndex % strokes.length] : __BACKGROUND_COLOR_DO_NOT_USE,
        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
        strokeOpacity: this.getOpacity()
      }
    );
    let format2;
    if (formatter) {
      format2 = callbackCache.call(formatter, {
        datum,
        angleKey,
        radiusKey,
        fill,
        stroke,
        fills,
        strokes,
        strokeWidth,
        highlighted: isDatumHighlighted,
        seriesId: this.id
      });
    }
    return {
      fill: (_a = format2 == null ? void 0 : format2.fill) != null ? _a : fill,
      fillOpacity: (_b = format2 == null ? void 0 : format2.fillOpacity) != null ? _b : fillOpacity,
      stroke: (_c = format2 == null ? void 0 : format2.stroke) != null ? _c : stroke,
      strokeWidth: (_d = format2 == null ? void 0 : format2.strokeWidth) != null ? _d : strokeWidth,
      strokeOpacity: (_e = format2 == null ? void 0 : format2.strokeOpacity) != null ? _e : strokeOpacity
    };
  }
  getInnerRadius() {
    const { radius } = this;
    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;
    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;
    if (innerRadius === radius || innerRadius < 0) {
      return 0;
    }
    return innerRadius;
  }
  getOuterRadius() {
    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);
  }
  updateRadiusScale(resize) {
    const newRange = [this.getInnerRadius(), this.getOuterRadius()];
    this.radiusScale.range = newRange;
    if (resize) {
      this.previousRadiusScale.range = newRange;
    }
    this.nodeData = this.nodeData.map((_a) => {
      var _b = _a, { radius } = _b, d = __objRest(_b, ["radius"]);
      return __spreadProps(__spreadValues({}, d), {
        radius,
        innerRadius: Math.max(this.radiusScale.convert(0), 0),
        outerRadius: Math.max(this.radiusScale.convert(radius), 0)
      });
    });
  }
  getTitleTranslationY() {
    var _a, _b;
    const outerRadius = Math.max(0, this.radiusScale.range[1]);
    if (outerRadius === 0) {
      return NaN;
    }
    const spacing = (_b = (_a = this.properties.title) == null ? void 0 : _a.spacing) != null ? _b : 0;
    const titleOffset = 2 + spacing;
    const dy = Math.max(0, -outerRadius);
    return -outerRadius - titleOffset - dy;
  }
  update(_0) {
    return __async(this, arguments, function* ({ seriesRect }) {
      const { title } = this.properties;
      const newNodeDataDependencies = {
        seriesRectWidth: seriesRect == null ? void 0 : seriesRect.width,
        seriesRectHeight: seriesRect == null ? void 0 : seriesRect.height
      };
      const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
      if (resize) {
        this._nodeDataDependencies = newNodeDataDependencies;
      }
      yield this.maybeRefreshNodeData();
      this.updateTitleNodes();
      this.updateRadiusScale(resize);
      this.contentGroup.translationX = this.centerX;
      this.contentGroup.translationY = this.centerY;
      this.highlightGroup.translationX = this.centerX;
      this.highlightGroup.translationY = this.centerY;
      this.backgroundGroup.translationX = this.centerX;
      this.backgroundGroup.translationY = this.centerY;
      if (this.labelGroup) {
        this.labelGroup.translationX = this.centerX;
        this.labelGroup.translationY = this.centerY;
      }
      if (title) {
        const dy = this.getTitleTranslationY();
        const titleBox = title.node.computeBBox();
        title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);
        title.node.translationY = isFinite(dy) ? dy : 0;
      }
      this.updateNodeMidPoint();
      yield this.updateSelections();
      yield this.updateNodes(seriesRect);
    });
  }
  updateTitleNodes() {
    var _a, _b;
    const { oldTitle } = this;
    const { title } = this.properties;
    if (oldTitle !== title) {
      if (oldTitle) {
        (_a = this.labelGroup) == null ? void 0 : _a.removeChild(oldTitle.node);
      }
      if (title) {
        title.node.textBaseline = "bottom";
        (_b = this.labelGroup) == null ? void 0 : _b.appendChild(title.node);
      }
      this.oldTitle = title;
    }
  }
  updateNodeMidPoint() {
    this.nodeData.forEach((d) => {
      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
      d.midPoint = {
        x: d.midCos * Math.max(0, radius),
        y: d.midSin * Math.max(0, radius)
      };
    });
  }
  updateSelections() {
    return __async(this, null, function* () {
      yield this.updateGroupSelection();
      this.updateInnerCircleSelection();
    });
  }
  updateGroupSelection() {
    return __async(this, null, function* () {
      const { itemSelection, highlightSelection, calloutLabelSelection, sectorLabelSelection, innerLabelsSelection } = this;
      const update = (selection, clone) => {
        let nodeData = this.nodeData;
        if (clone) {
          nodeData = nodeData.map((datum) => __spreadProps(__spreadValues({}, datum), { sectorFormat: __spreadValues({}, datum.sectorFormat) }));
        }
        selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));
        if (this.ctx.animationManager.isSkipped()) {
          selection.cleanup();
        }
      };
      update(itemSelection, false);
      update(highlightSelection, true);
      calloutLabelSelection.update(this.nodeData, (group2) => {
        const line = new Line();
        line.tag = 1 /* Callout */;
        line.pointerEvents = 1 /* None */;
        group2.appendChild(line);
        const text = new Text();
        text.tag = 2 /* Label */;
        text.pointerEvents = 1 /* None */;
        group2.appendChild(text);
      });
      sectorLabelSelection.update(this.nodeData, (node) => {
        node.pointerEvents = 1 /* None */;
      });
      innerLabelsSelection.update(this.properties.innerLabels, (node) => {
        node.pointerEvents = 1 /* None */;
      });
    });
  }
  updateInnerCircleSelection() {
    const { innerCircle } = this.properties;
    let radius = 0;
    const innerRadius = this.getInnerRadius();
    if (innerRadius > 0) {
      const circleRadius = Math.min(innerRadius, this.getOuterRadius());
      const antiAliasingPadding = 1;
      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);
    }
    const datums = innerCircle ? [{ radius }] : [];
    this.innerCircleSelection.update(datums);
  }
  updateNodes(seriesRect) {
    return __async(this, null, function* () {
      const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
      const isVisible = this.seriesItemEnabled.indexOf(true) >= 0;
      this.rootGroup.visible = isVisible;
      this.backgroundGroup.visible = isVisible;
      this.contentGroup.visible = isVisible;
      this.highlightGroup.visible = isVisible && (highlightedDatum == null ? void 0 : highlightedDatum.series) === this;
      if (this.labelGroup) {
        this.labelGroup.visible = isVisible;
      }
      this.contentGroup.opacity = this.getOpacity();
      this.innerCircleSelection.each((node, { radius }) => {
        var _a, _b;
        node.setProperties({
          fill: (_a = this.properties.innerCircle) == null ? void 0 : _a.fill,
          opacity: (_b = this.properties.innerCircle) == null ? void 0 : _b.fillOpacity,
          size: radius
        });
      });
      const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
        const format2 = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);
        datum.sectorFormat.fill = format2.fill;
        datum.sectorFormat.stroke = format2.stroke;
        const animationDisabled = this.ctx.animationManager.isSkipped();
        if (animationDisabled) {
          sector.startAngle = datum.startAngle;
          sector.endAngle = datum.endAngle;
          sector.innerRadius = datum.innerRadius;
          sector.outerRadius = datum.outerRadius;
        }
        if (isDatumHighlighted || animationDisabled) {
          sector.fill = format2.fill;
          sector.stroke = format2.stroke;
        }
        sector.strokeWidth = format2.strokeWidth;
        sector.fillOpacity = format2.fillOpacity;
        sector.strokeOpacity = this.properties.strokeOpacity;
        sector.lineDash = this.properties.lineDash;
        sector.lineDashOffset = this.properties.lineDashOffset;
        sector.fillShadow = this.properties.shadow;
        sector.inset = this.properties.sectorSpacing != null ? (this.properties.sectorSpacing + (format2.stroke != null ? format2.strokeWidth : 0)) / 2 : 0;
        sector.lineJoin = this.properties.sectorSpacing != null ? "miter" : "round";
      };
      this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
      this.highlightSelection.each((node, datum, index) => {
        const isDatumHighlighted = (highlightedDatum == null ? void 0 : highlightedDatum.series) === this && node.datum.itemId === highlightedDatum.itemId;
        updateSectorFn(node, datum, index, true);
        node.visible = isDatumHighlighted;
      });
      this.updateCalloutLineNodes();
      this.updateCalloutLabelNodes(seriesRect);
      this.updateSectorLabelNodes();
      this.updateInnerLabelNodes();
      this.updateZerosumRings();
      this.animationState.transition("update");
    });
  }
  updateCalloutLineNodes() {
    var _a;
    const { calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const calloutStrokeWidth = calloutLine.strokeWidth;
    const calloutColors = (_a = calloutLine.colors) != null ? _a : this.properties.strokes;
    const { offset: offset4 } = this.properties.calloutLabel;
    this.calloutLabelSelection.selectByTag(1 /* Callout */).forEach((line, index) => {
      const datum = line.datum;
      const { calloutLabel: label, outerRadius } = datum;
      if ((label == null ? void 0 : label.text) && !label.hidden && outerRadius !== 0) {
        line.visible = true;
        line.strokeWidth = calloutStrokeWidth;
        line.stroke = calloutColors[index % calloutColors.length];
        line.fill = void 0;
        const x1 = datum.midCos * outerRadius;
        const y1 = datum.midSin * outerRadius;
        let x2 = datum.midCos * (outerRadius + calloutLength);
        let y2 = datum.midSin * (outerRadius + calloutLength);
        const isMoved = label.collisionTextAlign || label.collisionOffsetY !== 0;
        if (isMoved && label.box != null) {
          const box = label.box;
          let cx = x2;
          let cy = y2;
          if (x2 < box.x) {
            cx = box.x;
          } else if (x2 > box.x + box.width) {
            cx = box.x + box.width;
          }
          if (y2 < box.y) {
            cy = box.y;
          } else if (y2 > box.y + box.height) {
            cy = box.y + box.height;
          }
          const dx = cx - x2;
          const dy = cy - y2;
          const length = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          const paddedLength = length - offset4;
          if (paddedLength > 0) {
            x2 = x2 + dx * paddedLength / length;
            y2 = y2 + dy * paddedLength / length;
          }
        }
        line.x1 = x1;
        line.y1 = y1;
        line.x2 = x2;
        line.y2 = y2;
      } else {
        line.visible = false;
      }
    });
  }
  getLabelOverflow(text, box, seriesRect) {
    const seriesLeft = seriesRect.x - this.centerX;
    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;
    const seriesTop = seriesRect.y - this.centerY;
    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;
    const errPx = 1;
    let visibleTextPart = 1;
    if (box.x + errPx < seriesLeft) {
      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
    } else if (box.x + box.width - errPx > seriesRight) {
      visibleTextPart = (seriesRight - box.x) / box.width;
    }
    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
  }
  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {
    const { surroundingRadius } = this;
    if (surroundingRadius == null) {
      return false;
    }
    const corners = [
      { x: box.x + dx, y: box.y + dy },
      { x: box.x + box.width + dx, y: box.y + dy },
      { x: box.x + box.width + dx, y: box.y + box.height + dy },
      { x: box.x + dx, y: box.y + box.height + dy }
    ];
    const sur2 = __pow(surroundingRadius, 2);
    return corners.some((corner) => __pow(corner.x, 2) + __pow(corner.y, 2) > sur2);
  }
  computeCalloutLabelCollisionOffsets() {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const { offset: offset4, minSpacing } = calloutLabel;
    const innerRadius = radiusScale.convert(0);
    const shouldSkip = (datum) => {
      const label = datum.calloutLabel;
      return !label || datum.outerRadius === 0;
    };
    const fullData = this.nodeData;
    const data = this.nodeData.filter((t) => !shouldSkip(t));
    data.forEach((datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return;
      label.hidden = false;
      label.collisionTextAlign = void 0;
      label.collisionOffsetY = 0;
    });
    if (data.length <= 1) {
      return;
    }
    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
    const topLabels = data.filter((d) => {
      var _a;
      return d.midSin < 0 && ((_a = d.calloutLabel) == null ? void 0 : _a.textAlign) === "center";
    }).sort((a, b) => a.midCos - b.midCos);
    const bottomLabels = data.filter((d) => {
      var _a;
      return d.midSin >= 0 && ((_a = d.calloutLabel) == null ? void 0 : _a.textAlign) === "center";
    }).sort((a, b) => a.midCos - b.midCos);
    const tempTextNode = new Text();
    const getTextBBox = (datum) => {
      var _a;
      const label = datum.calloutLabel;
      if (label == null)
        return new BBox(0, 0, 0, 0);
      const labelRadius = datum.outerRadius + calloutLine.length + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(this.properties.calloutLabel);
      tempTextNode.setAlign({
        textAlign: (_a = label.collisionTextAlign) != null ? _a : label.textAlign,
        textBaseline: label.textBaseline
      });
      return tempTextNode.computeBBox();
    };
    const avoidNeighbourYCollision = (label, next, direction) => {
      const box = getTextBBox(label).grow(minSpacing / 2);
      const other = getTextBBox(next).grow(minSpacing / 2);
      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
      if (collidesOrBehind) {
        const dy = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
        next.calloutLabel.collisionOffsetY = dy;
      }
    };
    const avoidYCollisions = (labels) => {
      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
      const midIndex = labels.indexOf(midLabel);
      for (let i = midIndex - 1; i >= 0; i--) {
        const prev = labels[i + 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-top");
      }
      for (let i = midIndex + 1; i < labels.length; i++) {
        const prev = labels[i - 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-bottom");
      }
    };
    const avoidXCollisions = (labels) => {
      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
      const boxes = labels.map((label) => getTextBBox(label));
      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
      let labelsCollideLabelsByX = false;
      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
        const box = paddedBoxes[i];
        for (let j = i + 1; j < labels.length; j++) {
          const other = paddedBoxes[j];
          if (box.collidesBBox(other)) {
            labelsCollideLabelsByX = true;
            break;
          }
        }
      }
      const sectors = fullData.map((datum) => {
        const { startAngle, endAngle, outerRadius } = datum;
        return { startAngle, endAngle, innerRadius, outerRadius };
      });
      const labelsCollideSectors = boxes.some((box) => {
        return sectors.some((sector) => boxCollidesSector(box, sector));
      });
      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
        return;
      }
      labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
        const label = d.calloutLabel;
        if (d.midCos < 0) {
          label.collisionTextAlign = "right";
        } else if (d.midCos > 0) {
          label.collisionTextAlign = "left";
        } else {
          label.collisionTextAlign = "center";
        }
      });
    };
    avoidYCollisions(leftLabels);
    avoidYCollisions(rightLabels);
    avoidXCollisions(topLabels);
    avoidXCollisions(bottomLabels);
  }
  updateCalloutLabelNodes(seriesRect) {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, color } = calloutLabel;
    const tempTextNode = new Text();
    this.calloutLabelSelection.selectByTag(2 /* Label */).forEach((text) => {
      var _a;
      const { datum } = text;
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!(label == null ? void 0 : label.text) || outerRadius === 0 || label.hidden) {
        text.visible = false;
        return;
      }
      const labelRadius = outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const align = {
        textAlign: (_a = label.collisionTextAlign) != null ? _a : label.textAlign,
        textBaseline: label.textBaseline
      };
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(this.properties.calloutLabel);
      tempTextNode.setAlign(align);
      const box = tempTextNode.computeBBox();
      let displayText = label.text;
      let visible = true;
      if (calloutLabel.avoidCollisions) {
        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
        visible = !hasVerticalOverflow;
      }
      text.text = displayText;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign(align);
      text.fill = color;
      text.visible = visible;
    });
  }
  computeLabelsBBox(options, seriesRect) {
    return __async(this, null, function* () {
      const { calloutLabel, calloutLine } = this.properties;
      const calloutLength = calloutLine.length;
      const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;
      if (!calloutLabel.avoidCollisions) {
        return null;
      }
      yield this.maybeRefreshNodeData();
      this.updateRadiusScale(false);
      this.computeCalloutLabelCollisionOffsets();
      const textBoxes = [];
      const text = new Text();
      let titleBox;
      const { title } = this.properties;
      if ((title == null ? void 0 : title.text) && title.enabled) {
        const dy = this.getTitleTranslationY();
        if (isFinite(dy)) {
          text.text = title.text;
          text.x = 0;
          text.y = dy;
          text.setFont(title);
          text.setAlign({
            textBaseline: "bottom",
            textAlign: "center"
          });
          titleBox = text.computeBBox();
          textBoxes.push(titleBox);
        }
      }
      this.nodeData.forEach((datum) => {
        var _a;
        const label = datum.calloutLabel;
        if (!label || datum.outerRadius === 0) {
          return null;
        }
        const labelRadius = datum.outerRadius + calloutLength + offset4;
        const x = datum.midCos * labelRadius;
        const y = datum.midSin * labelRadius + label.collisionOffsetY;
        text.text = label.text;
        text.x = x;
        text.y = y;
        text.setFont(this.properties.calloutLabel);
        text.setAlign({
          textAlign: (_a = label.collisionTextAlign) != null ? _a : label.textAlign,
          textBaseline: label.textBaseline
        });
        const box = text.computeBBox();
        label.box = box;
        if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
          label.hidden = true;
          return;
        }
        if (titleBox) {
          const seriesTop = seriesRect.y - this.centerY;
          const titleCleanArea = new BBox(
            titleBox.x - minSpacing,
            seriesTop,
            titleBox.width + 2 * minSpacing,
            titleBox.y + titleBox.height + minSpacing - seriesTop
          );
          if (box.collidesBBox(titleCleanArea)) {
            label.hidden = true;
            return;
          }
        }
        if (options.hideWhenNecessary) {
          const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
            label.text,
            box,
            seriesRect
          );
          const isTooShort = label.text.length > 2 && textLength < 2;
          if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
            label.hidden = true;
            return;
          }
        }
        label.hidden = false;
        textBoxes.push(box);
      });
      if (textBoxes.length === 0) {
        return null;
      }
      return BBox.merge(textBoxes);
    });
  }
  updateSectorLabelNodes() {
    const { radiusScale } = this;
    const innerRadius = radiusScale.convert(0);
    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;
    const isDonut = innerRadius > 0;
    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;
    this.sectorLabelSelection.each((text, datum) => {
      const { sectorLabel, outerRadius } = datum;
      let isTextVisible = false;
      if (sectorLabel && outerRadius !== 0) {
        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
        text.fill = color;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.text = sectorLabel.text;
        const shouldPutTextInCenter = !isDonut && singleVisibleSector;
        if (shouldPutTextInCenter) {
          text.x = 0;
          text.y = 0;
        } else {
          text.x = datum.midCos * labelRadius;
          text.y = datum.midSin * labelRadius;
        }
        text.textAlign = "center";
        text.textBaseline = "middle";
        const bbox = text.computeBBox();
        const corners = [
          [bbox.x, bbox.y],
          [bbox.x + bbox.width, bbox.y],
          [bbox.x + bbox.width, bbox.y + bbox.height],
          [bbox.x, bbox.y + bbox.height]
        ];
        const { startAngle, endAngle } = datum;
        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
          isTextVisible = true;
        }
      }
      text.visible = isTextVisible;
    });
  }
  updateInnerLabelNodes() {
    const textBBoxes = [];
    const margins = [];
    this.innerLabelsSelection.each((text, datum) => {
      const { fontStyle, fontWeight, fontSize, fontFamily, color, margin = 2 } = datum;
      text.fontStyle = fontStyle;
      text.fontWeight = fontWeight;
      text.fontSize = fontSize;
      text.fontFamily = fontFamily;
      text.text = datum.text;
      text.x = 0;
      text.y = 0;
      text.fill = color;
      text.textAlign = "center";
      text.textBaseline = "alphabetic";
      textBBoxes.push(text.computeBBox());
      margins.push(margin);
    });
    const getMarginTop = (index) => index === 0 ? 0 : margins[index];
    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];
    const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {
      return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);
    }, 0);
    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));
    const innerRadius = this.getInnerRadius();
    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
    const textBottoms = [];
    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {
      const bbox = textBBoxes[i];
      const bottom = bbox.height + prev + getMarginTop(i);
      textBottoms.push(bottom);
      prev = bottom + getMarginBottom(i);
    }
    this.innerLabelsSelection.each((text, _datum, index) => {
      text.y = textBottoms[index];
      text.visible = labelsVisible;
    });
  }
  updateZerosumRings() {
    this.zerosumOuterRing.size = this.getOuterRadius() * 2;
    this.zerosumInnerRing.size = this.getInnerRadius() * 2;
  }
  getDatumLegendName(nodeDatum) {
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;
    if (legendItemKey && legendItem !== void 0) {
      return legendItem.text;
    } else if (calloutLabelKey && calloutLabelKey !== angleKey && (calloutLabel == null ? void 0 : calloutLabel.text) !== void 0) {
      return calloutLabel.text;
    } else if (sectorLabelKey && sectorLabelKey !== angleKey && (sectorLabel == null ? void 0 : sectorLabel.text) !== void 0) {
      return sectorLabel.text;
    }
  }
  getTooltipHtml(nodeDatum) {
    var _a;
    if (!this.properties.isValid()) {
      return "";
    }
    const {
      datum,
      angleValue,
      sectorFormat: { fill: color }
    } = nodeDatum;
    const title = sanitizeHtml((_a = this.properties.title) == null ? void 0 : _a.text);
    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);
    const labelText = this.getDatumLegendName(nodeDatum);
    return this.properties.tooltip.toTooltipHtml(
      {
        title: title != null ? title : labelText,
        content: title && labelText ? `${labelText}: ${content}` : content,
        backgroundColor: color
      },
      {
        datum,
        title,
        color,
        seriesId: this.id,
        angleKey: this.properties.angleKey,
        angleName: this.properties.angleName,
        radiusKey: this.properties.radiusKey,
        radiusName: this.properties.radiusName,
        calloutLabelKey: this.properties.calloutLabelKey,
        calloutLabelName: this.properties.calloutLabelName,
        sectorLabelKey: this.properties.sectorLabelKey,
        sectorLabelName: this.properties.sectorLabelName
      }
    );
  }
  getLegendData(legendType) {
    var _a, _b, _c, _d, _e;
    const { processedData, dataModel } = this;
    if (!dataModel || !(processedData == null ? void 0 : processedData.data.length) || legendType !== "category") {
      return [];
    }
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {
      return [];
    }
    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
    const titleText = ((_a = this.properties.title) == null ? void 0 : _a.showInLegend) && this.properties.title.text;
    const legendData = [];
    for (let index = 0; index < processedData.data.length; index++) {
      const { datum, values } = processedData.data[index];
      const labelParts = [];
      if (titleText) {
        labelParts.push(titleText);
      }
      const labels = this.getLabels(
        datum,
        2 * Math.PI,
        2 * Math.PI,
        false,
        values[calloutLabelIdx],
        values[sectorLabelIdx],
        values[legendItemIdx]
      );
      if (legendItemKey && labels.legendItem !== void 0) {
        labelParts.push(labels.legendItem.text);
      } else if (calloutLabelKey && calloutLabelKey !== angleKey && ((_b = labels.calloutLabel) == null ? void 0 : _b.text) !== void 0) {
        labelParts.push((_c = labels.calloutLabel) == null ? void 0 : _c.text);
      } else if (sectorLabelKey && sectorLabelKey !== angleKey && ((_d = labels.sectorLabel) == null ? void 0 : _d.text) !== void 0) {
        labelParts.push((_e = labels.sectorLabel) == null ? void 0 : _e.text);
      }
      if (labelParts.length === 0)
        continue;
      const sectorFormat = this.getSectorFormat(datum, index, false);
      legendData.push({
        legendType: "category",
        id: this.id,
        itemId: index,
        seriesId: this.id,
        enabled: this.seriesItemEnabled[index],
        label: {
          text: labelParts.join(" - ")
        },
        marker: {
          fill: sectorFormat.fill,
          stroke: sectorFormat.stroke,
          fillOpacity: this.properties.fillOpacity,
          strokeOpacity: this.properties.strokeOpacity,
          strokeWidth: this.properties.strokeWidth
        },
        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0
      });
    }
    return legendData;
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series, legendItemName } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    } else if (legendItemName != null) {
      this.toggleOtherSeriesItems(legendItemName, enabled);
    }
  }
  toggleSeriesItem(itemId, enabled) {
    this.seriesItemEnabled[itemId] = enabled;
    this.nodeDataRefresh = true;
  }
  toggleOtherSeriesItems(legendItemName, enabled) {
    var _a;
    if (!this.properties.legendItemKey || !this.dataModel) {
      return;
    }
    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index;
    (_a = this.processedData) == null ? void 0 : _a.data.forEach(({ values }, datumItemId) => {
      if (values[legendItemIdx] === legendItemName) {
        this.toggleSeriesItem(datumItemId, enabled);
      }
    });
  }
  animateEmptyUpdateReady(_data) {
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      true,
      this.properties.rotation,
      this.radiusScale,
      this.previousRadiusScale
    );
    fromToMotion(this.id, "nodes", animationManager, [this.itemSelection, this.highlightSelection], fns.nodes);
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", animationManager, [this.calloutLabelSelection]);
    seriesLabelFadeInAnimation(this, "sector", animationManager, [this.sectorLabelSelection]);
    seriesLabelFadeInAnimation(this, "inner", animationManager, [this.innerLabelsSelection]);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateWaitingUpdateReady() {
    var _a, _b, _c, _d, _e, _f;
    const { itemSelection, highlightSelection, processedData, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const diff2 = (_a = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _a.diff;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const supportedDiff = ((_b = diff2 == null ? void 0 : diff2.moved.length) != null ? _b : 0) === 0 && (diff2 == null ? void 0 : diff2.addedIndices.every((i) => !diff2.removedIndices.includes(i)));
    const hasKeys = ((_c = processedData == null ? void 0 : processedData.defs.keys.length) != null ? _c : 0) > 0;
    const hasUniqueKeys = (_f = (_e = (_d = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _d.animationValidation) == null ? void 0 : _e.uniqueKeys) != null ? _f : true;
    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum),
      diff2
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, [this.calloutLabelSelection]);
    seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, [this.sectorLabelSelection]);
    seriesLabelFadeInAnimation(this, "inner", this.ctx.animationManager, [this.innerLabelsSelection]);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateClearingUpdateEmpty() {
    const { itemSelection, highlightSelection, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(this.id, "nodes", animationManager, [itemSelection, highlightSelection], fns.nodes);
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, [this.calloutLabelSelection]);
    seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, [this.sectorLabelSelection]);
    seriesLabelFadeOutAnimation(this, "inner", this.ctx.animationManager, [this.innerLabelsSelection]);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  getDatumIdFromData(datum) {
    var _a, _b, _c;
    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    if (!((_c = (_b = (_a = this.processedData) == null ? void 0 : _a.reduced) == null ? void 0 : _b.animationValidation) == null ? void 0 : _c.uniqueKeys)) {
      return;
    }
    if (legendItemKey) {
      return datum[legendItemKey];
    } else if (calloutLabelKey) {
      return datum[calloutLabelKey];
    } else if (sectorLabelKey) {
      return datum[sectorLabelKey];
    }
  }
  getDatumId(datum) {
    var _a;
    const { index } = datum;
    return (_a = this.getDatumIdFromData(datum.datum)) != null ? _a : `${index}`;
  }
  onDataChange() {
    this.processSeriesItemEnabled();
  }
};
PieSeries.className = "PieSeries";
PieSeries.type = "pie";

// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts
var PieSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["polar"],
  identifier: "pie",
  instanceConstructor: PieSeries,
  seriesDefaults: {},
  themeTemplate: pieTheme,
  paletteFactory: piePaletteFactory
};

// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts
function registerInbuiltModules() {
  registerModule(BackgroundModule);
  registerModule(NavigatorModule);
  registerModule(AreaSeriesModule);
  registerModule(BarSeriesModule);
  registerModule(BubbleSeriesModule);
  registerModule(LineSeriesModule);
  registerModule(ScatterSeriesModule);
  registerModule(DonutSeriesModule);
  registerModule(PieSeriesModule);
  registerModule(HistogramSeriesModule);
  const inbuiltAxes = /* @__PURE__ */ new Map([
    [NumberAxis.type, NumberAxis],
    [CategoryAxis.type, CategoryAxis],
    [TimeAxis.type, TimeAxis],
    [GroupedCategoryAxis.type, GroupedCategoryAxis],
    [LogAxis.type, LogAxis]
  ]);
  inbuiltAxes.forEach((impl, type) => {
    registerAxis(type, impl);
  });
  registerLegend("category", "legend", Legend, void 0);
}

// packages/ag-charts-community/src/chart/factory/setupModules.ts
function setupModules() {
  for (const m of REGISTERED_MODULES) {
    if (m.packageType === "enterprise" && !verifyIfModuleExpected(m)) {
      Logger.errorOnce("Unexpected enterprise module registered: " + m.identifier);
    }
    if (m.type === "root" && m.themeTemplate) {
      for (const chartType2 of m.chartTypes) {
        registerChartDefaults(chartType2, m.themeTemplate);
      }
    }
    if (m.type === "series") {
      if (m.chartTypes.length > 1) {
        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);
      }
      registerSeries(m);
    }
    if (m.type === "series-option" && m.themeTemplate) {
      for (const seriesType of m.seriesTypes) {
        registerSeriesThemeTemplate(seriesType, m.themeTemplate);
      }
    }
    if (m.type === "axis-option" && m.themeTemplate) {
      for (const axisType of m.axisTypes) {
        const axisTypeTheme = m.themeTemplate[axisType];
        const theme = __spreadValues(__spreadValues({}, m.themeTemplate), axisTypeTheme);
        for (const axisType2 of m.axisTypes) {
          delete theme[axisType2];
        }
        registerAxisThemeTemplate(axisType, theme);
      }
    }
    if (m.type === "axis") {
      registerAxis(m.identifier, m.instanceConstructor);
      if (m.themeTemplate) {
        registerAxisThemeTemplate(m.identifier, m.themeTemplate);
      }
    }
    if (m.type === "legend") {
      registerLegend(m.identifier, m.optionsKey, m.instanceConstructor, m.themeTemplate);
    }
  }
  if (hasRegisteredEnterpriseModules()) {
    const expectedButUnused = getUnusedExpectedModules();
    if (expectedButUnused.length > 0) {
      Logger.errorOnce("Enterprise modules expected but not registered: ", expectedButUnused);
    }
  }
}

// packages/ag-charts-community/src/chart/hierarchyChart.ts
var _HierarchyChart = class _HierarchyChart extends Chart {
  constructor(options, resources) {
    super(options, resources);
    this._data = {};
  }
  performLayout() {
    return __async(this, null, function* () {
      const shrinkRect = yield __superGet(_HierarchyChart.prototype, this, "performLayout").call(this);
      const {
        seriesArea: { padding },
        seriesRoot
      } = this;
      const fullSeriesRect = shrinkRect.clone();
      shrinkRect.shrink(padding.left, "left");
      shrinkRect.shrink(padding.top, "top");
      shrinkRect.shrink(padding.right, "right");
      shrinkRect.shrink(padding.bottom, "bottom");
      this.seriesRect = shrinkRect;
      this.animationRect = shrinkRect;
      this.hoverRect = shrinkRect;
      seriesRoot.translationX = Math.floor(shrinkRect.x);
      seriesRoot.translationY = Math.floor(shrinkRect.y);
      yield Promise.all(
        this.series.map((series) => __async(this, null, function* () {
          yield series.update({ seriesRect: shrinkRect });
        }))
      );
      seriesRoot.visible = this.series[0].visible;
      seriesRoot.setClipRectInGroupCoordinateSpace(
        new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)
      );
      this.layoutService.dispatchLayoutComplete({
        type: "layout-complete",
        chart: { width: this.scene.width, height: this.scene.height },
        clipSeries: false,
        series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },
        axes: []
      });
      return shrinkRect;
    });
  }
};
_HierarchyChart.className = "HierarchyChart";
_HierarchyChart.type = "hierarchy";
var HierarchyChart = _HierarchyChart;

// packages/ag-charts-community/src/chart/axis/polarAxis.ts
var PolarAxis = class extends Axis {
  constructor() {
    super(...arguments);
    this.shape = "polygon";
    this.innerRadiusRatio = 0;
    this.defaultTickMinSpacing = 20;
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
};
__decorateClass([
  Validate(UNION(["polygon", "circle"], "a polar axis shape"))
], PolarAxis.prototype, "shape", 2);
__decorateClass([
  Validate(RATIO)
], PolarAxis.prototype, "innerRadiusRatio", 2);

// packages/ag-charts-community/src/chart/polarChart.ts
var _PolarChart = class _PolarChart extends Chart {
  constructor(options, resources) {
    super(options, resources);
    this.padding = new Padding(40);
    this.axisGroup.zIndex = 5 /* AXIS_FOREGROUND_ZINDEX */;
  }
  performLayout() {
    return __async(this, null, function* () {
      const shrinkRect = yield __superGet(_PolarChart.prototype, this, "performLayout").call(this);
      const fullSeriesRect = shrinkRect.clone();
      this.computeSeriesRect(shrinkRect);
      yield this.computeCircle(shrinkRect);
      this.axes.forEach((axis) => axis.update());
      this.hoverRect = shrinkRect;
      this.layoutService.dispatchLayoutComplete({
        type: "layout-complete",
        chart: { width: this.scene.width, height: this.scene.height },
        clipSeries: false,
        series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },
        axes: []
      });
      return shrinkRect;
    });
  }
  updateAxes(cx, cy, radius) {
    var _a, _b;
    const angleAxis = this.axes.find((axis) => axis.direction === "x" /* X */);
    const radiusAxis = this.axes.find((axis) => axis.direction === "y" /* Y */);
    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) {
      return;
    }
    const angleScale = angleAxis.scale;
    const angles = (_a = angleScale.ticks) == null ? void 0 : _a.call(angleScale).map((value) => angleScale.convert(value));
    const innerRadiusRatio = radiusAxis.innerRadiusRatio;
    angleAxis.innerRadiusRatio = innerRadiusRatio;
    (_b = angleAxis.computeRange) == null ? void 0 : _b.call(angleAxis);
    angleAxis.gridLength = radius;
    radiusAxis.gridAngles = angles;
    radiusAxis.gridRange = angleAxis.range;
    radiusAxis.range = [radius, radius * innerRadiusRatio];
    [angleAxis, radiusAxis].forEach((axis) => {
      axis.translation.x = cx;
      axis.translation.y = cy;
      axis.calculateLayout();
    });
  }
  computeSeriesRect(shrinkRect) {
    const {
      seriesArea: { padding }
    } = this;
    shrinkRect.shrink(padding.left, "left");
    shrinkRect.shrink(padding.top, "top");
    shrinkRect.shrink(padding.right, "right");
    shrinkRect.shrink(padding.bottom, "bottom");
    this.seriesRect = shrinkRect;
    this.animationRect = shrinkRect;
  }
  computeCircle(seriesBox) {
    return __async(this, null, function* () {
      const polarSeries = this.series.filter((series) => {
        return series instanceof PolarSeries;
      });
      const polarAxes = this.axes.filter((axis) => {
        return axis instanceof PolarAxis;
      });
      const setSeriesCircle = (cx, cy, r) => {
        this.updateAxes(cx, cy, r);
        polarSeries.forEach((series) => {
          series.centerX = cx;
          series.centerY = cy;
          series.radius = r;
        });
        const pieSeries = polarSeries.filter((s) => {
          return s instanceof PieSeries || s instanceof DonutSeries;
        });
        if (pieSeries.length > 1) {
          const innerRadii = pieSeries.map((series) => {
            const innerRadius = series.getInnerRadius();
            return { series, innerRadius };
          }).sort((a, b) => a.innerRadius - b.innerRadius);
          innerRadii.at(-1).series.surroundingRadius = void 0;
          for (let i = 0; i < innerRadii.length - 1; i++) {
            innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;
          }
        }
      };
      const centerX = seriesBox.x + seriesBox.width / 2;
      const centerY = seriesBox.y + seriesBox.height / 2;
      const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);
      let radius = initialRadius;
      setSeriesCircle(centerX, centerY, radius);
      const shake = (..._0) => __async(this, [..._0], function* ({ hideWhenNecessary = false } = {}) {
        const labelBoxes = [];
        for (const series of [...polarAxes, ...polarSeries]) {
          const box = yield series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);
          if (box) {
            labelBoxes.push(box);
          }
        }
        if (labelBoxes.length === 0) {
          setSeriesCircle(centerX, centerY, initialRadius);
          return;
        }
        const labelBox = BBox.merge(labelBoxes);
        const refined = this.refineCircle(labelBox, radius, seriesBox);
        setSeriesCircle(refined.centerX, refined.centerY, refined.radius);
        if (refined.radius === radius) {
          return;
        }
        radius = refined.radius;
      });
      yield shake();
      yield shake();
      yield shake();
      yield shake({ hideWhenNecessary: true });
      yield shake({ hideWhenNecessary: true });
      return { radius, centerX, centerY };
    });
  }
  refineCircle(labelsBox, radius, seriesBox) {
    const minCircleRatio = 0.5;
    const circleLeft = -radius;
    const circleTop = -radius;
    const circleRight = radius;
    const circleBottom = radius;
    let padLeft = Math.max(0, circleLeft - labelsBox.x);
    let padTop = Math.max(0, circleTop - labelsBox.y);
    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);
    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);
    padLeft = padRight = Math.max(padLeft, padRight);
    padTop = padBottom = Math.max(padTop, padBottom);
    const availCircleWidth = seriesBox.width - padLeft - padRight;
    const availCircleHeight = seriesBox.height - padTop - padBottom;
    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;
    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;
    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;
    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);
    if (newRadius < minRadius) {
      newRadius = minRadius;
      const horizontalPadding = padLeft + padRight;
      const verticalPadding = padTop + padBottom;
      if (2 * newRadius + verticalPadding > seriesBox.height) {
        const padHeight = seriesBox.height - 2 * newRadius;
        if (Math.min(padTop, padBottom) * 2 > padHeight) {
          padTop = padHeight / 2;
          padBottom = padHeight / 2;
        } else if (padTop > padBottom) {
          padTop = padHeight - padBottom;
        } else {
          padBottom = padHeight - padTop;
        }
      }
      if (2 * newRadius + horizontalPadding > seriesBox.width) {
        const padWidth = seriesBox.width - 2 * newRadius;
        if (Math.min(padLeft, padRight) * 2 > padWidth) {
          padLeft = padWidth / 2;
          padRight = padWidth / 2;
        } else if (padLeft > padRight) {
          padLeft = padWidth - padRight;
        } else {
          padRight = padWidth - padLeft;
        }
      }
    }
    const newWidth = padLeft + 2 * newRadius + padRight;
    const newHeight = padTop + 2 * newRadius + padBottom;
    return {
      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,
      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,
      radius: newRadius
    };
  }
};
_PolarChart.className = "PolarChart";
_PolarChart.type = "polar";
var PolarChart = _PolarChart;

// packages/ag-charts-community/src/chart/agChartV2.ts
var debug2 = Debug.create(true, "opts");
function chartType(options) {
  if (isAgCartesianChartOptions(options)) {
    return "cartesian";
  } else if (isAgPolarChartOptions(options)) {
    return "polar";
  } else if (isAgHierarchyChartOptions(options)) {
    return "hierarchy";
  }
  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);
}
var _AgCharts = class _AgCharts {
  static licenseCheck(options) {
    var _a, _b, _c, _d;
    if (this.licenseChecked)
      return;
    this.licenseManager = (_b = (_a = enterpriseModule).licenseManager) == null ? void 0 : _b.call(_a, options);
    (_c = this.licenseManager) == null ? void 0 : _c.setLicenseKey(this.licenseKey, this.gridContext);
    (_d = this.licenseManager) == null ? void 0 : _d.validateLicense();
    this.licenseChecked = true;
  }
  static setLicenseKey(licenseKey) {
    this.licenseKey = licenseKey;
  }
  static setGridContext(gridContext) {
    this.gridContext = gridContext;
  }
  static getLicenseDetails(licenseKey) {
    var _a, _b;
    return (_b = (_a = enterpriseModule).licenseManager) == null ? void 0 : _b.call(_a, {}).getLicenseDetails(licenseKey);
  }
  /**
   * Returns the `AgChartInstance` for a DOM node, if there is one.
   */
  static getInstance(element2) {
    return AgChartsInternal.getInstance(element2);
  }
  /**
   * Create a new `AgChartInstance` based upon the given configuration options.
   */
  static create(options) {
    var _a, _b, _c, _d;
    this.licenseCheck(options);
    const chart = AgChartsInternal.createOrUpdate(options);
    if ((_a = this.licenseManager) == null ? void 0 : _a.isDisplayWatermark()) {
      (_d = (_c = enterpriseModule).injectWatermark) == null ? void 0 : _d.call(
        _c,
        (_b = options.document) != null ? _b : document,
        chart.chart.element,
        this.licenseManager.getWatermarkMessage()
      );
    }
    return chart;
  }
  /**
   * Update an existing `AgChartInstance`. Options provided should be complete and not
   * partial.
   *
   * __NOTE__: As each call could trigger a chart redraw, multiple calls to update options in
   * quick succession could result in undesirable flickering, so callers should batch up and/or
   * debounce changes to avoid unintended partial update renderings.
   */
  static update(chart, options) {
    if (!AgChartInstanceProxy.isInstance(chart)) {
      throw new Error(_AgCharts.INVALID_CHART_REF_MESSAGE);
    }
    AgChartsInternal.createOrUpdate(options, chart);
  }
  /**
   * Update an existing `AgChartInstance` by applying a partial set of option changes.
   *
   * __NOTE__: As each call could trigger a chart redraw, each individual delta options update
   * should leave the chart in a valid options state. Also, multiple calls to update options in
   * quick succession could result in undesirable flickering, so callers should batch up and/or
   * debounce changes to avoid unintended partial update renderings.
   */
  static updateDelta(chart, deltaOptions) {
    if (!AgChartInstanceProxy.isInstance(chart)) {
      throw new Error(_AgCharts.INVALID_CHART_REF_MESSAGE);
    }
    AgChartsInternal.updateUserDelta(chart, deltaOptions);
  }
  /**
   * Starts a browser-based image download for the given `AgChartInstance`.
   */
  static download(chart, options) {
    if (!(chart instanceof AgChartInstanceProxy)) {
      throw new Error(_AgCharts.INVALID_CHART_REF_MESSAGE);
    }
    AgChartsInternal.download(chart, options);
  }
  /**
   * Returns a base64-encoded image data URL for the given `AgChartInstance`.
   */
  static getImageDataURL(chart, options) {
    if (!(chart instanceof AgChartInstanceProxy)) {
      throw new Error(_AgCharts.INVALID_CHART_REF_MESSAGE);
    }
    return AgChartsInternal.getImageDataURL(chart, options);
  }
};
_AgCharts.INVALID_CHART_REF_MESSAGE = "AG Charts - invalid chart reference passed";
_AgCharts.licenseChecked = false;
_AgCharts.gridContext = false;
var AgCharts = _AgCharts;
var AgChart = class _AgChart {
  static warnDeprecated(memberName) {
    const warnDeprecated = createDeprecationWarning();
    warnDeprecated(`AgChart.${memberName}`, `Use AgCharts.${memberName} instead`);
  }
  static create(options) {
    _AgChart.warnDeprecated("create");
    return AgCharts.create(options);
  }
  static update(chart, options) {
    _AgChart.warnDeprecated("update");
    return AgCharts.update(chart, options);
  }
  static updateDelta(chart, deltaOptions) {
    _AgChart.warnDeprecated("updateDelta");
    return AgCharts.updateDelta(chart, deltaOptions);
  }
  static download(chart, options) {
    _AgChart.warnDeprecated("download");
    return AgCharts.download(chart, options);
  }
  static getImageDataURL(chart, options) {
    _AgChart.warnDeprecated("getImageDataURL");
    return AgCharts.getImageDataURL(chart, options);
  }
};
var _AgChartsInternal = class _AgChartsInternal {
  static getInstance(element2) {
    const chart = Chart.getInstance(element2);
    return chart != null ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;
  }
  static initialiseModules() {
    if (_AgChartsInternal.initialised)
      return;
    registerInbuiltModules();
    setupModules();
    _AgChartsInternal.initialised = true;
  }
  static createOrUpdate(options, proxy) {
    var _b;
    _AgChartsInternal.initialiseModules();
    debug2(">>> AgChartV2.createOrUpdate() user options", options);
    const _a = options, { overrideDevicePixelRatio, document: document2, window: userWindow } = _a, userOptions = __objRest(_a, ["overrideDevicePixelRatio", "document", "window"]);
    const chartOptions = new ChartOptions(userOptions, { overrideDevicePixelRatio, document: document2, window: userWindow });
    let chart = proxy == null ? void 0 : proxy.chart;
    if (chart == null || chartType(userOptions) !== chartType(chart.processedOptions)) {
      chart = _AgChartsInternal.createChartInstance(chartOptions, chart);
    }
    if (proxy == null) {
      proxy = new AgChartInstanceProxy(chart);
    } else {
      proxy.chart = chart;
    }
    if (debug2.check() && typeof window !== "undefined") {
      (_b = window.agChartInstances) != null ? _b : window.agChartInstances = {};
      window.agChartInstances[chart.id] = chart;
    }
    chart.queuedUserOptions.push(userOptions);
    chart.requestFactoryUpdate((chart2) => {
      chart2.applyOptions(chartOptions);
      chart2.queuedUserOptions.splice(0, chart2.queuedUserOptions.indexOf(userOptions));
    });
    return proxy;
  }
  static updateUserDelta(proxy, deltaOptions) {
    deltaOptions = deepClone(deltaOptions, { shallow: ["data"] });
    jsonWalk(
      deltaOptions,
      (node) => {
        if (typeof node !== "object")
          return;
        for (const [key, value] of Object.entries(node)) {
          if (typeof value === "undefined") {
            Object.assign(node, { [key]: Symbol("UNSET") });
          }
        }
      },
      { skip: ["data"] }
    );
    const { chart } = proxy;
    const lastUpdateOptions = chart.getOptions();
    const userOptions = mergeDefaults(deltaOptions, lastUpdateOptions);
    debug2(">>> AgChartV2.updateUserDelta() user delta", deltaOptions);
    debug2("AgChartV2.updateUserDelta() - base options", lastUpdateOptions);
    _AgChartsInternal.createOrUpdate(userOptions, proxy);
  }
  /**
   * Returns the content of the current canvas as an image.
   */
  static download(proxy, opts) {
    return __async(this, null, function* () {
      try {
        const clone = yield _AgChartsInternal.prepareResizedChart(proxy, opts);
        clone.chart.scene.download(opts == null ? void 0 : opts.fileName, opts == null ? void 0 : opts.fileFormat);
        clone.destroy();
      } catch (error) {
        Logger.errorOnce(error);
      }
    });
  }
  static getImageDataURL(proxy, opts) {
    return __async(this, null, function* () {
      const clone = yield _AgChartsInternal.prepareResizedChart(proxy, opts);
      const { canvas } = clone.chart.scene;
      const result = canvas.getDataURL(opts == null ? void 0 : opts.fileFormat);
      clone.destroy();
      return result;
    });
  }
  static prepareResizedChart(_0) {
    return __async(this, arguments, function* (chartProxy, opts = {}) {
      const { chart } = chartProxy;
      const { width = chart.width, height = chart.height } = opts;
      const options = mergeDefaults(
        {
          container: document.createElement("div"),
          overrideDevicePixelRatio: 1,
          autoSize: false,
          width,
          height
        },
        // Disable enterprise features that may interfere with image generation.
        hasRegisteredEnterpriseModules() && { animation: { enabled: false } },
        chart.userOptions
      );
      const cloneProxy = _AgChartsInternal.createOrUpdate(options);
      cloneProxy.chart.zoomManager.updateZoom(chartProxy.chart.zoomManager.getZoom());
      chartProxy.chart.series.forEach((series, index) => {
        if (series.visible !== true) {
          cloneProxy.chart.series[index].visible = series.visible;
        }
      });
      chartProxy.chart.update(0 /* FULL */, { forceNodeDataRefresh: true });
      yield cloneProxy.chart.waitForUpdate();
      return cloneProxy;
    });
  }
  static createChartInstance(options, oldChart) {
    const transferableResource = oldChart == null ? void 0 : oldChart.destroy({ keepTransferableResources: true });
    const ChartConstructor = _AgChartsInternal.getChartByOptions(options.processedOptions);
    return new ChartConstructor(options, transferableResource);
  }
  static getChartByOptions(options) {
    if (isAgCartesianChartOptions(options)) {
      return CartesianChart;
    } else if (isAgHierarchyChartOptions(options)) {
      return HierarchyChart;
    } else if (isAgPolarChartOptions(options)) {
      return PolarChart;
    }
    throw new Error(
      `AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`
    );
  }
};
_AgChartsInternal.initialised = false;
var AgChartsInternal = _AgChartsInternal;

// packages/ag-charts-community/src/version.ts
var VERSION$2 = "9.1.1";

// packages/ag-charts-community/src/integrated-charts-scene.ts
var integrated_charts_scene_exports = {};
__export(integrated_charts_scene_exports, {
  Arc: () => Arc,
  BBox: () => BBox,
  BandScale: () => BandScale,
  Caption: () => Caption,
  Circle: () => Circle,
  ContinuousScale: () => ContinuousScale,
  Diamond: () => Diamond,
  DropShadow: () => DropShadow,
  Group: () => Group,
  HdpiCanvas: () => HdpiCanvas,
  Image: () => Image,
  Label: () => Label,
  Line: () => Line,
  LinearGradientFill: () => LinearGradientFill,
  LinearScale: () => LinearScale,
  Marker: () => Marker,
  Node: () => Node,
  Path: () => Path,
  Path2D: () => Path2D,
  PointerEvents: () => PointerEvents,
  RadialColumnShape: () => RadialColumnShape,
  Rect: () => Rect,
  RedrawType: () => RedrawType,
  Scene: () => Scene,
  SceneChangeDetection: () => SceneChangeDetection,
  ScenePathChangeDetection: () => ScenePathChangeDetection,
  Sector: () => Sector,
  Selection: () => Selection,
  Shape: () => Shape,
  Square: () => Square,
  Text: () => Text,
  Tooltip: () => Tooltip,
  Triangle: () => Triangle,
  easing: () => easing_exports,
  getFont: () => getFont,
  getMarker: () => getMarker,
  getRadialColumnWidth: () => getRadialColumnWidth,
  motion: () => motion,
  nearestSquared: () => nearestSquared,
  nearestSquaredInContainer: () => nearestSquaredInContainer,
  toRadians: () => toRadians,
  toTooltipHtml: () => toTooltipHtml
});

// packages/ag-charts-community/src/scene/shape/arc.ts
var Arc = class extends Path {
  constructor() {
    super();
    this.centerX = 0;
    this.centerY = 0;
    this.radius = 10;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.counterClockwise = false;
    this.type = 0 /* Open */;
    this.restoreOwnStyles();
  }
  get fullPie() {
    return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));
  }
  updatePath() {
    const path = this.path;
    path.clear();
    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);
    if (this.type === 1 /* Chord */) {
      path.closePath();
    } else if (this.type === 2 /* Round */ && !this.fullPie) {
      path.lineTo(this.centerX, this.centerY);
      path.closePath();
    }
  }
  computeBBox() {
    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);
  }
  isPointInPath(x, y) {
    const point = this.transformPoint(x, y);
    const bbox = this.computeBBox();
    return this.type !== 0 /* Open */ && bbox.containsPoint(point.x, point.y) && this.path.isPointInPath(point.x, point.y);
  }
};
Arc.className = "Arc";
Arc.defaultStyles = Object.assign({}, Shape.defaultStyles, {
  lineWidth: 1,
  fillStyle: null
});
__decorateClass([
  ScenePathChangeDetection()
], Arc.prototype, "centerX", 2);
__decorateClass([
  ScenePathChangeDetection()
], Arc.prototype, "centerY", 2);
__decorateClass([
  ScenePathChangeDetection()
], Arc.prototype, "radius", 2);
__decorateClass([
  ScenePathChangeDetection()
], Arc.prototype, "startAngle", 2);
__decorateClass([
  ScenePathChangeDetection()
], Arc.prototype, "endAngle", 2);
__decorateClass([
  ScenePathChangeDetection()
], Arc.prototype, "counterClockwise", 2);
__decorateClass([
  ScenePathChangeDetection()
], Arc.prototype, "type", 2);

// packages/ag-charts-community/src/scene/shape/linearGradientFill.ts
var LinearGradientFill = class extends Shape {
  constructor() {
    super(...arguments);
    this.direction = "to-right";
    this.stops = void 0;
    this._mask = void 0;
  }
  get mask() {
    return this._mask;
  }
  set mask(newMask) {
    if (this._mask != null) {
      this.removeChild(this._mask);
    }
    if (newMask != null) {
      this.appendChild(newMask);
    }
    this._mask = newMask;
  }
  isPointInPath(x, y) {
    var _a, _b;
    return (_b = (_a = this.mask) == null ? void 0 : _a.isPointInPath(x, y)) != null ? _b : false;
  }
  computeBBox() {
    var _a;
    return (_a = this.mask) == null ? void 0 : _a.computeBBox();
  }
  render(renderCtx) {
    const { mask, stops } = this;
    const { ctx, devicePixelRatio } = renderCtx;
    const pixelLength = 1 / devicePixelRatio;
    const maskBbox = mask == null ? void 0 : mask.computeTransformedBBox();
    if (mask == null || stops == null || maskBbox == null)
      return;
    if (mask.dirtyPath) {
      mask.updatePath();
      mask.dirtyPath = false;
    }
    ctx.save();
    ctx.beginPath();
    mask.path.draw(ctx);
    ctx.clip();
    ctx.resetTransform();
    const x0 = Math.floor(maskBbox.x);
    const x1 = Math.ceil(maskBbox.x + maskBbox.width);
    const y0 = Math.floor(maskBbox.y);
    const y1 = Math.ceil(maskBbox.y + maskBbox.height);
    const colorScale = new ColorScale();
    const [i0, i1] = this.direction === "to-right" ? [x0, x1] : [y0, y1];
    colorScale.domain = stops.map((_, index) => {
      return i0 + (i1 - i0) * index / (stops.length - 1);
    });
    colorScale.range = stops;
    colorScale.update();
    if (this.direction === "to-right") {
      const height = y1 - y0;
      for (let x = x0; x <= x1; x += pixelLength) {
        ctx.fillStyle = colorScale.convert(x);
        ctx.fillRect(x, y0, pixelLength, height);
      }
    } else {
      const width = x1 - x0;
      for (let y = y0; y <= y1; y += pixelLength) {
        ctx.fillStyle = colorScale.convert(y);
        ctx.fillRect(x0, y, width, pixelLength);
      }
    }
    ctx.restore();
  }
};
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], LinearGradientFill.prototype, "direction", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], LinearGradientFill.prototype, "stops", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], LinearGradientFill.prototype, "_mask", 2);

// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts
function rotatePoint(x, y, rotation) {
  const radius = Math.sqrt(__pow(x, 2) + __pow(y, 2));
  const angle = Math.atan2(y, x);
  const rotated = angle + rotation;
  return {
    x: Math.cos(rotated) * radius,
    y: Math.sin(rotated) * radius
  };
}
var RadialColumnShape = class extends Path {
  constructor() {
    super(...arguments);
    this.borderPath = new Path2D();
    this.isBeveled = true;
    this.columnWidth = 0;
    this.startAngle = 0;
    this.endAngle = 0;
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.axisInnerRadius = 0;
    this.axisOuterRadius = 0;
    this.isRadiusAxisReversed = false;
  }
  getRotation() {
    const { startAngle, endAngle } = this;
    const midAngle = angleBetween(startAngle, endAngle);
    return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);
  }
  updatePath() {
    const { isBeveled } = this;
    if (isBeveled) {
      this.updateBeveledPath();
    } else {
      this.updateRectangularPath();
    }
    this.checkPathDirty();
  }
  updateRectangularPath() {
    const { columnWidth, innerRadius, outerRadius, path } = this;
    const left = -columnWidth / 2;
    const right = columnWidth / 2;
    const top = -outerRadius;
    const bottom = -innerRadius;
    const rotation = this.getRotation();
    const points = [
      [left, bottom],
      [left, top],
      [right, top],
      [right, bottom],
      [left, bottom]
    ].map(([x, y]) => rotatePoint(x, y, rotation));
    path.clear({ trackChanges: true });
    path.moveTo(points[0].x, points[0].y);
    path.lineTo(points[1].x, points[1].y);
    path.lineTo(points[2].x, points[2].y);
    path.lineTo(points[3].x, points[3].y);
    path.lineTo(points[0].x, points[0].y);
    path.closePath();
  }
  updateBeveledPath() {
    const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;
    const isStackBottom = isEqual(innerRadius, axisInnerRadius);
    const sideRotation = Math.asin(columnWidth / 2 / innerRadius);
    const pointRotation = this.getRotation();
    const rotate = (x, y) => rotatePoint(x, y, pointRotation);
    const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(__pow(leg, 2) + __pow(otherLeg, 2));
    const getTriangleLeg = (hypotenuse, otherLeg) => {
      if (otherLeg > hypotenuse) {
        return 0;
      }
      return Math.sqrt(__pow(hypotenuse, 2) - __pow(otherLeg, 2));
    };
    const compare = (value, otherValue, lessThan) => lessThan ? value < otherValue : value > otherValue;
    const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;
    let left = -columnWidth / 2;
    let right = columnWidth / 2;
    const top = -outerRadius;
    const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);
    const hasBottomIntersection = compare(
      axisOuterRadius,
      getTriangleHypotenuse(innerRadius, columnWidth / 2),
      !isRadiusAxisReversed
    );
    if (hasBottomIntersection) {
      const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);
      left = -bottomIntersectionX;
      right = bottomIntersectionX;
    }
    path.clear({ trackChanges: true });
    const bottomLeftPt = rotate(left, bottom);
    path.moveTo(bottomLeftPt.x, bottomLeftPt.y);
    const isEmpty = isEqual(innerRadius, outerRadius);
    const hasSideIntersection = compare(
      axisOuterRadius,
      getTriangleHypotenuse(outerRadius, columnWidth / 2),
      !isRadiusAxisReversed
    );
    if (isEmpty && shouldConnectBottomCircle) {
      path.arc(
        0,
        0,
        innerRadius,
        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,
        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,
        false
      );
    } else if (hasSideIntersection) {
      const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);
      const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);
      if (!hasBottomIntersection) {
        const topLeftPt = rotate(left, sideIntersectionY);
        path.lineTo(topLeftPt.x, topLeftPt.y);
      }
      path.arc(
        0,
        0,
        axisOuterRadius,
        Math.atan2(sideIntersectionY, left) + pointRotation,
        Math.atan2(top, -topIntersectionX) + pointRotation,
        false
      );
      if (!isEqual(topIntersectionX, 0)) {
        const topRightBevelPt = rotate(topIntersectionX, top);
        path.lineTo(topRightBevelPt.x, topRightBevelPt.y);
      }
      path.arc(
        0,
        0,
        axisOuterRadius,
        Math.atan2(top, topIntersectionX) + pointRotation,
        Math.atan2(sideIntersectionY, right) + pointRotation,
        false
      );
    } else {
      const topLeftPt = rotate(left, top);
      const topRightPt = rotate(right, top);
      path.lineTo(topLeftPt.x, topLeftPt.y);
      path.lineTo(topRightPt.x, topRightPt.y);
    }
    const bottomRightPt = rotate(right, bottom);
    path.lineTo(bottomRightPt.x, bottomRightPt.y);
    if (shouldConnectBottomCircle) {
      path.arc(
        0,
        0,
        innerRadius,
        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,
        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,
        true
      );
    } else {
      const bottomLeftPt2 = rotate(left, bottom);
      path.lineTo(bottomLeftPt2.x, bottomLeftPt2.y);
    }
    path.closePath();
  }
};
RadialColumnShape.className = "RadialColumnShape";
__decorateClass([
  ScenePathChangeDetection()
], RadialColumnShape.prototype, "isBeveled", 2);
__decorateClass([
  ScenePathChangeDetection()
], RadialColumnShape.prototype, "columnWidth", 2);
__decorateClass([
  ScenePathChangeDetection()
], RadialColumnShape.prototype, "startAngle", 2);
__decorateClass([
  ScenePathChangeDetection()
], RadialColumnShape.prototype, "endAngle", 2);
__decorateClass([
  ScenePathChangeDetection()
], RadialColumnShape.prototype, "outerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], RadialColumnShape.prototype, "innerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], RadialColumnShape.prototype, "axisInnerRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], RadialColumnShape.prototype, "axisOuterRadius", 2);
__decorateClass([
  ScenePathChangeDetection()
], RadialColumnShape.prototype, "isRadiusAxisReversed", 2);
function getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {
  const rotation = angleBetween(startAngle, endAngle);
  const pad2 = rotation * (1 - columnWidthRatio) / 2;
  startAngle += pad2;
  endAngle -= pad2;
  if (rotation < 1e-3) {
    return 2 * axisOuterRadius * maxColumnWidthRatio;
  }
  if (rotation >= 2 * Math.PI) {
    const midAngle = startAngle + rotation / 2;
    startAngle = midAngle - Math.PI;
    endAngle = midAngle + Math.PI;
  }
  const startX = axisOuterRadius * Math.cos(startAngle);
  const startY = axisOuterRadius * Math.sin(startAngle);
  const endX = axisOuterRadius * Math.cos(endAngle);
  const endY = axisOuterRadius * Math.sin(endAngle);
  const colWidth = Math.floor(Math.sqrt(__pow(startX - endX, 2) + __pow(startY - endY, 2)));
  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;
  return Math.max(1, Math.min(maxWidth, colWidth));
}

// packages/ag-charts-community/src/scene/image.ts
var Image = class extends Node {
  constructor(sourceImage) {
    super();
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.opacity = 1;
    this.sourceImage = sourceImage;
  }
  render(renderCtx) {
    const { ctx, forceRender, stats } = renderCtx;
    if (this.dirty === 0 /* NONE */ && !forceRender) {
      if (stats)
        stats.nodesSkipped++;
      return;
    }
    this.computeTransformMatrix();
    this.matrix.toContext(ctx);
    const image = this.sourceImage;
    ctx.globalAlpha = this.opacity;
    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);
    super.render(renderCtx);
  }
};
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "width", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "height", 2);
__decorateClass([
  SceneChangeDetection({ redraw: 3 /* MAJOR */ })
], Image.prototype, "opacity", 2);

// packages/ag-charts-community/src/integrated-charts-scene.ts
var motion = __spreadValues(__spreadValues({}, fromToMotion_exports), resetMotion_exports);

// packages/ag-charts-community/src/integrated-charts-theme.ts
var integrated_charts_theme_exports = {};
__export(integrated_charts_theme_exports, {
  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,
  ChartTheme: () => ChartTheme,
  DEFAULT_AXIS_GRID_COLOUR: () => DEFAULT_AXIS_GRID_COLOUR,
  DEFAULT_AXIS_LINE_COLOUR: () => DEFAULT_AXIS_LINE_COLOUR,
  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,
  DEFAULT_CROSS_LINES_COLOUR: () => DEFAULT_CROSS_LINES_COLOUR,
  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOUR_RANGE,
  DEFAULT_FONT_FAMILY: () => DEFAULT_FONT_FAMILY,
  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,
  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,
  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: () => DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
  DEFAULT_INVERTED_LABEL_COLOUR: () => DEFAULT_INVERTED_LABEL_COLOUR,
  DEFAULT_LABEL_COLOUR: () => DEFAULT_LABEL_COLOUR,
  DEFAULT_MUTED_LABEL_COLOUR: () => DEFAULT_MUTED_LABEL_COLOUR,
  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,
  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,
  DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE: () => DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
  DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS: () => DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
  DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS: () => DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
  DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS: () => DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
  EXTENDS_AXES_DEFAULTS: () => EXTENDS_AXES_DEFAULTS,
  EXTENDS_AXES_GRID_LINE_DEFAULTS: () => EXTENDS_AXES_GRID_LINE_DEFAULTS,
  EXTENDS_AXES_LABEL_DEFAULTS: () => EXTENDS_AXES_LABEL_DEFAULTS,
  EXTENDS_AXES_LINE_DEFAULTS: () => EXTENDS_AXES_LINE_DEFAULTS,
  EXTENDS_AXES_TICK_DEFAULTS: () => EXTENDS_AXES_TICK_DEFAULTS,
  EXTENDS_CARTESIAN_MARKER_DEFAULTS: () => EXTENDS_CARTESIAN_MARKER_DEFAULTS,
  EXTENDS_CHART_DEFAULTS: () => EXTENDS_CHART_DEFAULTS,
  EXTENDS_LEGEND_DEFAULTS: () => EXTENDS_LEGEND_DEFAULTS,
  EXTENDS_LEGEND_ITEM_DEFAULTS: () => EXTENDS_LEGEND_ITEM_DEFAULTS,
  EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS: () => EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS,
  EXTENDS_SERIES_DEFAULTS: () => EXTENDS_SERIES_DEFAULTS,
  FONT_SIZE: () => FONT_SIZE,
  FONT_WEIGHT: () => FONT_WEIGHT,
  IS_DARK_THEME: () => IS_DARK_THEME,
  OVERRIDE_SERIES_LABEL_DEFAULTS: () => OVERRIDE_SERIES_LABEL_DEFAULTS,
  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,
  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE,
  POSITION: () => POSITION,
  getChartTheme: () => getChartTheme,
  themes: () => themes2
});
var themes2 = Object.entries(themes).reduce(
  (obj, [name, factory]) => {
    obj[name] = factory();
    return obj;
  },
  {}
);

// packages/ag-charts-community/src/sparklines-scale.ts
var sparklines_scale_exports = {};
__export(sparklines_scale_exports, {
  BandScale: () => BandScale,
  ColorScale: () => ColorScale,
  ContinuousScale: () => ContinuousScale,
  Invalidating: () => Invalidating,
  LinearScale: () => LinearScale,
  TimeScale: () => TimeScale
});

// packages/ag-charts-community/src/sparklines-util.ts
var sparklines_util_exports = {};
__export(sparklines_util_exports, {
  Color: () => Color,
  Logger: () => Logger,
  Padding: () => Padding,
  angleBetween: () => angleBetween,
  checkDatum: () => checkDatum,
  clamp: () => clamp,
  clampArray: () => clampArray,
  countFractionDigits: () => countFractionDigits,
  createId: () => createId,
  deepClone: () => deepClone,
  extent: () => extent,
  findMinMax: () => findMinMax,
  findRangeExtent: () => findRangeExtent,
  isContinuous: () => isContinuous,
  isDate: () => isValidDate,
  isEqual: () => isEqual,
  isNegative: () => isNegative,
  isNumber: () => isFiniteNumber,
  isNumberEqual: () => isEqual,
  isString: () => isString,
  isStringObject: () => isStringObject,
  jsonApply: () => jsonApply,
  jsonDiff: () => jsonDiff,
  jsonWalk: () => jsonWalk,
  mod: () => mod,
  normalisedExtent: () => normalisedExtent,
  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,
  normalizeAngle180: () => normalizeAngle180,
  normalizeAngle360: () => normalizeAngle360,
  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,
  range: () => range,
  resetIds: () => resetIds,
  round: () => round,
  sanitizeHtml: () => sanitizeHtml,
  shallowClone: () => shallowClone,
  tickFormat: () => tickFormat,
  tickStep: () => tickStep,
  ticks: () => ticks_default,
  toDegrees: () => toDegrees,
  toFixed: () => toFixed,
  toRadians: () => toRadians,
  transformIntegratedCategoryValue: () => transformIntegratedCategoryValue,
  zipObject: () => zipObject
});

// packages/ag-charts-community/src/module-support.ts
var module_support_exports = {};
__export(module_support_exports, {
  ADD_PHASE: () => ADD_PHASE,
  AGG_VALUES_EXTENT: () => AGG_VALUES_EXTENT,
  AND: () => AND,
  ANIMATION_PHASE_ORDER: () => ANIMATION_PHASE_ORDER,
  ANIMATION_PHASE_TIMINGS: () => ANIMATION_PHASE_TIMINGS,
  ARRAY: () => ARRAY,
  ARRAY_OF: () => ARRAY_OF,
  AbstractBarSeries: () => AbstractBarSeries,
  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,
  ActionOnSet: () => ActionOnSet,
  Animation: () => Animation,
  AnimationManager: () => AnimationManager,
  AreaSeriesTag: () => AreaSeriesTag,
  Axis: () => Axis,
  AxisLabel: () => AxisLabel,
  AxisTick: () => AxisTick,
  BOOLEAN: () => BOOLEAN,
  BOOLEAN_ARRAY: () => BOOLEAN_ARRAY,
  Background: () => Background,
  BackgroundModule: () => BackgroundModule,
  BaseModuleInstance: () => BaseModuleInstance,
  BaseProperties: () => BaseProperties,
  COLOR_STRING: () => COLOR_STRING,
  COLOR_STRING_ARRAY: () => COLOR_STRING_ARRAY,
  CartesianAxis: () => CartesianAxis,
  CartesianSeries: () => CartesianSeries,
  CartesianSeriesNodeClickEvent: () => CartesianSeriesNodeClickEvent,
  CartesianSeriesProperties: () => CartesianSeriesProperties,
  CategoryAxis: () => CategoryAxis,
  ChartAxisDirection: () => ChartAxisDirection,
  ChartEventManager: () => ChartEventManager,
  ChartOptions: () => ChartOptions,
  ChartUpdateType: () => ChartUpdateType,
  ContextMenuRegistry: () => ContextMenuRegistry,
  CursorManager: () => CursorManager,
  DATE: () => DATE,
  DATE_ARRAY: () => DATE_ARRAY,
  DATE_OR_DATETIME_MS: () => DATE_OR_DATETIME_MS,
  DEGREE: () => DEGREE,
  DIRECTION: () => DIRECTION,
  DataController: () => DataController,
  DataModel: () => DataModel,
  DataService: () => DataService,
  Default: () => Default,
  Deprecated: () => Deprecated,
  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,
  FONT_STYLE: () => FONT_STYLE,
  FONT_WEIGHT: () => FONT_WEIGHT2,
  FUNCTION: () => FUNCTION,
  GREATER_THAN: () => GREATER_THAN,
  GestureDetector: () => GestureDetector,
  GroupedCategoryAxis: () => GroupedCategoryAxis,
  HierarchyNode: () => HierarchyNode,
  HierarchySeries: () => HierarchySeries,
  HierarchySeriesProperties: () => HierarchySeriesProperties,
  HighlightManager: () => HighlightManager,
  HighlightStyle: () => HighlightStyle,
  INITIAL_LOAD: () => INITIAL_LOAD,
  INTERACTION_RANGE: () => INTERACTION_RANGE,
  INTERACTION_TYPES: () => INTERACTION_TYPES,
  InteractionManager: () => InteractionManager,
  InteractionState: () => InteractionState,
  LABEL_PHASE: () => LABEL_PHASE,
  LESS_THAN: () => LESS_THAN,
  LINE_CAP: () => LINE_CAP,
  LINE_DASH: () => LINE_DASH,
  LINE_JOIN: () => LINE_JOIN,
  Layers: () => Layers,
  LayoutService: () => LayoutService,
  MATCHING_CROSSLINE_TYPE: () => MATCHING_CROSSLINE_TYPE,
  MAX_SPACING: () => MAX_SPACING,
  MIN_SPACING: () => MIN_SPACING,
  Motion: () => easing_exports,
  NAN: () => NAN,
  NODE_UPDATE_PHASES: () => NODE_UPDATE_PHASES,
  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,
  NUMBER: () => NUMBER,
  NUMBER_ARRAY: () => NUMBER_ARRAY,
  NUMBER_OR_NAN: () => NUMBER_OR_NAN,
  Navigator: () => Navigator,
  NavigatorModule: () => NavigatorModule,
  OBJECT: () => OBJECT,
  OBJECT_ARRAY: () => OBJECT_ARRAY,
  OR: () => OR,
  OVERFLOW_STRATEGY: () => OVERFLOW_STRATEGY,
  ObserveChanges: () => ObserveChanges,
  PLACEMENT: () => PLACEMENT,
  POSITION: () => POSITION2,
  POSITIVE_NUMBER: () => POSITIVE_NUMBER,
  PolarAxis: () => PolarAxis,
  PolarSeries: () => PolarSeries,
  PropertiesArray: () => PropertiesArray,
  ProxyOnWrite: () => ProxyOnWrite,
  ProxyProperty: () => ProxyProperty,
  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,
  QUICK_TRANSITION: () => QUICK_TRANSITION,
  RATIO: () => RATIO,
  REGISTERED_MODULES: () => REGISTERED_MODULES,
  REMOVE_PHASE: () => REMOVE_PHASE,
  RepeatType: () => RepeatType,
  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,
  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,
  STRING: () => STRING,
  STRING_ARRAY: () => STRING_ARRAY,
  Series: () => Series,
  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,
  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,
  SeriesMarker: () => SeriesMarker,
  SeriesNodeClickEvent: () => SeriesNodeClickEvent,
  SeriesNodePickMode: () => SeriesNodePickMode,
  SeriesProperties: () => SeriesProperties,
  SeriesTooltip: () => SeriesTooltip,
  StateMachine: () => StateMachine,
  TEXT_ALIGN: () => TEXT_ALIGN,
  TEXT_WRAP: () => TEXT_WRAP,
  Tags: () => Tags,
  TooltipManager: () => TooltipManager,
  UNION: () => UNION,
  UPDATE_PHASE: () => UPDATE_PHASE,
  UpdateService: () => UpdateService,
  VERTICAL_ALIGN: () => VERTICAL_ALIGN,
  Validate: () => Validate,
  ZoomManager: () => ZoomManager,
  __FORCE_MODULE_DETECTION: () => __FORCE_MODULE_DETECTION2,
  accumulateGroup: () => accumulateGroup,
  accumulatedValue: () => accumulatedValue,
  accumulativeValueProperty: () => accumulativeValueProperty,
  adjustLabelPlacement: () => adjustLabelPlacement,
  animationValidation: () => animationValidation,
  area: () => area,
  arraysEqual: () => arraysEqual,
  assignJsonApplyConstructedArray: () => assignJsonApplyConstructedArray,
  average: () => average,
  backfillPathPointData: () => backfillPathPointData,
  buildResetPathFn: () => buildResetPathFn,
  checkCrisp: () => checkCrisp,
  circularSliceArray: () => circularSliceArray,
  clamp: () => clamp,
  clampArray: () => clampArray,
  collapsedStartingBarPosition: () => collapsedStartingBarPosition,
  count: () => count,
  countFractionDigits: () => countFractionDigits,
  createDatumId: () => createDatumId,
  createDeprecationWarning: () => createDeprecationWarning,
  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,
  deepClone: () => deepClone,
  deepMerge: () => deepMerge,
  determinePathStatus: () => determinePathStatus,
  diff: () => diff,
  enterpriseModule: () => enterpriseModule,
  extent: () => extent,
  extractDecoratedProperties: () => extractDecoratedProperties,
  findMinMax: () => findMinMax,
  findRangeExtent: () => findRangeExtent,
  fixNumericExtent: () => fixNumericExtent,
  fromToMotion: () => fromToMotion,
  getMissCount: () => getMissCount,
  getPath: () => getPath,
  getRectConfig: () => getRectConfig,
  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,
  groupAverage: () => groupAverage,
  groupBy: () => groupBy,
  groupCount: () => groupCount,
  groupSum: () => groupSum,
  hasRegisteredEnterpriseModules: () => hasRegisteredEnterpriseModules,
  injectStyle: () => injectStyle,
  invertShapeDirection: () => invertShapeDirection,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isDecoratedObject: () => isDecoratedObject,
  isDefined: () => isDefined,
  isEnumKey: () => isEnumKey,
  isEnumValue: () => isEnumValue,
  isEqual: () => isEqual,
  isFiniteNumber: () => isFiniteNumber,
  isFunction: () => isFunction,
  isHtmlElement: () => isHtmlElement,
  isNegative: () => isNegative,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isObjectLike: () => isObjectLike,
  isPlainObject: () => isPlainObject,
  isProperties: () => isProperties,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isValidDate: () => isValidDate,
  jsonApply: () => jsonApply,
  jsonDiff: () => jsonDiff,
  jsonWalk: () => jsonWalk,
  keyProperty: () => keyProperty,
  listDecoratedProperties: () => listDecoratedProperties,
  mapValues: () => mapValues,
  markerFadeInAnimation: () => markerFadeInAnimation,
  markerPaletteFactory: () => markerPaletteFactory,
  markerScaleInAnimation: () => markerScaleInAnimation,
  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,
  mergeArrayDefaults: () => mergeArrayDefaults,
  mergeDefaults: () => mergeDefaults,
  midpointStartingBarPosition: () => midpointStartingBarPosition,
  minMax: () => minMax,
  mod: () => mod,
  normaliseGroupTo: () => normaliseGroupTo,
  normalisePropertyTo: () => normalisePropertyTo,
  normalisedExtent: () => normalisedExtent,
  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,
  pairCategoryData: () => pairCategoryData,
  pairContinuousData: () => pairContinuousData,
  partialAssign: () => partialAssign,
  pathFadeInAnimation: () => pathFadeInAnimation,
  pathFadeOutAnimation: () => pathFadeOutAnimation,
  pathSwipeInAnimation: () => pathSwipeInAnimation,
  predicateWithMessage: () => predicateWithMessage,
  prepareAreaPathAnimation: () => prepareAreaPathAnimation,
  prepareAxisAnimationContext: () => prepareAxisAnimationContext,
  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,
  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,
  prepareLinePathAnimation: () => prepareLinePathAnimation,
  prepareLinePathAnimationFns: () => prepareLinePathAnimationFns,
  prepareMarkerAnimation: () => prepareMarkerAnimation,
  range: () => range2,
  rangedValueProperty: () => rangedValueProperty,
  registerModule: () => registerModule,
  renderPartialPath: () => renderPartialPath,
  resetAxisGroupFn: () => resetAxisGroupFn,
  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,
  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,
  resetAxisSelectionFn: () => resetAxisSelectionFn,
  resetBarSelectionsFn: () => resetBarSelectionsFn,
  resetIds: () => resetIds,
  resetLabelFn: () => resetLabelFn,
  resetMarkerFn: () => resetMarkerFn,
  resetMarkerPositionFn: () => resetMarkerPositionFn,
  resetMotion: () => resetMotion,
  round: () => round,
  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,
  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,
  setPath: () => setPath,
  shallowClone: () => shallowClone,
  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,
  staticFromToMotion: () => staticFromToMotion,
  stringify: () => stringify,
  sum: () => sum,
  toArray: () => toArray,
  toFixed: () => toFixed,
  trailingAccumulatedValue: () => trailingAccumulatedValue,
  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,
  trailingValue: () => trailingValue,
  trailingValueProperty: () => trailingValueProperty,
  unique: () => unique,
  updateClipPath: () => updateClipPath,
  updateLabelNode: () => updateLabelNode,
  updateRect: () => updateRect,
  validateCrossLineValues: () => validateCrossLineValues,
  valueProperty: () => valueProperty
});

// packages/ag-charts-community/src/scene/util/shapes.ts
function invertShapeDirection(...supportedShapes) {
  for (const shape of supportedShapes) {
    if (shape instanceof Rect) {
      const { x, y, width, height } = shape;
      shape.setProperties({ x: y, y: x, width: height, height: width });
    } else if (shape instanceof Line) {
      const { x1, y1, x2, y2 } = shape;
      shape.setProperties({ x1: y1, y1: x1, x2: y2, y2: x2 });
    }
  }
}

// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts
var _HierarchyNode = class _HierarchyNode {
  constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {
    this.series = series;
    this.index = index;
    this.datum = datum;
    this.size = size;
    this.colorValue = colorValue;
    this.fill = fill;
    this.stroke = stroke;
    this.sumSize = sumSize;
    this.depth = depth;
    this.parent = parent;
    this.children = children;
    this.midPoint = { x: 0, y: 0 };
  }
  contains(other) {
    let current = other;
    while (current != null && current.index >= this.index) {
      if (current === this) {
        return true;
      }
      current = current.parent;
    }
    return false;
  }
  walk(callback, order = _HierarchyNode.Walk.PreOrder) {
    if (order === _HierarchyNode.Walk.PreOrder) {
      callback(this);
    }
    this.children.forEach((child) => {
      child.walk(callback, order);
    });
    if (order === _HierarchyNode.Walk.PostOrder) {
      callback(this);
    }
  }
  *[Symbol.iterator]() {
    yield this;
    for (const child of this.children) {
      yield* __yieldStar(child);
    }
  }
};
_HierarchyNode.Walk = {
  PreOrder: 0,
  PostOrder: 1
};
var HierarchyNode = _HierarchyNode;
var HierarchySeries = class extends Series {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [0 /* EXACT_SHAPE_MATCH */],
      contentGroupVirtual: false
    });
    this.rootNode = new HierarchyNode(
      this,
      0,
      void 0,
      0,
      void 0,
      void 0,
      void 0,
      0,
      void 0,
      void 0,
      []
    );
    this.colorDomain = [0, 0];
    this.maxDepth = 0;
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => this.animateWaitingUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  processData() {
    return __async(this, null, function* () {
      var _a, _b;
      const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this.properties;
      let index = 0;
      const getIndex = () => {
        index += 1;
        return index;
      };
      let maxDepth = 0;
      let minColor = Infinity;
      let maxColor = -Infinity;
      const colors = new Array(((_b = (_a = this.data) == null ? void 0 : _a.length) != null ? _b : 0) + 1).fill(void 0);
      const createNode = (datum, parent) => {
        const index2 = getIndex();
        const depth = parent.depth != null ? parent.depth + 1 : 0;
        const children = childrenKey != null ? datum[childrenKey] : void 0;
        const isLeaf = children == null || children.length === 0;
        let size = sizeKey != null ? datum[sizeKey] : void 0;
        if (Number.isFinite(size)) {
          size = Math.max(size, 0);
        } else {
          size = isLeaf ? 1 : 0;
        }
        const sumSize = size;
        maxDepth = Math.max(maxDepth, depth);
        const color = colorKey != null ? datum[colorKey] : void 0;
        if (typeof color === "number") {
          colors[index2] = color;
          minColor = Math.min(minColor, color);
          maxColor = Math.max(maxColor, color);
        }
        return appendChildren(
          new HierarchyNode(
            this,
            index2,
            datum,
            size,
            color,
            void 0,
            void 0,
            sumSize,
            depth,
            parent,
            []
          ),
          children
        );
      };
      const appendChildren = (node, data) => {
        data == null ? void 0 : data.forEach((datum) => {
          const child = createNode(datum, node);
          node.children.push(child);
          node.sumSize += child.sumSize;
        });
        return node;
      };
      const rootNode = appendChildren(
        new HierarchyNode(
          this,
          0,
          void 0,
          0,
          void 0,
          void 0,
          void 0,
          0,
          void 0,
          void 0,
          []
        ),
        this.data
      );
      const colorDomain = [minColor, maxColor];
      let colorScale;
      if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {
        colorScale = new ColorScale();
        colorScale.domain = colorDomain;
        colorScale.range = colorRange;
        colorScale.update();
      }
      rootNode.children.forEach((child, index2) => {
        child.walk((node) => {
          let fill;
          const color = colors[node.index];
          if (color != null) {
            fill = colorScale == null ? void 0 : colorScale.convert(color);
          }
          fill != null ? fill : fill = fills == null ? void 0 : fills[index2 % fills.length];
          node.fill = fill;
          node.stroke = colorScale == null ? strokes == null ? void 0 : strokes[index2 % strokes.length] : "rgba(0, 0, 0, 0.2)";
        });
      });
      this.rootNode = rootNode;
      this.maxDepth = maxDepth;
      this.colorDomain = colorDomain;
    });
  }
  update(_0) {
    return __async(this, arguments, function* ({ seriesRect }) {
      yield this.updateSelections();
      yield this.updateNodes();
      const animationData = this.getAnimationData();
      const resize = this.checkResize(seriesRect);
      if (resize) {
        this.animationState.transition("resize", animationData);
      }
      this.animationState.transition("update", animationData);
    });
  }
  resetAllAnimation(data) {
    var _a;
    const datum = (_a = this.animationResetFns) == null ? void 0 : _a.datum;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    if (datum != null) {
      resetMotion(data.datumSelections, datum);
    }
  }
  animateEmptyUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateWaitingUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateReadyHighlight(data) {
    var _a;
    const datum = (_a = this.animationResetFns) == null ? void 0 : _a.datum;
    if (datum != null) {
      resetMotion([data], datum);
    }
  }
  animateReadyResize(data) {
    this.resetAllAnimation(data);
  }
  animateClearingUpdateEmpty(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animationTransitionClear() {
    this.animationState.transition("clear", this.getAnimationData());
  }
  getAnimationData() {
    const animationData = {
      datumSelections: [this.groupSelection]
    };
    return animationData;
  }
  isProcessedDataAnimatable() {
    return true;
  }
  checkProcessedDataAnimatable() {
    if (!this.isProcessedDataAnimatable()) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  getLabelData() {
    return [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getLegendData(legendType) {
    const { colorKey, colorName, colorRange, visible } = this.properties;
    return legendType === "gradient" && colorKey != null && colorRange != null ? [
      {
        legendType: "gradient",
        enabled: visible,
        seriesId: this.id,
        colorName,
        colorRange,
        colorDomain: this.colorDomain
      }
    ] : [];
  }
  getDatumIdFromData(node) {
    return `${node.index}`;
  }
  getDatumId(node) {
    return this.getDatumIdFromData(node);
  }
};

// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts
var HierarchySeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.childrenKey = "children";
    this.fills = Object.values(DEFAULT_FILLS);
    this.strokes = Object.values(DEFAULT_STROKES);
  }
};
__decorateClass([
  Validate(STRING)
], HierarchySeriesProperties.prototype, "childrenKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], HierarchySeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], HierarchySeriesProperties.prototype, "colorKey", 2);
__decorateClass([
  Validate(STRING, { optional: true })
], HierarchySeriesProperties.prototype, "colorName", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], HierarchySeriesProperties.prototype, "fills", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY)
], HierarchySeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Validate(COLOR_STRING_ARRAY, { optional: true })
], HierarchySeriesProperties.prototype, "colorRange", 2);

// packages/ag-charts-community/src/chart/legendDatum.ts
var __FORCE_MODULE_DETECTION2 = 0;

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __reflectGet$1 = Reflect.get;
var __pow$1 = Math.pow;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
var __superGet$1 = (cls, obj, key) => __reflectGet$1(__getProtoOf$1(cls), key, obj);
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var ANGLE_AXIS_THEME = {
  __extends__: integrated_charts_theme_exports.EXTENDS_AXES_DEFAULTS,
  gridLine: {
    enabled: false,
    __extends__: integrated_charts_theme_exports.EXTENDS_AXES_GRID_LINE_DEFAULTS
  }
};

// packages/ag-charts-enterprise/src/utils/polar.ts
function loopSymmetrically(items, step, iterator) {
  const loop = (start, end, step2, iterator2) => {
    let prev = items[0];
    for (let i = start; step2 > 0 ? i <= end : i > end; i += step2) {
      const curr = items[i];
      if (iterator2(prev, curr))
        return true;
      prev = curr;
    }
    return false;
  };
  const midIndex = Math.floor(items.length / 2);
  if (loop(step, midIndex, step, iterator))
    return true;
  return loop(items.length - step, midIndex, -step, iterator);
}
var {
  ChartAxisDirection: ChartAxisDirection$1,
  Layers: Layers$1,
  ARRAY: ARRAY$1,
  BOOLEAN: BOOLEAN$1,
  COLOR_STRING: COLOR_STRING$1,
  FONT_STYLE: FONT_STYLE$1,
  FONT_WEIGHT: FONT_WEIGHT$1,
  LINE_DASH: LINE_DASH$1,
  NUMBER: NUMBER$1,
  POSITIVE_NUMBER: POSITIVE_NUMBER$1,
  RATIO: RATIO$1,
  STRING: STRING$1,
  UNION: UNION$1,
  AND: AND$1,
  Validate: Validate$1,
  MATCHING_CROSSLINE_TYPE: MATCHING_CROSSLINE_TYPE$1
} = module_support_exports;
var { Group: Group$1 } = integrated_charts_scene_exports;
var { createId: createId$1 } = sparklines_util_exports;
var PolarCrossLineLabel = class {
  constructor() {
    this.enabled = void 0;
    this.text = void 0;
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 14;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.color = "rgba(87, 87, 87, 1)";
    this.parallel = void 0;
  }
};
__decorateClass$1([
  Validate$1(BOOLEAN$1, { optional: true })
], PolarCrossLineLabel.prototype, "enabled", 2);
__decorateClass$1([
  Validate$1(STRING$1, { optional: true })
], PolarCrossLineLabel.prototype, "text", 2);
__decorateClass$1([
  Validate$1(FONT_STYLE$1, { optional: true })
], PolarCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass$1([
  Validate$1(FONT_WEIGHT$1, { optional: true })
], PolarCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass$1([
  Validate$1(POSITIVE_NUMBER$1)
], PolarCrossLineLabel.prototype, "fontSize", 2);
__decorateClass$1([
  Validate$1(STRING$1)
], PolarCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass$1([
  Validate$1(NUMBER$1)
], PolarCrossLineLabel.prototype, "padding", 2);
__decorateClass$1([
  Validate$1(COLOR_STRING$1, { optional: true })
], PolarCrossLineLabel.prototype, "color", 2);
__decorateClass$1([
  Validate$1(BOOLEAN$1, { optional: true })
], PolarCrossLineLabel.prototype, "parallel", 2);
var _PolarCrossLine = class _PolarCrossLine {
  constructor() {
    this.id = createId$1(this);
    this.enabled = void 0;
    this.type = void 0;
    this.range = void 0;
    this.value = void 0;
    this.fill = void 0;
    this.fillOpacity = void 0;
    this.stroke = void 0;
    this.strokeWidth = void 0;
    this.strokeOpacity = void 0;
    this.lineDash = void 0;
    this.shape = "polygon";
    this.label = new PolarCrossLineLabel();
    this.scale = void 0;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.sideFlag = -1;
    this.parallelFlipRotation = 0;
    this.regularFlipRotation = 0;
    this.direction = ChartAxisDirection$1.X;
    this.axisInnerRadius = 0;
    this.axisOuterRadius = 0;
    this.group = new Group$1({ name: `${this.id}`, layer: true, zIndex: _PolarCrossLine.LINE_LAYER_ZINDEX });
    this.labelGroup = new Group$1({ name: `${this.id}`, layer: true, zIndex: _PolarCrossLine.LABEL_LAYER_ZINDEX });
  }
  calculatePadding() {
  }
  setSectorNodeProps(node) {
    var _a2, _b, _c;
    node.fill = this.fill;
    node.fillOpacity = (_a2 = this.fillOpacity) != null ? _a2 : 1;
    node.stroke = this.stroke;
    node.strokeOpacity = (_b = this.strokeOpacity) != null ? _b : 1;
    node.strokeWidth = (_c = this.strokeWidth) != null ? _c : 1;
    node.lineDash = this.lineDash;
  }
  setLabelNodeProps(node, x, y, baseline, rotation) {
    const { label } = this;
    node.x = x;
    node.y = y;
    node.text = label.text;
    node.textAlign = "center";
    node.textBaseline = baseline;
    node.rotation = rotation;
    node.rotationCenterX = x;
    node.rotationCenterY = y;
    node.fill = label.color;
    node.fontFamily = label.fontFamily;
    node.fontSize = label.fontSize;
    node.fontStyle = label.fontStyle;
    node.visible = true;
  }
  calculateLayout(_visible) {
    return void 0;
  }
};
_PolarCrossLine.LINE_LAYER_ZINDEX = Layers$1.SERIES_CROSSLINE_LINE_ZINDEX;
_PolarCrossLine.RANGE_LAYER_ZINDEX = Layers$1.SERIES_CROSSLINE_RANGE_ZINDEX;
_PolarCrossLine.LABEL_LAYER_ZINDEX = Layers$1.SERIES_LABEL_ZINDEX;
__decorateClass$1([
  Validate$1(BOOLEAN$1, { optional: true })
], _PolarCrossLine.prototype, "enabled", 2);
__decorateClass$1([
  Validate$1(UNION$1(["range", "line"], "a crossLine type"), { optional: true })
], _PolarCrossLine.prototype, "type", 2);
__decorateClass$1([
  Validate$1(AND$1(MATCHING_CROSSLINE_TYPE$1("range"), ARRAY$1.restrict({ length: 2 })), {
    optional: true
  })
], _PolarCrossLine.prototype, "range", 2);
__decorateClass$1([
  Validate$1(MATCHING_CROSSLINE_TYPE$1("value"), { optional: true })
], _PolarCrossLine.prototype, "value", 2);
__decorateClass$1([
  Validate$1(COLOR_STRING$1, { optional: true })
], _PolarCrossLine.prototype, "fill", 2);
__decorateClass$1([
  Validate$1(RATIO$1, { optional: true })
], _PolarCrossLine.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate$1(COLOR_STRING$1, { optional: true })
], _PolarCrossLine.prototype, "stroke", 2);
__decorateClass$1([
  Validate$1(NUMBER$1, { optional: true })
], _PolarCrossLine.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate$1(RATIO$1, { optional: true })
], _PolarCrossLine.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate$1(LINE_DASH$1, { optional: true })
], _PolarCrossLine.prototype, "lineDash", 2);
var PolarCrossLine = _PolarCrossLine;

// packages/ag-charts-enterprise/src/axes/polar-crosslines/angleCrossLine.ts
var { ChartAxisDirection: ChartAxisDirection2, validateCrossLineValues: validateCrossLineValues$1 } = module_support_exports;
var { Path: Path$1, Sector: Sector$1, Text: Text$1 } = integrated_charts_scene_exports;
var { normalizeAngle360: normalizeAngle360$1, isNumberEqual } = sparklines_util_exports;
var _AngleCrossLine = class _AngleCrossLine extends PolarCrossLine {
  constructor() {
    super();
    this.direction = ChartAxisDirection2.X;
    this.polygonNode = new Path$1();
    this.sectorNode = new Sector$1();
    this.lineNode = new Path$1();
    this.labelNode = new Text$1();
    this.group.append(this.polygonNode);
    this.group.append(this.sectorNode);
    this.group.append(this.lineNode);
    this.labelGroup.append(this.labelNode);
  }
  update(visible) {
    const { scale, shape, type, value, range: range2 } = this;
    if (!scale || !type || !validateCrossLineValues$1(type, value, range2, scale)) {
      this.group.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.group.visible = visible;
    this.labelGroup.visible = visible;
    if (type === "line" && shape === "circle" && scale instanceof sparklines_scale_exports.BandScale) {
      this.type = "range";
      this.range = [value, value];
    }
    this.updateLineNode(visible);
    this.updatePolygonNode(visible);
    this.updateSectorNode(visible);
    this.updateLabelNode(visible);
  }
  updateLineNode(visible) {
    var _a2, _b;
    const { scale, type, value, lineNode: line } = this;
    let angle;
    if (!visible || type !== "line" || !scale || isNaN(angle = scale.convert(value))) {
      line.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    line.visible = true;
    line.stroke = this.stroke;
    line.strokeOpacity = (_a2 = this.strokeOpacity) != null ? _a2 : 1;
    line.strokeWidth = (_b = this.strokeWidth) != null ? _b : 1;
    line.fill = void 0;
    line.lineDash = this.lineDash;
    const x = axisOuterRadius * Math.cos(angle);
    const y = axisOuterRadius * Math.sin(angle);
    const x0 = axisInnerRadius * Math.cos(angle);
    const y0 = axisInnerRadius * Math.sin(angle);
    line.path.clear({ trackChanges: true });
    line.path.moveTo(x0, y0);
    line.path.lineTo(x, y);
    this.group.zIndex = _AngleCrossLine.LINE_LAYER_ZINDEX;
  }
  updatePolygonNode(visible) {
    var _a2;
    const { polygonNode: polygon, range: range2, scale, shape, type } = this;
    let ticks;
    if (!visible || type !== "range" || shape !== "polygon" || !scale || !range2 || !(ticks = (_a2 = scale.ticks) == null ? void 0 : _a2.call(scale))) {
      polygon.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    const startIndex = ticks.indexOf(range2[0]);
    const endIndex = ticks.indexOf(range2[1]);
    const stops = startIndex <= endIndex ? ticks.slice(startIndex, endIndex + 1) : ticks.slice(startIndex).concat(ticks.slice(0, endIndex + 1));
    const angles = stops.map((value) => scale.convert(value));
    polygon.visible = true;
    this.setSectorNodeProps(polygon);
    const { path } = polygon;
    path.clear({ trackChanges: true });
    angles.forEach((angle, index) => {
      const x = axisOuterRadius * Math.cos(angle);
      const y = axisOuterRadius * Math.sin(angle);
      if (index === 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    if (axisInnerRadius === 0) {
      path.lineTo(0, 0);
    } else {
      angles.slice().reverse().forEach((angle) => {
        const x = axisInnerRadius * Math.cos(angle);
        const y = axisInnerRadius * Math.sin(angle);
        path.lineTo(x, y);
      });
    }
    polygon.path.closePath();
    this.group.zIndex = _AngleCrossLine.RANGE_LAYER_ZINDEX;
  }
  updateSectorNode(visible) {
    var _a2;
    const { sectorNode: sector, range: range2, scale, shape, type } = this;
    if (!visible || type !== "range" || shape !== "circle" || !scale || !range2) {
      sector.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    const angles = range2.map((value) => scale.convert(value));
    const step = (_a2 = scale.step) != null ? _a2 : 0;
    const padding = scale instanceof sparklines_scale_exports.BandScale ? step / 2 : 0;
    sector.visible = true;
    this.setSectorNodeProps(sector);
    sector.centerX = 0;
    sector.centerY = 0;
    sector.innerRadius = axisInnerRadius;
    sector.outerRadius = axisOuterRadius;
    sector.startAngle = angles[0] - padding;
    sector.endAngle = angles[1] + padding;
    this.group.zIndex = _AngleCrossLine.RANGE_LAYER_ZINDEX;
  }
  updateLabelNode(visible) {
    var _a2, _b;
    const { label, labelNode: node, range: range2, scale, type } = this;
    if (!visible || label.enabled === false || !label.text || !scale || type === "range" && !range2) {
      node.visible = true;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    let labelX;
    let labelY;
    let rotation;
    let textBaseline;
    if (type === "line") {
      const angle = normalizeAngle360$1(scale.convert(this.value));
      const angle270 = 3 * Math.PI / 2;
      const isRightSide = isNumberEqual(angle, angle270) || angle > angle270 || angle < Math.PI / 2;
      const midX = (axisInnerRadius + axisOuterRadius) / 2 * Math.cos(angle);
      const midY = (axisInnerRadius + axisOuterRadius) / 2 * Math.sin(angle);
      labelX = midX + label.padding * Math.cos(angle + Math.PI / 2);
      labelY = midY + label.padding * Math.sin(angle + Math.PI / 2);
      textBaseline = isRightSide ? "top" : "bottom";
      rotation = isRightSide ? angle : angle - Math.PI;
    } else {
      const [startAngle, endAngle] = range2.map((value) => normalizeAngle360$1(scale.convert(value)));
      let angle = (startAngle + endAngle) / 2;
      if (startAngle > endAngle) {
        angle -= Math.PI;
      }
      angle = normalizeAngle360$1(angle);
      const isBottomSide = (isNumberEqual(angle, 0) || angle > 0) && angle < Math.PI;
      let distance;
      const ticks = (_b = (_a2 = scale.ticks) == null ? void 0 : _a2.call(scale)) != null ? _b : [];
      if (this.shape === "circle" || ticks.length < 3) {
        distance = axisOuterRadius - label.padding;
      } else {
        distance = axisOuterRadius * Math.cos(Math.PI / ticks.length) - label.padding;
      }
      labelX = distance * Math.cos(angle);
      labelY = distance * Math.sin(angle);
      textBaseline = isBottomSide ? "bottom" : "top";
      rotation = isBottomSide ? angle - Math.PI / 2 : angle + Math.PI / 2;
    }
    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);
  }
};
_AngleCrossLine.className = "AngleCrossLine";
var AngleCrossLine = _AngleCrossLine;

// packages/ag-charts-enterprise/src/axes/angle/angleAxis.ts
var {
  AND: AND2,
  assignJsonApplyConstructedArray: assignJsonApplyConstructedArray$1,
  ChartAxisDirection: ChartAxisDirection3,
  GREATER_THAN: GREATER_THAN$1,
  NUMBER: NUMBER2,
  UNION: UNION2,
  ProxyOnWrite: ProxyOnWrite$1,
  Validate: Validate2
} = module_support_exports;
var { Path: Path2, Text: Text2 } = integrated_charts_scene_exports;
var { angleBetween: angleBetween$1, isNumberEqual: isNumberEqual2, toRadians: toRadians$1, normalizeAngle360: normalizeAngle3602 } = sparklines_util_exports;
var AngleAxisLabel = class extends module_support_exports.AxisLabel {
  constructor() {
    super(...arguments);
    this.orientation = "fixed";
  }
};
__decorateClass$1([
  Validate2(UNION2(["fixed", "parallel", "perpendicular"], "a label orientation"))
], AngleAxisLabel.prototype, "orientation", 2);
var AngleAxis = class extends module_support_exports.PolarAxis {
  constructor(moduleCtx, scale) {
    super(moduleCtx, scale);
    this.startAngle = 0;
    this.endAngle = void 0;
    this.labelData = [];
    this.tickData = [];
    this.radiusLine = this.axisGroup.appendChild(new Path2());
    this.computeRange = () => {
      const startAngle = normalizeAngle3602(-Math.PI / 2 + toRadians$1(this.startAngle));
      let endAngle = this.endAngle == null ? startAngle + Math.PI * 2 : -Math.PI / 2 + toRadians$1(this.endAngle);
      if (endAngle < startAngle) {
        endAngle += 2 * Math.PI;
      }
      this.range = [startAngle, endAngle];
    };
    this.includeInvisibleDomains = true;
  }
  get direction() {
    return ChartAxisDirection3.X;
  }
  assignCrossLineArrayConstructor(crossLines) {
    assignJsonApplyConstructedArray$1(crossLines, AngleCrossLine);
  }
  createLabel() {
    return new AngleAxisLabel();
  }
  update() {
    this.updateScale();
    this.updatePosition();
    this.updateGridLines();
    this.updateTickLines();
    this.updateLabels();
    this.updateRadiusLine();
    this.updateCrossLines();
    return this.tickData.length;
  }
  calculateAvailableRange() {
    const { range: range2, gridLength: radius } = this;
    return angleBetween$1(range2[0], range2[1]) * radius;
  }
  updatePosition() {
    const { translation, axisGroup, gridGroup, crossLineGroup } = this;
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    axisGroup.translationX = translationX;
    axisGroup.translationY = translationY;
    gridGroup.translationX = translationX;
    gridGroup.translationY = translationY;
    crossLineGroup.translationX = translationX;
    crossLineGroup.translationY = translationY;
  }
  updateRadiusLine() {
    const node = this.radiusLine;
    const { path } = node;
    path.clear({ trackChanges: true });
    const { points, closePath } = this.getAxisLinePoints();
    points.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {
      if (arc) {
        path.arc(x, y, radius, startAngle, endAngle);
      } else if (moveTo) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    if (closePath) {
      path.closePath();
    }
    node.visible = this.line.enabled;
    node.stroke = this.line.color;
    node.strokeWidth = this.line.width;
    node.fill = void 0;
  }
  getAxisLinePoints() {
    var _a2;
    const { scale, shape, gridLength: radius } = this;
    const [startAngle, endAngle] = this.range;
    const isFullCircle = isNumberEqual2(endAngle - startAngle, 2 * Math.PI);
    const points = [];
    if (shape === "circle") {
      if (isFullCircle) {
        points.push({ x: radius, y: 0, moveTo: true });
        points.push({
          x: 0,
          y: 0,
          radius,
          startAngle: 0,
          endAngle: 2 * Math.PI,
          arc: true,
          moveTo: false
        });
      } else {
        points.push({
          x: radius * Math.cos(startAngle),
          y: radius * Math.sin(startAngle),
          moveTo: true
        });
        points.push({
          x: 0,
          y: 0,
          radius,
          startAngle: normalizeAngle3602(startAngle),
          endAngle: normalizeAngle3602(endAngle),
          arc: true,
          moveTo: false
        });
      }
    } else if (shape === "polygon") {
      const angles = (((_a2 = scale.ticks) == null ? void 0 : _a2.call(scale)) || []).map((value) => scale.convert(value));
      if (angles.length > 2) {
        angles.forEach((angle, i) => {
          const x = radius * Math.cos(angle);
          const y = radius * Math.sin(angle);
          const moveTo = i === 0;
          points.push({ x, y, moveTo });
        });
      }
    }
    return { points, closePath: isFullCircle };
  }
  updateGridLines() {
    const {
      scale,
      gridLength: radius,
      gridLine: { enabled, style, width },
      innerRadiusRatio
    } = this;
    if (!(style && radius > 0)) {
      return;
    }
    const ticks = this.tickData;
    const innerRadius = radius * innerRadiusRatio;
    const styleCount = style.length;
    const idFn = (datum) => datum.value;
    this.gridLineGroupSelection.update(enabled ? ticks : [], void 0, idFn).each((line, datum, index) => {
      const { value } = datum;
      const { stroke, lineDash } = style[index % styleCount];
      const angle = scale.convert(value);
      line.x1 = innerRadius * Math.cos(angle);
      line.y1 = innerRadius * Math.sin(angle);
      line.x2 = radius * Math.cos(angle);
      line.y2 = radius * Math.sin(angle);
      line.stroke = stroke;
      line.strokeWidth = width;
      line.lineDash = lineDash;
      line.fill = void 0;
    });
    this.gridLineGroupSelection.cleanup();
  }
  updateLabels() {
    const { label, tickLabelGroupSelection } = this;
    const ticks = this.tickData;
    tickLabelGroupSelection.update(label.enabled ? ticks : []).each((node, _, index) => {
      const labelDatum = this.labelData[index];
      if (!labelDatum || labelDatum.hidden) {
        node.visible = false;
        return;
      }
      node.text = labelDatum.text;
      node.setFont(label);
      node.fill = label.color;
      node.x = labelDatum.x;
      node.y = labelDatum.y;
      node.textAlign = labelDatum.textAlign;
      node.textBaseline = labelDatum.textBaseline;
      node.visible = true;
      if (labelDatum.rotation) {
        node.rotation = labelDatum.rotation;
        node.rotationCenterX = labelDatum.x;
        node.rotationCenterY = labelDatum.y;
      } else {
        node.rotation = 0;
      }
    });
  }
  updateTickLines() {
    const { scale, gridLength: radius, tick, tickLineGroupSelection } = this;
    const ticks = this.tickData;
    tickLineGroupSelection.update(tick.enabled ? ticks : []).each((line, datum) => {
      const { value } = datum;
      const angle = scale.convert(value);
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      line.x1 = radius * cos;
      line.y1 = radius * sin;
      line.x2 = (radius + tick.size) * cos;
      line.y2 = (radius + tick.size) * sin;
      line.stroke = tick.color;
      line.strokeWidth = tick.width;
    });
  }
  createLabelNodeData(ticks, options, seriesRect) {
    const { label, gridLength: radius, scale, tick } = this;
    if (!label.enabled) {
      return [];
    }
    const tempText2 = new Text2();
    const seriesLeft = seriesRect.x - this.translation.x;
    const seriesRight = seriesRect.x + seriesRect.width - this.translation.x;
    const labelData = ticks.map((datum, index) => {
      var _a2;
      const { value } = datum;
      const distance = radius + label.padding + tick.size;
      const angle = scale.convert(value);
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x = distance * cos;
      const y = distance * sin;
      const { textAlign, textBaseline } = this.getLabelAlign(angle);
      const isLastTickOverFirst = index === ticks.length - 1 && value !== ticks[0] && isNumberEqual2(normalizeAngle3602(angle), normalizeAngle3602(scale.convert(ticks[0])));
      const rotation = this.getLabelRotation(angle);
      let text = String(value);
      if (label.formatter) {
        const { callbackCache } = this.moduleCtx;
        text = (_a2 = callbackCache.call(label.formatter, { value, index })) != null ? _a2 : "";
      }
      tempText2.text = text;
      tempText2.x = x;
      tempText2.y = y;
      tempText2.setFont(label);
      tempText2.textAlign = textAlign;
      tempText2.textBaseline = textBaseline;
      tempText2.rotation = rotation;
      if (rotation) {
        tempText2.rotationCenterX = x;
        tempText2.rotationCenterY = y;
      }
      let box = rotation ? tempText2.computeTransformedBBox() : tempText2.computeBBox();
      if (box && options.hideWhenNecessary && !rotation) {
        const overflowLeft = seriesLeft - box.x;
        const overflowRight = box.x + box.width - seriesRight;
        const pixelError = 1;
        if (overflowLeft > pixelError || overflowRight > pixelError) {
          const availWidth = box.width - Math.max(overflowLeft, overflowRight);
          ({ text } = Text2.wrap(text, availWidth, Infinity, label, "never"));
          if (text === "\u2026") {
            text = "";
            box = void 0;
          }
          tempText2.text = text;
          box = tempText2.computeBBox();
        }
      }
      return {
        text,
        x,
        y,
        textAlign,
        textBaseline,
        hidden: text === "" || datum.hidden || isLastTickOverFirst,
        rotation,
        box
      };
    });
    if (label.avoidCollisions) {
      this.avoidLabelCollisions(labelData);
    }
    return labelData;
  }
  computeLabelsBBox(options, seriesRect) {
    this.tickData = this.generateAngleTicks();
    this.labelData = this.createLabelNodeData(this.tickData, options, seriesRect);
    const textBoxes = this.labelData.map(({ box }) => box).filter((box) => box != null);
    if (!this.label.enabled || textBoxes.length === 0) {
      return null;
    }
    return integrated_charts_scene_exports.BBox.merge(textBoxes);
  }
  getLabelOrientation() {
    const { label } = this;
    return label instanceof AngleAxisLabel ? label.orientation : "fixed";
  }
  getLabelRotation(tickAngle) {
    var _a2;
    let rotation = toRadians$1((_a2 = this.label.rotation) != null ? _a2 : 0);
    tickAngle = normalizeAngle3602(tickAngle);
    const orientation = this.getLabelOrientation();
    if (orientation === "parallel") {
      rotation += tickAngle;
      if (tickAngle >= 0 && tickAngle < Math.PI) {
        rotation -= Math.PI / 2;
      } else {
        rotation += Math.PI / 2;
      }
    } else if (orientation === "perpendicular") {
      rotation += tickAngle;
      if (tickAngle >= Math.PI / 2 && tickAngle < 3 * Math.PI / 2) {
        rotation += Math.PI;
      }
    }
    return rotation;
  }
  getLabelAlign(tickAngle) {
    const cos = Math.cos(tickAngle);
    const sin = Math.sin(tickAngle);
    let textAlign;
    let textBaseline;
    const orientation = this.getLabelOrientation();
    const isCos0 = isNumberEqual2(cos, 0);
    const isSin0 = isNumberEqual2(sin, 0);
    const isCos1 = isNumberEqual2(cos, 1);
    const isSinMinus1 = isNumberEqual2(sin, -1);
    const isCosPositive = cos > 0 && !isCos0;
    const isSinPositive = sin > 0 && !isSin0;
    if (orientation === "parallel") {
      textAlign = "center";
      textBaseline = isCos1 && isSin0 || isSinPositive ? "top" : "bottom";
    } else if (orientation === "perpendicular") {
      textAlign = isSinMinus1 || isCosPositive ? "left" : "right";
      textBaseline = "middle";
    } else {
      textAlign = isCos0 ? "center" : isCosPositive ? "left" : "right";
      textBaseline = isSin0 ? "middle" : isSinPositive ? "top" : "bottom";
    }
    return { textAlign, textBaseline };
  }
  updateCrossLines() {
    var _a2;
    (_a2 = this.crossLines) == null ? void 0 : _a2.forEach((crossLine) => {
      if (crossLine instanceof AngleCrossLine) {
        const { shape, gridLength: radius, innerRadiusRatio } = this;
        crossLine.shape = shape;
        crossLine.axisOuterRadius = radius;
        crossLine.axisInnerRadius = radius * innerRadiusRatio;
      }
    });
    super.updateCrossLines({ rotation: 0, parallelFlipRotation: 0, regularFlipRotation: 0 });
  }
};
__decorateClass$1([
  ProxyOnWrite$1("rotation"),
  Validate2(NUMBER2.restrict({ min: 0, max: 360 }))
], AngleAxis.prototype, "startAngle", 2);
__decorateClass$1([
  Validate2(AND2(NUMBER2.restrict({ min: 0, max: 720 }), GREATER_THAN$1("startAngle")), { optional: true })
], AngleAxis.prototype, "endAngle", 2);

// packages/ag-charts-enterprise/src/axes/angle-category/angleCategoryAxis.ts
var { RATIO: RATIO2, Validate: Validate3 } = module_support_exports;
var { BandScale: BandScale$1 } = sparklines_scale_exports;
var { isNumberEqual: isNumberEqual3 } = sparklines_util_exports;
var AngleCategoryAxis = class extends AngleAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale$1());
    this.groupPaddingInner = 0;
    this.paddingInner = 0;
  }
  generateAngleTicks() {
    var _a2, _b;
    const { scale, tick, gridLength: radius } = this;
    const ticks = (_b = (_a2 = tick.values) != null ? _a2 : scale.ticks()) != null ? _b : [];
    if (ticks.length < 2 || isNaN(tick.minSpacing)) {
      return ticks.map((value) => {
        return { value, visible: true };
      });
    }
    const startTick = ticks[0];
    const startAngle = scale.convert(startTick);
    const startX = radius * Math.cos(startAngle);
    const startY = radius * Math.sin(startAngle);
    for (let step = 1; step < ticks.length - 1; step++) {
      const nextTick = ticks[step];
      const nextAngle = scale.convert(nextTick);
      if (nextAngle - startAngle > Math.PI) {
        break;
      }
      const nextX = radius * Math.cos(nextAngle);
      const nextY = radius * Math.sin(nextAngle);
      const spacing = Math.sqrt(__pow$1(nextX - startX, 2) + __pow$1(nextY - startY, 2));
      if (spacing > tick.minSpacing) {
        const visibleTicks = /* @__PURE__ */ new Set([startTick]);
        loopSymmetrically(ticks, step, (_, next) => {
          visibleTicks.add(next);
        });
        return ticks.map((value) => {
          const visible = visibleTicks.has(value);
          return { value, visible };
        });
      }
    }
    return [{ value: startTick, visible: true }];
  }
  avoidLabelCollisions(labelData) {
    let { minSpacing } = this.label;
    if (!Number.isFinite(minSpacing)) {
      minSpacing = 0;
    }
    if (labelData.length < 3) {
      return;
    }
    const labelsCollide = (prev, next) => {
      if (prev.hidden || next.hidden) {
        return false;
      }
      const prevBox = prev.box.clone().grow(minSpacing / 2);
      const nextBox = next.box.clone().grow(minSpacing / 2);
      return prevBox.collidesBBox(nextBox);
    };
    const firstLabel = labelData[0];
    const lastLabel = labelData.at(-1);
    const visibleLabels = /* @__PURE__ */ new Set([firstLabel]);
    const lastLabelIsOverFirst = isNumberEqual3(firstLabel.x, lastLabel.x) && isNumberEqual3(firstLabel.y, lastLabel.y);
    const maxStep = Math.floor(labelData.length / 2);
    for (let step = 1; step <= maxStep; step++) {
      const labels = lastLabelIsOverFirst ? labelData.slice(0, -1) : labelData;
      const collisionDetected = loopSymmetrically(labels, step, labelsCollide);
      if (!collisionDetected) {
        loopSymmetrically(labels, step, (_, next) => {
          visibleLabels.add(next);
        });
        break;
      }
    }
    labelData.forEach((datum) => {
      if (!visibleLabels.has(datum)) {
        datum.hidden = true;
        datum.box = void 0;
      }
    });
  }
};
AngleCategoryAxis.className = "AngleCategoryAxis";
AngleCategoryAxis.type = "angle-category";
__decorateClass$1([
  Validate3(RATIO2)
], AngleCategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass$1([
  Validate3(RATIO2)
], AngleCategoryAxis.prototype, "paddingInner", 2);

// packages/ag-charts-enterprise/src/axes/angle-category/angleCategoryAxisModule.ts
var AngleCategoryAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "angle-category",
  instanceConstructor: AngleCategoryAxis,
  themeTemplate: ANGLE_AXIS_THEME
};
var { LinearScale: LinearScale$1, Invalidating: Invalidating$1 } = sparklines_scale_exports;
var { isNumberEqual: isNumberEqual4, range: range$1 } = sparklines_util_exports;
var LinearAngleScale = class extends LinearScale$1 {
  constructor() {
    super(...arguments);
    this.arcLength = 0;
    this.niceTickStep = 0;
  }
  ticks() {
    if (!this.domain || this.domain.length < 2 || this.domain.some((d) => !isFinite(d))) {
      return [];
    }
    this.refresh();
    const [d0, d1] = this.getDomain();
    const { interval } = this;
    if (interval) {
      const step2 = Math.abs(interval);
      if (!this.isDenseInterval({ start: d0, stop: d1, interval: step2 })) {
        return range$1(d0, d1, step2);
      }
    }
    const step = this.nice && this.niceTickStep ? this.niceTickStep : this.getTickStep(d0, d1);
    return range$1(d0, d1, step);
  }
  hasNiceRange() {
    const range2 = this.range.slice().sort((a, b) => a - b);
    const niceRanges = [Math.PI, 2 * Math.PI];
    return niceRanges.some((r) => isNumberEqual4(r, range2[1] - range2[0]));
  }
  getNiceStepAndTickCount() {
    const [start, stop] = this.niceDomain;
    let step = this.getTickStep(start, stop);
    const maxTickCount = isNaN(this.maxTickCount) ? Infinity : this.maxTickCount;
    const expectedTickCount = Math.abs(stop - start) / step;
    let niceTickCount = Math.pow(2, Math.ceil(Math.log(expectedTickCount) / Math.log(2)));
    if (niceTickCount > maxTickCount) {
      niceTickCount /= 2;
      step *= 2;
    }
    return {
      count: niceTickCount,
      step
    };
  }
  updateNiceDomain() {
    super.updateNiceDomain();
    if (!this.hasNiceRange()) {
      return;
    }
    const reversed = this.niceDomain[0] > this.niceDomain[1];
    const start = reversed ? this.niceDomain[1] : this.niceDomain[0];
    const { step, count } = this.getNiceStepAndTickCount();
    const s = 1 / step;
    const stop = step >= 1 ? Math.ceil(start / step + count) * step : Math.ceil((start + count * step) * s) / s;
    this.niceDomain = reversed ? [stop, start] : [start, stop];
    this.niceTickStep = step;
  }
  getPixelRange() {
    return this.arcLength;
  }
};
__decorateClass$1([
  Invalidating$1
], LinearAngleScale.prototype, "arcLength", 2);

// packages/ag-charts-enterprise/src/axes/angle-number/angleNumberAxis.ts
var { AND: AND3, Default: Default$1, GREATER_THAN: GREATER_THAN2, LESS_THAN: LESS_THAN$1, NUMBER_OR_NAN: NUMBER_OR_NAN$1, MIN_SPACING: MIN_SPACING$1, Validate: Validate4 } = module_support_exports;
var { angleBetween: angleBetween2, isNumberEqual: isNumberEqual5, normalisedExtentWithMetadata: normalisedExtentWithMetadata$1 } = sparklines_util_exports;
var AngleNumberAxisTick = class extends module_support_exports.AxisTick {
  constructor() {
    super(...arguments);
    this.maxSpacing = NaN;
  }
};
__decorateClass$1([
  Validate4(MIN_SPACING$1),
  Default$1(NaN)
], AngleNumberAxisTick.prototype, "maxSpacing", 2);
var AngleNumberAxis = class extends AngleAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LinearAngleScale());
    this.shape = "circle";
    this.min = NaN;
    this.max = NaN;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent5, clipped } = normalisedExtentWithMetadata$1(d, min, max);
    return { domain: extent5, clipped };
  }
  createTick() {
    return new AngleNumberAxisTick();
  }
  getRangeArcLength() {
    const { range: requestedRange } = this;
    const min = Math.min(...requestedRange);
    const max = Math.max(...requestedRange);
    const rotation = angleBetween2(min, max) || 2 * Math.PI;
    const radius = this.gridLength;
    return rotation * radius;
  }
  generateAngleTicks() {
    var _a2;
    const arcLength = this.getRangeArcLength();
    const { scale, tick, range: requestedRange } = this;
    const { minSpacing = NaN, maxSpacing = NaN } = tick;
    const minTicksCount = maxSpacing ? Math.floor(arcLength / maxSpacing) : 1;
    const maxTicksCount = minSpacing ? Math.floor(arcLength / minSpacing) : Infinity;
    const preferredTicksCount = Math.floor(4 / Math.PI * Math.abs(requestedRange[0] - requestedRange[1]));
    scale.tickCount = Math.max(minTicksCount, Math.min(maxTicksCount, preferredTicksCount));
    scale.minTickCount = minTicksCount;
    scale.maxTickCount = maxTicksCount;
    scale.arcLength = arcLength;
    const ticks = (_a2 = tick.values) != null ? _a2 : scale.ticks();
    return ticks.map((value) => {
      return { value, visible: true };
    });
  }
  avoidLabelCollisions(labelData) {
    let { minSpacing } = this.label;
    if (!Number.isFinite(minSpacing)) {
      minSpacing = 0;
    }
    const labelsCollide = (prev, next) => {
      if (prev.hidden || next.hidden) {
        return false;
      }
      const prevBox = prev.box.clone().grow(minSpacing / 2);
      const nextBox = next.box.clone().grow(minSpacing / 2);
      return prevBox.collidesBBox(nextBox);
    };
    const firstLabel = labelData[0];
    const lastLabel = labelData.at(-1);
    if (firstLabel !== lastLabel && isNumberEqual5(firstLabel.x, lastLabel.x) && isNumberEqual5(firstLabel.y, lastLabel.y)) {
      lastLabel.hidden = true;
    }
    for (let step = 1; step < labelData.length; step *= 2) {
      let collisionDetected = false;
      for (let i = step; i < labelData.length; i += step) {
        const next = labelData[i];
        const prev = labelData[i - step];
        if (labelsCollide(prev, next)) {
          collisionDetected = true;
          break;
        }
      }
      if (!collisionDetected) {
        labelData.forEach((datum, i) => {
          if (i % step > 0) {
            datum.hidden = true;
            datum.box = void 0;
          }
        });
        return;
      }
    }
    labelData.forEach((datum, i) => {
      if (i > 0) {
        datum.hidden = true;
        datum.box = void 0;
      }
    });
  }
};
AngleNumberAxis.className = "AngleNumberAxis";
AngleNumberAxis.type = "angle-number";
__decorateClass$1([
  Validate4(AND3(NUMBER_OR_NAN$1, LESS_THAN$1("max"))),
  Default$1(NaN)
], AngleNumberAxis.prototype, "min", 2);
__decorateClass$1([
  Validate4(AND3(NUMBER_OR_NAN$1, GREATER_THAN2("min"))),
  Default$1(NaN)
], AngleNumberAxis.prototype, "max", 2);

// packages/ag-charts-enterprise/src/axes/angle-number/angleNumberAxisModule.ts
var AngleNumberAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "angle-number",
  instanceConstructor: AngleNumberAxis,
  themeTemplate: ANGLE_AXIS_THEME
};
var RADIUS_AXIS_THEME = {
  __extends__: integrated_charts_theme_exports.EXTENDS_AXES_DEFAULTS,
  line: {
    enabled: false,
    __extends__: integrated_charts_theme_exports.EXTENDS_AXES_LINE_DEFAULTS
  },
  tick: {
    enabled: false,
    __extends__: integrated_charts_theme_exports.EXTENDS_AXES_TICK_DEFAULTS
  }
};
var { ChartAxisDirection: ChartAxisDirection4, Validate: Validate5, DEGREE: DEGREE$1, validateCrossLineValues: validateCrossLineValues2 } = module_support_exports;
var { Path: Path3, Sector: Sector2, Text: Text3 } = integrated_charts_scene_exports;
var { normalizeAngle360: normalizeAngle3603, toRadians: toRadians2, isNumberEqual: isNumberEqual6 } = sparklines_util_exports;
var RadiusCrossLineLabel = class extends PolarCrossLineLabel {
  constructor() {
    super(...arguments);
    this.positionAngle = void 0;
  }
};
__decorateClass$1([
  Validate5(DEGREE$1, { optional: true })
], RadiusCrossLineLabel.prototype, "positionAngle", 2);
var _RadiusCrossLine = class _RadiusCrossLine extends PolarCrossLine {
  constructor() {
    super();
    this.direction = ChartAxisDirection4.Y;
    this.label = new RadiusCrossLineLabel();
    this.polygonNode = new Path3();
    this.sectorNode = new Sector2();
    this.labelNode = new Text3();
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.group.append(this.polygonNode);
    this.group.append(this.sectorNode);
    this.labelGroup.append(this.labelNode);
  }
  update(visible) {
    const { scale, type, value, range: range2 } = this;
    if (!scale || !type || !validateCrossLineValues2(type, value, range2, scale)) {
      this.group.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    if (type === "line" && scale instanceof sparklines_scale_exports.BandScale) {
      this.type = "range";
      this.range = [value, value];
    }
    this.updateRadii();
    const { innerRadius, outerRadius } = this;
    visible && (visible = innerRadius >= this.axisInnerRadius && outerRadius <= this.axisOuterRadius);
    this.group.visible = visible;
    this.labelGroup.visible = visible;
    this.updatePolygonNode(visible);
    this.updateSectorNode(visible);
    this.updateLabelNode(visible);
    this.group.zIndex = this.type === "line" ? _RadiusCrossLine.LINE_LAYER_ZINDEX : _RadiusCrossLine.RANGE_LAYER_ZINDEX;
  }
  updateRadii() {
    var _a2;
    const { range: range2, scale, type, axisInnerRadius, axisOuterRadius } = this;
    if (!scale)
      return { innerRadius: 0, outerRadius: 0 };
    const getRadius = (value) => axisOuterRadius + axisInnerRadius - value;
    let outerRadius = 0;
    let innerRadius = 0;
    if (type === "line") {
      outerRadius = getRadius(scale.convert(this.value));
      innerRadius = outerRadius;
    } else {
      const bandwidth = Math.abs((_a2 = scale == null ? void 0 : scale.bandwidth) != null ? _a2 : 0);
      const convertedRange = range2.map((r) => scale.convert(r));
      outerRadius = getRadius(Math.max(...convertedRange));
      innerRadius = getRadius(Math.min(...convertedRange)) + bandwidth;
    }
    this.outerRadius = outerRadius;
    this.innerRadius = innerRadius;
  }
  drawPolygon(radius, angles, polygon) {
    angles.forEach((angle, index) => {
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      if (index === 0) {
        polygon.path.moveTo(x, y);
      } else {
        polygon.path.lineTo(x, y);
      }
    });
    polygon.path.closePath();
  }
  updatePolygonNode(visible) {
    const { gridAngles, polygonNode: polygon, scale, shape, type, innerRadius, outerRadius } = this;
    if (!visible || shape !== "polygon" || !scale || !gridAngles) {
      polygon.visible = false;
      return;
    }
    polygon.visible = true;
    const padding = this.getPadding();
    polygon.path.clear({ trackChanges: true });
    this.drawPolygon(outerRadius - padding, gridAngles, polygon);
    const reversedAngles = gridAngles.slice().reverse();
    const innerPolygonRadius = type === "line" ? outerRadius - padding : innerRadius + padding;
    this.drawPolygon(innerPolygonRadius, reversedAngles, polygon);
    this.setSectorNodeProps(polygon);
  }
  updateSectorNode(visible) {
    const { axisInnerRadius, axisOuterRadius, scale, sectorNode: sector, shape, innerRadius, outerRadius } = this;
    if (!visible || shape !== "circle" || !scale) {
      sector.visible = false;
      return;
    }
    sector.visible = true;
    sector.startAngle = 0;
    sector.endAngle = 2 * Math.PI;
    const padding = this.getPadding();
    sector.innerRadius = sparklines_util_exports.clamp(axisInnerRadius, innerRadius + padding, axisOuterRadius);
    sector.outerRadius = sparklines_util_exports.clamp(axisInnerRadius, outerRadius - padding, axisOuterRadius);
    this.setSectorNodeProps(sector);
  }
  updateLabelNode(visible) {
    var _a2, _b;
    const { innerRadius, label, labelNode: node, scale, shape, type } = this;
    if (!visible || label.enabled === false || !label.text || !scale) {
      node.visible = false;
      return;
    }
    const angle = normalizeAngle3603(toRadians2(((_a2 = label.positionAngle) != null ? _a2 : 0) - 90));
    const isBottomSide = (isNumberEqual6(angle, 0) || angle > 0) && angle < Math.PI;
    const rotation = isBottomSide ? angle - Math.PI / 2 : angle + Math.PI / 2;
    let distance = 0;
    const angles = (_b = this.gridAngles) != null ? _b : [];
    if (type === "line") {
      distance = innerRadius + label.padding;
    } else if (shape === "circle" || angles.length < 3) {
      distance = innerRadius - label.padding;
    } else {
      distance = innerRadius * Math.cos(Math.PI / angles.length) - label.padding;
    }
    const labelX = distance * Math.cos(angle);
    const labelY = distance * Math.sin(angle);
    let textBaseline;
    if (type === "line") {
      textBaseline = isBottomSide ? "top" : "bottom";
    } else {
      textBaseline = isBottomSide ? "bottom" : "top";
    }
    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);
  }
  getPadding() {
    var _a2, _b;
    const { scale } = this;
    if (!scale)
      return 0;
    const bandwidth = Math.abs((_a2 = scale.bandwidth) != null ? _a2 : 0);
    const step = Math.abs((_b = scale.step) != null ? _b : 0);
    return scale instanceof sparklines_scale_exports.BandScale ? (step - bandwidth) / 2 : 0;
  }
};
_RadiusCrossLine.className = "RadiusCrossLine";
var RadiusCrossLine = _RadiusCrossLine;

// packages/ag-charts-enterprise/src/axes/radius/radiusAxis.ts
var { assignJsonApplyConstructedArray: assignJsonApplyConstructedArray2, ChartAxisDirection: ChartAxisDirection5, Default: Default2, Layers: Layers2, DEGREE: DEGREE2, MIN_SPACING: MIN_SPACING2, BOOLEAN: BOOLEAN2, Validate: Validate6 } = module_support_exports;
var { Caption: Caption$1, Group: Group2, Path: Path4, Selection: Selection$1 } = integrated_charts_scene_exports;
var { isNumberEqual: isNumberEqual7, normalizeAngle360: normalizeAngle3604, toRadians: toRadians3 } = sparklines_util_exports;
var RadiusAxisTick = class extends module_support_exports.AxisTick {
  constructor() {
    super(...arguments);
    this.maxSpacing = NaN;
  }
};
__decorateClass$1([
  Validate6(MIN_SPACING2),
  Default2(NaN)
], RadiusAxisTick.prototype, "maxSpacing", 2);
var RadiusAxisLabel = class extends module_support_exports.AxisLabel {
  constructor() {
    super(...arguments);
    this.autoRotateAngle = 335;
  }
};
__decorateClass$1([
  Validate6(BOOLEAN2, { optional: true })
], RadiusAxisLabel.prototype, "autoRotate", 2);
__decorateClass$1([
  Validate6(DEGREE2)
], RadiusAxisLabel.prototype, "autoRotateAngle", 2);
var RadiusAxis = class extends module_support_exports.PolarAxis {
  constructor(moduleCtx, scale) {
    super(moduleCtx, scale);
    this.positionAngle = 0;
    this.gridPathGroup = this.gridGroup.appendChild(
      new Group2({
        name: `${this.id}-gridPaths`,
        zIndex: Layers2.AXIS_GRID_ZINDEX
      })
    );
    this.gridPathSelection = Selection$1.select(this.gridPathGroup, Path4);
  }
  get direction() {
    return ChartAxisDirection5.Y;
  }
  assignCrossLineArrayConstructor(crossLines) {
    assignJsonApplyConstructedArray2(crossLines, RadiusCrossLine);
  }
  getAxisTransform() {
    const maxRadius = this.scale.range[0];
    const { translation, positionAngle, innerRadiusRatio } = this;
    const innerRadius = maxRadius * innerRadiusRatio;
    const rotation = toRadians3(positionAngle);
    return {
      translationX: translation.x,
      translationY: translation.y - maxRadius - innerRadius,
      rotation,
      rotationCenterX: 0,
      rotationCenterY: maxRadius + innerRadius
    };
  }
  updateSelections(lineData, data, params) {
    var _a2;
    super.updateSelections(lineData, data, params);
    const {
      gridLine: { enabled, style, width },
      shape
    } = this;
    if (!style) {
      return;
    }
    const ticks = this.prepareTickData(data);
    const styleCount = style.length;
    const setStyle = (node, index) => {
      const { stroke, lineDash } = style[index % styleCount];
      node.stroke = stroke;
      node.strokeWidth = width;
      node.lineDash = lineDash;
      node.fill = void 0;
    };
    const [startAngle, endAngle] = (_a2 = this.gridRange) != null ? _a2 : [0, 2 * Math.PI];
    const isFullCircle = isNumberEqual7(endAngle - startAngle, 2 * Math.PI);
    const drawCircleShape = (node, value) => {
      const { path } = node;
      path.clear({ trackChanges: true });
      const radius = this.getTickRadius(value);
      if (isFullCircle) {
        path.moveTo(radius, 0);
        path.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        path.moveTo(radius * Math.cos(startAngle), radius * Math.sin(startAngle));
        path.arc(0, 0, radius, normalizeAngle3604(startAngle), normalizeAngle3604(endAngle));
      }
      if (isFullCircle) {
        path.closePath();
      }
    };
    const drawPolygonShape = (node, value) => {
      const { path } = node;
      const angles = this.gridAngles;
      path.clear({ trackChanges: true });
      if (!angles || angles.length < 3) {
        return;
      }
      const radius = this.getTickRadius(value);
      angles.forEach((angle, i) => {
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        if (i === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        angles.forEach((angle2, i2) => {
          const x2 = radius * Math.cos(angle2);
          const y2 = radius * Math.sin(angle2);
          if (i2 === 0) {
            path.moveTo(x2, y2);
          } else {
            path.lineTo(x2, y2);
          }
        });
        path.closePath();
      });
      path.closePath();
    };
    this.gridPathSelection.update(enabled ? ticks : []).each((node, value, index) => {
      setStyle(node, index);
      if (shape === "circle") {
        drawCircleShape(node, value);
      } else {
        drawPolygonShape(node, value);
      }
    });
  }
  updateTitle() {
    var _a2;
    const identityFormatter = (params) => params.defaultValue;
    const {
      title,
      _titleCaption,
      range: requestedRange,
      moduleCtx: { callbackCache }
    } = this;
    const { formatter = identityFormatter } = (_a2 = this.title) != null ? _a2 : {};
    if (!title) {
      _titleCaption.enabled = false;
      return;
    }
    _titleCaption.enabled = title.enabled;
    _titleCaption.fontFamily = title.fontFamily;
    _titleCaption.fontSize = title.fontSize;
    _titleCaption.fontStyle = title.fontStyle;
    _titleCaption.fontWeight = title.fontWeight;
    _titleCaption.color = title.color;
    _titleCaption.wrapping = title.wrapping;
    let titleVisible = false;
    const titleNode = _titleCaption.node;
    if (title.enabled) {
      titleVisible = true;
      titleNode.rotation = Math.PI / 2;
      titleNode.x = Math.floor((requestedRange[0] + requestedRange[1]) / 2);
      titleNode.y = -Caption$1.SMALL_PADDING;
      titleNode.textAlign = "center";
      titleNode.textBaseline = "bottom";
      titleNode.text = callbackCache.call(formatter, this.getTitleFormatterParams());
    }
    titleNode.visible = titleVisible;
  }
  createTick() {
    return new RadiusAxisTick();
  }
  updateCrossLines() {
    var _a2;
    (_a2 = this.crossLines) == null ? void 0 : _a2.forEach((crossLine) => {
      if (crossLine instanceof RadiusCrossLine) {
        const { shape, gridAngles, range: range2, innerRadiusRatio } = this;
        const radius = range2[0];
        crossLine.shape = shape;
        crossLine.gridAngles = gridAngles;
        crossLine.axisOuterRadius = radius;
        crossLine.axisInnerRadius = radius * innerRadiusRatio;
      }
    });
    super.updateCrossLines({ rotation: 0, parallelFlipRotation: 0, regularFlipRotation: 0 });
  }
  createLabel() {
    return new RadiusAxisLabel();
  }
};
__decorateClass$1([
  Validate6(DEGREE2),
  Default2(0)
], RadiusAxis.prototype, "positionAngle", 2);

// packages/ag-charts-enterprise/src/axes/radius-category/radiusCategoryAxis.ts
var { RATIO: RATIO3, ProxyPropertyOnWrite: ProxyPropertyOnWrite$1, Validate: Validate7 } = module_support_exports;
var { BandScale: BandScale2 } = sparklines_scale_exports;
var RadiusCategoryAxis = class extends RadiusAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale2());
    this.shape = "circle";
    this.groupPaddingInner = 0;
    this.paddingInner = 0;
    this.paddingOuter = 0;
  }
  prepareTickData(data) {
    return data.slice().reverse();
  }
  getTickRadius(tickDatum) {
    const { scale } = this;
    const maxRadius = scale.range[0];
    const minRadius = maxRadius * this.innerRadiusRatio;
    const tickRange = (maxRadius - minRadius) / scale.domain.length;
    return maxRadius - tickDatum.translationY + minRadius - tickRange / 2;
  }
};
RadiusCategoryAxis.className = "RadiusCategoryAxis";
RadiusCategoryAxis.type = "radius-category";
__decorateClass$1([
  Validate7(RATIO3)
], RadiusCategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass$1([
  ProxyPropertyOnWrite$1("scale", "paddingInner"),
  Validate7(RATIO3)
], RadiusCategoryAxis.prototype, "paddingInner", 2);
__decorateClass$1([
  ProxyPropertyOnWrite$1("scale", "paddingOuter"),
  Validate7(RATIO3)
], RadiusCategoryAxis.prototype, "paddingOuter", 2);

// packages/ag-charts-enterprise/src/axes/radius-category/radiusCategoryAxisModule.ts
var RadiusCategoryAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radius-category",
  instanceConstructor: RadiusCategoryAxis,
  themeTemplate: RADIUS_AXIS_THEME
};
var { AND: AND4, Default: Default3, GREATER_THAN: GREATER_THAN3, LESS_THAN: LESS_THAN2, NUMBER_OR_NAN: NUMBER_OR_NAN2, Validate: Validate8 } = module_support_exports;
var { LinearScale: LinearScale2 } = sparklines_scale_exports;
var { normalisedExtentWithMetadata: normalisedExtentWithMetadata2 } = sparklines_util_exports;
var RadiusNumberAxis = class extends RadiusAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LinearScale2());
    this.shape = "polygon";
    this.min = NaN;
    this.max = NaN;
  }
  prepareTickData(data) {
    var _a2;
    const { scale } = this;
    const domainTop = (_a2 = scale.getDomain) == null ? void 0 : _a2.call(scale)[1];
    return data.filter(({ tick }) => tick !== domainTop).sort((a, b) => b.tick - a.tick);
  }
  getTickRadius(tickDatum) {
    const { scale } = this;
    const maxRadius = scale.range[0];
    const minRadius = maxRadius * this.innerRadiusRatio;
    return maxRadius - tickDatum.translationY + minRadius;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent5, clipped } = normalisedExtentWithMetadata2(d, min, max);
    return { domain: extent5, clipped };
  }
};
RadiusNumberAxis.className = "RadiusNumberAxis";
RadiusNumberAxis.type = "radius-number";
__decorateClass$1([
  Validate8(AND4(NUMBER_OR_NAN2, LESS_THAN2("max"))),
  Default3(NaN)
], RadiusNumberAxis.prototype, "min", 2);
__decorateClass$1([
  Validate8(AND4(NUMBER_OR_NAN2, GREATER_THAN3("min"))),
  Default3(NaN)
], RadiusNumberAxis.prototype, "max", 2);

// packages/ag-charts-enterprise/src/axes/radius-number/radiusNumberAxisModule.ts
var RadiusNumberAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radius-number",
  instanceConstructor: RadiusNumberAxis,
  themeTemplate: RADIUS_AXIS_THEME
};
var { BOOLEAN: BOOLEAN3, POSITIVE_NUMBER: POSITIVE_NUMBER2, ActionOnSet: ActionOnSet$1, Validate: Validate9 } = module_support_exports;
var Animation$1 = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.animationManager = ctx.animationManager;
    this.animationManager.skip(false);
  }
};
__decorateClass$1([
  ActionOnSet$1({
    newValue(value) {
      if (this.animationManager) {
        this.animationManager.skip(!value);
      }
    }
  }),
  Validate9(BOOLEAN3)
], Animation$1.prototype, "enabled", 2);
__decorateClass$1([
  ActionOnSet$1({
    newValue(value) {
      if (this.animationManager) {
        this.animationManager.defaultDuration = value;
      }
    }
  }),
  Validate9(POSITIVE_NUMBER2)
], Animation$1.prototype, "duration", 2);

// packages/ag-charts-enterprise/src/features/animation/animationModule.ts
var AnimationModule = {
  type: "root",
  optionsKey: "animation",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy"],
  instanceConstructor: Animation$1,
  themeTemplate: {
    animation: {
      enabled: true
    }
  }
};
var { Image: Image$1 } = integrated_charts_scene_exports;
var { BaseProperties: BaseProperties$1, ObserveChanges: ObserveChanges$1, ProxyProperty: ProxyProperty$1, Validate: Validate10, NUMBER: NUMBER3, POSITIVE_NUMBER: POSITIVE_NUMBER3, RATIO: RATIO4 } = module_support_exports;
var BackgroundImage = class extends BaseProperties$1 {
  constructor(ctx) {
    super();
    this.loadedSynchronously = true;
    this.opacity = 1;
    this.containerWidth = 0;
    this.containerHeight = 0;
    this.onLoad = void 0;
    this.onImageLoad = () => {
      var _a2;
      if (this.loadedSynchronously) {
        return;
      }
      this.node.visible = false;
      this.performLayout(this.containerWidth, this.containerHeight);
      (_a2 = this.onLoad) == null ? void 0 : _a2.call(this);
    };
    this.imageElement = ctx.document.createElement("img");
    this.imageElement.onload = this.onImageLoad;
    this.node = new Image$1(this.imageElement);
  }
  get complete() {
    return this.imageElement.width > 0 && this.imageElement.height > 0;
  }
  performLayout(containerWidth, containerHeight) {
    this.containerWidth = containerWidth;
    this.containerHeight = containerHeight;
    this.node.setProperties(
      this.complete ? __spreadValues$1({
        visible: true,
        opacity: this.opacity
      }, this.calculatePosition(this.imageElement.width, this.imageElement.height)) : { visible: false }
    );
  }
  calculatePosition(naturalWidth, naturalHeight) {
    let { top, right, bottom, left, width, height } = this;
    if (left != null) {
      if (width != null) {
        right = this.containerWidth - left + width;
      } else if (right != null) {
        width = this.containerWidth - left - right;
      }
    } else if (right != null && width != null) {
      left = this.containerWidth - right - width;
    }
    if (top != null) {
      if (height != null) {
        bottom = this.containerHeight - top - height;
      } else if (bottom != null) {
        height = this.containerHeight - bottom - top;
      }
    } else if (bottom != null && height != null) {
      top = this.containerHeight - bottom - height;
    }
    if (width == null) {
      if (height == null) {
        width = naturalWidth;
        height = naturalHeight;
      } else {
        width = Math.ceil(naturalWidth * height / naturalHeight);
      }
    } else if (height == null) {
      height = Math.ceil(naturalHeight * width / naturalWidth);
    }
    if (left == null) {
      if (right == null) {
        left = Math.floor((this.containerWidth - width) / 2);
      } else {
        left = this.containerWidth - right - width;
      }
    }
    if (top == null) {
      if (bottom == null) {
        top = Math.floor((this.containerHeight - height) / 2);
      } else {
        top = this.containerHeight - height - bottom;
      }
    }
    return { x: left, y: top, width, height };
  }
};
__decorateClass$1([
  Validate10(NUMBER3, { optional: true })
], BackgroundImage.prototype, "top", 2);
__decorateClass$1([
  Validate10(NUMBER3, { optional: true })
], BackgroundImage.prototype, "right", 2);
__decorateClass$1([
  Validate10(NUMBER3, { optional: true })
], BackgroundImage.prototype, "bottom", 2);
__decorateClass$1([
  Validate10(NUMBER3, { optional: true })
], BackgroundImage.prototype, "left", 2);
__decorateClass$1([
  Validate10(POSITIVE_NUMBER3, { optional: true })
], BackgroundImage.prototype, "width", 2);
__decorateClass$1([
  Validate10(POSITIVE_NUMBER3, { optional: true })
], BackgroundImage.prototype, "height", 2);
__decorateClass$1([
  Validate10(RATIO4)
], BackgroundImage.prototype, "opacity", 2);
__decorateClass$1([
  ProxyProperty$1("imageElement.src"),
  ObserveChanges$1((target) => target.loadedSynchronously = target.complete)
], BackgroundImage.prototype, "url", 2);

// packages/ag-charts-enterprise/src/features/background/background.ts
var { ActionOnSet: ActionOnSet2, OBJECT: OBJECT$1, Validate: Validate11 } = module_support_exports;
var Background$1 = class extends module_support_exports.Background {
  constructor(ctx) {
    super(ctx);
    this.image = new BackgroundImage(ctx);
    this.updateService = ctx.updateService;
  }
  onLayoutComplete(event) {
    super.onLayoutComplete(event);
    if (this.image) {
      const { width, height } = event.chart;
      this.image.performLayout(width, height);
    }
  }
  onImageLoad() {
    this.updateService.update(module_support_exports.ChartUpdateType.SCENE_RENDER);
  }
};
__decorateClass$1([
  Validate11(OBJECT$1, { optional: true }),
  ActionOnSet2({
    newValue(image) {
      this.node.appendChild(image.node);
      image.onLoad = () => this.onImageLoad();
    },
    oldValue(image) {
      this.node.removeChild(image.node);
      image.onLoad = void 0;
    }
  })
], Background$1.prototype, "image", 2);

// packages/ag-charts-enterprise/src/features/background/backgroundModule.ts
var BackgroundModule$1 = {
  type: "root",
  optionsKey: "background",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy"],
  instanceConstructor: Background$1
};

// packages/ag-charts-enterprise/src/features/context-menu/contextMenuStyles.ts
var DEFAULT_CONTEXT_MENU_CLASS = "ag-chart-context-menu";
var DEFAULT_CONTEXT_MENU_DARK_CLASS = `ag-charts-dark-context-menu`;
var defaultContextMenuCss = `
.${DEFAULT_CONTEXT_MENU_CLASS} {
    background: rgb(248, 248, 248);
    border: 1px solid #babfc7;
    border-radius: 5px;
    box-shadow: 0 1px 4px 1px rgba(186, 191, 199, 0.4);
    color: rgb(24, 29, 31);
    font: 13px Verdana, sans-serif;
    position: fixed;
    transition: transform 0.1s ease;
    white-space: nowrap;
    z-index: 99999;
}

.${DEFAULT_CONTEXT_MENU_CLASS}.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    color: white;
    background: #15181c;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__cover {
    position: fixed;
    left: 0px;
    top: 0px;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__menu {
    display: flex;
    flex-direction: column;
    padding: 0.5em 0;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item {
    background: none;
    border: none;
    box-sizing: border-box;
    font: inherit;
    padding: 0.5em 1em;
    text-align: left;
    -webkit-appearance: none;
    -moz-appearance: none;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    color: white;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item:hover {
    background: rgb(33, 150, 243, 0.1);
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item:hover.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    background: rgb(33, 150, 243, 0.1);
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item:active {
    background: rgb(33, 150, 243, 0.2);
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item:active.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    background: rgb(33, 150, 243, 0.1);
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item[disabled] {
    border: none;
    opacity: 0.5;
    text-align: left;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item[disabled]:hover {
    background: inherit;
    cursor: inherit;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__divider {
    margin: 5px 0;
    background: #babfc7;
    height: 1px;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__divider.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    background: rgb(33, 150, 243, 0.1);
}
`;

// packages/ag-charts-enterprise/src/features/context-menu/contextMenu.ts
var { BOOLEAN: BOOLEAN4, Validate: Validate12 } = module_support_exports;
var _ContextMenu = class _ContextMenu extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.darkTheme = false;
    /**
     * Extra menu actions with a label and callback.
     */
    this.extraActions = [];
    /**
     * Extra menu actions that only appear when clicking on a node.
     */
    this.extraNodeActions = [];
    this.x = 0;
    this.y = 0;
    this.highlightManager = ctx.highlightManager;
    this.interactionManager = ctx.interactionManager;
    this.registry = ctx.contextMenuRegistry;
    this.scene = ctx.scene;
    const { Default: Default5, ContextMenu: ContextMenuState, All } = module_support_exports.InteractionState;
    const contextState = Default5 | ContextMenuState;
    this.destroyFns.push(
      ctx.interactionManager.addListener("contextmenu", (event) => this.onContextMenu(event), contextState),
      ctx.interactionManager.addListener("click", () => this.onClick(), All)
    );
    this.groups = { default: [], node: [], extra: [], extraNode: [] };
    this.canvasElement = ctx.scene.canvas.element;
    this.container = ctx.document.body;
    this.element = this.container.appendChild(ctx.document.createElement("div"));
    this.element.classList.add(DEFAULT_CONTEXT_MENU_CLASS);
    this.element.addEventListener("contextmenu", (event) => event.preventDefault());
    this.destroyFns.push(() => {
      var _a2;
      return (_a2 = this.element.parentNode) == null ? void 0 : _a2.removeChild(this.element);
    });
    this.hide();
    if (typeof IntersectionObserver !== "undefined") {
      const observer = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (entry.target === this.canvasElement && entry.intersectionRatio === 0) {
              this.hide();
            }
          }
        },
        { root: this.container }
      );
      observer.observe(this.canvasElement);
      this.intersectionObserver = observer;
    }
    if (typeof MutationObserver !== "undefined") {
      const observer = new MutationObserver(() => {
        if (this.menuElement && this.element.contains(this.menuElement)) {
          this.reposition();
        }
      });
      observer.observe(this.element, { childList: true });
      this.mutationObserver = observer;
    }
    if (_ContextMenu.contextMenuDocuments.indexOf(ctx.document) < 0) {
      const styleElement = ctx.document.createElement("style");
      styleElement.innerHTML = defaultContextMenuCss;
      ctx.document.head.insertBefore(styleElement, ctx.document.head.querySelector("style"));
      _ContextMenu.contextMenuDocuments.push(ctx.document);
    }
    this.registry.registerDefaultAction({
      id: "download",
      label: "Download",
      action: () => {
        const title = ctx.chartService.title;
        let fileName = "image";
        if (title !== void 0 && title.enabled && title.text !== void 0) {
          fileName = title.text;
        }
        this.scene.download(fileName);
      }
    });
  }
  isShown() {
    return this.menuElement !== void 0;
  }
  onClick() {
    if (this.isShown()) {
      this.hide();
    }
  }
  onContextMenu(event) {
    if (!this.enabled)
      return;
    this.showEvent = event.sourceEvent;
    this.x = event.pageX;
    this.y = event.pageY;
    this.groups.default = this.registry.copyDefaultAction();
    this.pickedNode = this.highlightManager.getActivePicked();
    if (this.extraActions.length > 0) {
      this.groups.extra = [...this.extraActions];
    }
    if (this.extraNodeActions.length > 0 && this.pickedNode) {
      this.groups.extraNode = [...this.extraNodeActions];
    }
    const { default: def, node, extra, extraNode } = this.groups;
    const groupCount = def.length + node.length + extra.length + extraNode.length;
    if (groupCount === 0)
      return;
    event.consume();
    event.sourceEvent.preventDefault();
    this.show();
  }
  show() {
    this.interactionManager.pushState(module_support_exports.InteractionState.ContextMenu);
    this.element.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    const newMenuElement = this.renderMenu();
    if (this.menuElement) {
      this.element.replaceChild(newMenuElement, this.menuElement);
    } else {
      this.element.appendChild(newMenuElement);
    }
    this.menuElement = newMenuElement;
    this.element.style.display = "block";
  }
  hide() {
    this.interactionManager.popState(module_support_exports.InteractionState.ContextMenu);
    if (this.menuElement) {
      this.element.removeChild(this.menuElement);
      this.menuElement = void 0;
    }
    this.element.style.display = "none";
  }
  renderMenu() {
    const menuElement = this.ctx.document.createElement("div");
    menuElement.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__menu`);
    menuElement.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    this.groups.default.forEach((i) => {
      const item = this.renderItem(i);
      if (item)
        menuElement.appendChild(item);
    });
    ["node", "extra", "extraNode"].forEach((group) => {
      if (this.groups[group].length === 0 || ["node", "extraNode"].includes(group) && !this.pickedNode)
        return;
      menuElement.appendChild(this.createDividerElement());
      this.groups[group].forEach((i) => {
        const item = this.renderItem(i);
        if (item)
          menuElement.appendChild(item);
      });
    });
    return menuElement;
  }
  renderItem(item) {
    if (item && typeof item === "object" && item.constructor === Object) {
      return this.createActionElement(item);
    }
  }
  createDividerElement() {
    const el = this.ctx.document.createElement("div");
    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__divider`);
    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    return el;
  }
  createActionElement({ id, label, action }) {
    if (id && this.registry.isDisabled(id)) {
      return this.createDisabledElement(label);
    }
    return this.createButtonElement(label, action);
  }
  createButtonElement(label, callback) {
    const el = this.ctx.document.createElement("button");
    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__item`);
    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    el.innerHTML = label;
    el.onclick = () => {
      var _a2, _b, _c;
      const params = {
        event: this.showEvent,
        datum: (_a2 = this.pickedNode) == null ? void 0 : _a2.datum,
        itemId: (_b = this.pickedNode) == null ? void 0 : _b.itemId,
        seriesId: (_c = this.pickedNode) == null ? void 0 : _c.series.id
      };
      callback(params);
      this.hide();
    };
    return el;
  }
  createDisabledElement(label) {
    const el = this.ctx.document.createElement("button");
    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__item`);
    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    el.disabled = true;
    el.innerHTML = label;
    return el;
  }
  reposition() {
    const {
      x,
      y,
      ctx: { window: window2 }
    } = this;
    this.element.style.top = "unset";
    this.element.style.bottom = "unset";
    this.element.style.left = "unset";
    this.element.style.right = "unset";
    if (x + this.element.offsetWidth > window2.innerWidth) {
      this.element.style.right = `calc(100% - ${x - 1}px)`;
    } else {
      this.element.style.left = `${x + 1}px`;
    }
    if (y + this.element.offsetHeight > window2.innerHeight) {
      this.element.style.bottom = `calc(100% - ${y}px - 0.5em)`;
    } else {
      this.element.style.top = `calc(${y}px - 0.5em)`;
    }
  }
  destroy() {
    var _a2, _b;
    super.destroy();
    this.destroyFns.forEach((f) => f());
    (_a2 = this.intersectionObserver) == null ? void 0 : _a2.unobserve(this.canvasElement);
    (_b = this.mutationObserver) == null ? void 0 : _b.disconnect();
  }
};
// Global shared state
_ContextMenu.contextMenuDocuments = [];
__decorateClass$1([
  Validate12(BOOLEAN4)
], _ContextMenu.prototype, "enabled", 2);
__decorateClass$1([
  Validate12(BOOLEAN4)
], _ContextMenu.prototype, "darkTheme", 2);
var ContextMenu = _ContextMenu;

// packages/ag-charts-enterprise/src/features/context-menu/contextMenuModule.ts
var ContextMenuModule = {
  type: "root",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy"],
  optionsKey: "contextMenu",
  instanceConstructor: ContextMenu,
  themeTemplate: {
    contextMenu: {
      enabled: true,
      darkTheme: integrated_charts_theme_exports.IS_DARK_THEME
    }
  }
};
var { ActionOnSet: ActionOnSet3, BaseProperties: BaseProperties2, BOOLEAN: BOOLEAN5, FUNCTION: FUNCTION$1, NUMBER: NUMBER4, STRING: STRING2, Validate: Validate13 } = module_support_exports;
var { BBox: BBox$1 } = integrated_charts_scene_exports;
var DEFAULT_LABEL_CLASS = "ag-crosshair-label";
var defaultLabelCss = `
.${DEFAULT_LABEL_CLASS} {
    position: absolute;
    left: 0px;
    top: 0px;
    user-select: none;
    pointer-events: none;
    font: 12px Verdana, sans-serif;
    overflow: hidden;
    white-space: nowrap;
    z-index: 99999;
    box-sizing: border-box;
}

.${DEFAULT_LABEL_CLASS}-content {
    padding: 0 7px;
    border-radius: 2px;
    line-height: 1.7em;
    background-color: rgb(71,71,71);
    color: rgb(255, 255, 255);
}

.${DEFAULT_LABEL_CLASS}-hidden {
    top: -10000px !important;
}
`;
var _CrosshairLabel = class _CrosshairLabel extends BaseProperties2 {
  constructor(document2, container) {
    super();
    this.enabled = true;
    this.xOffset = 0;
    this.yOffset = 0;
    this.format = void 0;
    this.renderer = void 0;
    this.element = container.appendChild(document2.createElement("div"));
    this.element.classList.add(DEFAULT_LABEL_CLASS);
    this.labelRoot = container;
    if (_CrosshairLabel.labelDocuments.indexOf(document2) < 0) {
      const styleElement = document2.createElement("style");
      styleElement.innerHTML = defaultLabelCss;
      document2.head.insertBefore(styleElement, document2.head.querySelector("style"));
      _CrosshairLabel.labelDocuments.push(document2);
    }
  }
  show(meta) {
    const { element } = this;
    let left = meta.x + this.xOffset;
    let top = meta.y + this.yOffset;
    const limit = (low, actual, high) => {
      return Math.max(Math.min(actual, high), low);
    };
    const containerBounds = this.getContainerBoundingBox();
    const maxLeft = containerBounds.x + containerBounds.width - element.clientWidth - 1;
    const maxTop = containerBounds.y + containerBounds.height - element.clientHeight;
    left = limit(containerBounds.x + 1, left, maxLeft);
    top = limit(containerBounds.y, top, maxTop);
    element.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;
    this.toggle(true);
  }
  setLabelHtml(html) {
    if (html !== void 0) {
      this.element.innerHTML = html;
    }
  }
  computeBBox() {
    const { element } = this;
    return new integrated_charts_scene_exports.BBox(element.clientLeft, element.clientTop, element.clientWidth, element.clientHeight);
  }
  getContainerBoundingBox() {
    const { width, height } = this.labelRoot.getBoundingClientRect();
    return new BBox$1(0, 0, width, height);
  }
  toggle(visible) {
    this.element.classList.toggle(`${DEFAULT_LABEL_CLASS}-hidden`, !visible);
  }
  destroy() {
    const { parentNode } = this.element;
    if (parentNode) {
      parentNode.removeChild(this.element);
    }
  }
  toLabelHtml(input, defaults) {
    var _a2, _b;
    if (typeof input === "string") {
      return input;
    }
    defaults = defaults != null ? defaults : {};
    const {
      text = (_a2 = defaults.text) != null ? _a2 : "",
      color = defaults.color,
      backgroundColor = defaults.backgroundColor,
      opacity = (_b = defaults.opacity) != null ? _b : 1
    } = input;
    const style = `opacity: ${opacity}; background-color: ${backgroundColor == null ? void 0 : backgroundColor.toLowerCase()}; color: ${color}`;
    return `<div class="${DEFAULT_LABEL_CLASS}-content" style="${style}">
                    <span>${text}</span>
                </div>`;
  }
};
_CrosshairLabel.labelDocuments = [];
__decorateClass$1([
  Validate13(BOOLEAN5)
], _CrosshairLabel.prototype, "enabled", 2);
__decorateClass$1([
  Validate13(STRING2, { optional: true }),
  ActionOnSet3({
    changeValue(newValue, oldValue) {
      if (newValue !== oldValue) {
        if (oldValue) {
          this.element.classList.remove(oldValue);
        }
        if (newValue) {
          this.element.classList.add(newValue);
        }
      }
    }
  })
], _CrosshairLabel.prototype, "className", 2);
__decorateClass$1([
  Validate13(NUMBER4)
], _CrosshairLabel.prototype, "xOffset", 2);
__decorateClass$1([
  Validate13(NUMBER4)
], _CrosshairLabel.prototype, "yOffset", 2);
__decorateClass$1([
  Validate13(STRING2, { optional: true })
], _CrosshairLabel.prototype, "format", 2);
__decorateClass$1([
  Validate13(FUNCTION$1, { optional: true })
], _CrosshairLabel.prototype, "renderer", 2);
var CrosshairLabel = _CrosshairLabel;

// packages/ag-charts-enterprise/src/features/crosshair/crosshair.ts
var { Group: Group3, Line: Line$1, BBox: BBox2 } = integrated_charts_scene_exports;
var { POSITIVE_NUMBER: POSITIVE_NUMBER4, RATIO: RATIO5, BOOLEAN: BOOLEAN6, COLOR_STRING: COLOR_STRING2, LINE_DASH: LINE_DASH2, OBJECT: OBJECT2, Validate: Validate14, Layers: Layers3 } = module_support_exports;
var Crosshair = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    var _a2, _b;
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.stroke = "rgb(195, 195, 195)";
    this.lineDash = [6, 3];
    this.lineDashOffset = 0;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.snap = true;
    this.seriesRect = new BBox2(0, 0, 0, 0);
    this.hoverRect = new BBox2(0, 0, 0, 0);
    this.bounds = new BBox2(0, 0, 0, 0);
    this.visible = false;
    this.crosshairGroup = new Group3({ layer: true, zIndex: Layers3.SERIES_CROSSHAIR_ZINDEX });
    this.lineNode = this.crosshairGroup.appendChild(new Line$1());
    this.activeHighlight = void 0;
    (_a2 = ctx.scene.root) == null ? void 0 : _a2.appendChild(this.crosshairGroup);
    this.axisCtx = ctx.parent;
    this.crosshairGroup.visible = false;
    this.label = new CrosshairLabel(ctx.document, (_b = ctx.scene.canvas.container) != null ? _b : ctx.document.body);
    this.destroyFns.push(
      ctx.interactionManager.addListener("hover", (event) => this.onMouseMove(event)),
      ctx.interactionManager.addListener("leave", () => this.onMouseOut()),
      ctx.highlightManager.addListener("highlight-change", (event) => this.onHighlightChange(event)),
      ctx.layoutService.addListener("layout-complete", (event) => this.layout(event)),
      () => {
        var _a3;
        return (_a3 = ctx.scene.root) == null ? void 0 : _a3.removeChild(this.crosshairGroup);
      },
      () => this.label.destroy()
    );
  }
  layout({ series: { rect, paddedRect, visible }, axes }) {
    var _a2;
    this.hideCrosshair();
    if (!(visible && axes && this.enabled)) {
      this.visible = false;
      return;
    }
    this.visible = true;
    this.seriesRect = rect;
    this.hoverRect = paddedRect;
    const { position: axisPosition = "left", axisId } = this.axisCtx;
    const axisLayout = axes.find((a) => a.id === axisId);
    if (!axisLayout) {
      return;
    }
    this.axisLayout = axisLayout;
    const padding = axisLayout.gridPadding + axisLayout.seriesAreaPadding;
    this.bounds = this.buildBounds(rect, axisPosition, padding);
    const { crosshairGroup, bounds } = this;
    crosshairGroup.translationX = Math.round(bounds.x);
    crosshairGroup.translationY = Math.round(
      axisPosition === "top" || axisPosition === "bottom" ? bounds.y + bounds.height : bounds.y
    );
    const rotation = axisPosition === "top" || axisPosition === "bottom" ? -Math.PI / 2 : 0;
    crosshairGroup.rotation = rotation;
    this.updateLine();
    const format = (_a2 = this.label.format) != null ? _a2 : axisLayout.label.format;
    this.labelFormatter = format ? this.axisCtx.scaleValueFormatter(format) : void 0;
  }
  buildBounds(rect, axisPosition, padding) {
    const bounds = rect.clone();
    bounds.x += axisPosition === "left" ? -padding : 0;
    bounds.y += axisPosition === "top" ? -padding : 0;
    bounds.width += axisPosition === "left" || axisPosition === "right" ? padding : 0;
    bounds.height += axisPosition === "top" || axisPosition === "bottom" ? padding : 0;
    return bounds;
  }
  updateLine() {
    const {
      lineNode: line,
      bounds,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      axisCtx,
      axisLayout
    } = this;
    if (!axisLayout) {
      return;
    }
    line.stroke = stroke;
    line.strokeWidth = strokeWidth;
    line.strokeOpacity = strokeOpacity;
    line.lineDash = lineDash;
    line.lineDashOffset = lineDashOffset;
    line.y1 = line.y2 = 0;
    line.x1 = 0;
    line.x2 = axisCtx.direction === "x" ? bounds.height : bounds.width;
  }
  formatValue(val) {
    var _a2;
    const {
      labelFormatter,
      axisLayout,
      ctx: { callbackCache }
    } = this;
    if (labelFormatter) {
      const result = callbackCache.call(labelFormatter, val);
      if (result !== void 0)
        return result;
    }
    const isInteger = val % 1 === 0;
    const fractionDigits = ((_a2 = axisLayout == null ? void 0 : axisLayout.label.fractionDigits) != null ? _a2 : 0) + (isInteger ? 0 : 1);
    return typeof val === "number" ? val.toFixed(fractionDigits) : String(val);
  }
  onMouseMove(event) {
    if (!this.enabled || this.snap) {
      return;
    }
    const { crosshairGroup, seriesRect, hoverRect, axisCtx, activeHighlight } = this;
    const { offsetX, offsetY } = event;
    if (this.visible && hoverRect.containsPoint(offsetX, offsetY)) {
      crosshairGroup.visible = true;
      const highlight = activeHighlight ? this.getActiveHighlight(activeHighlight) : void 0;
      let value;
      let clampedX = 0;
      let clampedY = 0;
      if (axisCtx.direction === "x") {
        clampedX = Math.max(Math.min(seriesRect.x + seriesRect.width, offsetX), seriesRect.x);
        crosshairGroup.translationX = Math.round(clampedX);
        value = axisCtx.continuous ? axisCtx.scaleInvert(offsetX - seriesRect.x) : highlight == null ? void 0 : highlight.value;
      } else {
        clampedY = Math.max(Math.min(seriesRect.y + seriesRect.height, offsetY), seriesRect.y);
        crosshairGroup.translationY = Math.round(clampedY);
        value = axisCtx.continuous ? axisCtx.scaleInvert(offsetY - seriesRect.y) : highlight == null ? void 0 : highlight.value;
      }
      if (value && this.label.enabled) {
        this.showLabel(clampedX, clampedY, value);
      } else {
        this.hideLabel();
      }
    } else {
      this.hideCrosshair();
    }
  }
  onMouseOut() {
    this.hideCrosshair();
  }
  onHighlightChange(event) {
    var _a2, _b, _c;
    if (!this.enabled) {
      return;
    }
    const { crosshairGroup, seriesRect, axisCtx } = this;
    const { datum, series } = (_a2 = event.currentHighlight) != null ? _a2 : {};
    const hasCrosshair = datum && (((_b = series == null ? void 0 : series.axes.x) == null ? void 0 : _b.id) === axisCtx.axisId || ((_c = series == null ? void 0 : series.axes.y) == null ? void 0 : _c.id) === axisCtx.axisId);
    this.activeHighlight = hasCrosshair ? event.currentHighlight : void 0;
    if (this.snap) {
      if (!this.visible || !this.activeHighlight) {
        this.hideCrosshair();
        return;
      }
      const { value, position } = this.getActiveHighlight(this.activeHighlight);
      crosshairGroup.visible = true;
      let x = 0;
      let y = 0;
      if (axisCtx.direction === "x") {
        x = position;
        crosshairGroup.translationX = Math.round(x + seriesRect.x);
      } else {
        y = position;
        crosshairGroup.translationY = Math.round(y + seriesRect.y);
      }
      if (this.label.enabled) {
        this.showLabel(x + seriesRect.x, y + seriesRect.y, value);
      } else {
        this.hideLabel();
      }
    }
  }
  getActiveHighlight(activeHighlight) {
    var _a2, _b;
    const { axisCtx } = this;
    const { datum, xKey = "", yKey = "", aggregatedValue, series, cumulativeValue, midPoint } = activeHighlight;
    const halfBandwidth = axisCtx.scaleBandwidth() / 2;
    if (aggregatedValue !== void 0 && ((_a2 = series.axes.y) == null ? void 0 : _a2.id) === axisCtx.axisId) {
      return { value: aggregatedValue, position: axisCtx.scaleConvert(aggregatedValue) + halfBandwidth };
    }
    const isYValue = axisCtx.keys().indexOf(yKey) >= 0;
    if (cumulativeValue !== void 0 && isYValue) {
      return { value: cumulativeValue, position: axisCtx.scaleConvert(cumulativeValue) + halfBandwidth };
    }
    const key = isYValue ? yKey : xKey;
    const position = (_b = axisCtx.direction === "x" ? midPoint == null ? void 0 : midPoint.x : midPoint == null ? void 0 : midPoint.y) != null ? _b : 0;
    const value = axisCtx.continuous ? axisCtx.scaleInvert(position) : datum[key];
    return { value, position };
  }
  getLabelHtml(value) {
    const { label, axisLayout: { label: { fractionDigits = 0 } = {} } = {} } = this;
    const { renderer: labelRenderer } = label;
    const defaults = {
      text: this.formatValue(value)
    };
    if (labelRenderer) {
      const params = {
        value,
        fractionDigits
      };
      return label.toLabelHtml(labelRenderer(params), defaults);
    }
    return label.toLabelHtml(defaults);
  }
  showLabel(x, y, value) {
    const { axisCtx, bounds, label, axisLayout } = this;
    if (!axisLayout) {
      return;
    }
    const {
      label: { padding: labelPadding },
      tickSize
    } = axisLayout;
    const padding = labelPadding + tickSize;
    const html = this.getLabelHtml(value);
    label.setLabelHtml(html);
    const labelBBox = label.computeBBox();
    let labelMeta;
    if (axisCtx.direction === "x") {
      const xOffset = -labelBBox.width / 2;
      const yOffset = axisCtx.position === "bottom" ? 0 : -labelBBox.height;
      const fixedY = axisCtx.position === "bottom" ? bounds.y + bounds.height + padding : bounds.y - padding;
      labelMeta = {
        x: x + xOffset,
        y: fixedY + yOffset
      };
    } else {
      const yOffset = -labelBBox.height / 2;
      const xOffset = axisCtx.position === "right" ? 0 : -labelBBox.width;
      const fixedX = axisCtx.position === "right" ? bounds.x + bounds.width + padding : bounds.x - padding;
      labelMeta = {
        x: fixedX + xOffset,
        y: y + yOffset
      };
    }
    label.show(labelMeta);
  }
  hideCrosshair() {
    this.crosshairGroup.visible = false;
    this.hideLabel();
  }
  hideLabel() {
    this.label.toggle(false);
  }
};
__decorateClass$1([
  Validate14(BOOLEAN6)
], Crosshair.prototype, "enabled", 2);
__decorateClass$1([
  Validate14(COLOR_STRING2, { optional: true })
], Crosshair.prototype, "stroke", 2);
__decorateClass$1([
  Validate14(LINE_DASH2, { optional: true })
], Crosshair.prototype, "lineDash", 2);
__decorateClass$1([
  Validate14(POSITIVE_NUMBER4)
], Crosshair.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate14(POSITIVE_NUMBER4)
], Crosshair.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate14(RATIO5)
], Crosshair.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate14(BOOLEAN6)
], Crosshair.prototype, "snap", 2);
__decorateClass$1([
  Validate14(OBJECT2)
], Crosshair.prototype, "label", 2);
var AXIS_CROSSHAIR_THEME = {
  crosshair: {
    enabled: true,
    snap: true,
    stroke: integrated_charts_theme_exports.DEFAULT_MUTED_LABEL_COLOUR,
    strokeWidth: 1,
    strokeOpacity: 1,
    lineDash: [5, 6],
    lineDashOffset: 0,
    label: {
      enabled: true
    }
  },
  category: {
    crosshair: {
      enabled: false,
      snap: true,
      stroke: integrated_charts_theme_exports.DEFAULT_MUTED_LABEL_COLOUR,
      strokeWidth: 1,
      strokeOpacity: 1,
      lineDash: [5, 6],
      lineDashOffset: 0,
      label: {
        enabled: true
      }
    }
  }
};

// packages/ag-charts-enterprise/src/features/crosshair/crosshairModule.ts
var CrosshairModule = {
  type: "axis-option",
  optionsKey: "crosshair",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  axisTypes: ["category", "number", "log", "time"],
  instanceConstructor: Crosshair,
  themeTemplate: AXIS_CROSSHAIR_THEME
};
var { BOOLEAN: BOOLEAN7, FUNCTION: FUNCTION2, ActionOnSet: ActionOnSet4, Validate: Validate15 } = module_support_exports;
var DataSource = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.enabled = false;
    this.getData = () => Promise.resolve();
    this.dataService = ctx.dataService;
  }
  updateCallback(enabled, getData) {
    if (!this.dataService)
      return;
    if (enabled && getData != null) {
      this.dataService.updateCallback(getData);
    } else {
      this.dataService.clearCallback();
    }
  }
};
__decorateClass$1([
  ActionOnSet4({
    newValue(enabled) {
      this.updateCallback(enabled, this.getData);
    }
  }),
  Validate15(BOOLEAN7)
], DataSource.prototype, "enabled", 2);
__decorateClass$1([
  ActionOnSet4({
    newValue(getData) {
      this.updateCallback(this.enabled, getData);
    }
  }),
  Validate15(FUNCTION2)
], DataSource.prototype, "getData", 2);
__decorateClass$1([
  ActionOnSet4({
    newValue(requestThrottle) {
      this.dataService.requestThrottle = requestThrottle;
    }
  })
], DataSource.prototype, "requestThrottle", 2);
__decorateClass$1([
  ActionOnSet4({
    newValue(updateThrottle) {
      this.dataService.dispatchThrottle = updateThrottle;
    }
  })
], DataSource.prototype, "updateThrottle", 2);
__decorateClass$1([
  ActionOnSet4({
    newValue(updateDuringInteraction) {
      this.dataService.dispatchOnlyLatest = !updateDuringInteraction;
    }
  })
], DataSource.prototype, "updateDuringInteraction", 2);

// packages/ag-charts-enterprise/src/features/data-source/dataSourceModule.ts
var DataSourceModule = {
  type: "root",
  optionsKey: "dataSource",
  packageType: "enterprise",
  chartTypes: ["cartesian", "hierarchy", "polar"],
  instanceConstructor: DataSource,
  themeTemplate: {
    dataSource: { enabled: false }
  }
};
var { partialAssign: partialAssign$1, mergeDefaults: mergeDefaults$1 } = module_support_exports;
var { BBox: BBox3 } = integrated_charts_scene_exports;
var HierarchicalBBox = class {
  constructor(components) {
    this.components = components;
    this.union = BBox3.merge(components);
  }
  containsPoint(x, y) {
    if (!this.union.containsPoint(x, y)) {
      return false;
    }
    for (const bbox of this.components) {
      if (bbox.containsPoint(x, y)) {
        return true;
      }
    }
    return false;
  }
};
var ErrorBarNode = class extends integrated_charts_scene_exports.Group {
  constructor() {
    super();
    this.capLength = NaN;
    this._datum = void 0;
    this.whiskerPath = new integrated_charts_scene_exports.Path();
    this.capsPath = new integrated_charts_scene_exports.Path();
    this.bboxes = new HierarchicalBBox([]);
    this.append([this.whiskerPath, this.capsPath]);
  }
  get datum() {
    return this._datum;
  }
  set datum(datum) {
    this._datum = datum;
  }
  calculateCapLength(capsTheme, capDefaults) {
    const { lengthRatio = 1, length } = capsTheme;
    const { lengthRatioMultiplier, lengthMax } = capDefaults;
    const desiredLength = length != null ? length : lengthRatio * lengthRatioMultiplier;
    return Math.min(desiredLength, lengthMax);
  }
  getFormatterParams(formatters, highlighted) {
    const { datum } = this;
    if (datum === void 0 || formatters.formatter === void 0 && formatters.cap.formatter === void 0) {
      return void 0;
    }
    const { xLowerKey, xLowerName, xUpperKey, xUpperName, yLowerKey, yLowerName, yUpperKey, yUpperName } = formatters;
    return {
      datum: datum.datum,
      seriesId: datum.datum.seriesId,
      xKey: datum.xKey,
      yKey: datum.yKey,
      xLowerKey,
      xLowerName,
      xUpperKey,
      xUpperName,
      yLowerKey,
      yLowerName,
      yUpperKey,
      yUpperName,
      highlighted
    };
  }
  formatStyles(style, formatters, highlighted) {
    let _a2 = style, { cap: capsStyle } = _a2, whiskerStyle = __objRest$1(_a2, ["cap"]);
    const params = this.getFormatterParams(formatters, highlighted);
    if (params !== void 0) {
      if (formatters.formatter !== void 0) {
        const result = formatters.formatter(params);
        whiskerStyle = mergeDefaults$1(result, whiskerStyle);
        capsStyle = mergeDefaults$1(result, capsStyle);
        capsStyle = mergeDefaults$1(result == null ? void 0 : result.cap, capsStyle);
      }
      if (formatters.cap.formatter !== void 0) {
        const result = formatters.cap.formatter(params);
        capsStyle = mergeDefaults$1(result, capsStyle);
      }
    }
    return { whiskerStyle, capsStyle };
  }
  applyStyling(target, source) {
    partialAssign$1(
      ["visible", "stroke", "strokeWidth", "strokeOpacity", "lineDash", "lineDashOffset"],
      target,
      source
    );
  }
  update(style, formatters, highlighted) {
    if (this.datum === void 0) {
      return;
    }
    const { whiskerStyle, capsStyle } = this.formatStyles(style, formatters, highlighted);
    const { xBar, yBar, capDefaults } = this.datum;
    const whisker = this.whiskerPath;
    this.applyStyling(whisker, whiskerStyle);
    whisker.path.clear();
    if (yBar !== void 0) {
      whisker.path.moveTo(yBar.lowerPoint.x, yBar.lowerPoint.y);
      whisker.path.lineTo(yBar.upperPoint.x, yBar.upperPoint.y);
    }
    if (xBar !== void 0) {
      whisker.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y);
      whisker.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y);
    }
    whisker.path.closePath();
    whisker.markDirtyTransform();
    this.capLength = this.calculateCapLength(capsStyle != null ? capsStyle : {}, capDefaults);
    const capOffset = this.capLength / 2;
    const caps = this.capsPath;
    this.applyStyling(caps, capsStyle);
    caps.path.clear();
    if (yBar !== void 0) {
      caps.path.moveTo(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y);
      caps.path.lineTo(yBar.lowerPoint.x + capOffset, yBar.lowerPoint.y);
      caps.path.moveTo(yBar.upperPoint.x - capOffset, yBar.upperPoint.y);
      caps.path.lineTo(yBar.upperPoint.x + capOffset, yBar.upperPoint.y);
    }
    if (xBar !== void 0) {
      caps.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset);
      caps.path.lineTo(xBar.lowerPoint.x, xBar.lowerPoint.y + capOffset);
      caps.path.moveTo(xBar.upperPoint.x, xBar.upperPoint.y - capOffset);
      caps.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y + capOffset);
    }
    caps.path.closePath();
    caps.markDirtyTransform();
  }
  updateBBoxes() {
    var _a2;
    const { capLength, whiskerPath: whisker, capsPath: caps } = this;
    const { yBar, xBar } = (_a2 = this.datum) != null ? _a2 : {};
    const capOffset = capLength / 2;
    const components = [];
    if (yBar !== void 0) {
      const whiskerHeight = yBar.lowerPoint.y - yBar.upperPoint.y;
      components.push(
        new BBox3(yBar.lowerPoint.x, yBar.upperPoint.y, whisker.strokeWidth, whiskerHeight),
        new BBox3(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y, capLength, caps.strokeWidth),
        new BBox3(yBar.upperPoint.x - capOffset, yBar.upperPoint.y, capLength, caps.strokeWidth)
      );
    }
    if (xBar !== void 0) {
      const whiskerWidth = xBar.upperPoint.x - xBar.lowerPoint.x;
      components.push(
        new BBox3(xBar.lowerPoint.x, xBar.upperPoint.y, whiskerWidth, whisker.strokeWidth),
        new BBox3(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset, caps.strokeWidth, capLength),
        new BBox3(xBar.upperPoint.x, xBar.upperPoint.y - capOffset, caps.strokeWidth, capLength)
      );
    }
    this.bboxes.components = components;
    this.bboxes.union = BBox3.merge(components);
  }
  containsPoint(x, y) {
    return this.bboxes.containsPoint(x, y);
  }
  pickNode(x, y) {
    return this.containsPoint(x, y) ? this : void 0;
  }
  nearestSquared(point, maxDistance) {
    const { bboxes } = this;
    if (bboxes.union.distanceSquared(point) > maxDistance) {
      return { nearest: void 0, distanceSquared: Infinity };
    }
    const { distanceSquared } = BBox3.nearestBox(point, bboxes.components);
    return { nearest: this, distanceSquared };
  }
};
var ErrorBarGroup = class extends integrated_charts_scene_exports.Group {
  get children() {
    return super.children;
  }
  nearestSquared(point) {
    const { nearest, distanceSquared } = integrated_charts_scene_exports.nearestSquaredInContainer(point, this);
    if (nearest !== void 0 && !isNaN(distanceSquared)) {
      return { datum: nearest.datum, distanceSquared };
    }
  }
};
var {
  BaseProperties: BaseProperties3,
  Validate: Validate16,
  BOOLEAN: BOOLEAN8,
  COLOR_STRING: COLOR_STRING3,
  FUNCTION: FUNCTION3,
  LINE_DASH: LINE_DASH3,
  NUMBER: NUMBER5,
  OBJECT: OBJECT3,
  POSITIVE_NUMBER: POSITIVE_NUMBER5,
  RATIO: RATIO6,
  STRING: STRING3
} = module_support_exports;
var ErrorBarCap = class extends BaseProperties3 {
};
__decorateClass$1([
  Validate16(BOOLEAN8, { optional: true })
], ErrorBarCap.prototype, "visible", 2);
__decorateClass$1([
  Validate16(COLOR_STRING3, { optional: true })
], ErrorBarCap.prototype, "stroke", 2);
__decorateClass$1([
  Validate16(POSITIVE_NUMBER5, { optional: true })
], ErrorBarCap.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate16(RATIO6, { optional: true })
], ErrorBarCap.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate16(LINE_DASH3, { optional: true })
], ErrorBarCap.prototype, "lineDash", 2);
__decorateClass$1([
  Validate16(POSITIVE_NUMBER5, { optional: true })
], ErrorBarCap.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate16(NUMBER5, { optional: true })
], ErrorBarCap.prototype, "length", 2);
__decorateClass$1([
  Validate16(RATIO6, { optional: true })
], ErrorBarCap.prototype, "lengthRatio", 2);
__decorateClass$1([
  Validate16(FUNCTION3, { optional: true })
], ErrorBarCap.prototype, "formatter", 2);
var ErrorBarProperties = class extends BaseProperties3 {
  constructor() {
    super(...arguments);
    this.visible = true;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cap = new ErrorBarCap();
  }
};
__decorateClass$1([
  Validate16(STRING3, { optional: true })
], ErrorBarProperties.prototype, "yLowerKey", 2);
__decorateClass$1([
  Validate16(STRING3, { optional: true })
], ErrorBarProperties.prototype, "yLowerName", 2);
__decorateClass$1([
  Validate16(STRING3, { optional: true })
], ErrorBarProperties.prototype, "yUpperKey", 2);
__decorateClass$1([
  Validate16(STRING3, { optional: true })
], ErrorBarProperties.prototype, "yUpperName", 2);
__decorateClass$1([
  Validate16(STRING3, { optional: true })
], ErrorBarProperties.prototype, "xLowerKey", 2);
__decorateClass$1([
  Validate16(STRING3, { optional: true })
], ErrorBarProperties.prototype, "xLowerName", 2);
__decorateClass$1([
  Validate16(STRING3, { optional: true })
], ErrorBarProperties.prototype, "xUpperKey", 2);
__decorateClass$1([
  Validate16(STRING3, { optional: true })
], ErrorBarProperties.prototype, "xUpperName", 2);
__decorateClass$1([
  Validate16(BOOLEAN8, { optional: true })
], ErrorBarProperties.prototype, "visible", 2);
__decorateClass$1([
  Validate16(COLOR_STRING3, { optional: true })
], ErrorBarProperties.prototype, "stroke", 2);
__decorateClass$1([
  Validate16(POSITIVE_NUMBER5, { optional: true })
], ErrorBarProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate16(RATIO6, { optional: true })
], ErrorBarProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate16(LINE_DASH3, { optional: true })
], ErrorBarProperties.prototype, "lineDash", 2);
__decorateClass$1([
  Validate16(POSITIVE_NUMBER5, { optional: true })
], ErrorBarProperties.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate16(FUNCTION3, { optional: true })
], ErrorBarProperties.prototype, "formatter", 2);
__decorateClass$1([
  Validate16(OBJECT3)
], ErrorBarProperties.prototype, "cap", 2);

// packages/ag-charts-enterprise/src/features/error-bar/errorBar.ts
var {
  fixNumericExtent: fixNumericExtent$1,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty$1,
  isDefined: isDefined$1,
  mergeDefaults: mergeDefaults2,
  valueProperty: valueProperty$1,
  ChartAxisDirection: ChartAxisDirection6
} = module_support_exports;
function toErrorBoundCartesianSeries(ctx) {
  for (const supportedType of AgErrorBarSupportedSeriesTypes) {
    if (supportedType == ctx.series.type) {
      return ctx.series;
    }
  }
  throw new Error(
    `AG Charts - unsupported series type '${ctx.series.type}', error bars supported series types: ${AgErrorBarSupportedSeriesTypes.join(", ")}`
  );
}
var ErrorBars = class _ErrorBars extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.properties = new ErrorBarProperties();
    const series = toErrorBoundCartesianSeries(ctx);
    const { annotationGroup, annotationSelections } = series;
    this.cartesianSeries = series;
    this.groupNode = new ErrorBarGroup({
      name: `${annotationGroup.id}-errorBars`,
      zIndex: module_support_exports.Layers.SERIES_LAYER_ZINDEX,
      zIndexSubOrder: series.getGroupZIndexSubOrder("annotation")
    });
    annotationGroup.appendChild(this.groupNode);
    this.selection = integrated_charts_scene_exports.Selection.select(this.groupNode, () => this.errorBarFactory());
    annotationSelections.add(this.selection);
    this.destroyFns.push(
      series.addListener("data-processed", (e) => this.onDataProcessed(e)),
      series.addListener("data-update", (e) => this.onDataUpdate(e)),
      series.addListener("visibility-changed", (e) => this.onToggleSeriesItem(e)),
      ctx.highlightManager.addListener("highlight-change", (event) => this.onHighlightChange(event)),
      () => annotationGroup.removeChild(this.groupNode),
      () => annotationSelections.delete(this.selection)
    );
  }
  hasErrorBars() {
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;
    return isDefined$1(xLowerKey) && isDefined$1(xUpperKey) || isDefined$1(yLowerKey) && isDefined$1(yUpperKey);
  }
  isStacked() {
    var _a2;
    const stackCount = (_a2 = this.cartesianSeries.seriesGrouping) == null ? void 0 : _a2.stackCount;
    return stackCount === void 0 ? false : stackCount > 0;
  }
  getUnstackPropertyDefinition(opts) {
    const props = [];
    const { cartesianSeries } = this;
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();
    const { isContinuousX, isContinuousY } = opts;
    if (yLowerKey !== void 0 && yUpperKey !== void 0) {
      props.push(
        valueProperty$1(cartesianSeries, yLowerKey, isContinuousY, { id: yErrorsID }),
        valueProperty$1(cartesianSeries, yUpperKey, isContinuousY, { id: yErrorsID })
      );
    }
    if (xLowerKey !== void 0 && xUpperKey !== void 0) {
      props.push(
        valueProperty$1(cartesianSeries, xLowerKey, isContinuousX, { id: xErrorsID }),
        valueProperty$1(cartesianSeries, xUpperKey, isContinuousX, { id: xErrorsID })
      );
    }
    return props;
  }
  getStackPropertyDefinition(opts) {
    var _a2, _b;
    const props = [];
    const { cartesianSeries } = this;
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();
    const { isContinuousX, isContinuousY } = opts;
    const groupIndex = (_b = (_a2 = cartesianSeries.seriesGrouping) == null ? void 0 : _a2.groupIndex) != null ? _b : cartesianSeries.id;
    const groupOpts = __spreadValues$1({
      invalidValue: null,
      missingValue: 0,
      separateNegative: true
    }, !cartesianSeries.visible ? { forceValue: 0 } : {});
    const makeErrorProperty = (key, continuous, id, type) => {
      return groupAccumulativeValueProperty$1(cartesianSeries, key, continuous, "normal", "current", __spreadValues$1({
        id: `${id}-${type}`,
        groupId: `errorGroup-${groupIndex}-${type}`
      }, groupOpts));
    };
    const pushErrorProperties = (lowerKey, upperKey, continuous, id) => {
      props.push(
        ...makeErrorProperty(lowerKey, continuous, id, "lower"),
        ...makeErrorProperty(upperKey, continuous, id, "upper")
      );
    };
    if (yLowerKey !== void 0 && yUpperKey !== void 0) {
      pushErrorProperties(yLowerKey, yUpperKey, isContinuousY, yErrorsID);
    }
    if (xLowerKey !== void 0 && xUpperKey !== void 0) {
      pushErrorProperties(xLowerKey, xUpperKey, isContinuousX, xErrorsID);
    }
    return props;
  }
  getPropertyDefinitions(opts) {
    if (this.isStacked()) {
      return this.getStackPropertyDefinition(opts);
    } else {
      return this.getUnstackPropertyDefinition(opts);
    }
  }
  onDataProcessed(event) {
    this.dataModel = event.dataModel;
    this.processedData = event.processedData;
  }
  getDomain(direction) {
    const { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID } = this.getMaybeFlippedKeys();
    const hasAxisErrors = direction === ChartAxisDirection6.X ? isDefined$1(xLowerKey) && isDefined$1(xUpperKey) : isDefined$1(yLowerKey) && isDefined$1(yUpperKey);
    if (hasAxisErrors) {
      const { dataModel, processedData, cartesianSeries: series } = this;
      const axis = series.axes[direction];
      const id = { x: xErrorsID, y: yErrorsID }[direction];
      if (dataModel !== void 0 && processedData !== void 0) {
        if (this.isStacked()) {
          const lowerDomain = dataModel.getDomain(series, `${id}-lower`, "value", processedData);
          const upperDomain = dataModel.getDomain(series, `${id}-upper`, "value", processedData);
          const domain = [Math.min(...lowerDomain, ...upperDomain), Math.max(...lowerDomain, ...upperDomain)];
          return fixNumericExtent$1(domain, axis);
        } else {
          const domain = dataModel.getDomain(series, id, "value", processedData);
          return fixNumericExtent$1(domain, axis);
        }
      }
    }
    return [];
  }
  onDataUpdate(event) {
    this.dataModel = event.dataModel;
    this.processedData = event.processedData;
    if (isDefined$1(event.dataModel) && isDefined$1(event.processedData)) {
      this.createNodeData();
      this.update();
    }
  }
  getNodeData() {
    const { contextNodeData } = this.cartesianSeries;
    if (contextNodeData.length > 0) {
      return contextNodeData[0].nodeData;
    }
  }
  createNodeData() {
    var _a2, _b;
    const nodeData = this.getNodeData();
    const xScale = (_a2 = this.cartesianSeries.axes[ChartAxisDirection6.X]) == null ? void 0 : _a2.scale;
    const yScale = (_b = this.cartesianSeries.axes[ChartAxisDirection6.Y]) == null ? void 0 : _b.scale;
    if (!this.hasErrorBars() || !xScale || !yScale || !nodeData) {
      return;
    }
    for (let i = 0; i < nodeData.length; i++) {
      const { midPoint, xLower, xUpper, yLower, yUpper } = this.getDatum(nodeData, i);
      if (midPoint !== void 0) {
        let xBar, yBar;
        if (isDefined$1(xLower) && isDefined$1(xUpper)) {
          xBar = {
            lowerPoint: { x: this.convert(xScale, xLower), y: midPoint.y },
            upperPoint: { x: this.convert(xScale, xUpper), y: midPoint.y }
          };
        }
        if (isDefined$1(yLower) && isDefined$1(yUpper)) {
          yBar = {
            lowerPoint: { x: midPoint.x, y: this.convert(yScale, yLower) },
            upperPoint: { x: midPoint.x, y: this.convert(yScale, yUpper) }
          };
        }
        nodeData[i].xBar = xBar;
        nodeData[i].yBar = yBar;
      }
    }
  }
  getMaybeFlippedKeys() {
    let { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;
    let [xErrorsID, yErrorsID] = ["xValue-errors", "yValue-errors"];
    if (this.cartesianSeries.shouldFlipXY()) {
      [xLowerKey, yLowerKey] = [yLowerKey, xLowerKey];
      [xUpperKey, yUpperKey] = [yUpperKey, xUpperKey];
      [xErrorsID, yErrorsID] = [yErrorsID, xErrorsID];
    }
    return { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID };
  }
  static getDatumKey(datum, key, offset) {
    if (key === void 0) {
      return void 0;
    }
    const value = datum.datum[key];
    if (value === void 0) {
      return void 0;
    }
    if (typeof value !== "number") {
      sparklines_util_exports.Logger.warnOnce(`Found [${key}] error value of type ${typeof value}. Expected number type`);
      return void 0;
    }
    return value + offset;
  }
  getDatum(nodeData, datumIndex) {
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.getMaybeFlippedKeys();
    const datum = nodeData[datumIndex];
    const d = datum.cumulativeValue === void 0 || !this.isStacked() ? 0 : datum.cumulativeValue - datum.yValue;
    const [xOffset, yOffset] = this.cartesianSeries.shouldFlipXY() ? [d, 0] : [0, d];
    return {
      midPoint: datum.midPoint,
      xLower: _ErrorBars.getDatumKey(datum, xLowerKey, xOffset),
      xUpper: _ErrorBars.getDatumKey(datum, xUpperKey, xOffset),
      yLower: _ErrorBars.getDatumKey(datum, yLowerKey, yOffset),
      yUpper: _ErrorBars.getDatumKey(datum, yUpperKey, yOffset)
    };
  }
  convert(scale, value) {
    var _a2;
    const offset = ((_a2 = scale.bandwidth) != null ? _a2 : 0) / 2;
    return scale.convert(value) + offset;
  }
  update() {
    const nodeData = this.getNodeData();
    if (nodeData !== void 0) {
      this.selection.update(nodeData);
      this.selection.each((node, datum, i) => this.updateNode(node, datum, i));
    }
  }
  updateNode(node, datum, _index) {
    node.datum = datum;
    node.update(this.getDefaultStyle(), this.properties, false);
    node.updateBBoxes();
  }
  pickNodeExact(point) {
    const { x, y } = this.groupNode.transformPoint(point.x, point.y);
    const node = this.groupNode.pickNode(x, y);
    if (node !== void 0) {
      return { datum: node.datum, distanceSquared: 0 };
    }
  }
  pickNodeNearest(point) {
    return this.groupNode.nearestSquared(point);
  }
  pickNodeMainAxisFirst(point) {
    return this.groupNode.nearestSquared(point);
  }
  getTooltipParams() {
    const {
      xLowerKey,
      xUpperKey,
      yLowerKey,
      yUpperKey,
      xLowerName = xLowerKey,
      xUpperName = xUpperKey,
      yLowerName = yLowerKey,
      yUpperName = yUpperKey
    } = this.properties;
    return { xLowerKey, xLowerName, xUpperKey, xUpperName, yLowerKey, yLowerName, yUpperKey, yUpperName };
  }
  onToggleSeriesItem(event) {
    this.groupNode.visible = event.enabled;
  }
  makeStyle(baseStyle) {
    return {
      visible: baseStyle.visible,
      lineDash: baseStyle.lineDash,
      lineDashOffset: baseStyle.lineDashOffset,
      stroke: baseStyle.stroke,
      strokeWidth: baseStyle.strokeWidth,
      strokeOpacity: baseStyle.strokeOpacity,
      cap: mergeDefaults2(this.properties.cap, baseStyle)
    };
  }
  getDefaultStyle() {
    return this.makeStyle(this.getWhiskerProperties());
  }
  getHighlightStyle() {
    return this.makeStyle(this.getWhiskerProperties());
  }
  restyleHighlightChange(highlightChange, style, highlighted) {
    const nodeData = this.getNodeData();
    if (nodeData === void 0)
      return;
    for (let i = 0; i < nodeData.length; i++) {
      if (highlightChange === nodeData[i]) {
        this.selection.nodes()[i].update(style, this.properties, highlighted);
        break;
      }
    }
  }
  onHighlightChange(event) {
    const { previousHighlight, currentHighlight } = event;
    if ((currentHighlight == null ? void 0 : currentHighlight.series) === this.cartesianSeries) {
      this.restyleHighlightChange(currentHighlight, this.getHighlightStyle(), true);
    }
    if ((previousHighlight == null ? void 0 : previousHighlight.series) === this.cartesianSeries) {
      this.restyleHighlightChange(previousHighlight, this.getDefaultStyle(), false);
    }
    this.groupNode.opacity = this.cartesianSeries.getOpacity();
  }
  errorBarFactory() {
    return new ErrorBarNode();
  }
  getWhiskerProperties() {
    const { stroke, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset } = this.properties;
    return { stroke, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset };
  }
};
var ERROR_BARS_THEME = {
  series: {
    errorBar: {
      visible: true,
      stroke: integrated_charts_theme_exports.DEFAULT_LABEL_COLOUR,
      strokeWidth: 1,
      strokeOpacity: 1,
      cap: {
        length: void 0,
        lengthRatio: void 0
      }
    }
  }
};

// packages/ag-charts-enterprise/src/features/error-bar/errorBarModule.ts
var ErrorBarsModule = {
  type: "series-option",
  identifier: "error-bars",
  optionsKey: "errorBar",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  seriesTypes: AgErrorBarSupportedSeriesTypes,
  instanceConstructor: ErrorBars,
  themeTemplate: ERROR_BARS_THEME
};
var { Validate: Validate17, BOOLEAN: BOOLEAN9, POSITIVE_NUMBER: POSITIVE_NUMBER6, Layers: Layers4, ActionOnSet: ActionOnSet5, CategoryAxis: CategoryAxis$1, GroupedCategoryAxis: GroupedCategoryAxis$1 } = module_support_exports;
var { toRadians: toRadians4, Padding: Padding$1, Logger: Logger$1 } = sparklines_util_exports;
var { Text: Text4, Group: Group4, BBox: BBox4 } = integrated_charts_scene_exports;
var MiniChartPadding = class {
  constructor() {
    this.top = 0;
    this.bottom = 0;
  }
};
__decorateClass$1([
  Validate17(POSITIVE_NUMBER6)
], MiniChartPadding.prototype, "top", 2);
__decorateClass$1([
  Validate17(POSITIVE_NUMBER6)
], MiniChartPadding.prototype, "bottom", 2);
var MiniChart = class extends module_support_exports.BaseModuleInstance {
  constructor() {
    super(...arguments);
    this.enabled = false;
    this.padding = new MiniChartPadding();
    this.root = new Group4({ name: "root" });
    this.seriesRoot = this.root.appendChild(
      new Group4({ name: "Series-root", layer: true, zIndex: Layers4.SERIES_LAYER_ZINDEX })
    );
    this.axisGridGroup = this.root.appendChild(
      new Group4({ name: "Axes-Grids", layer: true, zIndex: Layers4.AXIS_GRID_ZINDEX })
    );
    this.axisGroup = this.root.appendChild(
      new Group4({ name: "Axes-Grids", layer: true, zIndex: Layers4.AXIS_GRID_ZINDEX })
    );
    this.data = [];
    this._destroyed = false;
    this.axes = [];
    this.series = [];
  }
  destroy() {
    if (this._destroyed) {
      return;
    }
    this.destroySeries(this.series);
    this.axes.forEach((a) => a.destroy());
    this.axes = [];
    this._destroyed = true;
  }
  onSeriesChange(newValue, oldValue) {
    var _a2;
    const seriesToDestroy = (_a2 = oldValue == null ? void 0 : oldValue.filter((series) => !newValue.includes(series))) != null ? _a2 : [];
    this.destroySeries(seriesToDestroy);
    for (const series of newValue) {
      if (oldValue == null ? void 0 : oldValue.includes(series))
        continue;
      if (series.rootGroup.parent == null) {
        this.seriesRoot.appendChild(series.rootGroup);
      }
      const chart = this;
      series.chart = {
        get mode() {
          return "standalone";
        },
        get isMiniChart() {
          return true;
        },
        get seriesRect() {
          return chart.seriesRect;
        },
        placeLabels() {
          return /* @__PURE__ */ new Map();
        }
      };
      series.resetAnimation("initial");
    }
  }
  destroySeries(series) {
    series == null ? void 0 : series.forEach((series2) => {
      series2.destroy();
      if (series2.rootGroup != null) {
        this.seriesRoot.removeChild(series2.rootGroup);
      }
      series2.chart = void 0;
    });
  }
  assignSeriesToAxes() {
    this.axes.forEach((axis) => {
      axis.boundSeries = this.series.filter((s) => {
        const seriesAxis = s.axes[axis.direction];
        return seriesAxis === axis;
      });
    });
  }
  assignAxesToSeries() {
    const directionToAxesMap = {};
    this.axes.forEach((axis) => {
      var _a2;
      const direction = axis.direction;
      const directionAxes = (_a2 = directionToAxesMap[direction]) != null ? _a2 : directionToAxesMap[direction] = [];
      directionAxes.push(axis);
    });
    this.series.forEach((series) => {
      series.directions.forEach((direction) => {
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          Logger$1.warnOnce(
            `no available axis for direction [${direction}]; check series and axes configuration.`
          );
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = this.findMatchingAxis(directionAxes, seriesKeys);
        if (!newAxis) {
          Logger$1.warnOnce(
            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
          );
          return;
        }
        series.axes[direction] = newAxis;
      });
    });
  }
  findMatchingAxis(directionAxes, directionKeys) {
    for (const axis of directionAxes) {
      if (!axis.keys.length) {
        return axis;
      }
      if (!directionKeys) {
        continue;
      }
      for (const directionKey of directionKeys) {
        if (axis.keys.includes(directionKey)) {
          return axis;
        }
      }
    }
  }
  updateData(opts) {
    return __async$1(this, null, function* () {
      this.series.forEach((s) => s.setChartData(opts.data));
    });
  }
  processData(opts) {
    return __async$1(this, null, function* () {
      if (this.series.some((s) => s.canHaveAxes)) {
        this.assignAxesToSeries();
        this.assignSeriesToAxes();
      }
      const seriesPromises = this.series.map((s) => s.processData(opts.dataController));
      yield Promise.all(seriesPromises);
    });
  }
  computeAxisPadding() {
    const padding = new Padding$1();
    this.axes.forEach((axis) => {
      var _a2;
      const { position, thickness = 0, line, label } = axis;
      if (position == null)
        return;
      let size;
      if (thickness > 0) {
        size = thickness;
      } else {
        size = (line.enabled ? line.width : 0) + (label.enabled ? ((_a2 = label.fontSize) != null ? _a2 : 0) * Text4.defaultLineHeightRatio + label.padding : 0);
      }
      padding[position] = Math.ceil(size);
    });
    return padding;
  }
  layout(width, height) {
    return __async$1(this, null, function* () {
      const { padding } = this;
      const animated = this.seriesRect != null;
      const seriesRect = new BBox4(0, 0, width, height - (padding.top + padding.bottom));
      this.seriesRect = seriesRect;
      this.seriesRoot.translationY = padding.top;
      this.seriesRoot.setClipRectInGroupCoordinateSpace(
        this.seriesRoot.inverseTransformBBox(new BBox4(0, -padding.top, width, height))
      );
      const axisLeftRightRange = (axis) => {
        if (axis instanceof CategoryAxis$1 || axis instanceof GroupedCategoryAxis$1) {
          return [0, seriesRect.height];
        }
        return [seriesRect.height, 0];
      };
      this.axes.forEach((axis) => {
        const { position = "left" } = axis;
        switch (position) {
          case "top":
          case "bottom":
            axis.range = [0, seriesRect.width];
            axis.gridLength = seriesRect.height;
            break;
          case "right":
          case "left":
            axis.range = axisLeftRightRange(axis);
            axis.gridLength = seriesRect.width;
            break;
        }
        switch (position) {
          case "top":
          case "left":
            axis.translation.x = 0;
            axis.translation.y = 0;
            break;
          case "bottom":
            axis.translation.x = 0;
            axis.translation.y = height;
            break;
          case "right":
            axis.translation.x = width;
            axis.translation.y = 0;
            break;
        }
        axis.gridPadding = 0;
        axis.calculateLayout();
        axis.updatePosition({ rotation: toRadians4(axis.rotation), sideFlag: axis.label.getSideFlag() });
        axis.update(void 0, animated);
      });
      yield Promise.all(this.series.map((series) => series.update({ seriesRect })));
    });
  }
};
__decorateClass$1([
  Validate17(BOOLEAN9)
], MiniChart.prototype, "enabled", 2);
__decorateClass$1([
  ActionOnSet5({
    changeValue(newValue, oldValue = []) {
      for (const axis of oldValue) {
        if (newValue.includes(axis))
          continue;
        axis.detachAxis(this.axisGroup, this.axisGridGroup);
        axis.destroy();
      }
      for (const axis of newValue) {
        if (oldValue == null ? void 0 : oldValue.includes(axis))
          continue;
        axis.attachAxis(this.axisGroup, this.axisGridGroup);
      }
    }
  })
], MiniChart.prototype, "axes", 2);
__decorateClass$1([
  ActionOnSet5({
    changeValue(newValue, oldValue) {
      this.onSeriesChange(newValue, oldValue);
    }
  })
], MiniChart.prototype, "series", 2);

// packages/ag-charts-enterprise/src/features/navigator/navigator.ts
var { ObserveChanges: ObserveChanges2 } = module_support_exports;
var _Navigator = class _Navigator extends module_support_exports.Navigator {
  constructor() {
    super(...arguments);
    this.miniChart = new MiniChart();
  }
  updateData(opts) {
    return __async$1(this, null, function* () {
      yield this.miniChart.updateData(opts);
    });
  }
  processData(opts) {
    return __async$1(this, null, function* () {
      yield this.miniChart.processData(opts);
    });
  }
  performLayout(opts) {
    return __async$1(this, null, function* () {
      const { shrinkRect } = yield __superGet$1(_Navigator.prototype, this, "performLayout").call(this, opts);
      if (this.enabled) {
        const { top, bottom } = this.miniChart.computeAxisPadding();
        shrinkRect.shrink(top + bottom, "bottom");
        this.y -= bottom;
      }
      return { shrinkRect };
    });
  }
  performCartesianLayout(opts) {
    return __async$1(this, null, function* () {
      yield __superGet$1(_Navigator.prototype, this, "performCartesianLayout").call(this, opts);
      yield this.miniChart.layout(this.width, this.height);
    });
  }
};
__decorateClass$1([
  ObserveChanges2((target, value, oldValue) => {
    if (oldValue != null) {
      target.rs.background.removeChild(oldValue.root);
    }
    if (value != null) {
      target.rs.background.appendChild(value.root);
    }
  })
], _Navigator.prototype, "miniChart", 2);
var Navigator$1 = _Navigator;

// packages/ag-charts-enterprise/src/features/navigator/navigatorModule.ts
var _a;
var NavigatorModule$1 = {
  type: "root",
  optionsKey: "navigator",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  instanceConstructor: Navigator$1,
  themeTemplate: __spreadProps$1(__spreadValues$1({}, module_support_exports.NavigatorModule.themeTemplate), {
    navigator: __spreadProps$1(__spreadValues$1({}, (_a = module_support_exports.NavigatorModule.themeTemplate) == null ? void 0 : _a.navigator), {
      miniChart: {
        enabled: false,
        label: {
          color: integrated_charts_theme_exports.DEFAULT_LABEL_COLOUR,
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 10,
          fontFamily: integrated_charts_theme_exports.DEFAULT_FONT_FAMILY,
          formatter: void 0,
          padding: 0
        },
        padding: {
          top: 0,
          bottom: 0
        }
      }
    })
  })
};
var {
  BOOLEAN: BOOLEAN10,
  STRING: STRING4,
  UNION: UNION3,
  BaseProperties: BaseProperties4,
  CartesianAxis: CartesianAxis$1,
  ChartUpdateType: ChartUpdateType$1,
  isDate: isDate$1,
  isFiniteNumber: isFiniteNumber$1,
  ObserveChanges: ObserveChanges3,
  Validate: Validate18
} = module_support_exports;
var { Logger: Logger2 } = sparklines_util_exports;
var ChartSync = class extends BaseProperties4 {
  constructor(moduleContext) {
    super();
    this.moduleContext = moduleContext;
    this.enabled = false;
    this.axes = "x";
    this.nodeInteraction = true;
    this.zoom = true;
  }
  updateChart(chart, updateType = ChartUpdateType$1.UPDATE_DATA) {
    chart.updateService.update(updateType, { skipSync: true });
  }
  updateSiblings(groupId) {
    const { syncManager } = this.moduleContext;
    for (const chart of syncManager.getGroupSiblings(groupId)) {
      this.updateChart(chart);
    }
  }
  enabledZoomSync() {
    const { syncManager, zoomManager } = this.moduleContext;
    this.disableZoomSync = zoomManager.addListener("zoom-change", () => {
      var _a2;
      for (const chart of syncManager.getGroupSiblings(this.groupId)) {
        if ((_a2 = chart.modules.get("sync")) == null ? void 0 : _a2.zoom) {
          chart.zoomManager.updateZoom(this.mergeZoom(chart));
        }
      }
    });
  }
  enabledNodeInteractionSync() {
    const { highlightManager, syncManager } = this.moduleContext;
    this.disableNodeInteractionSync = highlightManager.addListener("highlight-change", (event) => {
      var _a2, _b;
      for (const chart of syncManager.getGroupSiblings(this.groupId)) {
        if (!((_a2 = chart.modules.get("sync")) == null ? void 0 : _a2.nodeInteraction))
          continue;
        if (!((_b = event.currentHighlight) == null ? void 0 : _b.datum)) {
          chart.highlightManager.updateHighlight(chart.id);
          continue;
        }
        for (const axis of chart.axes) {
          const validDirection = this.axes === "xy" ? "x" : this.axes;
          if (!CartesianAxis$1.is(axis) || axis.direction !== validDirection)
            continue;
          const matchingNodes = chart.series.map((series) => {
            const seriesKeys = series.getKeys(axis.direction);
            if (axis.keys.length && !axis.keys.some((key) => seriesKeys.includes(key)))
              return;
            const [{ nodeData }] = series.contextNodeData;
            if (!(nodeData == null ? void 0 : nodeData.length))
              return;
            const valueKey = nodeData[0][`${axis.direction}Key`];
            let eventValue = event.currentHighlight.datum[valueKey];
            const valueIsDate = isDate$1(eventValue);
            if (valueIsDate) {
              eventValue = eventValue.getTime();
            }
            return nodeData.find((nodeDatum) => {
              const nodeValue = nodeDatum.datum[valueKey];
              return valueIsDate ? nodeValue.getTime() === eventValue : nodeValue === eventValue;
            });
          }).filter(Boolean);
          if (matchingNodes.length < 2 && matchingNodes[0] !== chart.highlightManager.getActiveHighlight()) {
            chart.highlightManager.updateHighlight(chart.id, matchingNodes[0]);
            this.updateChart(chart, ChartUpdateType$1.SERIES_UPDATE);
          }
        }
      }
    });
  }
  syncAxes(stopPropagation = false) {
    const { syncManager } = this.moduleContext;
    const chart = syncManager.getChart();
    const syncSeries = syncManager.getGroup(this.groupId).flatMap((chart2) => chart2.series);
    const syncAxes = syncManager.getGroupSiblings(this.groupId).flatMap((chart2) => chart2.axes);
    chart.axes.forEach((axis) => {
      if (!CartesianAxis$1.is(axis) || this.axes !== "xy" && this.axes !== axis.direction)
        return;
      const { direction, min, max, nice, reverse } = axis;
      for (const siblingAxis of syncAxes) {
        if (direction !== siblingAxis.direction)
          continue;
        if (nice !== siblingAxis.nice || reverse !== siblingAxis.reverse || min !== siblingAxis.min && (isFiniteNumber$1(min) || isFiniteNumber$1(siblingAxis.min)) || max !== siblingAxis.max && (isFiniteNumber$1(max) || isFiniteNumber$1(siblingAxis.max))) {
          Logger2.warnOnce("For axes sync, ensure matching `min`, `max`, `nice`, and `reverse` properties.");
          return;
        }
      }
      axis.boundSeries = syncSeries.filter((series) => {
        const seriesKeys = series.getKeys(axis.direction);
        return axis.keys.length ? axis.keys.some((key) => seriesKeys.includes(key)) : true;
      });
    });
    if (!stopPropagation) {
      setTimeout(() => this.updateSiblings(this.groupId));
    }
  }
  mergeZoom(chart) {
    var _a2, _b;
    const { zoomManager } = this.moduleContext;
    if (this.axes === "xy") {
      return zoomManager.getZoom();
    }
    const combinedZoom = (_a2 = chart.zoomManager.getZoom()) != null ? _a2 : {};
    combinedZoom[this.axes] = (_b = zoomManager.getZoom()) == null ? void 0 : _b[this.axes];
    return combinedZoom;
  }
  onEnabledChange() {
    const { syncManager } = this.moduleContext;
    if (this.enabled) {
      syncManager.subscribe(this.groupId);
    } else {
      syncManager.unsubscribe(this.groupId);
    }
    this.updateSiblings(this.groupId);
    this.onNodeInteractionChange();
    this.onZoomChange();
  }
  onGroupIdChange(newValue, oldValue) {
    if (!this.enabled || newValue === oldValue)
      return;
    const { syncManager } = this.moduleContext;
    syncManager.unsubscribe(oldValue);
    syncManager.subscribe(newValue);
    this.updateSiblings(oldValue);
    this.updateSiblings(newValue);
  }
  onAxesChange() {
    if (!this.enabled)
      return;
    const { syncManager } = this.moduleContext;
    this.updateChart(syncManager.getChart());
  }
  onNodeInteractionChange() {
    var _a2;
    if (this.enabled && this.nodeInteraction) {
      this.enabledNodeInteractionSync();
    } else {
      (_a2 = this.disableNodeInteractionSync) == null ? void 0 : _a2.call(this);
    }
  }
  onZoomChange() {
    var _a2;
    if (this.enabled && this.zoom) {
      this.enabledZoomSync();
    } else {
      (_a2 = this.disableZoomSync) == null ? void 0 : _a2.call(this);
    }
  }
  destroy() {
    var _a2;
    const { syncManager } = this.moduleContext;
    syncManager.unsubscribe(this.groupId);
    this.updateSiblings(this.groupId);
    (_a2 = this.disableZoomSync) == null ? void 0 : _a2.call(this);
  }
};
ChartSync.className = "Sync";
__decorateClass$1([
  Validate18(BOOLEAN10),
  ObserveChanges3((target) => target.onEnabledChange())
], ChartSync.prototype, "enabled", 2);
__decorateClass$1([
  Validate18(STRING4, { optional: true }),
  ObserveChanges3((target, newValue, oldValue) => target.onGroupIdChange(newValue, oldValue))
], ChartSync.prototype, "groupId", 2);
__decorateClass$1([
  Validate18(UNION3(["x", "y", "xy"], "an axis")),
  ObserveChanges3((target) => target.onAxesChange())
], ChartSync.prototype, "axes", 2);
__decorateClass$1([
  Validate18(BOOLEAN10),
  ObserveChanges3((target) => target.onNodeInteractionChange())
], ChartSync.prototype, "nodeInteraction", 2);
__decorateClass$1([
  Validate18(BOOLEAN10),
  ObserveChanges3((target) => target.onZoomChange())
], ChartSync.prototype, "zoom", 2);

// packages/ag-charts-enterprise/src/features/sync/syncModule.ts
var SyncModule = {
  type: "root",
  optionsKey: "sync",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  instanceConstructor: ChartSync,
  themeTemplate: {
    sync: { enabled: false }
  }
};
var { COLOR_STRING: COLOR_STRING4, RATIO: RATIO7, Validate: Validate19 } = module_support_exports;
var ZoomRect = class extends integrated_charts_scene_exports.Rect {
  constructor() {
    super(...arguments);
    this.fill = "rgb(33, 150, 243)";
    this.fillOpacity = 0.2;
  }
};
ZoomRect.className = "ZoomRect";
__decorateClass$1([
  Validate19(COLOR_STRING4)
], ZoomRect.prototype, "fill", 2);
__decorateClass$1([
  Validate19(RATIO7)
], ZoomRect.prototype, "fillOpacity", 2);
var { clamp: clamp$1 } = module_support_exports;
var UNIT = { min: 0, max: 1 };
var constrain = (value, min = UNIT.min, max = UNIT.max) => clamp$1(min, value, max);
function unitZoomState() {
  return { x: __spreadValues$1({}, UNIT), y: __spreadValues$1({}, UNIT) };
}
function definedZoomState(zoom) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  return {
    x: { min: (_b = (_a2 = zoom == null ? void 0 : zoom.x) == null ? void 0 : _a2.min) != null ? _b : UNIT.min, max: (_d = (_c = zoom == null ? void 0 : zoom.x) == null ? void 0 : _c.max) != null ? _d : UNIT.max },
    y: { min: (_f = (_e = zoom == null ? void 0 : zoom.y) == null ? void 0 : _e.min) != null ? _f : UNIT.min, max: (_h = (_g = zoom == null ? void 0 : zoom.y) == null ? void 0 : _g.max) != null ? _h : UNIT.max }
  };
}
function pointToRatio(bbox, x, y) {
  if (!bbox)
    return { x: 0, y: 0 };
  const constrainedX = constrain(x - bbox.x, 0, bbox.x + bbox.width);
  const constrainedY = constrain(y - bbox.y, 0, bbox.y + bbox.height);
  const rx = 1 / bbox.width * constrainedX;
  const ry = 1 - 1 / bbox.height * constrainedY;
  return { x: constrain(rx), y: constrain(ry) };
}
function translateZoom(zoom, x, y) {
  return {
    x: { min: zoom.x.min + x, max: zoom.x.max + x },
    y: { min: zoom.y.min + y, max: zoom.y.max + y }
  };
}
function scaleZoom(zoom, sx, sy) {
  const dx = zoom.x.max - zoom.x.min;
  const dy = zoom.y.max - zoom.y.min;
  return {
    x: { min: zoom.x.min, max: zoom.x.min + dx * sx },
    y: { min: zoom.y.min, max: zoom.y.min + dy * sy }
  };
}
function scaleZoomCenter(zoom, sx, sy) {
  const dx = zoom.x.max - zoom.x.min;
  const dy = zoom.y.max - zoom.y.min;
  const cx = zoom.x.min + dx / 2;
  const cy = zoom.y.min + dy / 2;
  return {
    x: { min: cx - dx * sx / 2, max: cx + dx * sx / 2 },
    y: { min: cy - dy * sy / 2, max: cy + dy * sy / 2 }
  };
}
function scaleZoomAxisWithAnchor(newState, oldState, anchor, origin) {
  const { min, max } = oldState;
  const center = min + (max - min) / 2;
  const diff7 = newState.max - newState.min;
  switch (anchor) {
    case "start":
      return { min, max: oldState.min + diff7 };
    case "end":
      return { min: oldState.max - diff7, max };
    case "middle":
      return { min: center - diff7 / 2, max: center + diff7 / 2 };
    case "pointer":
      return scaleZoomAxisWithPoint(newState, oldState, origin != null ? origin : center);
    default:
      return { min, max };
  }
}
function scaleZoomAxisWithPoint(newState, oldState, origin) {
  const scaledOrigin = origin * (1 - (oldState.max - oldState.min - (newState.max - newState.min)));
  const translation = origin - scaledOrigin;
  const min = newState.min + translation;
  const max = newState.max + translation;
  return { min, max };
}
function multiplyZoom(zoom, nx, ny) {
  return {
    x: { min: zoom.x.min * nx, max: zoom.x.max * nx },
    y: { min: zoom.y.min * ny, max: zoom.y.max * ny }
  };
}
function constrainZoom(zoom) {
  const after = unitZoomState();
  after.x = constrainAxis(zoom.x);
  after.y = constrainAxis(zoom.y);
  return after;
}
function constrainAxis(axis) {
  const size = axis.max - axis.min;
  let min = axis.max > UNIT.max ? UNIT.max - size : axis.min;
  let max = axis.min < UNIT.min ? size : axis.max;
  min = Math.max(UNIT.min, min);
  max = Math.min(UNIT.max, max);
  return { min, max };
}

// packages/ag-charts-enterprise/src/features/zoom/zoomAxisDragger.ts
var ZoomAxisDragger = class {
  constructor() {
    this.isAxisDragging = false;
  }
  update(event, direction, anchor, bbox, zoom, axisZoom) {
    var _a2;
    this.isAxisDragging = true;
    (_a2 = this.oldZoom) != null ? _a2 : this.oldZoom = definedZoomState(
      direction === module_support_exports.ChartAxisDirection.X ? __spreadProps$1(__spreadValues$1({}, zoom), { x: axisZoom }) : __spreadProps$1(__spreadValues$1({}, zoom), { y: axisZoom })
    );
    this.updateCoords(event.offsetX, event.offsetY);
    return this.updateZoom(direction, anchor, bbox);
  }
  stop() {
    this.isAxisDragging = false;
    this.coords = void 0;
    this.oldZoom = void 0;
  }
  updateCoords(x, y) {
    if (!this.coords) {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
    } else {
      this.coords.x2 = x;
      this.coords.y2 = y;
    }
  }
  updateZoom(direction, anchor, bbox) {
    const { coords, oldZoom } = this;
    let newZoom = definedZoomState(oldZoom);
    if (!coords || !oldZoom) {
      if (direction === module_support_exports.ChartAxisDirection.X)
        return newZoom.x;
      return newZoom.y;
    }
    const origin = pointToRatio(bbox, coords.x1, coords.y1);
    const target = pointToRatio(bbox, coords.x2, coords.y2);
    if (direction === module_support_exports.ChartAxisDirection.X) {
      const scaleX = (target.x - origin.x) * (oldZoom.x.max - oldZoom.x.min);
      newZoom.x.max += scaleX;
      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchor, origin.x);
      newZoom = constrainZoom(newZoom);
      return newZoom.x;
    }
    const scaleY = (target.y - origin.y) * (oldZoom.y.max - oldZoom.y.min);
    newZoom.y.max -= scaleY;
    newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchor, origin.y);
    newZoom = constrainZoom(newZoom);
    return newZoom.y;
  }
};
var ZoomPanner = class {
  constructor() {
    this.isPanning = false;
    // Horizontal scrolling however does not have a 'start' and 'stop' event, it simply pans
    // by a fixed deltaX value whenever an event is fired.
    this.hscrollCoords = { x1: 0, x2: 0, y1: 0, y2: 0 };
  }
  updateDrag(event, bbox, zooms) {
    this.isPanning = true;
    const { offsetX: x, offsetY: y } = event;
    if (!this.dragCoords) {
      this.dragCoords = { x1: x, y1: y, x2: x, y2: y };
    } else {
      this.dragCoords.x1 = this.dragCoords.x2;
      this.dragCoords.y1 = this.dragCoords.y2;
      this.dragCoords.x2 = x;
      this.dragCoords.y2 = y;
    }
    return this.translateZooms(bbox, zooms, this.dragCoords);
  }
  updateHScroll(deltaX, bbox, zooms) {
    this.isPanning = true;
    this.hscrollCoords.x1 = deltaX * 5;
    return this.translateZooms(bbox, zooms, this.hscrollCoords);
  }
  stop() {
    this.isPanning = false;
    this.dragCoords = void 0;
  }
  translateZooms(bbox, currentZooms, coords) {
    const { x1, y1, x2, y2 } = coords;
    const dx = x1 <= x2 ? x2 - x1 : x1 - x2;
    const dy = y1 <= y2 ? y2 - y1 : y1 - y2;
    const offset = pointToRatio(bbox, bbox.x + dx, bbox.y + bbox.height - dy);
    const offsetX = x1 <= x2 ? -offset.x : offset.x;
    const offsetY = y1 <= y2 ? offset.y : -offset.y;
    const newZooms = {};
    for (const [axisId, { direction, zoom: currentZoom }] of Object.entries(currentZooms)) {
      let zoom;
      if (direction === module_support_exports.ChartAxisDirection.X) {
        zoom = definedZoomState({ x: currentZoom });
      } else {
        zoom = definedZoomState({ y: currentZoom });
      }
      const scaleX = zoom.x.max - zoom.x.min;
      const scaleY = zoom.y.max - zoom.y.min;
      zoom = constrainZoom(translateZoom(zoom, offsetX * scaleX, offsetY * scaleY));
      if (direction === module_support_exports.ChartAxisDirection.X) {
        newZooms[axisId] = { direction, zoom: zoom.x };
      } else {
        newZooms[axisId] = { direction, zoom: zoom.y };
      }
    }
    return newZooms;
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoomScroller.ts
var ZoomScroller = class {
  update(event, step, anchorPointX, anchorPointY, isScalingX, isScalingY, bbox, currentZoom) {
    const oldZoom = definedZoomState(currentZoom);
    const sourceEvent = event.sourceEvent;
    const dir = event.deltaY;
    let newZoom = definedZoomState(oldZoom);
    newZoom.x.max += isScalingX ? step * dir * (oldZoom.x.max - oldZoom.x.min) : 0;
    newZoom.y.max += isScalingY ? step * dir * (oldZoom.y.max - oldZoom.y.min) : 0;
    if (anchorPointX === "pointer" && isScalingX || anchorPointY === "pointer" && isScalingY) {
      newZoom = this.scaleZoomToPointer(sourceEvent, isScalingX, isScalingY, bbox, oldZoom, newZoom);
    } else {
      if (isScalingX) {
        newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchorPointX);
      }
      if (isScalingY) {
        newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchorPointY);
      }
    }
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
  scaleZoomToPointer(sourceEvent, isScalingX, isScalingY, bbox, oldZoom, newZoom) {
    var _a2, _b;
    const origin = pointToRatio(
      bbox,
      (_a2 = sourceEvent.offsetX) != null ? _a2 : sourceEvent.clientX,
      (_b = sourceEvent.offsetY) != null ? _b : sourceEvent.clientY
    );
    newZoom.x = isScalingX ? scaleZoomAxisWithPoint(newZoom.x, oldZoom.x, origin.x) : newZoom.x;
    newZoom.y = isScalingY ? scaleZoomAxisWithPoint(newZoom.y, oldZoom.y, origin.y) : newZoom.y;
    return newZoom;
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoomSelector.ts
var ZoomSelector = class {
  constructor(rect) {
    this.rect = rect;
    this.rect.visible = false;
  }
  update(event, minRatioX, minRatioY, isScalingX, isScalingY, bbox, currentZoom) {
    this.rect.visible = true;
    this.updateCoords(
      event.offsetX,
      event.offsetY,
      minRatioX,
      minRatioY,
      isScalingX,
      isScalingY,
      bbox,
      currentZoom
    );
    this.updateRect(bbox);
  }
  stop(innerBBox, bbox, currentZoom) {
    let zoom = definedZoomState();
    if (!innerBBox || !bbox)
      return zoom;
    if (this.coords) {
      zoom = this.createZoomFromCoords(bbox, currentZoom);
    }
    const multiplyX = bbox.width / innerBBox.width;
    const multiplyY = bbox.height / innerBBox.height;
    zoom = constrainZoom(multiplyZoom(zoom, multiplyX, multiplyY));
    this.reset();
    return zoom;
  }
  reset() {
    this.coords = void 0;
    this.rect.visible = false;
  }
  updateCoords(x, y, minRatioX, minRatioY, isScalingX, isScalingY, bbox, currentZoom) {
    if (!this.coords) {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
      return;
    }
    this.coords.x2 = x;
    this.coords.y2 = y;
    if (!bbox)
      return;
    const zoom = definedZoomState(currentZoom);
    const normal = this.getNormalisedDimensions();
    const aspectRatio = bbox.width / bbox.height;
    const scaleX = zoom.x.max - zoom.x.min;
    const scaleY = zoom.y.max - zoom.y.min;
    const xRatio = minRatioX / scaleX;
    const yRatio = minRatioY / scaleY;
    if (normal.width / bbox.width < xRatio) {
      if (this.coords.x2 < this.coords.x1) {
        this.coords.x2 = this.coords.x1 - bbox.width * xRatio;
      } else {
        this.coords.x2 = this.coords.x1 + bbox.width * xRatio;
      }
    }
    if (isScalingY && !isScalingX) {
      if (normal.height / bbox.height < yRatio) {
        if (this.coords.y2 < this.coords.y1) {
          this.coords.y2 = this.coords.y1 - bbox.width * xRatio;
        } else {
          this.coords.y2 = this.coords.y1 + bbox.height * yRatio;
        }
      }
    } else if (this.coords.y2 < this.coords.y1) {
      this.coords.y2 = Math.min(
        this.coords.y1 - normal.width / aspectRatio,
        this.coords.y1 - bbox.height * yRatio
      );
    } else {
      this.coords.y2 = Math.max(
        this.coords.y1 + normal.width / aspectRatio,
        this.coords.y1 + bbox.height * yRatio
      );
    }
    if (!isScalingX) {
      this.coords.x1 = bbox.x;
      this.coords.x2 = bbox.x + bbox.width;
    }
    if (!isScalingY) {
      this.coords.y1 = bbox.y;
      this.coords.y2 = bbox.y + bbox.height;
    }
  }
  updateRect(bbox) {
    if (!bbox)
      return;
    const { rect } = this;
    const normal = this.getNormalisedDimensions();
    const { width, height } = normal;
    let { x, y } = normal;
    x = Math.max(x, bbox.x);
    x -= Math.max(0, x + width - (bbox.x + bbox.width));
    y = Math.max(y, bbox.y);
    y -= Math.max(0, y + height - (bbox.y + bbox.height));
    rect.x = x;
    rect.y = y;
    rect.width = width;
    rect.height = height;
  }
  createZoomFromCoords(bbox, currentZoom) {
    const oldZoom = definedZoomState(currentZoom);
    const normal = this.getNormalisedDimensions();
    const origin = pointToRatio(bbox, normal.x, normal.y + normal.height);
    const xFactor = normal.width / bbox.width;
    const yFactor = normal.height / bbox.height;
    let newZoom = scaleZoom(oldZoom, xFactor, yFactor);
    const translateX = origin.x * (oldZoom.x.max - oldZoom.x.min);
    const translateY = origin.y * (oldZoom.y.max - oldZoom.y.min);
    newZoom = translateZoom(newZoom, translateX, translateY);
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
  getNormalisedDimensions() {
    var _a2;
    const { x1 = 0, y1 = 0, x2 = 0, y2 = 0 } = (_a2 = this.coords) != null ? _a2 : {};
    const x = x1 <= x2 ? x1 : x2;
    const y = y1 <= y2 ? y1 : y2;
    const width = x1 <= x2 ? x2 - x1 : x1 - x2;
    const height = y1 <= y2 ? y2 - y1 : y1 - y2;
    return { x, y, width, height };
  }
};

// packages/ag-charts-enterprise/src/features/zoom/zoom.ts
var {
  BOOLEAN: BOOLEAN11,
  NUMBER: NUMBER6,
  RATIO: RATIO8,
  UNION: UNION4,
  ActionOnSet: ActionOnSet6,
  ChartAxisDirection: ChartAxisDirection7,
  ChartUpdateType: ChartUpdateType2,
  Validate: Validate20,
  round: sharedRound
} = module_support_exports;
var ANCHOR_CORD = UNION4(["pointer", "start", "middle", "end"], "an anchor cord");
var CONTEXT_ZOOM_ACTION_ID = "zoom-action";
var CONTEXT_PAN_ACTION_ID = "pan-action";
var CURSOR_ID = "zoom-cursor";
var TOOLTIP_ID = "zoom-tooltip";
var DECIMALS = 3;
var round$1 = (value) => sharedRound(value, DECIMALS);
var Zoom = class extends module_support_exports.BaseModuleInstance {
  constructor(ctx) {
    var _a2;
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.enableAxisDragging = true;
    this.enableDoubleClickToReset = true;
    this.enablePanning = true;
    this.enableScrolling = true;
    this.enableSelecting = false;
    this.panKey = "alt";
    this.axes = "x";
    this.scrollingStep = (UNIT.max - UNIT.min) / 10;
    this.minVisibleItemsX = 2;
    this.minVisibleItemsY = 2;
    this.anchorPointX = "end";
    this.anchorPointY = "middle";
    // Zoom methods
    this.axisDragger = new ZoomAxisDragger();
    this.panner = new ZoomPanner();
    this.scroller = new ZoomScroller();
    // State
    this.isDragging = false;
    this.minRatioX = 0;
    this.minRatioY = 0;
    // TODO: This will become an option soon, and I don't want to delete my code in the meantime
    this.enableSecondaryAxis = false;
    this.scene = ctx.scene;
    this.cursorManager = ctx.cursorManager;
    this.highlightManager = ctx.highlightManager;
    this.tooltipManager = ctx.tooltipManager;
    this.zoomManager = ctx.zoomManager;
    this.dataService = ctx.dataService;
    this.updateService = ctx.updateService;
    this.contextMenuRegistry = ctx.contextMenuRegistry;
    const { Default: Default5, ZoomDrag, Animation: Animation2 } = module_support_exports.InteractionState;
    const draggableState = Default5 | Animation2 | ZoomDrag;
    const clickableState = Default5 | Animation2;
    this.destroyFns.push(
      ctx.interactionManager.addListener("dblclick", (event) => this.onDoubleClick(event), clickableState),
      ctx.interactionManager.addListener("drag", (event) => this.onDrag(event), draggableState),
      ctx.interactionManager.addListener("drag-start", (event) => this.onDragStart(event), draggableState),
      ctx.interactionManager.addListener("drag-end", () => this.onDragEnd(), draggableState),
      ctx.interactionManager.addListener("wheel", (event) => this.onWheel(event), clickableState),
      ctx.interactionManager.addListener("hover", () => this.onHover(), clickableState),
      ctx.chartEventManager.addListener("axis-hover", (event) => this.onAxisHover(event)),
      ctx.gestureDetector.addListener("pinch-move", (event) => this.onPinchMove(event)),
      ctx.layoutService.addListener("layout-complete", (event) => this.onLayoutComplete(event)),
      ctx.updateService.addListener("update-complete", (event) => this.onUpdateComplete(event))
    );
    const selectionRect = new ZoomRect();
    this.selector = new ZoomSelector(selectionRect);
    (_a2 = this.scene.root) == null ? void 0 : _a2.appendChild(selectionRect);
    this.destroyFns.push(() => {
      var _a3;
      return (_a3 = this.scene.root) == null ? void 0 : _a3.removeChild(selectionRect);
    });
  }
  registerContextMenuActions() {
    this.contextMenuRegistry.registerDefaultAction({
      id: CONTEXT_ZOOM_ACTION_ID,
      label: "Zoom to here",
      action: (params) => this.onContextMenuZoomToHere(params)
    });
    this.contextMenuRegistry.registerDefaultAction({
      id: CONTEXT_PAN_ACTION_ID,
      label: "Pan to here",
      action: (params) => this.onContextMenuPanToHere(params)
    });
    const zoom = definedZoomState(this.zoomManager.getZoom());
    this.toggleContextMenuActions(zoom);
  }
  toggleContextMenuActions(zoom) {
    if (this.isMinZoom(zoom)) {
      this.contextMenuRegistry.disableAction(CONTEXT_ZOOM_ACTION_ID);
    } else {
      this.contextMenuRegistry.enableAction(CONTEXT_ZOOM_ACTION_ID);
    }
    if (this.isMaxZoom(zoom)) {
      this.contextMenuRegistry.disableAction(CONTEXT_PAN_ACTION_ID);
    } else {
      this.contextMenuRegistry.enableAction(CONTEXT_PAN_ACTION_ID);
    }
  }
  onDoubleClick(event) {
    var _a2;
    if (!this.enabled || !this.enableDoubleClickToReset)
      return;
    if (this.hoveredAxis) {
      const { id, direction } = this.hoveredAxis;
      this.updateAxisZoom(id, direction, __spreadValues$1({}, UNIT));
    } else if (((_a2 = this.paddedRect) == null ? void 0 : _a2.containsPoint(event.offsetX, event.offsetY)) && this.highlightManager.getActivePicked() === void 0) {
      this.updateZoom(unitZoomState());
    }
  }
  onDragStart(event) {
    var _a2;
    this.canDragSelection = (_a2 = this.paddedRect) == null ? void 0 : _a2.containsPoint(event.offsetX, event.offsetY);
  }
  onDrag(event) {
    if (!this.enabled || !this.paddedRect || !this.seriesRect)
      return;
    this.ctx.interactionManager.pushState(module_support_exports.InteractionState.ZoomDrag);
    const sourceEvent = event.sourceEvent;
    const isPrimaryMouseButton = sourceEvent.button === 0;
    if (!isPrimaryMouseButton)
      return;
    this.isDragging = true;
    this.tooltipManager.updateTooltip(TOOLTIP_ID);
    const zoom = definedZoomState(this.zoomManager.getZoom());
    if (this.enableAxisDragging && this.hoveredAxis) {
      const { id: axisId, direction } = this.hoveredAxis;
      const anchor = direction === module_support_exports.ChartAxisDirection.X ? this.anchorPointX : this.anchorPointY;
      const axisZoom = this.zoomManager.getAxisZoom(axisId);
      const newZoom = this.axisDragger.update(event, direction, anchor, this.seriesRect, zoom, axisZoom);
      this.updateAxisZoom(axisId, direction, newZoom);
      return;
    }
    if (!this.paddedRect.containsPoint(event.offsetX, event.offsetY)) {
      return;
    }
    if (this.enablePanning && (!this.enableSelecting || this.isPanningKeyPressed(sourceEvent))) {
      const newZooms = this.panner.updateDrag(event, this.seriesRect, this.zoomManager.getAxisZooms());
      for (const [axisId, { direction, zoom: newZoom }] of Object.entries(newZooms)) {
        this.updateAxisZoom(axisId, direction, newZoom);
      }
      this.cursorManager.updateCursor(CURSOR_ID, "grabbing");
      return;
    }
    if (!this.enableSelecting || !this.canDragSelection || this.isPanningKeyPressed(sourceEvent) || this.panner.isPanning || this.isMinZoom(zoom)) {
      return;
    }
    this.selector.update(
      event,
      this.minRatioX,
      this.minRatioY,
      this.isScalingX(),
      this.isScalingY(),
      this.paddedRect,
      zoom
    );
    this.updateService.update(ChartUpdateType2.PERFORM_LAYOUT, { skipAnimations: true });
  }
  onDragEnd() {
    this.ctx.interactionManager.popState(module_support_exports.InteractionState.ZoomDrag);
    if (!this.enabled || !this.isDragging)
      return;
    const zoom = definedZoomState(this.zoomManager.getZoom());
    this.cursorManager.updateCursor(CURSOR_ID);
    if (this.enableAxisDragging && this.axisDragger.isAxisDragging) {
      this.axisDragger.stop();
    } else if (this.enablePanning && this.panner.isPanning) {
      this.panner.stop();
    } else if (this.enableSelecting && !this.isMinZoom(zoom) && this.canDragSelection) {
      const newZoom = this.selector.stop(this.seriesRect, this.paddedRect, zoom);
      this.updateZoom(newZoom);
    }
    this.isDragging = false;
    this.tooltipManager.removeTooltip(TOOLTIP_ID);
  }
  onWheel(event) {
    if (!this.enabled || !this.enableScrolling || !this.paddedRect || !this.seriesRect)
      return;
    const currentZoom = this.zoomManager.getZoom();
    const isSeriesScrolling = this.paddedRect.containsPoint(event.offsetX, event.offsetY);
    const isAxisScrolling = this.enableAxisDragging && this.hoveredAxis != null;
    let isScalingX = this.isScalingX();
    let isScalingY = this.isScalingY();
    if (isAxisScrolling) {
      isScalingX = this.hoveredAxis.direction === module_support_exports.ChartAxisDirection.X;
      isScalingY = !isScalingX;
    }
    const sourceEvent = event.sourceEvent;
    const { deltaX, deltaY } = sourceEvent;
    if (this.enablePanning && deltaX !== void 0 && deltaY !== void 0 && Math.abs(deltaX) > Math.abs(deltaY)) {
      event.consume();
      event.sourceEvent.preventDefault();
      const newZooms = this.panner.updateHScroll(event.deltaX, this.seriesRect, this.zoomManager.getAxisZooms());
      for (const [axisId, { direction, zoom: newZoom }] of Object.entries(newZooms)) {
        this.updateAxisZoom(axisId, direction, newZoom);
      }
      return;
    }
    if (isSeriesScrolling || isAxisScrolling) {
      event.consume();
      event.sourceEvent.preventDefault();
      const newZoom = this.scroller.update(
        event,
        this.scrollingStep,
        this.getAnchorPointX(),
        this.getAnchorPointY(),
        isScalingX,
        isScalingY,
        this.seriesRect,
        currentZoom
      );
      this.updateZoom(newZoom);
    }
  }
  onHover() {
    if (!this.enabled)
      return;
    this.hoveredAxis = void 0;
    this.cursorManager.updateCursor(CURSOR_ID);
  }
  onAxisHover(event) {
    if (!this.enabled)
      return;
    this.hoveredAxis = {
      id: event.axisId,
      direction: event.direction
    };
    if (this.enableAxisDragging) {
      this.cursorManager.updateCursor(
        CURSOR_ID,
        event.direction === ChartAxisDirection7.X ? "ew-resize" : "ns-resize"
      );
    }
  }
  onPinchMove(event) {
    if (!this.enabled || !this.enableScrolling || !this.paddedRect || !this.seriesRect)
      return;
    const currentZoom = this.zoomManager.getZoom();
    const oldZoom = definedZoomState(currentZoom);
    const newZoom = definedZoomState(currentZoom);
    const delta = event.deltaDistance * -0.01;
    const origin = pointToRatio(this.seriesRect, event.origin.x, event.origin.y);
    if (this.isScalingX()) {
      newZoom.x.max += delta * (oldZoom.x.max - oldZoom.x.min);
      newZoom.x = scaleZoomAxisWithPoint(newZoom.x, oldZoom.x, origin.x);
    }
    if (this.isScalingY()) {
      newZoom.y.max += delta * (oldZoom.y.max - oldZoom.y.min);
      newZoom.y = scaleZoomAxisWithPoint(newZoom.y, oldZoom.y, origin.y);
    }
    this.updateZoom(constrainZoom(newZoom));
  }
  onLayoutComplete(event) {
    if (!this.enabled)
      return;
    const {
      series: { rect, paddedRect, shouldFlipXY }
    } = event;
    this.seriesRect = rect;
    this.paddedRect = paddedRect;
    this.shouldFlipXY = shouldFlipXY;
  }
  onUpdateComplete({ minRect }) {
    if (!this.enabled || !this.paddedRect || !minRect)
      return;
    if (this.dataService.isLazy()) {
      this.minRatioX = 0;
      this.minRatioY = 0;
      return;
    }
    const zoom = definedZoomState(this.zoomManager.getZoom());
    const minVisibleItemsWidth = this.shouldFlipXY ? this.minVisibleItemsY : this.minVisibleItemsX;
    const minVisibleItemsHeight = this.shouldFlipXY ? this.minVisibleItemsX : this.minVisibleItemsY;
    const widthRatio = minRect.width * minVisibleItemsWidth / this.paddedRect.width;
    const heightRatio = minRect.height * minVisibleItemsHeight / this.paddedRect.height;
    const ratioX = widthRatio * (zoom.x.max - zoom.x.min);
    const ratioY = heightRatio * (zoom.y.max - zoom.y.min);
    if (this.isScalingX()) {
      this.minRatioX = Math.min(1, round$1(ratioX));
    }
    if (this.isScalingY()) {
      this.minRatioY = Math.min(1, round$1(ratioY));
    }
    this.minRatioX || (this.minRatioX = this.minRatioY || 0);
    this.minRatioY || (this.minRatioY = this.minRatioX || 0);
  }
  onContextMenuZoomToHere({ event }) {
    if (!this.enabled || !this.paddedRect || !event || !event.target)
      return;
    const zoom = definedZoomState(this.zoomManager.getZoom());
    const origin = pointToRatio(this.paddedRect, event.clientX, event.clientY);
    const scaledOriginX = origin.x * (zoom.x.max - zoom.x.min);
    const scaledOriginY = origin.y * (zoom.y.max - zoom.y.min);
    const size = UNIT.max - UNIT.min;
    const halfSize = size / 2;
    let newZoom = {
      x: { min: origin.x - halfSize, max: origin.x + halfSize },
      y: { min: origin.y - halfSize, max: origin.y + halfSize }
    };
    newZoom = scaleZoomCenter(
      newZoom,
      this.isScalingX() ? this.minRatioX : size,
      this.isScalingY() ? this.minRatioY : size
    );
    newZoom = translateZoom(newZoom, zoom.x.min - origin.x + scaledOriginX, zoom.y.min - origin.y + scaledOriginY);
    this.updateZoom(constrainZoom(newZoom));
  }
  onContextMenuPanToHere({ event }) {
    if (!this.enabled || !this.paddedRect || !event || !event.target)
      return;
    const zoom = definedZoomState(this.zoomManager.getZoom());
    const origin = pointToRatio(this.paddedRect, event.clientX, event.clientY);
    const scaleX = zoom.x.max - zoom.x.min;
    const scaleY = zoom.y.max - zoom.y.min;
    const scaledOriginX = origin.x * scaleX;
    const scaledOriginY = origin.y * scaleY;
    const halfSize = (UNIT.max - UNIT.min) / 2;
    let newZoom = {
      x: { min: origin.x - halfSize, max: origin.x + halfSize },
      y: { min: origin.y - halfSize, max: origin.y + halfSize }
    };
    newZoom = scaleZoomCenter(newZoom, scaleX, scaleY);
    newZoom = translateZoom(newZoom, zoom.x.min - origin.x + scaledOriginX, zoom.y.min - origin.y + scaledOriginY);
    this.updateZoom(constrainZoom(newZoom));
  }
  isPanningKeyPressed(event) {
    switch (this.panKey) {
      case "alt":
        return event.altKey;
      case "ctrl":
        return event.ctrlKey;
      case "shift":
        return event.shiftKey;
      case "meta":
        return event.metaKey;
    }
  }
  isScalingX() {
    if (this.axes === "xy")
      return true;
    return this.shouldFlipXY ? this.axes === "y" : this.axes === "x";
  }
  isScalingY() {
    if (this.axes === "xy")
      return true;
    return this.shouldFlipXY ? this.axes === "x" : this.axes === "y";
  }
  getAnchorPointX() {
    return this.shouldFlipXY ? this.anchorPointY : this.anchorPointX;
  }
  getAnchorPointY() {
    return this.shouldFlipXY ? this.anchorPointX : this.anchorPointY;
  }
  isMinZoom(zoom) {
    const minXCheckValue = this.enableScrolling ? (zoom.x.max - zoom.x.min) * (1 - this.scrollingStep) : round$1(zoom.x.max - zoom.x.min);
    const minYCheckValue = this.enableScrolling ? (zoom.y.max - zoom.y.min) * (1 - this.scrollingStep) : round$1(zoom.y.max - zoom.y.min);
    const isMinXZoom = !this.isScalingX() || minXCheckValue <= this.minRatioX;
    const isMinYZoom = !this.isScalingY() || minYCheckValue <= this.minRatioX;
    return isMinXZoom && isMinYZoom;
  }
  isMaxZoom(zoom) {
    return zoom.x.min === UNIT.min && zoom.x.max === UNIT.max && zoom.y.min === UNIT.min && zoom.y.max === UNIT.max;
  }
  updateZoom(zoom) {
    const dx = round$1(zoom.x.max - zoom.x.min);
    const dy = round$1(zoom.y.max - zoom.y.min);
    if (dx < this.minRatioX || dy < this.minRatioY) {
      this.contextMenuRegistry.disableAction(CONTEXT_ZOOM_ACTION_ID);
      this.contextMenuRegistry.enableAction(CONTEXT_PAN_ACTION_ID);
      return;
    }
    this.toggleContextMenuActions(zoom);
    this.zoomManager.updateZoom(zoom);
  }
  updateAxisZoom(axisId, direction, partialZoom) {
    if (!partialZoom)
      return;
    if (!this.enableSecondaryAxis) {
      const fullZoom = definedZoomState(this.zoomManager.getZoom());
      if (direction === ChartAxisDirection7.X) {
        fullZoom.x = partialZoom;
      } else {
        fullZoom.y = partialZoom;
      }
      this.updateZoom(fullZoom);
      return;
    }
    const d = round$1(partialZoom.max - partialZoom.min);
    if (direction === ChartAxisDirection7.X && d < this.minRatioX || direction === ChartAxisDirection7.Y && d < this.minRatioY) {
      return;
    }
    this.zoomManager.updateAxisZoom(axisId, partialZoom);
  }
};
__decorateClass$1([
  ActionOnSet6({
    newValue(newValue) {
      if (newValue) {
        this.registerContextMenuActions();
      }
    }
  }),
  Validate20(BOOLEAN11)
], Zoom.prototype, "enabled", 2);
__decorateClass$1([
  Validate20(BOOLEAN11)
], Zoom.prototype, "enableAxisDragging", 2);
__decorateClass$1([
  Validate20(BOOLEAN11)
], Zoom.prototype, "enableDoubleClickToReset", 2);
__decorateClass$1([
  Validate20(BOOLEAN11)
], Zoom.prototype, "enablePanning", 2);
__decorateClass$1([
  Validate20(BOOLEAN11)
], Zoom.prototype, "enableScrolling", 2);
__decorateClass$1([
  Validate20(BOOLEAN11)
], Zoom.prototype, "enableSelecting", 2);
__decorateClass$1([
  Validate20(UNION4(["alt", "ctrl", "meta", "shift"], "a pan key"))
], Zoom.prototype, "panKey", 2);
__decorateClass$1([
  Validate20(UNION4(["x", "y", "xy"], "an axis"))
], Zoom.prototype, "axes", 2);
__decorateClass$1([
  Validate20(RATIO8)
], Zoom.prototype, "scrollingStep", 2);
__decorateClass$1([
  Validate20(NUMBER6.restrict({ min: 1 }))
], Zoom.prototype, "minVisibleItemsX", 2);
__decorateClass$1([
  Validate20(NUMBER6.restrict({ min: 1 }))
], Zoom.prototype, "minVisibleItemsY", 2);
__decorateClass$1([
  Validate20(ANCHOR_CORD)
], Zoom.prototype, "anchorPointX", 2);
__decorateClass$1([
  Validate20(ANCHOR_CORD)
], Zoom.prototype, "anchorPointY", 2);

// packages/ag-charts-enterprise/src/features/zoom/zoomModule.ts
var ZoomModule = {
  type: "root",
  optionsKey: "zoom",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  instanceConstructor: Zoom,
  themeTemplate: {
    zoom: { enabled: false }
  }
};
var {
  BOOLEAN: BOOLEAN12,
  Layers: Layers5,
  POSITION: POSITION$1,
  Validate: Validate21,
  Default: Default4,
  MIN_SPACING: MIN_SPACING3,
  POSITIVE_NUMBER: POSITIVE_NUMBER7,
  ProxyProperty: ProxyProperty2,
  DeprecatedAndRenamedTo: DeprecatedAndRenamedTo$1
} = module_support_exports;
var { BBox: BBox5, Group: Group5, Rect: Rect$1, LinearGradientFill: LinearGradientFill$1, Triangle: Triangle$1 } = integrated_charts_scene_exports;
var { createId: createId2, Logger: Logger3 } = sparklines_util_exports;
var GradientBar = class {
  constructor() {
    this.thickness = 16;
    this.preferredLength = 100;
  }
};
__decorateClass$1([
  Validate21(POSITIVE_NUMBER7)
], GradientBar.prototype, "thickness", 2);
__decorateClass$1([
  Validate21(POSITIVE_NUMBER7)
], GradientBar.prototype, "preferredLength", 2);
var GradientLegendAxisTick = class extends module_support_exports.AxisTick {
  constructor() {
    super(...arguments);
    this.enabled = false;
    this.size = 0;
    this.maxSpacing = NaN;
  }
};
__decorateClass$1([
  Validate21(MIN_SPACING3),
  Default4(NaN)
], GradientLegendAxisTick.prototype, "maxSpacing", 2);
var GradientLegendAxis = class extends module_support_exports.CartesianAxis {
  constructor(ctx) {
    super(ctx, new sparklines_scale_exports.LinearScale(), { respondsToZoom: false });
    this.colorDomain = [];
    this.nice = false;
    this.line.enabled = false;
  }
  calculateDomain() {
    this.setDomain(this.colorDomain);
  }
  formatDatum(datum) {
    if (typeof datum === "number") {
      return datum.toFixed(2);
    } else {
      Logger3.warnOnce(
        "data contains Date objects which are being plotted against a number axis, please only use a number axis for numbers."
      );
      return String(datum);
    }
  }
  createTick() {
    return new GradientLegendAxisTick();
  }
};
var GradientLegendLabel = class {
  constructor(label) {
    this.label = label;
  }
};
__decorateClass$1([
  ProxyProperty2("label.fontStyle")
], GradientLegendLabel.prototype, "fontStyle", 2);
__decorateClass$1([
  ProxyProperty2("label.fontWeight")
], GradientLegendLabel.prototype, "fontWeight", 2);
__decorateClass$1([
  ProxyProperty2("label.fontSize")
], GradientLegendLabel.prototype, "fontSize", 2);
__decorateClass$1([
  ProxyProperty2("label.fontFamily")
], GradientLegendLabel.prototype, "fontFamily", 2);
__decorateClass$1([
  ProxyProperty2("label.color")
], GradientLegendLabel.prototype, "color", 2);
__decorateClass$1([
  ProxyProperty2("label.format")
], GradientLegendLabel.prototype, "format", 2);
__decorateClass$1([
  ProxyProperty2("label.formatter")
], GradientLegendLabel.prototype, "formatter", 2);
var GradientLegendInterval = class {
  constructor(tick) {
    this.tick = tick;
  }
};
__decorateClass$1([
  ProxyProperty2("tick.values")
], GradientLegendInterval.prototype, "values", 2);
__decorateClass$1([
  ProxyProperty2("tick.minSpacing")
], GradientLegendInterval.prototype, "minSpacing", 2);
__decorateClass$1([
  ProxyProperty2("tick.maxSpacing")
], GradientLegendInterval.prototype, "maxSpacing", 2);
__decorateClass$1([
  ProxyProperty2("tick.interval")
], GradientLegendInterval.prototype, "step", 2);
var GradientLegendScale = class {
  constructor(axis) {
    this.axis = axis;
    this.label = new GradientLegendLabel(axis.label);
    this.interval = new GradientLegendInterval(axis.tick);
  }
};
__decorateClass$1([
  ProxyProperty2("axis.seriesAreaPadding")
], GradientLegendScale.prototype, "padding", 2);
var GradientLegend = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.id = createId2(this);
    this.group = new Group5({ name: "legend", layer: true, zIndex: Layers5.LEGEND_ZINDEX });
    this.gradient = new GradientBar();
    this.destroyFns = [];
    this.enabled = false;
    this.position = "bottom";
    this.reverseOrder = void 0;
    // Placeholder
    this.pagination = void 0;
    this.spacing = 20;
    this.data = [];
    this.listeners = {};
    this.latestGradientBox = void 0;
    this.layoutService = ctx.layoutService;
    this.destroyFns.push(this.layoutService.addListener("start-layout", (e) => this.update(e.shrinkRect)));
    this.highlightManager = ctx.highlightManager;
    this.destroyFns.push(this.highlightManager.addListener("highlight-change", () => this.onChartHoverChange()));
    this.gradientRect = new Rect$1();
    this.gradientFill = new LinearGradientFill$1();
    this.gradientFill.mask = this.gradientRect;
    this.group.append(this.gradientFill);
    this.arrow = new Triangle$1();
    this.group.append(this.arrow);
    this.axisGridGroup = new Group5({ name: "legend-axis-grid-group" });
    this.group.append(this.axisGridGroup);
    this.axisGroup = new Group5({ name: "legend-axis-group" });
    this.group.append(this.axisGroup);
    this.axis = new GradientLegendAxis(ctx);
    this.axis.attachAxis(this.axisGroup, this.axisGridGroup);
    this.scale = new GradientLegendScale(this.axis);
    this.stop = this.scale;
    this.destroyFns.push(() => this.detachLegend());
  }
  getOrientation() {
    switch (this.position) {
      case "right":
      case "left":
        return "vertical";
      case "bottom":
      case "top":
        return "horizontal";
    }
  }
  destroy() {
    this.destroyFns.forEach((f) => f());
  }
  attachLegend(node) {
    node.append(this.group);
  }
  detachLegend() {
    var _a2;
    (_a2 = this.group.parent) == null ? void 0 : _a2.removeChild(this.group);
  }
  update(shrinkRect) {
    const data = this.data[0];
    if (!this.enabled || !data || !data.enabled) {
      this.group.visible = false;
      return { shrinkRect: shrinkRect.clone() };
    }
    const { colorRange } = this.normalizeColorArrays(data);
    const gradientBox = this.updateGradientRect(shrinkRect, colorRange);
    const axisBox = this.updateAxis(data, gradientBox);
    const { newShrinkRect, translateX, translateY } = this.getMeasurements(shrinkRect, gradientBox, axisBox);
    this.updateArrow(gradientBox);
    this.group.visible = true;
    this.group.translationX = translateX;
    this.group.translationY = translateY;
    this.latestGradientBox = gradientBox;
    return { shrinkRect: newShrinkRect };
  }
  normalizeColorArrays(data) {
    let colorDomain = data.colorDomain.slice();
    const colorRange = data.colorRange.slice();
    if (colorDomain.length === colorRange.length) {
      return { colorDomain, colorRange };
    }
    if (colorDomain.length > colorRange.length) {
      colorRange.splice(colorDomain.length);
    }
    const count = colorRange.length;
    colorDomain = colorRange.map((_, i) => {
      const [d0, d1] = colorDomain;
      if (i === 0)
        return d0;
      if (i === count - 1)
        return d1;
      return d0 + (d1 - d0) * i / (count - 1);
    });
    return { colorDomain, colorRange };
  }
  updateGradientRect(shrinkRect, colorRange) {
    const { preferredLength: gradientLength, thickness } = this.gradient;
    const gradientBox = new BBox5(0, 0, 0, 0);
    const vertical = this.getOrientation() === "vertical";
    if (vertical) {
      const maxHeight = shrinkRect.height;
      const preferredHeight = gradientLength;
      gradientBox.x = 0;
      gradientBox.y = 0;
      gradientBox.width = thickness;
      gradientBox.height = Math.min(maxHeight, preferredHeight);
    } else {
      const maxWidth = shrinkRect.width;
      const preferredWidth = gradientLength;
      gradientBox.x = 0;
      gradientBox.y = 0;
      gradientBox.width = Math.min(maxWidth, preferredWidth);
      gradientBox.height = thickness;
    }
    if (this.reverseOrder) {
      colorRange = colorRange.slice().reverse();
    }
    this.gradientFill.stops = colorRange;
    this.gradientFill.direction = vertical ? "to-bottom" : "to-right";
    this.gradientRect.x = gradientBox.x;
    this.gradientRect.y = gradientBox.y;
    this.gradientRect.width = gradientBox.width;
    this.gradientRect.height = gradientBox.height;
    return gradientBox;
  }
  updateAxis(data, gradientBox) {
    const { reverseOrder, axis } = this;
    const vertical = this.getOrientation() === "vertical";
    axis.position = vertical ? "right" : "bottom";
    axis.colorDomain = reverseOrder ? data.colorDomain.slice().reverse() : data.colorDomain;
    axis.calculateDomain();
    axis.range = vertical ? [0, gradientBox.height] : [0, gradientBox.width];
    axis.gridLength = 0;
    axis.translation.x = gradientBox.x + (vertical ? gradientBox.width : 0);
    axis.translation.y = gradientBox.y + (vertical ? 0 : gradientBox.height);
    const axisBox = axis.calculateLayout().bbox;
    axis.update();
    return axisBox;
  }
  updateArrow(gradientBox) {
    var _a2;
    const {
      arrow,
      axis: { label, scale }
    } = this;
    const highlighted = this.highlightManager.getActiveHighlight();
    const colorValue = highlighted == null ? void 0 : highlighted.colorValue;
    if (highlighted == null || colorValue == null) {
      arrow.visible = false;
      return;
    }
    const vertical = this.getOrientation() === "vertical";
    const size = (_a2 = label.fontSize) != null ? _a2 : 0;
    const t = scale.convert(colorValue);
    let x;
    let y;
    let rotation;
    if (vertical) {
      x = gradientBox.x - size / 2;
      y = gradientBox.y + t;
      rotation = Math.PI / 2;
    } else {
      x = gradientBox.x + t;
      y = gradientBox.y - size / 2;
      rotation = Math.PI;
    }
    arrow.fill = label.color;
    arrow.size = size;
    arrow.translationX = x;
    arrow.translationY = y;
    arrow.rotation = rotation;
    arrow.visible = true;
  }
  getMeasurements(shrinkRect, gradientBox, axisBox) {
    let width;
    let height;
    const vertical = this.getOrientation() === "vertical";
    if (vertical) {
      width = gradientBox.width + axisBox.width;
      height = gradientBox.height;
    } else {
      width = gradientBox.width;
      height = gradientBox.height + axisBox.height;
    }
    const { spacing } = this;
    const newShrinkRect = shrinkRect.clone();
    let left;
    let top;
    if (this.position === "left") {
      left = shrinkRect.x;
      top = shrinkRect.y + shrinkRect.height / 2 - height / 2;
      newShrinkRect.shrink(width + spacing, "left");
    } else if (this.position === "right") {
      left = shrinkRect.x + shrinkRect.width - width;
      top = shrinkRect.y + shrinkRect.height / 2 - height / 2;
      newShrinkRect.shrink(width + spacing, "right");
    } else if (this.position === "top") {
      left = shrinkRect.x + shrinkRect.width / 2 - width / 2;
      top = shrinkRect.y;
      newShrinkRect.shrink(height + spacing, "top");
    } else {
      left = shrinkRect.x + shrinkRect.width / 2 - width / 2;
      top = shrinkRect.y + shrinkRect.height - height;
      newShrinkRect.shrink(height + spacing, "bottom");
    }
    return {
      translateX: left,
      translateY: top,
      gradientBox,
      newShrinkRect
    };
  }
  computeBBox() {
    return this.group.computeBBox();
  }
  onChartHoverChange() {
    if (this.enabled && this.latestGradientBox != null) {
      this.updateArrow(this.latestGradientBox);
    }
  }
};
GradientLegend.className = "GradientLegend";
__decorateClass$1([
  Validate21(BOOLEAN12)
], GradientLegend.prototype, "enabled", 2);
__decorateClass$1([
  Validate21(POSITION$1)
], GradientLegend.prototype, "position", 2);
__decorateClass$1([
  Validate21(BOOLEAN12, { optional: true })
], GradientLegend.prototype, "reverseOrder", 2);
__decorateClass$1([
  Validate21(POSITIVE_NUMBER7)
], GradientLegend.prototype, "spacing", 2);
__decorateClass$1([
  DeprecatedAndRenamedTo$1("scale")
], GradientLegend.prototype, "stop", 2);
var BOTTOM = "bottom";
var GRADIENT_LEGEND_THEME = {
  position: BOTTOM,
  spacing: 20,
  scale: {
    padding: 8,
    label: {
      color: integrated_charts_theme_exports.DEFAULT_LABEL_COLOUR,
      fontStyle: void 0,
      fontWeight: void 0,
      fontSize: 12,
      fontFamily: integrated_charts_theme_exports.DEFAULT_FONT_FAMILY,
      formatter: void 0
    },
    interval: {
      minSpacing: 1
    }
  },
  gradient: {
    preferredLength: 100,
    thickness: 16
  },
  reverseOrder: false
};

// packages/ag-charts-enterprise/src/gradient-legend/main.ts
var GradientLegendModule = {
  type: "legend",
  optionsKey: "gradientLegend",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy"],
  identifier: "gradient",
  instanceConstructor: GradientLegend,
  themeTemplate: GRADIENT_LEGEND_THEME
};

// packages/ag-charts-enterprise/src/license/md5.ts
var MD5$1 = class {
  constructor() {
    this.ieCompatibility = false;
  }
  init() {
    this.ieCompatibility = this.md5("hello") != "5d41402abc4b2a76b9719d911017c592";
  }
  md5cycle(x, k) {
    let a = x[0], b = x[1], c = x[2], d = x[3];
    a = this.ff(a, b, c, d, k[0], 7, -680876936);
    d = this.ff(d, a, b, c, k[1], 12, -389564586);
    c = this.ff(c, d, a, b, k[2], 17, 606105819);
    b = this.ff(b, c, d, a, k[3], 22, -1044525330);
    a = this.ff(a, b, c, d, k[4], 7, -176418897);
    d = this.ff(d, a, b, c, k[5], 12, 1200080426);
    c = this.ff(c, d, a, b, k[6], 17, -1473231341);
    b = this.ff(b, c, d, a, k[7], 22, -45705983);
    a = this.ff(a, b, c, d, k[8], 7, 1770035416);
    d = this.ff(d, a, b, c, k[9], 12, -1958414417);
    c = this.ff(c, d, a, b, k[10], 17, -42063);
    b = this.ff(b, c, d, a, k[11], 22, -1990404162);
    a = this.ff(a, b, c, d, k[12], 7, 1804603682);
    d = this.ff(d, a, b, c, k[13], 12, -40341101);
    c = this.ff(c, d, a, b, k[14], 17, -1502002290);
    b = this.ff(b, c, d, a, k[15], 22, 1236535329);
    a = this.gg(a, b, c, d, k[1], 5, -165796510);
    d = this.gg(d, a, b, c, k[6], 9, -1069501632);
    c = this.gg(c, d, a, b, k[11], 14, 643717713);
    b = this.gg(b, c, d, a, k[0], 20, -373897302);
    a = this.gg(a, b, c, d, k[5], 5, -701558691);
    d = this.gg(d, a, b, c, k[10], 9, 38016083);
    c = this.gg(c, d, a, b, k[15], 14, -660478335);
    b = this.gg(b, c, d, a, k[4], 20, -405537848);
    a = this.gg(a, b, c, d, k[9], 5, 568446438);
    d = this.gg(d, a, b, c, k[14], 9, -1019803690);
    c = this.gg(c, d, a, b, k[3], 14, -187363961);
    b = this.gg(b, c, d, a, k[8], 20, 1163531501);
    a = this.gg(a, b, c, d, k[13], 5, -1444681467);
    d = this.gg(d, a, b, c, k[2], 9, -51403784);
    c = this.gg(c, d, a, b, k[7], 14, 1735328473);
    b = this.gg(b, c, d, a, k[12], 20, -1926607734);
    a = this.hh(a, b, c, d, k[5], 4, -378558);
    d = this.hh(d, a, b, c, k[8], 11, -2022574463);
    c = this.hh(c, d, a, b, k[11], 16, 1839030562);
    b = this.hh(b, c, d, a, k[14], 23, -35309556);
    a = this.hh(a, b, c, d, k[1], 4, -1530992060);
    d = this.hh(d, a, b, c, k[4], 11, 1272893353);
    c = this.hh(c, d, a, b, k[7], 16, -155497632);
    b = this.hh(b, c, d, a, k[10], 23, -1094730640);
    a = this.hh(a, b, c, d, k[13], 4, 681279174);
    d = this.hh(d, a, b, c, k[0], 11, -358537222);
    c = this.hh(c, d, a, b, k[3], 16, -722521979);
    b = this.hh(b, c, d, a, k[6], 23, 76029189);
    a = this.hh(a, b, c, d, k[9], 4, -640364487);
    d = this.hh(d, a, b, c, k[12], 11, -421815835);
    c = this.hh(c, d, a, b, k[15], 16, 530742520);
    b = this.hh(b, c, d, a, k[2], 23, -995338651);
    a = this.ii(a, b, c, d, k[0], 6, -198630844);
    d = this.ii(d, a, b, c, k[7], 10, 1126891415);
    c = this.ii(c, d, a, b, k[14], 15, -1416354905);
    b = this.ii(b, c, d, a, k[5], 21, -57434055);
    a = this.ii(a, b, c, d, k[12], 6, 1700485571);
    d = this.ii(d, a, b, c, k[3], 10, -1894986606);
    c = this.ii(c, d, a, b, k[10], 15, -1051523);
    b = this.ii(b, c, d, a, k[1], 21, -2054922799);
    a = this.ii(a, b, c, d, k[8], 6, 1873313359);
    d = this.ii(d, a, b, c, k[15], 10, -30611744);
    c = this.ii(c, d, a, b, k[6], 15, -1560198380);
    b = this.ii(b, c, d, a, k[13], 21, 1309151649);
    a = this.ii(a, b, c, d, k[4], 6, -145523070);
    d = this.ii(d, a, b, c, k[11], 10, -1120210379);
    c = this.ii(c, d, a, b, k[2], 15, 718787259);
    b = this.ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = this.add32(a, x[0]);
    x[1] = this.add32(b, x[1]);
    x[2] = this.add32(c, x[2]);
    x[3] = this.add32(d, x[3]);
  }
  cmn(q, a, b, x, s, t) {
    a = this.add32(this.add32(a, q), this.add32(x, t));
    return this.add32(a << s | a >>> 32 - s, b);
  }
  ff(a, b, c, d, x, s, t) {
    return this.cmn(b & c | ~b & d, a, b, x, s, t);
  }
  gg(a, b, c, d, x, s, t) {
    return this.cmn(b & d | c & ~d, a, b, x, s, t);
  }
  hh(a, b, c, d, x, s, t) {
    return this.cmn(b ^ c ^ d, a, b, x, s, t);
  }
  ii(a, b, c, d, x, s, t) {
    return this.cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  md51(s) {
    const n = s.length;
    const state = [1732584193, -271733879, -1732584194, 271733878];
    let i;
    for (i = 64; i <= s.length; i += 64) {
      this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < s.length; i++) {
      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    }
    tail[i >> 2] |= 128 << (i % 4 << 3);
    if (i > 55) {
      this.md5cycle(state, tail);
      for (i = 0; i < 16; i++) {
        tail[i] = 0;
      }
    }
    tail[14] = n * 8;
    this.md5cycle(state, tail);
    return state;
  }
  /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
   */
  md5blk(s) {
    const md5blks = [];
    for (let i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  }
  rhex(n) {
    const hex_chr = "0123456789abcdef".split("");
    let s = "", j = 0;
    for (; j < 4; j++) {
      s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
    }
    return s;
  }
  hex(x) {
    for (let i = 0; i < x.length; i++) {
      x[i] = this.rhex(x[i]);
    }
    return x.join("");
  }
  md5(s) {
    return this.hex(this.md51(s));
  }
  add32(a, b) {
    return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);
  }
  /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
   need the idiotic second function, generated by an if clause.  */
  add32Std(a, b) {
    return a + b & 4294967295;
  }
  add32Compat(x, y) {
    const lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
};

// packages/ag-charts-enterprise/src/license/licenseManager.ts
function missingOrEmpty$1(value) {
  return value == null || value.length === 0;
}
var LICENSE_TYPES$1 = {
  "01": "GRID",
  "02": "CHARTS",
  "0102": "BOTH"
};
var _LicenseManager = class _LicenseManager {
  constructor(document2) {
    this.gridContext = false;
    this.watermarkMessage = void 0;
    this.totalMessageLength = 124;
    this.document = document2;
    this.md5 = new MD5$1();
    this.md5.init();
  }
  validateLicense() {
    const licenseDetails = this.getLicenseDetails(this.licenseKey, this.gridContext);
    const currentLicenseName = `AG ${licenseDetails.currentLicenseType === "BOTH" ? "Grid and " : ""}Charts Enterprise`;
    const suppliedLicenseName = licenseDetails.suppliedLicenseType === void 0 ? "" : `AG ${licenseDetails.suppliedLicenseType === "BOTH" ? "Grid and AG Charts" : licenseDetails.suppliedLicenseType === "GRID" ? "Grid" : "Charts"} Enterprise`;
    if (licenseDetails.missing) {
      if (!this.isWebsiteUrl() || this.isForceWatermark()) {
        this.outputMissingLicenseKey(currentLicenseName);
      }
    } else if (licenseDetails.expired) {
      const gridReleaseDate = _LicenseManager.getChartsReleaseDate();
      const formattedReleaseDate = _LicenseManager.formatDate(gridReleaseDate);
      this.outputExpiredKey(licenseDetails.expiry, formattedReleaseDate, suppliedLicenseName);
    } else if (!licenseDetails.valid) {
      this.outputInvalidLicenseKey(
        !!licenseDetails.incorrectLicenseType,
        currentLicenseName,
        suppliedLicenseName
      );
    } else if (licenseDetails.isTrial && licenseDetails.trialExpired) {
      this.outputExpiredTrialKey(licenseDetails.expiry, currentLicenseName, suppliedLicenseName);
    }
  }
  static extractExpiry(license) {
    const restrictionHashed = license.substring(license.lastIndexOf("_") + 1, license.length);
    return new Date(parseInt(_LicenseManager.decode(restrictionHashed), 10));
  }
  static extractLicenseComponents(licenseKey) {
    let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, "");
    cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, "");
    if (licenseKey.length <= 32) {
      return { md5: null, license: licenseKey, version: null, isTrial: null };
    }
    const hashStart = cleanedLicenseKey.length - 32;
    const md5 = cleanedLicenseKey.substring(hashStart);
    const license = cleanedLicenseKey.substring(0, hashStart);
    const [version, isTrial, type] = _LicenseManager.extractBracketedInformation(cleanedLicenseKey);
    return { md5, license, version, isTrial, type };
  }
  getLicenseDetails(licenseKey, gridContext = false) {
    const currentLicenseType = "CHARTS";
    if (missingOrEmpty$1(licenseKey)) {
      return {
        licenseKey,
        valid: false,
        missing: true,
        currentLicenseType
      };
    }
    const chartsReleaseDate = _LicenseManager.getChartsReleaseDate();
    const { md5, license, version, isTrial, type } = _LicenseManager.extractLicenseComponents(licenseKey);
    let valid = md5 === this.md5.md5(license) && licenseKey.indexOf("For_Trialing_ag-Grid_Only") === -1;
    let trialExpired = void 0;
    let expired = void 0;
    let expiry = null;
    let incorrectLicenseType = false;
    let suppliedLicenseType = void 0;
    function handleTrial() {
      const now = /* @__PURE__ */ new Date();
      trialExpired = expiry < now;
      expired = void 0;
    }
    if (valid) {
      expiry = _LicenseManager.extractExpiry(license);
      valid = !isNaN(expiry.getTime());
      if (valid) {
        expired = chartsReleaseDate > expiry;
        switch (version) {
          case "legacy":
          case "2": {
            valid = false;
            break;
          }
          case "3": {
            if (missingOrEmpty$1(type)) {
              valid = false;
            } else {
              suppliedLicenseType = type;
              if (type !== LICENSE_TYPES$1["02"] && type !== LICENSE_TYPES$1["0102"]) {
                valid = false;
                incorrectLicenseType = true;
              } else if (isTrial) {
                handleTrial();
              }
            }
          }
        }
      }
    }
    if (!valid) {
      return {
        licenseKey,
        valid,
        incorrectLicenseType,
        currentLicenseType,
        suppliedLicenseType
      };
    }
    return {
      licenseKey,
      valid,
      expiry: _LicenseManager.formatDate(expiry),
      expired,
      version,
      isTrial,
      trialExpired,
      invalidLicenseTypeForCombo: gridContext ? suppliedLicenseType !== "BOTH" : void 0,
      incorrectLicenseType,
      currentLicenseType,
      suppliedLicenseType
    };
  }
  isDisplayWatermark() {
    return this.isForceWatermark() || !this.isLocalhost() && !this.isWebsiteUrl() && !missingOrEmpty$1(this.watermarkMessage);
  }
  getWatermarkMessage() {
    return this.watermarkMessage || "";
  }
  getHostname() {
    if (!this.document) {
      return "localhost";
    }
    const win = this.document.defaultView || window;
    if (!win) {
      return "localhost";
    }
    const loc = win.location;
    const { hostname = "" } = loc;
    return hostname;
  }
  isForceWatermark() {
    var _a2, _b;
    if (!this.document) {
      return false;
    }
    const win = ((_b = (_a2 = this.document) == null ? void 0 : _a2.defaultView) != null ? _b : typeof window != "undefined") ? window : void 0;
    if (!win) {
      return false;
    }
    const { pathname } = win.location;
    return pathname ? pathname.indexOf("forceWatermark") !== -1 : false;
  }
  isWebsiteUrl() {
    const hostname = this.getHostname();
    return hostname.match(/^((?:[\w-]+\.)?ag-grid\.com)$/) !== null;
  }
  isLocalhost() {
    const hostname = this.getHostname();
    return hostname.match(/^(?:127\.0\.0\.1|localhost)$/) !== null;
  }
  static formatDate(date) {
    const monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    const day = date.getDate();
    const monthIndex = date.getMonth();
    const year = date.getFullYear();
    return day + " " + monthNames[monthIndex] + " " + year;
  }
  static getChartsReleaseDate() {
    return new Date(parseInt(_LicenseManager.decode(_LicenseManager.RELEASE_INFORMATION), 10));
  }
  static decode(input) {
    const keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let t = "";
    let n, r, i;
    let s, o, u, a;
    let f = 0;
    const e = input.replace(/[^A-Za-z0-9+/=]/g, "");
    while (f < e.length) {
      s = keystr.indexOf(e.charAt(f++));
      o = keystr.indexOf(e.charAt(f++));
      u = keystr.indexOf(e.charAt(f++));
      a = keystr.indexOf(e.charAt(f++));
      n = s << 2 | o >> 4;
      r = (o & 15) << 4 | u >> 2;
      i = (u & 3) << 6 | a;
      t = t + String.fromCharCode(n);
      if (u != 64) {
        t = t + String.fromCharCode(r);
      }
      if (a != 64) {
        t = t + String.fromCharCode(i);
      }
    }
    t = _LicenseManager.utf8_decode(t);
    return t;
  }
  static utf8_decode(input) {
    input = input.replace(/rn/g, "n");
    let t = "";
    for (let n = 0; n < input.length; n++) {
      const r = input.charCodeAt(n);
      if (r < 128) {
        t += String.fromCharCode(r);
      } else if (r > 127 && r < 2048) {
        t += String.fromCharCode(r >> 6 | 192);
        t += String.fromCharCode(r & 63 | 128);
      } else {
        t += String.fromCharCode(r >> 12 | 224);
        t += String.fromCharCode(r >> 6 & 63 | 128);
        t += String.fromCharCode(r & 63 | 128);
      }
    }
    return t;
  }
  setLicenseKey(licenseKey, gridContext = false) {
    this.gridContext = gridContext;
    this.licenseKey = licenseKey;
  }
  static extractBracketedInformation(licenseKey) {
    if (!licenseKey.includes("[")) {
      return ["legacy", false, void 0];
    }
    const matches = licenseKey.match(/\[(.*?)\]/g).map((match) => match.replace("[", "").replace("]", ""));
    if (!matches || matches.length === 0) {
      return ["legacy", false, void 0];
    }
    const isTrial = matches.filter((match) => match === "TRIAL").length === 1;
    const rawVersion = matches.filter((match) => match.indexOf("v") === 0)[0];
    const version = rawVersion ? rawVersion.replace("v", "") : "legacy";
    const type = LICENSE_TYPES$1[matches.filter((match) => LICENSE_TYPES$1[match])[0]];
    return [version, isTrial, type];
  }
  centerPadAndOutput(input) {
    const paddingRequired = this.totalMessageLength - input.length;
    console.error(input.padStart(paddingRequired / 2 + input.length, "*").padEnd(this.totalMessageLength, "*"));
  }
  padAndOutput(input, padding = "*", terminateWithPadding = "") {
    console.error(
      input.padEnd(this.totalMessageLength - terminateWithPadding.length, padding) + terminateWithPadding
    );
  }
  outputInvalidLicenseKey(incorrectLicenseType, currentLicenseName, suppliedLicenseName) {
    if (!this.gridContext) {
      if (incorrectLicenseType) {
        this.centerPadAndOutput("");
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(" Incompatible License Key ");
        this.padAndOutput(
          `* Your license key is for ${suppliedLicenseName} only and does not cover you for ${currentLicenseName}.`,
          " ",
          "*"
        );
        this.padAndOutput("* Please contact info@ag-grid.com to obtain a combined license key.", " ", "*");
        this.centerPadAndOutput("");
        this.centerPadAndOutput("");
      } else {
        this.centerPadAndOutput("");
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(" Invalid License Key ");
        this.padAndOutput(
          `* Your license key is not valid - please contact info@ag-grid.com to obtain a valid license.`,
          " ",
          "*"
        );
        this.centerPadAndOutput("");
        this.centerPadAndOutput("");
      }
    }
    this.watermarkMessage = "Invalid License";
  }
  outputExpiredTrialKey(formattedExpiryDate, currentLicenseName, suppliedLicenseName) {
    if (!this.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" Trial Period Expired. ");
      this.padAndOutput(
        `* Your trial only license for ${suppliedLicenseName} expired on ${formattedExpiryDate}.`,
        " ",
        "*"
      );
      this.padAndOutput("* Please email info@ag-grid.com to purchase a license.", " ", "*");
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "Trial Period Expired";
  }
  outputMissingLicenseKey(currentLicenseName) {
    if (!this.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" License Key Not Found ");
      this.padAndOutput(`* All ${currentLicenseName} features are unlocked for trial.`, " ", "*");
      this.padAndOutput(
        "* If you want to hide the watermark please email info@ag-grid.com for a trial license key.",
        " ",
        "*"
      );
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "For Trial Use Only";
  }
  outputExpiredKey(formattedExpiryDate, formattedReleaseDate, currentLicenseName) {
    if (!this.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" Incompatible Software Version ");
      this.padAndOutput(
        `* Your license key works with versions of ${currentLicenseName} released before ${formattedExpiryDate}.`,
        " ",
        "*"
      );
      this.padAndOutput(`* The version you are trying to use was released on ${formattedReleaseDate}.`, " ", "*");
      this.padAndOutput("* Please contact info@ag-grid.com to renew your license key.", " ", "*");
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "License Expired";
  }
};
_LicenseManager.RELEASE_INFORMATION = "MTcwODMyOTU2Mjk0OA==";
var LicenseManager$1 = _LicenseManager;
var { injectStyle: injectStyle$1 } = module_support_exports;
var watermarkStyles = `
.ag-watermark {
    position: absolute;
    bottom: 20px;
    right: 25px;
    font-weight: bold;
    font-family: Impact, sans-serif;
    font-size: 19px;
    opacity: 0.7;
    animation: 1s ease-out 3s ag-watermark-fadeout;
    color: #9B9B9B;

    &::before {
        content: '';
        display: block;
        height: 40px;
        width: 170px;
        background-image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=);
        background-repeat: no-repeat;
        background-size: 170px 40px;
    }

    > span {
        padding-left: 0.7rem;
    }
}

@keyframes ag-watermark-fadeout {
    from { opacity: 0.5; }
    to { opacity: 0; }
}
`;
function injectWatermark(document2, parentElement, text) {
  injectStyle$1(document2, watermarkStyles);
  const element = document2.createElement("div");
  const textElement = document2.createElement("span");
  textElement.innerText = text;
  element.addEventListener("animationend", () => parentElement.removeChild(element));
  element.classList.add("ag-watermark");
  element.appendChild(textElement);
  parentElement.appendChild(element);
}

// packages/ag-charts-enterprise/src/series/box-plot/blotPlotUtil.ts
function prepareBoxPlotFromTo(isVertical) {
  const from = isVertical ? { scalingX: 1, scalingY: 0 } : { scalingX: 0, scalingY: 1 };
  const to = { scalingX: 1, scalingY: 1 };
  return { from, to };
}
function resetBoxPlotSelectionsScalingCenterFn(isVertical) {
  return (_node, datum) => {
    if (isVertical) {
      return { scalingCenterY: datum.scaledValues.medianValue };
    }
    return { scalingCenterX: datum.scaledValues.medianValue };
  };
}
var BoxPlotGroup = class extends integrated_charts_scene_exports.Group {
  constructor() {
    super();
    this.append([
      new integrated_charts_scene_exports.Rect({ tag: 0 /* Box */ }),
      new integrated_charts_scene_exports.Rect({ tag: 0 /* Box */ }),
      new integrated_charts_scene_exports.Rect({ tag: 2 /* Outline */ }),
      new integrated_charts_scene_exports.Rect({ tag: 1 /* Median */ }),
      new integrated_charts_scene_exports.Line({ tag: 3 /* Whisker */ }),
      new integrated_charts_scene_exports.Line({ tag: 3 /* Whisker */ }),
      new integrated_charts_scene_exports.Line({ tag: 4 /* Cap */ }),
      new integrated_charts_scene_exports.Line({ tag: 4 /* Cap */ })
    ]);
  }
  updateDatumStyles(datum, activeStyles, isVertical, isReversedValueAxis) {
    const {
      bandwidth,
      scaledValues: { xValue: axisValue, medianValue }
    } = datum;
    let { minValue, q1Value, q3Value, maxValue } = datum.scaledValues;
    if (isVertical && !isReversedValueAxis || !isVertical && isReversedValueAxis) {
      [maxValue, q3Value, q1Value, minValue] = [minValue, q1Value, q3Value, maxValue];
    }
    const {
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cap,
      whisker: whiskerStyles
    } = activeStyles;
    const selection = integrated_charts_scene_exports.Selection.select(this, integrated_charts_scene_exports.Rect);
    const boxes = selection.selectByTag(0 /* Box */);
    const [outline] = selection.selectByTag(2 /* Outline */);
    const [median] = selection.selectByTag(1 /* Median */);
    const whiskers = selection.selectByTag(3 /* Whisker */);
    const caps = selection.selectByTag(4 /* Cap */);
    if (whiskerStyles.strokeWidth > bandwidth) {
      whiskerStyles.strokeWidth = bandwidth;
    }
    outline.setProperties({ x: q1Value, y: axisValue, width: q3Value - q1Value, height: bandwidth });
    boxes[0].setProperties({
      x: q1Value,
      y: axisValue,
      width: Math.round(medianValue - q1Value + strokeWidth / 2),
      height: bandwidth
    });
    boxes[1].setProperties({
      x: Math.round(medianValue - strokeWidth / 2),
      y: axisValue,
      width: Math.floor(q3Value - medianValue + strokeWidth / 2),
      height: bandwidth
    });
    const medianStart = Math.max(Math.round(medianValue - strokeWidth / 2), q1Value + strokeWidth);
    const medianEnd = Math.min(Math.round(medianValue + strokeWidth / 2), q3Value - strokeWidth);
    median.setProperties({
      visible: medianStart < medianEnd,
      x: medianStart,
      y: axisValue + strokeWidth,
      width: medianEnd - medianStart,
      height: Math.max(0, bandwidth - strokeWidth * 2)
    });
    const capStart = Math.floor(axisValue + bandwidth * (1 - cap.lengthRatio) / 2);
    const capEnd = Math.ceil(axisValue + bandwidth * (1 + cap.lengthRatio) / 2);
    caps[0].setProperties({ x: minValue, y1: capStart, y2: capEnd });
    caps[1].setProperties({ x: maxValue, y1: capStart, y2: capEnd });
    whiskers[0].setProperties({
      x1: Math.round(minValue + whiskerStyles.strokeWidth / 2),
      x2: q1Value,
      y: Math.floor(axisValue + bandwidth / 2)
    });
    whiskers[1].setProperties({
      x1: q3Value,
      x2: Math.round(maxValue - whiskerStyles.strokeWidth / 2),
      y: Math.floor(axisValue + bandwidth / 2)
    });
    if (isVertical) {
      module_support_exports.invertShapeDirection(outline, median, ...boxes, ...caps, ...whiskers);
    }
    for (const element of boxes) {
      element.setProperties({ fill, fillOpacity, strokeWidth: strokeWidth * 2, strokeOpacity: 0 });
    }
    median.setProperties({ fill: stroke, fillOpacity: strokeOpacity, strokeWidth: 0 });
    for (const element of [...whiskers, ...caps]) {
      element.setProperties(whiskerStyles);
    }
    outline.setProperties({ stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, fillOpacity: 0 });
  }
};
var {
  BaseProperties: BaseProperties5,
  AbstractBarSeriesProperties: AbstractBarSeriesProperties$1,
  SeriesTooltip: SeriesTooltip$1,
  Validate: Validate22,
  COLOR_STRING: COLOR_STRING5,
  FUNCTION: FUNCTION4,
  LINE_DASH: LINE_DASH4,
  OBJECT: OBJECT4,
  POSITIVE_NUMBER: POSITIVE_NUMBER8,
  RATIO: RATIO9,
  STRING: STRING5,
  mergeDefaults: mergeDefaults3
} = module_support_exports;
var BoxPlotSeriesCap = class extends BaseProperties5 {
  constructor() {
    super(...arguments);
    this.lengthRatio = 0.5;
  }
};
__decorateClass$1([
  Validate22(RATIO9)
], BoxPlotSeriesCap.prototype, "lengthRatio", 2);
var BoxPlotSeriesWhisker = class extends BaseProperties5 {
};
__decorateClass$1([
  Validate22(COLOR_STRING5, { optional: true })
], BoxPlotSeriesWhisker.prototype, "stroke", 2);
__decorateClass$1([
  Validate22(POSITIVE_NUMBER8)
], BoxPlotSeriesWhisker.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate22(RATIO9)
], BoxPlotSeriesWhisker.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate22(LINE_DASH4, { optional: true })
], BoxPlotSeriesWhisker.prototype, "lineDash", 2);
__decorateClass$1([
  Validate22(POSITIVE_NUMBER8)
], BoxPlotSeriesWhisker.prototype, "lineDashOffset", 2);
var BoxPlotSeriesProperties = class extends AbstractBarSeriesProperties$1 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cap = new BoxPlotSeriesCap();
    this.whisker = new BoxPlotSeriesWhisker();
    this.tooltip = new SeriesTooltip$1();
  }
  toJson() {
    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    const properties = super.toJson();
    properties.whisker = mergeDefaults3(properties.whisker, {
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    });
    return properties;
  }
};
__decorateClass$1([
  Validate22(STRING5)
], BoxPlotSeriesProperties.prototype, "xKey", 2);
__decorateClass$1([
  Validate22(STRING5)
], BoxPlotSeriesProperties.prototype, "minKey", 2);
__decorateClass$1([
  Validate22(STRING5)
], BoxPlotSeriesProperties.prototype, "q1Key", 2);
__decorateClass$1([
  Validate22(STRING5)
], BoxPlotSeriesProperties.prototype, "medianKey", 2);
__decorateClass$1([
  Validate22(STRING5)
], BoxPlotSeriesProperties.prototype, "q3Key", 2);
__decorateClass$1([
  Validate22(STRING5)
], BoxPlotSeriesProperties.prototype, "maxKey", 2);
__decorateClass$1([
  Validate22(STRING5, { optional: true })
], BoxPlotSeriesProperties.prototype, "xName", 2);
__decorateClass$1([
  Validate22(STRING5, { optional: true })
], BoxPlotSeriesProperties.prototype, "yName", 2);
__decorateClass$1([
  Validate22(STRING5, { optional: true })
], BoxPlotSeriesProperties.prototype, "minName", 2);
__decorateClass$1([
  Validate22(STRING5, { optional: true })
], BoxPlotSeriesProperties.prototype, "q1Name", 2);
__decorateClass$1([
  Validate22(STRING5, { optional: true })
], BoxPlotSeriesProperties.prototype, "medianName", 2);
__decorateClass$1([
  Validate22(STRING5, { optional: true })
], BoxPlotSeriesProperties.prototype, "q3Name", 2);
__decorateClass$1([
  Validate22(STRING5, { optional: true })
], BoxPlotSeriesProperties.prototype, "maxName", 2);
__decorateClass$1([
  Validate22(COLOR_STRING5, { optional: true })
], BoxPlotSeriesProperties.prototype, "fill", 2);
__decorateClass$1([
  Validate22(RATIO9)
], BoxPlotSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate22(COLOR_STRING5)
], BoxPlotSeriesProperties.prototype, "stroke", 2);
__decorateClass$1([
  Validate22(POSITIVE_NUMBER8)
], BoxPlotSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate22(RATIO9)
], BoxPlotSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate22(LINE_DASH4)
], BoxPlotSeriesProperties.prototype, "lineDash", 2);
__decorateClass$1([
  Validate22(POSITIVE_NUMBER8)
], BoxPlotSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate22(FUNCTION4, { optional: true })
], BoxPlotSeriesProperties.prototype, "formatter", 2);
__decorateClass$1([
  Validate22(OBJECT4)
], BoxPlotSeriesProperties.prototype, "cap", 2);
__decorateClass$1([
  Validate22(OBJECT4)
], BoxPlotSeriesProperties.prototype, "whisker", 2);
__decorateClass$1([
  Validate22(OBJECT4)
], BoxPlotSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/box-plot/boxPlotSeries.ts
var {
  extent: extent$1,
  extractDecoratedProperties: extractDecoratedProperties$1,
  fixNumericExtent: fixNumericExtent2,
  keyProperty: keyProperty$1,
  mergeDefaults: mergeDefaults4,
  SeriesNodePickMode: SeriesNodePickMode$1,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL$1,
  valueProperty: valueProperty2,
  diff: diff$1,
  animationValidation: animationValidation$1,
  ChartAxisDirection: ChartAxisDirection8
} = module_support_exports;
var { motion: motion$1 } = integrated_charts_scene_exports;
var BoxPlotSeriesNodeClickEvent = class extends module_support_exports.SeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.minKey = series.properties.minKey;
    this.q1Key = series.properties.q1Key;
    this.medianKey = series.properties.medianKey;
    this.q3Key = series.properties.q3Key;
    this.maxKey = series.properties.maxKey;
  }
};
var _BoxPlotSeries = class _BoxPlotSeries extends module_support_exports.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode$1.EXACT_SHAPE_MATCH],
      pathsPerSeries: 1,
      hasHighlightedLabels: true
    });
    this.properties = new BoxPlotSeriesProperties();
    this.NodeClickEvent = BoxPlotSeriesNodeClickEvent;
    /**
     * Used to get the position of items within each group.
     */
    this.groupScale = new sparklines_scale_exports.BandScale();
    this.smallestDataInterval = void 0;
  }
  processData(dataController) {
    return __async$1(this, null, function* () {
      var _a2, _b, _c, _d;
      if (!this.properties.isValid()) {
        return;
      }
      const { xKey, minKey, q1Key, medianKey, q3Key, maxKey } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const isContinuousX = ((_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale) instanceof sparklines_scale_exports.ContinuousScale;
      const extraProps = [];
      if (animationEnabled && this.processedData) {
        extraProps.push(diff$1(this.processedData));
      }
      if (animationEnabled) {
        extraProps.push(animationValidation$1(this));
      }
      const { processedData } = yield this.requestDataModel(dataController, (_b = this.data) != null ? _b : [], {
        props: [
          keyProperty$1(this, xKey, isContinuousX, { id: `xValue` }),
          valueProperty2(this, minKey, true, { id: `minValue` }),
          valueProperty2(this, q1Key, true, { id: `q1Value` }),
          valueProperty2(this, medianKey, true, { id: `medianValue` }),
          valueProperty2(this, q3Key, true, { id: `q3Value` }),
          valueProperty2(this, maxKey, true, { id: `maxValue` }),
          ...isContinuousX ? [SMALLEST_KEY_INTERVAL$1] : [],
          ...extraProps
        ],
        dataVisible: this.visible
      });
      this.smallestDataInterval = {
        x: (_d = (_c = processedData.reduced) == null ? void 0 : _c.smallestKeyInterval) != null ? _d : Infinity,
        y: Infinity
      };
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    var _a2;
    const { processedData, dataModel, smallestDataInterval } = this;
    if (!(processedData && dataModel))
      return [];
    if (direction === this.getBarDirection()) {
      const minValues = dataModel.getDomain(this, `minValue`, "value", processedData);
      const maxValues = dataModel.getDomain(this, `maxValue`, "value", processedData);
      return fixNumericExtent2([Math.min(...minValues), Math.max(...maxValues)], this.getValueAxis());
    }
    const { index, def } = dataModel.resolveProcessedDataIndexById(this, `xValue`);
    const keys = processedData.domain.keys[index];
    if (def.type === "key" && def.valueType === "category") {
      return keys;
    }
    const categoryAxis = this.getCategoryAxis();
    const isReversed = categoryAxis == null ? void 0 : categoryAxis.isReversed();
    const keysExtent = (_a2 = extent$1(keys)) != null ? _a2 : [NaN, NaN];
    const scalePadding = smallestDataInterval && isFinite(smallestDataInterval.x) ? smallestDataInterval.x : 0;
    if (direction === ChartAxisDirection8.Y) {
      const d02 = keysExtent[0] + (isReversed ? 0 : -scalePadding);
      const d12 = keysExtent[1] + (isReversed ? scalePadding : 0);
      return fixNumericExtent2([d02, d12], categoryAxis);
    }
    const d0 = keysExtent[0] + (isReversed ? -scalePadding : 0);
    const d1 = keysExtent[1] + (isReversed ? 0 : scalePadding);
    return fixNumericExtent2([d0, d1], categoryAxis);
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      var _a2;
      const { visible, dataModel } = this;
      const xAxis = this.getCategoryAxis();
      const yAxis = this.getValueAxis();
      if (!(dataModel && visible && xAxis && yAxis)) {
        return [];
      }
      const { xKey, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cap, whisker } = this.properties;
      const {
        groupScale,
        smallestDataInterval,
        ctx: { seriesStateManager }
      } = this;
      const xBandWidth = xAxis.scale instanceof sparklines_scale_exports.ContinuousScale ? xAxis.scale.calcBandwidth(smallestDataInterval == null ? void 0 : smallestDataInterval.x) : xAxis.scale.bandwidth;
      const domain = [];
      const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);
      for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {
        domain.push(String(groupIdx));
      }
      groupScale.domain = domain;
      groupScale.range = [0, xBandWidth != null ? xBandWidth : 0];
      if (xAxis instanceof module_support_exports.CategoryAxis) {
        groupScale.paddingInner = xAxis.groupPaddingInner;
      }
      const barWidth = groupScale.bandwidth >= 1 ? (
        // Pixel-rounded value for low-volume bar charts.
        groupScale.bandwidth
      ) : (
        // Handle high-volume bar charts gracefully.
        groupScale.rawBandwidth
      );
      const nodeData = [];
      const defs = dataModel.resolveProcessedDataDefsByIds(this, [
        "xValue",
        "minValue",
        "q1Value",
        `medianValue`,
        `q3Value`,
        `maxValue`
      ]);
      (_a2 = this.processedData) == null ? void 0 : _a2.data.forEach(({ datum, keys, values }) => {
        const { xValue, minValue, q1Value, medianValue, q3Value, maxValue } = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });
        if ([minValue, q1Value, medianValue, q3Value, maxValue].some((value) => typeof value !== "number") || minValue > q1Value || q1Value > medianValue || medianValue > q3Value || q3Value > maxValue) {
          return;
        }
        const scaledValues = this.convertValuesToScaleByDefs(defs, {
          xValue,
          minValue,
          q1Value,
          medianValue,
          q3Value,
          maxValue
        });
        scaledValues.xValue += Math.round(groupScale.convert(String(groupIndex)));
        nodeData.push({
          series: this,
          itemId: xValue,
          datum,
          xKey,
          bandwidth: Math.round(barWidth),
          scaledValues,
          cap,
          whisker,
          fill,
          fillOpacity,
          stroke,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset
        });
      });
      return [{ itemId: xKey, nodeData, labelData: [], scales: __superGet$1(_BoxPlotSeries.prototype, this, "calculateScaling").call(this), visible: this.visible }];
    });
  }
  getLegendData(legendType) {
    var _a2;
    const { id, data } = this;
    const {
      xKey,
      yName,
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      showInLegend,
      legendItemName,
      visible
    } = this.properties;
    if (!showInLegend || !(data == null ? void 0 : data.length) || !xKey || legendType !== "category") {
      return [];
    }
    return [
      {
        legendType: "category",
        id,
        itemId: id,
        seriesId: id,
        enabled: visible,
        label: {
          text: (_a2 = legendItemName != null ? legendItemName : yName) != null ? _a2 : id
        },
        marker: { fill, fillOpacity, stroke, strokeOpacity, strokeWidth },
        legendItemName
      }
    ];
  }
  getTooltipHtml(nodeDatum) {
    const {
      xKey,
      minKey,
      q1Key,
      medianKey,
      q3Key,
      maxKey,
      xName,
      yName,
      minName,
      q1Name,
      medianName,
      q3Name,
      maxName,
      tooltip
    } = this.properties;
    const { datum } = nodeDatum;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!xAxis || !yAxis || !this.properties.isValid())
      return "";
    const title = sparklines_util_exports.sanitizeHtml(yName);
    const contentData = [
      [xKey, xName, xAxis],
      [minKey, minName, yAxis],
      [q1Key, q1Name, yAxis],
      [medianKey, medianName, yAxis],
      [q3Key, q3Name, yAxis],
      [maxKey, maxName, yAxis]
    ];
    const content = contentData.map(([key, name, axis]) => sparklines_util_exports.sanitizeHtml(`${name != null ? name : key}: ${axis.formatDatum(datum[key])}`)).join(title ? "<br/>" : ", ");
    const { fill } = this.getFormattedStyles(nodeDatum);
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: fill },
      {
        seriesId: this.id,
        datum,
        fill,
        xKey,
        minKey,
        q1Key,
        medianKey,
        q3Key,
        maxKey,
        xName,
        minName,
        q1Name,
        medianName,
        q3Name,
        maxName
      }
    );
  }
  animateEmptyUpdateReady({
    datumSelections
  }) {
    const isVertical = this.isVertical();
    const { from, to } = prepareBoxPlotFromTo(isVertical);
    motion$1.resetMotion(datumSelections, resetBoxPlotSelectionsScalingCenterFn(isVertical));
    motion$1.staticFromToMotion(this.id, "datums", this.ctx.animationManager, datumSelections, from, to, {
      phase: "initial"
    });
  }
  isLabelEnabled() {
    return false;
  }
  updateDatumSelection(opts) {
    return __async$1(this, null, function* () {
      var _a2;
      const data = (_a2 = opts.nodeData) != null ? _a2 : [];
      return opts.datumSelection.update(data);
    });
  }
  updateDatumNodes(_0) {
    return __async$1(this, arguments, function* ({
      datumSelection,
      isHighlight: highlighted
    }) {
      var _a2;
      const isVertical = this.isVertical();
      const isReversedValueAxis = (_a2 = this.getValueAxis()) == null ? void 0 : _a2.isReversed();
      datumSelection.each((boxPlotGroup, nodeDatum) => {
        let activeStyles = this.getFormattedStyles(nodeDatum, highlighted);
        if (highlighted) {
          activeStyles = mergeDefaults4(this.properties.highlightStyle.item, activeStyles);
        }
        const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = activeStyles;
        activeStyles.whisker = mergeDefaults4(activeStyles.whisker, {
          stroke,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset
        });
        boxPlotGroup.updateDatumStyles(
          nodeDatum,
          activeStyles,
          isVertical,
          isReversedValueAxis
        );
      });
    });
  }
  updateLabelNodes(_opts) {
    return __async$1(this, null, function* () {
    });
  }
  updateLabelSelection(opts) {
    return __async$1(this, null, function* () {
      const { labelData, labelSelection } = opts;
      return labelSelection.update(labelData);
    });
  }
  nodeFactory() {
    return new BoxPlotGroup();
  }
  getFormattedStyles(nodeDatum, highlighted = false) {
    const {
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const { xKey, minKey, q1Key, medianKey, q3Key, maxKey, formatter } = this.properties;
    const { datum, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cap, whisker } = nodeDatum;
    const activeStyles = {
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cap: extractDecoratedProperties$1(cap),
      whisker: extractDecoratedProperties$1(whisker)
    };
    if (formatter) {
      const formatStyles = callbackCache.call(formatter, __spreadProps$1(__spreadValues$1({
        datum,
        seriesId,
        highlighted
      }, activeStyles), {
        xKey,
        minKey,
        q1Key,
        medianKey,
        q3Key,
        maxKey
      }));
      if (formatStyles) {
        return mergeDefaults4(formatStyles, activeStyles);
      }
    }
    return activeStyles;
  }
  convertValuesToScaleByDefs(defs, values) {
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!(xAxis && yAxis)) {
      throw new Error("Axes must be defined");
    }
    const result = {};
    for (const [searchId, [{ def }]] of defs) {
      if (Object.hasOwn(values, searchId)) {
        const { scale } = def.type === "key" ? xAxis : yAxis;
        result[searchId] = Math.round(scale.convert(values[searchId]));
      }
    }
    return result;
  }
};
_BoxPlotSeries.type = "box-plot";
var BoxPlotSeries = _BoxPlotSeries;
var BOX_PLOT_SERIES_THEME = {
  series: {
    __extends__: integrated_charts_theme_exports.EXTENDS_SERIES_DEFAULTS,
    direction: "vertical",
    strokeWidth: 2
  },
  axes: {
    [integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        snap: false
      }
    },
    [integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.CATEGORY]: {
      groupPaddingInner: 0.2,
      crosshair: {
        enabled: false,
        snap: false
      }
    }
  }
};

// packages/ag-charts-enterprise/src/series/box-plot/boxPlotModule.ts
var BoxPlotModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "box-plot",
  instanceConstructor: BoxPlotSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.NUMBER,
        position: integrated_charts_theme_exports.POSITION.LEFT
      },
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.CATEGORY,
        position: integrated_charts_theme_exports.POSITION.BOTTOM
      }
    ]
  },
  themeTemplate: BOX_PLOT_SERIES_THEME,
  groupable: true,
  paletteFactory: ({ takeColors, userPalette, themeTemplateParameters }) => {
    var _a2;
    const themeBackgroundColor = themeTemplateParameters.properties.get(integrated_charts_theme_exports.DEFAULT_BACKGROUND_COLOUR);
    const backgroundFill = (_a2 = Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor) != null ? _a2 : "white";
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill: userPalette ? fill : sparklines_util_exports.Color.interpolate(fill, backgroundFill)(0.7),
      stroke
    };
  },
  swapDefaultAxesCondition: ({ direction }) => direction === "horizontal"
};
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties2,
  BaseProperties: BaseProperties6,
  PropertiesArray: PropertiesArray$1,
  SeriesTooltip: SeriesTooltip2,
  Validate: Validate23,
  ARRAY: ARRAY2,
  COLOR_STRING: COLOR_STRING6,
  LINE_DASH: LINE_DASH5,
  OBJECT: OBJECT5,
  POSITIVE_NUMBER: POSITIVE_NUMBER9,
  RATIO: RATIO10,
  STRING: STRING6
} = module_support_exports;
var TargetStyle = class extends BaseProperties6 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.lengthRatio = 0.75;
  }
};
__decorateClass$1([
  Validate23(COLOR_STRING6)
], TargetStyle.prototype, "fill", 2);
__decorateClass$1([
  Validate23(RATIO10)
], TargetStyle.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate23(COLOR_STRING6)
], TargetStyle.prototype, "stroke", 2);
__decorateClass$1([
  Validate23(POSITIVE_NUMBER9)
], TargetStyle.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate23(RATIO10)
], TargetStyle.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate23(LINE_DASH5)
], TargetStyle.prototype, "lineDash", 2);
__decorateClass$1([
  Validate23(POSITIVE_NUMBER9)
], TargetStyle.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate23(RATIO10)
], TargetStyle.prototype, "lengthRatio", 2);
var BulletScale = class extends BaseProperties6 {
};
__decorateClass$1([
  Validate23(POSITIVE_NUMBER9, { optional: true })
], BulletScale.prototype, "max", 2);
var BulletColorRange = class extends BaseProperties6 {
  constructor() {
    super(...arguments);
    this.color = "lightgrey";
  }
};
__decorateClass$1([
  Validate23(COLOR_STRING6)
], BulletColorRange.prototype, "color", 2);
__decorateClass$1([
  Validate23(POSITIVE_NUMBER9, { optional: true })
], BulletColorRange.prototype, "stop", 2);
var BulletSeriesProperties = class extends AbstractBarSeriesProperties2 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.widthRatio = 0.5;
    this.colorRanges = new PropertiesArray$1(BulletColorRange);
    this.target = new TargetStyle();
    this.scale = new BulletScale();
    this.tooltip = new SeriesTooltip2();
    // Internal: Set by paletteFactory.
    this.backgroundFill = "white";
  }
};
__decorateClass$1([
  Validate23(STRING6)
], BulletSeriesProperties.prototype, "valueKey", 2);
__decorateClass$1([
  Validate23(STRING6, { optional: true })
], BulletSeriesProperties.prototype, "valueName", 2);
__decorateClass$1([
  Validate23(STRING6, { optional: true })
], BulletSeriesProperties.prototype, "targetKey", 2);
__decorateClass$1([
  Validate23(STRING6, { optional: true })
], BulletSeriesProperties.prototype, "targetName", 2);
__decorateClass$1([
  Validate23(COLOR_STRING6)
], BulletSeriesProperties.prototype, "fill", 2);
__decorateClass$1([
  Validate23(RATIO10)
], BulletSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate23(COLOR_STRING6)
], BulletSeriesProperties.prototype, "stroke", 2);
__decorateClass$1([
  Validate23(POSITIVE_NUMBER9)
], BulletSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate23(RATIO10)
], BulletSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate23(LINE_DASH5)
], BulletSeriesProperties.prototype, "lineDash", 2);
__decorateClass$1([
  Validate23(POSITIVE_NUMBER9)
], BulletSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate23(RATIO10)
], BulletSeriesProperties.prototype, "widthRatio", 2);
__decorateClass$1([
  Validate23(ARRAY2.restrict({ minLength: 0 }))
], BulletSeriesProperties.prototype, "colorRanges", 2);
__decorateClass$1([
  Validate23(OBJECT5)
], BulletSeriesProperties.prototype, "target", 2);
__decorateClass$1([
  Validate23(OBJECT5)
], BulletSeriesProperties.prototype, "scale", 2);
__decorateClass$1([
  Validate23(OBJECT5)
], BulletSeriesProperties.prototype, "tooltip", 2);
__decorateClass$1([
  Validate23(COLOR_STRING6)
], BulletSeriesProperties.prototype, "backgroundFill", 2);

// packages/ag-charts-enterprise/src/series/bullet/bulletSeries.ts
var {
  animationValidation: animationValidation2,
  collapsedStartingBarPosition: collapsedStartingBarPosition$1,
  diff: diff2,
  keyProperty: keyProperty2,
  partialAssign: partialAssign2,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions$1,
  resetBarSelectionsFn: resetBarSelectionsFn$1,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation$1,
  valueProperty: valueProperty3,
  createDatumId: createDatumId$1
} = module_support_exports;
var { fromToMotion: fromToMotion$1 } = integrated_charts_scene_exports.motion;
var { sanitizeHtml: sanitizeHtml$1 } = sparklines_util_exports;
var STYLING_KEYS = [
  "fill",
  "fillOpacity",
  "stroke",
  "strokeWidth",
  "strokeOpacity",
  "lineDash",
  "lineDashOffset"
];
var BulletSeries = class _BulletSeries extends module_support_exports.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [module_support_exports.SeriesNodePickMode.EXACT_SHAPE_MATCH],
      hasHighlightedLabels: true,
      animationResetFns: {
        datum: resetBarSelectionsFn$1
      }
    });
    this.properties = new BulletSeriesProperties();
    this.normalizedColorRanges = [];
    this.colorRangesGroup = new integrated_charts_scene_exports.Group({ name: `${this.id}-colorRanges` });
    this.colorRangesSelection = integrated_charts_scene_exports.Selection.select(this.colorRangesGroup, integrated_charts_scene_exports.Rect, false);
    this.rootGroup.append(this.colorRangesGroup);
    this.targetLinesSelection = integrated_charts_scene_exports.Selection.select(this.annotationGroup, integrated_charts_scene_exports.Line, false);
  }
  destroy() {
    this.rootGroup.removeChild(this.colorRangesGroup);
    super.destroy();
  }
  processData(dataController) {
    return __async$1(this, null, function* () {
      var _a2, _b;
      if (!this.properties.isValid() || !this.data) {
        return;
      }
      const { valueKey, targetKey } = this.properties;
      const isContinuousX = sparklines_scale_exports.ContinuousScale.is((_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale);
      const isContinuousY = sparklines_scale_exports.ContinuousScale.is((_b = this.getValueAxis()) == null ? void 0 : _b.scale);
      const extraProps = [];
      if (targetKey !== void 0) {
        extraProps.push(valueProperty3(this, targetKey, isContinuousY, { id: "target" }));
      }
      if (!this.ctx.animationManager.isSkipped()) {
        if (this.processedData !== void 0) {
          extraProps.push(diff2(this.processedData));
        }
        extraProps.push(animationValidation2(this));
      }
      yield this.requestDataModel(dataController, this.data.slice(0, 1), {
        props: [
          keyProperty2(this, valueKey, isContinuousX, { id: "xValue" }),
          valueProperty3(this, valueKey, isContinuousY, { id: "value" }),
          ...extraProps
        ],
        groupByKeys: true,
        dataVisible: this.visible
      });
      this.animationState.transition("updateData");
    });
  }
  getBandScalePadding() {
    return { inner: 0, outer: 0 };
  }
  getMaxValue() {
    var _a2, _b;
    return Math.max(...(_b = (_a2 = this.getValueAxis()) == null ? void 0 : _a2.dataDomain.domain) != null ? _b : [0]);
  }
  getSeriesDomain(direction) {
    var _a2, _b;
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return [];
    }
    const { valueKey, targetKey, valueName, scale } = this.properties;
    if (direction === this.getCategoryDirection()) {
      return [valueName != null ? valueName : valueKey];
    }
    if (direction == ((_a2 = this.getValueAxis()) == null ? void 0 : _a2.direction)) {
      const valueDomain = dataModel.getDomain(this, "value", "value", processedData);
      const targetDomain = targetKey === void 0 ? [] : dataModel.getDomain(this, "target", "value", processedData);
      return [0, (_b = scale.max) != null ? _b : Math.max(...valueDomain, ...targetDomain)];
    }
    throw new Error(`unknown direction ${direction}`);
  }
  getKeys(direction) {
    if (direction === this.getBarDirection()) {
      return [this.properties.valueKey];
    }
    return super.getKeys(direction);
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      var _a2, _b, _c, _d;
      const { dataModel, processedData } = this;
      const {
        valueKey,
        targetKey,
        widthRatio,
        target: { lengthRatio }
      } = this.properties;
      const xScale = (_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale;
      const yScale = (_b = this.getValueAxis()) == null ? void 0 : _b.scale;
      if (!valueKey || !dataModel || !processedData || !xScale || !yScale)
        return [];
      if (widthRatio === void 0 || lengthRatio === void 0)
        return [];
      const multiplier = (_c = xScale.bandwidth) != null ? _c : NaN;
      const maxValue = this.getMaxValue();
      const valueIndex = dataModel.resolveProcessedDataIndexById(this, "value").index;
      const targetIndex = targetKey === void 0 ? NaN : dataModel.resolveProcessedDataIndexById(this, "target").index;
      const context = {
        itemId: valueKey,
        nodeData: [],
        labelData: [],
        scales: __superGet$1(_BulletSeries.prototype, this, "calculateScaling").call(this),
        visible: this.visible
      };
      for (const { datum, values } of processedData.data) {
        if (!Array.isArray(datum) || datum.length < 1) {
          continue;
        }
        if (values[0][valueIndex] < 0) {
          sparklines_util_exports.Logger.warnOnce("negative values are not supported, clipping to 0.");
        }
        const xValue = (_d = this.properties.valueName) != null ? _d : this.properties.valueKey;
        const yValue = Math.min(maxValue, Math.max(0, values[0][valueIndex]));
        const y = yScale.convert(yValue);
        const barWidth = widthRatio * multiplier;
        const bottomY = yScale.convert(0);
        const barAlongX = this.getBarDirection() === module_support_exports.ChartAxisDirection.X;
        const rect = {
          x: multiplier * (1 - widthRatio) / 2,
          y: Math.min(y, bottomY),
          width: barWidth,
          height: Math.abs(bottomY - y)
        };
        if (barAlongX) {
          [rect.x, rect.y, rect.width, rect.height] = [rect.y, rect.x, rect.height, rect.width];
        }
        let target;
        if (values[0][targetIndex] < 0) {
          sparklines_util_exports.Logger.warnOnce("negative targets are not supported, ignoring.");
        }
        if (this.properties.targetKey && values[0][targetIndex] >= 0) {
          const targetLineLength = lengthRatio * multiplier;
          const targetValue = Math.min(maxValue, values[0][targetIndex]);
          if (!isNaN(targetValue) && targetValue !== void 0) {
            const convertedY = yScale.convert(targetValue);
            let x1 = multiplier * (1 - lengthRatio) / 2;
            let x2 = x1 + targetLineLength;
            let [y1, y2] = [convertedY, convertedY];
            if (barAlongX) {
              [x1, x2, y1, y2] = [y1, y2, x1, x2];
            }
            target = { value: targetValue, x1, x2, y1, y2 };
          }
        }
        const nodeData = __spreadProps$1(__spreadValues$1({
          series: this,
          datum: datum[0],
          xKey: valueKey,
          xValue,
          yKey: valueKey,
          yValue,
          cumulativeValue: yValue,
          target
        }, rect), {
          midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },
          opacity: 1
        });
        context.nodeData.push(nodeData);
      }
      const sortedRanges = [...this.getColorRanges()].sort((a, b) => (a.stop || maxValue) - (b.stop || maxValue));
      let start = 0;
      this.normalizedColorRanges = sortedRanges.map((item) => {
        var _a3;
        const stop = Math.min(maxValue, (_a3 = item.stop) != null ? _a3 : Infinity);
        const result = { color: item.color, start, stop };
        start = stop;
        return result;
      });
      return [context];
    });
  }
  getColorRanges() {
    const { colorRanges, fill, backgroundFill } = this.properties;
    if (colorRanges !== void 0 && colorRanges.length > 0) {
      return colorRanges;
    }
    const defaultColorRange = new BulletColorRange();
    defaultColorRange.color = sparklines_util_exports.Color.interpolate(fill, backgroundFill)(0.7);
    return [defaultColorRange];
  }
  getLegendData(_legendType) {
    return [];
  }
  getTooltipHtml(nodeDatum) {
    const { valueKey, valueName, targetKey, targetName } = this.properties;
    const axis = this.getValueAxis();
    const { yValue: valueValue, target: { value: targetValue } = { value: void 0 }, datum } = nodeDatum;
    if (valueKey === void 0 || valueValue === void 0 || axis === void 0) {
      return "";
    }
    const makeLine = (key, name, value) => {
      const nameString = sanitizeHtml$1(name != null ? name : key);
      const valueString = sanitizeHtml$1(axis.formatDatum(value));
      return `<b>${nameString}</b>: ${valueString}`;
    };
    const title = void 0;
    const content = targetKey === void 0 || targetValue === void 0 ? makeLine(valueKey, valueName, valueValue) : `${makeLine(valueKey, valueName, valueValue)}<br/>${makeLine(targetKey, targetName, targetValue)}`;
    return this.properties.tooltip.toTooltipHtml(
      { title, content, backgroundColor: this.properties.fill },
      { datum, title, seriesId: this.id, valueKey, valueName, targetKey, targetName }
    );
  }
  isLabelEnabled() {
    return false;
  }
  nodeFactory() {
    return new integrated_charts_scene_exports.Rect();
  }
  updateDatumSelection(opts) {
    return __async$1(this, null, function* () {
      this.targetLinesSelection.update(opts.nodeData, void 0, void 0);
      return opts.datumSelection.update(opts.nodeData, void 0, void 0);
    });
  }
  updateDatumNodes(opts) {
    return __async$1(this, null, function* () {
      for (const { node } of opts.datumSelection) {
        const style = this.properties;
        partialAssign2(STYLING_KEYS, node, style);
      }
      for (const { node, datum } of this.targetLinesSelection) {
        if (datum.target !== void 0) {
          const style = this.properties.target;
          partialAssign2(["x1", "x2", "y1", "y2"], node, datum.target);
          partialAssign2(STYLING_KEYS, node, style);
        } else {
          node.visible = false;
        }
      }
    });
  }
  updateColorRanges() {
    return __async$1(this, null, function* () {
      const valAxis = this.getValueAxis();
      const catAxis = this.getCategoryAxis();
      if (!valAxis || !catAxis)
        return;
      const [min, max] = [0, Math.max(...catAxis.scale.range)];
      const computeRect = this.getBarDirection() === module_support_exports.ChartAxisDirection.Y ? (rect, colorRange) => {
        rect.x = min;
        rect.y = valAxis.scale.convert(colorRange.stop);
        rect.height = valAxis.scale.convert(colorRange.start) - rect.y;
        rect.width = max;
      } : (rect, colorRange) => {
        rect.x = valAxis.scale.convert(colorRange.start);
        rect.y = min;
        rect.height = max;
        rect.width = valAxis.scale.convert(colorRange.stop) - rect.x;
      };
      this.colorRangesSelection.update(this.normalizedColorRanges);
      for (const { node, datum } of this.colorRangesSelection) {
        computeRect(node, datum);
        node.fill = datum.color;
      }
    });
  }
  updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {
    return __async$1(this, null, function* () {
      __superGet$1(_BulletSeries.prototype, this, "updateNodes").call(this, highlightedItems, seriesHighlighted, anySeriesItemEnabled);
      yield this.updateColorRanges();
    });
  }
  updateLabelSelection(opts) {
    return __async$1(this, null, function* () {
      return opts.labelSelection;
    });
  }
  updateLabelNodes(_opts) {
    return __async$1(this, null, function* () {
    });
  }
  animateEmptyUpdateReady(data) {
    const { datumSelections, labelSelections, annotationSelections } = data;
    const fns = prepareBarAnimationFunctions$1(collapsedStartingBarPosition$1(this.isVertical(), this.axes, "normal"));
    fromToMotion$1(this.id, "nodes", this.ctx.animationManager, datumSelections, fns);
    seriesLabelFadeInAnimation$1(this, "labels", this.ctx.animationManager, labelSelections);
    seriesLabelFadeInAnimation$1(this, "annotations", this.ctx.animationManager, annotationSelections);
  }
  animateWaitingUpdateReady(data) {
    var _a2, _b, _c;
    const { datumSelections, labelSelections, annotationSelections } = data;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const diff7 = (_b = (_a2 = this.processedData) == null ? void 0 : _a2.reduced) == null ? void 0 : _b.diff;
    const fns = prepareBarAnimationFunctions$1(collapsedStartingBarPosition$1(this.isVertical(), this.axes, "normal"));
    fromToMotion$1(
      this.id,
      "nodes",
      this.ctx.animationManager,
      datumSelections,
      fns,
      (_, datum) => createDatumId$1(datum.xValue),
      diff7
    );
    const hasMotion = (_c = diff7 == null ? void 0 : diff7.changed) != null ? _c : true;
    if (hasMotion) {
      seriesLabelFadeInAnimation$1(this, "labels", this.ctx.animationManager, labelSelections);
      seriesLabelFadeInAnimation$1(this, "annotations", this.ctx.animationManager, annotationSelections);
    }
  }
};
var BULLET_SERIES_THEME = {
  series: {
    direction: "vertical",
    strokeWidth: 0,
    strokeOpacity: 1,
    fillOpacity: 1,
    widthRatio: 0.5,
    target: {
      strokeWidth: 3,
      strokeOpacity: 1,
      lengthRatio: 0.75
    }
  },
  axes: {
    [integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.NUMBER]: {
      nice: false,
      crosshair: {
        enabled: false
      }
    }
  }
};

// packages/ag-charts-enterprise/src/series/bullet/bulletModule.ts
var BulletModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "bullet",
  solo: true,
  instanceConstructor: BulletSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.NUMBER,
        position: integrated_charts_theme_exports.POSITION.LEFT
      },
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.CATEGORY,
        position: integrated_charts_theme_exports.POSITION.BOTTOM
      }
    ]
  },
  themeTemplate: BULLET_SERIES_THEME,
  swapDefaultAxesCondition: (series) => (series == null ? void 0 : series.direction) === "horizontal",
  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {
    var _a2;
    const { properties } = themeTemplateParameters;
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(colorsCount);
    const themeBackgroundColor = themeTemplateParameters.properties.get(integrated_charts_theme_exports.DEFAULT_BACKGROUND_COLOUR);
    const backgroundFill = (_a2 = Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor) != null ? _a2 : "white";
    const targetStroke = properties.get(integrated_charts_theme_exports.DEFAULT_CROSS_LINES_COLOUR);
    return {
      fill,
      stroke,
      target: { stroke: targetStroke },
      backgroundFill
    };
  }
};
var { Validate: Validate24, NUMBER: NUMBER7, TEXT_WRAP: TEXT_WRAP$1, OVERFLOW_STRATEGY: OVERFLOW_STRATEGY$1 } = module_support_exports;
var { Logger: Logger4 } = sparklines_util_exports;
var { Text: Text5, Label: Label$1 } = integrated_charts_scene_exports;
var BaseAutoSizedLabel = class extends Label$1 {
  constructor() {
    super(...arguments);
    this.wrapping = "on-space";
    this.overflowStrategy = "ellipsis";
  }
  static lineHeight(fontSize) {
    return Math.ceil(fontSize * Text5.defaultLineHeightRatio);
  }
};
__decorateClass$1([
  Validate24(TEXT_WRAP$1)
], BaseAutoSizedLabel.prototype, "wrapping", 2);
__decorateClass$1([
  Validate24(OVERFLOW_STRATEGY$1)
], BaseAutoSizedLabel.prototype, "overflowStrategy", 2);
__decorateClass$1([
  Validate24(NUMBER7, { optional: true })
], BaseAutoSizedLabel.prototype, "minimumFontSize", 2);
var AutoSizedLabel = class extends BaseAutoSizedLabel {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass$1([
  Validate24(NUMBER7)
], AutoSizedLabel.prototype, "spacing", 2);
var AutoSizeableSecondaryLabel = class extends BaseAutoSizedLabel {
};
function generateLabelSecondaryLabelFontSizeCandidates(label, secondaryLabel) {
  const { fontSize: labelFontSize, minimumFontSize: labelMinimumFontSize = labelFontSize } = label;
  const {
    fontSize: secondaryLabelFontSize,
    minimumFontSize: secondaryLabelMinimumFontSize = secondaryLabelFontSize
  } = secondaryLabel;
  const labelTracks = labelFontSize - labelMinimumFontSize;
  const secondaryLabelTracks = secondaryLabelFontSize - secondaryLabelMinimumFontSize;
  let currentLabelFontSize = label.fontSize;
  let currentSecondaryLabelFontSize = secondaryLabel.fontSize;
  const out = [{ labelFontSize, secondaryLabelFontSize }];
  while (currentLabelFontSize > labelMinimumFontSize || currentSecondaryLabelFontSize > secondaryLabelMinimumFontSize) {
    const labelProgress = labelTracks > 0 ? (currentLabelFontSize - labelMinimumFontSize) / labelTracks : -1;
    const secondaryLabelProgress = secondaryLabelTracks > 0 ? (currentSecondaryLabelFontSize - secondaryLabelMinimumFontSize) / secondaryLabelTracks : -1;
    if (labelProgress > secondaryLabelProgress) {
      currentLabelFontSize--;
    } else {
      currentSecondaryLabelFontSize--;
    }
    out.push({
      labelFontSize: currentLabelFontSize,
      secondaryLabelFontSize: currentSecondaryLabelFontSize
    });
  }
  out.reverse();
  return out;
}
function maximumValueSatisfying(from, to, iteratee) {
  if (from > to) {
    return void 0;
  }
  let min = from;
  let max = to;
  let found;
  while (max >= min) {
    const index = (max + min) / 2 | 0;
    const value = iteratee(index);
    if (value != null) {
      found = value;
      min = index + 1;
    } else {
      max = index - 1;
    }
  }
  return found;
}
function formatStackedLabels(labelValue, labelProps, secondaryLabelValue, secondaryLabelProps, { padding }, sizeFittingHeight) {
  var _a2, _b;
  const { spacing } = labelProps;
  const widthAdjust = 2 * padding;
  const heightAdjust = 2 * padding + spacing;
  const minimumHeight = ((_a2 = labelProps.minimumFontSize) != null ? _a2 : labelProps.fontSize) + ((_b = secondaryLabelProps.minimumFontSize) != null ? _b : secondaryLabelProps.fontSize);
  if (minimumHeight > sizeFittingHeight(minimumHeight + heightAdjust).height - heightAdjust) {
    return void 0;
  }
  const fontSizeCandidates = generateLabelSecondaryLabelFontSizeCandidates(labelProps, secondaryLabelProps);
  const labelTextNode = new Text5();
  labelTextNode.setFont(labelProps);
  const labelTextSizeProps = {
    fontFamily: labelProps.fontFamily,
    fontSize: labelProps.fontSize,
    fontStyle: labelProps.fontStyle,
    fontWeight: labelProps.fontWeight
  };
  const secondaryLabelTextNode = new Text5();
  secondaryLabelTextNode.setFont(secondaryLabelProps);
  const secondaryLabelTextSizeProps = {
    fontFamily: secondaryLabelProps.fontFamily,
    fontSize: secondaryLabelProps.fontSize,
    fontStyle: secondaryLabelProps.fontStyle,
    fontWeight: secondaryLabelProps.fontWeight
  };
  let label;
  let secondaryLabel;
  return maximumValueSatisfying(0, fontSizeCandidates.length - 1, (index) => {
    const { labelFontSize, secondaryLabelFontSize } = fontSizeCandidates[index];
    const allowTruncation = index === 0;
    const labelLineHeight = AutoSizedLabel.lineHeight(labelFontSize);
    const secondaryLabelLineHeight = AutoSizeableSecondaryLabel.lineHeight(secondaryLabelFontSize);
    const sizeFitting = sizeFittingHeight(labelLineHeight + secondaryLabelLineHeight + heightAdjust);
    const availableWidth = sizeFitting.width - widthAdjust;
    const availableHeight = sizeFitting.height - heightAdjust;
    if (labelLineHeight + secondaryLabelLineHeight > availableHeight) {
      return void 0;
    }
    if (label == null || label.fontSize !== labelFontSize) {
      labelTextSizeProps.fontSize = labelFontSize;
      const { lines: labelLines } = Text5.wrapLines(
        labelValue,
        availableWidth,
        availableHeight,
        labelTextSizeProps,
        labelProps.wrapping,
        allowTruncation ? labelProps.overflowStrategy : "hide"
      );
      if (labelLines != null) {
        const labelText = labelLines.join("\n");
        labelTextNode.text = labelText;
        labelTextNode.fontSize = labelFontSize;
        labelTextNode.lineHeight = labelFontSize;
        const labelWidth = labelTextNode.computeBBox().width;
        const labelHeight = labelLines.length * labelLineHeight;
        label = {
          text: labelText,
          fontSize: labelFontSize,
          lineHeight: labelLineHeight,
          width: labelWidth,
          height: labelHeight
        };
      } else {
        label = void 0;
      }
    }
    if (label == null || label.width > availableWidth || label.height > availableHeight) {
      return void 0;
    }
    if (secondaryLabel == null || secondaryLabel.fontSize !== secondaryLabelFontSize) {
      secondaryLabelTextSizeProps.fontSize = secondaryLabelFontSize;
      const { lines: secondaryLabelLines } = Text5.wrapLines(
        secondaryLabelValue,
        availableWidth,
        availableHeight,
        secondaryLabelTextSizeProps,
        secondaryLabelProps.wrapping,
        allowTruncation ? secondaryLabelProps.overflowStrategy : "hide"
      );
      if (secondaryLabelLines != null) {
        const secondaryLabelText = secondaryLabelLines.join("\n");
        secondaryLabelTextNode.text = secondaryLabelText;
        secondaryLabelTextNode.fontSize = secondaryLabelFontSize;
        secondaryLabelTextNode.lineHeight = secondaryLabelLineHeight;
        const secondaryLabelWidth = secondaryLabelTextNode.computeBBox().width;
        const secondaryLabelHeight = secondaryLabelLines.length * secondaryLabelLineHeight;
        secondaryLabel = {
          text: secondaryLabelText,
          fontSize: secondaryLabelFontSize,
          lineHeight: secondaryLabelLineHeight,
          width: secondaryLabelWidth,
          height: secondaryLabelHeight
        };
      } else {
        secondaryLabel = void 0;
      }
    }
    if (secondaryLabel == null) {
      return void 0;
    }
    const totalLabelHeight = label.height + secondaryLabel.height;
    if (secondaryLabel.width > availableWidth || totalLabelHeight > availableHeight) {
      return void 0;
    }
    return {
      width: Math.max(label.width, secondaryLabel.width),
      height: totalLabelHeight + spacing,
      meta: sizeFitting.meta,
      label,
      secondaryLabel
    };
  });
}
function formatSingleLabel(value, props, { padding }, sizeFittingHeight) {
  var _a2;
  const sizeAdjust = 2 * padding;
  const minimumFontSize = Math.min((_a2 = props.minimumFontSize) != null ? _a2 : props.fontSize, props.fontSize);
  const textNode = new Text5();
  textNode.setFont(props);
  const textSizeProps = {
    fontFamily: props.fontFamily,
    fontSize: props.fontSize,
    fontStyle: props.fontStyle,
    fontWeight: props.fontWeight
  };
  return maximumValueSatisfying(minimumFontSize, props.fontSize, (fontSize) => {
    const lineHeight = AutoSizedLabel.lineHeight(fontSize);
    const sizeFitting = sizeFittingHeight(lineHeight + sizeAdjust);
    const availableWidth = sizeFitting.width - sizeAdjust;
    const availableHeight = sizeFitting.height - sizeAdjust;
    if (lineHeight > availableHeight) {
      return void 0;
    }
    const allowTruncation = fontSize === minimumFontSize;
    textSizeProps.fontSize = fontSize;
    const { lines } = Text5.wrapLines(
      value,
      availableWidth,
      availableHeight,
      textSizeProps,
      props.wrapping,
      allowTruncation ? props.overflowStrategy : "hide"
    );
    if (lines == null) {
      return void 0;
    }
    const text = lines.join("\n");
    textNode.text = text;
    textNode.fontSize = fontSize;
    textNode.lineHeight = lineHeight;
    const size = textNode.computeBBox();
    const width = textNode.computeBBox().width;
    const height = lineHeight * lines.length;
    if (size.width > availableWidth || height > availableHeight) {
      return void 0;
    }
    return [{ text, fontSize, lineHeight, width, height }, sizeFitting.meta];
  });
}
function hasInvalidFontSize(label) {
  return label != null && label.minimumFontSize != null && label.fontSize && label.minimumFontSize > label.fontSize;
}
function formatLabels(baseLabelValue, labelProps, baseSecondaryLabelValue, secondaryLabelProps, layoutParams, sizeFittingHeight) {
  const labelValue = labelProps.enabled ? baseLabelValue : void 0;
  const secondaryLabelValue = secondaryLabelProps.enabled ? baseSecondaryLabelValue : void 0;
  if (hasInvalidFontSize(labelProps) || hasInvalidFontSize(secondaryLabelProps)) {
    Logger4.warnOnce(`minimumFontSize should be set to a value less than or equal to the font size`);
  }
  let value;
  if (labelValue != null && secondaryLabelValue != null) {
    value = formatStackedLabels(
      labelValue,
      labelProps,
      secondaryLabelValue,
      secondaryLabelProps,
      layoutParams,
      sizeFittingHeight
    );
  }
  let labelMeta;
  if (value == null && labelValue != null) {
    labelMeta = formatSingleLabel(labelValue, labelProps, layoutParams, sizeFittingHeight);
  }
  if (labelMeta != null) {
    const [label, meta] = labelMeta;
    value = {
      width: label.width,
      height: label.height,
      meta,
      label,
      secondaryLabel: void 0
    };
  }
  let secondaryLabelMeta;
  if (value == null && labelValue == null && secondaryLabelValue != null) {
    secondaryLabelMeta = formatSingleLabel(
      secondaryLabelValue,
      secondaryLabelProps,
      layoutParams,
      sizeFittingHeight
    );
  }
  if (secondaryLabelMeta != null) {
    const [secondaryLabel, meta] = secondaryLabelMeta;
    value = {
      width: secondaryLabel.width,
      height: secondaryLabel.height,
      meta,
      label: void 0,
      secondaryLabel
    };
  }
  return value;
}
var {
  CartesianSeriesProperties: CartesianSeriesProperties$1,
  SeriesTooltip: SeriesTooltip3,
  Validate: Validate25,
  AND: AND5,
  ARRAY: ARRAY3,
  COLOR_STRING: COLOR_STRING7,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY$1,
  FUNCTION: FUNCTION5,
  OBJECT: OBJECT6,
  POSITIVE_NUMBER: POSITIVE_NUMBER10,
  RATIO: RATIO11,
  STRING: STRING7,
  TEXT_ALIGN: TEXT_ALIGN$1,
  VERTICAL_ALIGN: VERTICAL_ALIGN$1
} = module_support_exports;
var HeatmapSeriesProperties = class extends CartesianSeriesProperties$1 {
  constructor() {
    super(...arguments);
    this.colorRange = ["black", "black"];
    this.stroke = "black";
    this.strokeWidth = 0;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.itemPadding = 0;
    this.label = new AutoSizedLabel();
    this.tooltip = new SeriesTooltip3();
  }
};
__decorateClass$1([
  Validate25(STRING7, { optional: true })
], HeatmapSeriesProperties.prototype, "title", 2);
__decorateClass$1([
  Validate25(STRING7)
], HeatmapSeriesProperties.prototype, "xKey", 2);
__decorateClass$1([
  Validate25(STRING7)
], HeatmapSeriesProperties.prototype, "yKey", 2);
__decorateClass$1([
  Validate25(STRING7, { optional: true })
], HeatmapSeriesProperties.prototype, "colorKey", 2);
__decorateClass$1([
  Validate25(STRING7, { optional: true })
], HeatmapSeriesProperties.prototype, "xName", 2);
__decorateClass$1([
  Validate25(STRING7, { optional: true })
], HeatmapSeriesProperties.prototype, "yName", 2);
__decorateClass$1([
  Validate25(STRING7, { optional: true })
], HeatmapSeriesProperties.prototype, "colorName", 2);
__decorateClass$1([
  Validate25(AND5(COLOR_STRING_ARRAY$1, ARRAY3.restrict({ minLength: 1 })))
], HeatmapSeriesProperties.prototype, "colorRange", 2);
__decorateClass$1([
  Validate25(COLOR_STRING7, { optional: true })
], HeatmapSeriesProperties.prototype, "stroke", 2);
__decorateClass$1([
  Validate25(RATIO11, { optional: true })
], HeatmapSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate25(POSITIVE_NUMBER10, { optional: true })
], HeatmapSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate25(TEXT_ALIGN$1)
], HeatmapSeriesProperties.prototype, "textAlign", 2);
__decorateClass$1([
  Validate25(VERTICAL_ALIGN$1)
], HeatmapSeriesProperties.prototype, "verticalAlign", 2);
__decorateClass$1([
  Validate25(POSITIVE_NUMBER10)
], HeatmapSeriesProperties.prototype, "itemPadding", 2);
__decorateClass$1([
  Validate25(FUNCTION5, { optional: true })
], HeatmapSeriesProperties.prototype, "formatter", 2);
__decorateClass$1([
  Validate25(OBJECT6)
], HeatmapSeriesProperties.prototype, "label", 2);
__decorateClass$1([
  Validate25(OBJECT6)
], HeatmapSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/heatmap/heatmapSeries.ts
var { SeriesNodePickMode: SeriesNodePickMode2, getMissCount: getMissCount$1, valueProperty: valueProperty4, ChartAxisDirection: ChartAxisDirection9 } = module_support_exports;
var { Rect: Rect2, PointerEvents: PointerEvents$1 } = integrated_charts_scene_exports;
var { ColorScale: ColorScale$1 } = sparklines_scale_exports;
var { sanitizeHtml: sanitizeHtml2, Color: Color$1, Logger: Logger5 } = sparklines_util_exports;
var HeatmapSeriesNodeClickEvent = class extends module_support_exports.CartesianSeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.colorKey = series.properties.colorKey;
  }
};
var textAlignFactors = {
  left: -0.5,
  center: 0,
  right: -0.5
};
var verticalAlignFactors = {
  top: -0.5,
  middle: 0,
  bottom: -0.5
};
var _HeatmapSeries = class _HeatmapSeries extends module_support_exports.CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode2.EXACT_SHAPE_MATCH],
      pathsPerSeries: 0,
      hasMarkers: false,
      hasHighlightedLabels: true
    });
    this.properties = new HeatmapSeriesProperties();
    this.NodeClickEvent = HeatmapSeriesNodeClickEvent;
    this.colorScale = new ColorScale$1();
  }
  processData(dataController) {
    return __async$1(this, null, function* () {
      var _a2;
      const xAxis = this.axes[ChartAxisDirection9.X];
      const yAxis = this.axes[ChartAxisDirection9.Y];
      if (!xAxis || !yAxis || !this.properties.isValid() || !((_a2 = this.data) == null ? void 0 : _a2.length)) {
        return;
      }
      const { xKey, yKey, colorRange, colorKey } = this.properties;
      const { isContinuousX, isContinuousY } = this.isContinuous();
      const { dataModel, processedData } = yield this.requestDataModel(dataController, this.data, {
        props: [
          valueProperty4(this, xKey, isContinuousX, { id: "xValue" }),
          valueProperty4(this, yKey, isContinuousY, { id: "yValue" }),
          ...colorKey ? [valueProperty4(this, colorKey, true, { id: "colorValue" })] : []
        ]
      });
      if (this.isColorScaleValid()) {
        const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue").index;
        this.colorScale.domain = processedData.domain.values[colorKeyIdx];
        this.colorScale.range = colorRange;
        this.colorScale.update();
      }
    });
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorDataIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue").index;
    const dataCount = processedData.data.length;
    const missCount = getMissCount$1(this, processedData.defs.values[colorDataIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return [];
    if (direction === ChartAxisDirection9.X) {
      return dataModel.getDomain(this, `xValue`, "value", processedData);
    } else {
      return dataModel.getDomain(this, `yValue`, "value", processedData);
    }
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g;
      const { data, visible, axes, dataModel } = this;
      const xAxis = axes[ChartAxisDirection9.X];
      const yAxis = axes[ChartAxisDirection9.Y];
      if (!(data && dataModel && visible && xAxis && yAxis)) {
        return [];
      }
      if (xAxis.type !== "category" || yAxis.type !== "category") {
        Logger5.warnOnce(
          `Heatmap series expected axes to have "category" type, but received "${xAxis.type}" and "${yAxis.type}" instead.`
        );
        return [];
      }
      const {
        xKey,
        xName,
        yKey,
        yName,
        colorKey,
        colorName,
        textAlign,
        verticalAlign,
        itemPadding,
        colorRange,
        label
      } = this.properties;
      const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;
      const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;
      const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`).index : void 0;
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const xOffset = ((_a2 = xScale.bandwidth) != null ? _a2 : 0) / 2;
      const yOffset = ((_b = yScale.bandwidth) != null ? _b : 0) / 2;
      const colorScaleValid = this.isColorScaleValid();
      const nodeData = [];
      const labelData = [];
      const width = (_c = xScale.bandwidth) != null ? _c : 10;
      const height = (_d = yScale.bandwidth) != null ? _d : 10;
      const textAlignFactor = (width - 2 * itemPadding) * textAlignFactors[textAlign];
      const verticalAlignFactor = (height - 2 * itemPadding) * verticalAlignFactors[verticalAlign];
      const sizeFittingHeight = () => ({ width, height, meta: null });
      for (const { values, datum } of (_f = (_e = this.processedData) == null ? void 0 : _e.data) != null ? _f : []) {
        const xDatum = values[xDataIdx];
        const yDatum = values[yDataIdx];
        const x = xScale.convert(xDatum) + xOffset;
        const y = yScale.convert(yDatum) + yOffset;
        const colorValue = colorDataIdx != null ? values[colorDataIdx] : void 0;
        const fill = colorScaleValid && colorValue != null ? this.colorScale.convert(colorValue) : colorRange[0];
        const labelText = colorValue != null ? this.getLabelText(label, {
          value: colorValue,
          datum,
          colorKey,
          colorName,
          xKey,
          yKey,
          xName,
          yName
        }) : void 0;
        const labels = formatLabels(
          labelText,
          this.properties.label,
          void 0,
          this.properties.label,
          { padding: itemPadding },
          sizeFittingHeight
        );
        const point = { x, y, size: 0 };
        nodeData.push({
          series: this,
          itemId: yKey,
          yKey,
          xKey,
          xValue: xDatum,
          yValue: yDatum,
          colorValue,
          datum,
          point,
          width,
          height,
          fill,
          midPoint: { x, y }
        });
        if ((labels == null ? void 0 : labels.label) != null) {
          const { text, fontSize, lineHeight, height: labelHeight } = labels.label;
          const { fontStyle, fontFamily, fontWeight, color } = this.properties.label;
          const x2 = point.x + textAlignFactor * (width - 2 * itemPadding);
          const y2 = point.y + verticalAlignFactor * (height - 2 * itemPadding) - (labels.height - labelHeight) * 0.5;
          labelData.push({
            series: this,
            itemId: yKey,
            datum,
            text,
            fontSize,
            lineHeight,
            fontStyle,
            fontFamily,
            fontWeight,
            color,
            textAlign,
            verticalAlign,
            x: x2,
            y: y2
          });
        }
      }
      return [
        {
          itemId: (_g = this.properties.yKey) != null ? _g : this.id,
          nodeData,
          labelData,
          scales: __superGet$1(_HeatmapSeries.prototype, this, "calculateScaling").call(this),
          visible: this.visible
        }
      ];
    });
  }
  nodeFactory() {
    return new Rect2();
  }
  updateDatumSelection(opts) {
    return __async$1(this, null, function* () {
      const { nodeData, datumSelection } = opts;
      const data = nodeData != null ? nodeData : [];
      return datumSelection.update(data);
    });
  }
  updateDatumNodes(opts) {
    return __async$1(this, null, function* () {
      var _a2;
      const { isHighlight: isDatumHighlighted } = opts;
      const {
        id: seriesId,
        ctx: { callbackCache }
      } = this;
      const {
        xKey,
        yKey,
        colorKey,
        formatter,
        highlightStyle: {
          item: {
            fill: highlightedFill,
            stroke: highlightedStroke,
            strokeWidth: highlightedDatumStrokeWidth,
            strokeOpacity: highlightedDatumStrokeOpacity,
            fillOpacity: highlightedFillOpacity
          }
        }
      } = this.properties;
      const xAxis = this.axes[ChartAxisDirection9.X];
      const [visibleMin, visibleMax] = (_a2 = xAxis == null ? void 0 : xAxis.visibleRange) != null ? _a2 : [];
      const isZoomed = visibleMin !== 0 || visibleMax !== 1;
      const crisp = !isZoomed;
      opts.datumSelection.each((rect, datum) => {
        var _a3, _b, _c, _d, _e;
        const { point, width, height } = datum;
        const fill = isDatumHighlighted && highlightedFill !== void 0 ? Color$1.interpolate(datum.fill, highlightedFill)(highlightedFillOpacity != null ? highlightedFillOpacity : 1) : datum.fill;
        const stroke = isDatumHighlighted && highlightedStroke !== void 0 ? highlightedStroke : this.properties.stroke;
        const strokeOpacity = isDatumHighlighted && highlightedDatumStrokeOpacity !== void 0 ? highlightedDatumStrokeOpacity : this.properties.strokeOpacity;
        const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : this.properties.strokeWidth;
        let format;
        if (formatter) {
          format = callbackCache.call(formatter, {
            datum: datum.datum,
            fill,
            stroke,
            strokeOpacity,
            strokeWidth,
            highlighted: isDatumHighlighted,
            xKey,
            yKey,
            colorKey,
            seriesId
          });
        }
        rect.crisp = crisp;
        rect.x = Math.floor(point.x - width / 2);
        rect.y = Math.floor(point.y - height / 2);
        rect.width = Math.ceil(width);
        rect.height = Math.ceil(height);
        rect.fill = (_a3 = format == null ? void 0 : format.fill) != null ? _a3 : fill;
        rect.stroke = (_b = format == null ? void 0 : format.stroke) != null ? _b : stroke;
        rect.strokeOpacity = (_d = (_c = format == null ? void 0 : format.strokeOpacity) != null ? _c : strokeOpacity) != null ? _d : 1;
        rect.strokeWidth = (_e = format == null ? void 0 : format.strokeWidth) != null ? _e : strokeWidth;
      });
    });
  }
  updateLabelSelection(opts) {
    return __async$1(this, null, function* () {
      const { labelData, labelSelection } = opts;
      const { enabled } = this.properties.label;
      const data = enabled ? labelData : [];
      return labelSelection.update(data);
    });
  }
  updateLabelNodes(opts) {
    return __async$1(this, null, function* () {
      opts.labelSelection.each((text, datum) => {
        text.text = datum.text;
        text.fontSize = datum.fontSize;
        text.lineHeight = datum.lineHeight;
        text.fontStyle = datum.fontStyle;
        text.fontFamily = datum.fontFamily;
        text.fontWeight = datum.fontWeight;
        text.fill = datum.color;
        text.textAlign = datum.textAlign;
        text.textBaseline = datum.verticalAlign;
        text.x = datum.x;
        text.y = datum.y;
        text.pointerEvents = PointerEvents$1.None;
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a2, _b, _c;
    const xAxis = this.axes[ChartAxisDirection9.X];
    const yAxis = this.axes[ChartAxisDirection9.Y];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return "";
    }
    const { xKey, yKey, colorKey, xName, yName, colorName, stroke, strokeWidth, colorRange, formatter, tooltip } = this.properties;
    const {
      colorScale,
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const { datum, xValue, yValue, colorValue } = nodeDatum;
    const fill = this.isColorScaleValid() ? colorScale.convert(colorValue) : colorRange[0];
    let format;
    if (formatter) {
      format = callbackCache.call(formatter, {
        datum: nodeDatum,
        xKey,
        yKey,
        colorKey,
        fill,
        stroke,
        strokeWidth,
        highlighted: false,
        seriesId
      });
    }
    const color = (_b = (_a2 = format == null ? void 0 : format.fill) != null ? _a2 : fill) != null ? _b : "gray";
    const title = (_c = this.properties.title) != null ? _c : yName;
    const xString = sanitizeHtml2(xAxis.formatDatum(xValue));
    const yString = sanitizeHtml2(yAxis.formatDatum(yValue));
    let content = `<b>${sanitizeHtml2(xName || xKey)}</b>: ${xString}<br><b>${sanitizeHtml2(yName || yKey)}</b>: ${yString}`;
    if (colorKey) {
      content = `<b>${sanitizeHtml2(colorName || colorKey)}</b>: ${sanitizeHtml2(colorValue)}<br>` + content;
    }
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        datum,
        xKey,
        yKey,
        xName,
        yName,
        title,
        color,
        colorKey
      }
    );
  }
  getLegendData(legendType) {
    var _a2;
    if (legendType !== "gradient" || !((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || !this.isColorScaleValid() || !this.dataModel) {
      return [];
    }
    return [
      {
        legendType: "gradient",
        enabled: this.visible,
        seriesId: this.id,
        colorName: this.properties.colorName,
        colorDomain: this.processedData.domain.values[this.dataModel.resolveProcessedDataIndexById(this, "colorValue").index],
        colorRange: this.properties.colorRange
      }
    ];
  }
  isLabelEnabled() {
    return this.properties.label.enabled && Boolean(this.properties.colorKey);
  }
  getBandScalePadding() {
    return { inner: 0, outer: 0 };
  }
};
_HeatmapSeries.className = "HeatmapSeries";
_HeatmapSeries.type = "heatmap";
var HeatmapSeries = _HeatmapSeries;
var HEATMAP_SERIES_THEME = {
  series: {
    __extends__: integrated_charts_theme_exports.EXTENDS_SERIES_DEFAULTS,
    label: {
      __overrides__: integrated_charts_theme_exports.OVERRIDE_SERIES_LABEL_DEFAULTS,
      enabled: false,
      color: integrated_charts_theme_exports.DEFAULT_LABEL_COLOUR,
      fontSize: integrated_charts_theme_exports.FONT_SIZE.SMALL,
      fontFamily: integrated_charts_theme_exports.DEFAULT_FONT_FAMILY,
      wrapping: "on-space",
      overflowStrategy: "ellipsis"
    },
    itemPadding: 3
  },
  gradientLegend: {
    enabled: true
  }
};

// packages/ag-charts-enterprise/src/series/heatmap/heatmapModule.ts
var HeatmapModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "heatmap",
  instanceConstructor: HeatmapSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.CATEGORY,
        position: integrated_charts_theme_exports.POSITION.LEFT
      },
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.CATEGORY,
        position: integrated_charts_theme_exports.POSITION.BOTTOM
      }
    ]
  },
  themeTemplate: HEATMAP_SERIES_THEME,
  paletteFactory: ({ takeColors, colorsCount, userPalette, themeTemplateParameters }) => {
    var _a2;
    const { properties } = themeTemplateParameters;
    const defaultColorRange = properties.get(integrated_charts_theme_exports.DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);
    const defaultBackgroundColor = properties.get(integrated_charts_theme_exports.DEFAULT_BACKGROUND_COLOUR);
    const backgroundFill = (_a2 = Array.isArray(defaultBackgroundColor) ? defaultBackgroundColor[0] : defaultBackgroundColor) != null ? _a2 : "white";
    const { fills, strokes } = takeColors(colorsCount);
    return {
      stroke: userPalette ? strokes[0] : backgroundFill,
      colorRange: userPalette ? [fills[0], fills[1]] : defaultColorRange
    };
  }
};
var {
  isDefined: isDefined2,
  ChartAxisDirection: ChartAxisDirection10,
  PolarAxis: PolarAxis$1,
  diff: diff3,
  fixNumericExtent: fixNumericExtent3,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty2,
  keyProperty: keyProperty3,
  normaliseGroupTo: normaliseGroupTo$1,
  resetLabelFn: resetLabelFn$1,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation2,
  seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation$1,
  valueProperty: valueProperty5,
  animationValidation: animationValidation3
} = module_support_exports;
var { BandScale: BandScale3 } = sparklines_scale_exports;
var { motion: motion2 } = integrated_charts_scene_exports;
var { isNumber: isNumber$1, normalizeAngle360: normalizeAngle3605, sanitizeHtml: sanitizeHtml3 } = sparklines_util_exports;
var RadialColumnSeriesNodeClickEvent = class extends module_support_exports.SeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadialColumnSeriesBase = class extends module_support_exports.PolarSeries {
  constructor(moduleCtx, {
    animationResetFns
  }) {
    super({
      moduleCtx,
      useLabelLayer: true,
      canHaveAxes: true,
      animationResetFns: __spreadProps$1(__spreadValues$1({}, animationResetFns), {
        label: resetLabelFn$1
      })
    });
    this.NodeClickEvent = RadialColumnSeriesNodeClickEvent;
    this.nodeData = [];
    this.groupScale = new BandScale3();
    this.circleCache = { r: 0, cx: 0, cy: 0 };
  }
  addChartEventListeners() {
    var _a2, _b;
    this.destroyFns.push(
      (_a2 = this.ctx.chartEventManager) == null ? void 0 : _a2.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      (_b = this.ctx.chartEventManager) == null ? void 0 : _b.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getSeriesDomain(direction) {
    const { axes, dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection10.X) {
      return dataModel.getDomain(this, "angleValue", "key", processedData);
    } else {
      const radiusAxis = axes[ChartAxisDirection10.Y];
      const yExtent = dataModel.getDomain(this, "radiusValue-end", "value", processedData);
      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];
      return fixNumericExtent3(fixedYExtent, radiusAxis);
    }
  }
  processData(dataController) {
    return __async$1(this, null, function* () {
      var _a2;
      if (!this.properties.isValid()) {
        return;
      }
      const stackGroupId = this.getStackId();
      const stackGroupTrailingId = `${stackGroupId}-trailing`;
      const { angleKey, radiusKey, normalizedTo, visible } = this.properties;
      const extraProps = [];
      if (isDefined2(normalizedTo)) {
        extraProps.push(
          normaliseGroupTo$1(this, [stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo), "range")
        );
      }
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      if (animationEnabled && this.processedData) {
        extraProps.push(diff3(this.processedData));
      }
      if (animationEnabled) {
        extraProps.push(animationValidation3(this));
      }
      const visibleProps = visible || !animationEnabled ? {} : { forceValue: 0 };
      yield this.requestDataModel(dataController, (_a2 = this.data) != null ? _a2 : [], {
        props: [
          keyProperty3(this, angleKey, false, { id: "angleValue" }),
          valueProperty5(this, radiusKey, true, __spreadValues$1({
            id: "radiusValue-raw",
            invalidValue: null
          }, visibleProps)),
          ...groupAccumulativeValueProperty2(this, radiusKey, true, "normal", "current", __spreadValues$1({
            id: `radiusValue-end`,
            invalidValue: null,
            groupId: stackGroupId
          }, visibleProps)),
          ...groupAccumulativeValueProperty2(this, radiusKey, true, "trailing", "current", __spreadValues$1({
            id: `radiusValue-start`,
            invalidValue: null,
            groupId: stackGroupTrailingId
          }, visibleProps)),
          ...extraProps
        ],
        dataVisible: visible || animationEnabled
      });
      this.animationState.transition("updateData");
    });
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  isRadiusAxisReversed() {
    var _a2;
    return (_a2 = this.axes[ChartAxisDirection10.Y]) == null ? void 0 : _a2.isReversed();
  }
  maybeRefreshNodeData() {
    return __async$1(this, null, function* () {
      const circleChanged = this.didCircleChange();
      if (!circleChanged && !this.nodeDataRefresh)
        return;
      const [{ nodeData = [] } = {}] = yield this.createNodeData();
      this.nodeData = nodeData;
      this.nodeDataRefresh = false;
    });
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection10.Y];
    return radiusAxis instanceof PolarAxis$1 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      var _a2;
      const { processedData, dataModel, groupScale } = this;
      if (!processedData || !dataModel || !this.properties.isValid()) {
        return [];
      }
      const angleAxis = this.axes[ChartAxisDirection10.X];
      const radiusAxis = this.axes[ChartAxisDirection10.Y];
      const angleScale = angleAxis == null ? void 0 : angleAxis.scale;
      const radiusScale = radiusAxis == null ? void 0 : radiusAxis.scale;
      if (!angleScale || !radiusScale) {
        return [];
      }
      const radiusStartIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-start`).index;
      const radiusEndIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-end`).index;
      const radiusRawIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-raw`).index;
      let groupPaddingInner = 0;
      let groupPaddingOuter = 0;
      if (angleAxis instanceof AngleCategoryAxis) {
        groupPaddingInner = angleAxis.groupPaddingInner;
        groupPaddingOuter = angleAxis.paddingInner;
      }
      const groupAngleStep = (_a2 = angleScale.bandwidth) != null ? _a2 : 0;
      const paddedGroupAngleStep = groupAngleStep * (1 - groupPaddingOuter);
      const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
      groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));
      groupScale.range = [-paddedGroupAngleStep / 2, paddedGroupAngleStep / 2];
      groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;
      const radiusAxisReversed = this.isRadiusAxisReversed();
      const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();
      const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;
      const axisTotalRadius = axisOuterRadius + axisInnerRadius;
      const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;
      const getLabelNodeDatum = (datum, radiusDatum, x, y) => {
        const labelText = this.getLabelText(
          label,
          { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName },
          (value) => isNumber$1(value) ? value.toFixed(2) : String(value)
        );
        if (labelText) {
          return { x, y, text: labelText, textAlign: "center", textBaseline: "middle" };
        }
      };
      const nodeData = processedData.data.map((group, index, data) => {
        const { datum, keys, values } = group;
        const angleDatum = keys[0];
        const radiusDatum = values[radiusRawIndex];
        const innerRadiusDatum = values[radiusStartIndex];
        const outerRadiusDatum = values[radiusEndIndex];
        let startAngle;
        let endAngle;
        if (data.length === 1) {
          startAngle = -0.5 * Math.PI;
          endAngle = 1.5 * Math.PI;
        } else {
          const groupAngle = angleScale.convert(angleDatum);
          startAngle = normalizeAngle3605(groupAngle + groupScale.convert(String(groupIndex)));
          endAngle = normalizeAngle3605(startAngle + groupScale.bandwidth);
        }
        const angle = startAngle + groupScale.bandwidth / 2;
        const innerRadius = axisTotalRadius - radiusScale.convert(innerRadiusDatum);
        const outerRadius = axisTotalRadius - radiusScale.convert(outerRadiusDatum);
        const midRadius = (innerRadius + outerRadius) / 2;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = cos * midRadius;
        const y = sin * midRadius;
        const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, radiusDatum, x, y) : void 0;
        const columnWidth = this.getColumnWidth(startAngle, endAngle);
        return {
          series: this,
          datum,
          point: { x, y, size: 0 },
          midPoint: { x, y },
          label: labelNodeDatum,
          angleValue: angleDatum,
          radiusValue: radiusDatum,
          innerRadius,
          outerRadius,
          startAngle,
          endAngle,
          axisInnerRadius,
          axisOuterRadius,
          columnWidth,
          index
        };
      });
      return [{ itemId: radiusKey, nodeData, labelData: nodeData }];
    });
  }
  getColumnWidth(_startAngle, _endAngle) {
    return NaN;
  }
  update(_0) {
    return __async$1(this, arguments, function* ({ seriesRect }) {
      const resize = this.checkResize(seriesRect);
      yield this.maybeRefreshNodeData();
      this.contentGroup.translationX = this.centerX;
      this.contentGroup.translationY = this.centerY;
      this.highlightGroup.translationX = this.centerX;
      this.highlightGroup.translationY = this.centerY;
      if (this.labelGroup) {
        this.labelGroup.translationX = this.centerX;
        this.labelGroup.translationY = this.centerY;
      }
      this.updateSectorSelection(this.itemSelection, false);
      this.updateSectorSelection(this.highlightSelection, true);
      this.updateLabels();
      if (resize) {
        this.animationState.transition("resize");
      }
      this.animationState.transition("update");
    });
  }
  updateSectorSelection(selection, highlight) {
    var _a2, _b, _c, _d, _e;
    let selectionData = [];
    if (highlight) {
      const highlighted = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
      if ((highlighted == null ? void 0 : highlighted.datum) && highlighted.series === this) {
        selectionData = [highlighted];
      }
    } else {
      selectionData = this.nodeData;
    }
    const highlightedStyle = highlight ? this.properties.highlightStyle.item : void 0;
    const fill = (_b = highlightedStyle == null ? void 0 : highlightedStyle.fill) != null ? _b : this.properties.fill;
    const fillOpacity = (_c = highlightedStyle == null ? void 0 : highlightedStyle.fillOpacity) != null ? _c : this.properties.fillOpacity;
    const stroke = (_d = highlightedStyle == null ? void 0 : highlightedStyle.stroke) != null ? _d : this.properties.stroke;
    const strokeOpacity = this.properties.strokeOpacity;
    const strokeWidth = (_e = highlightedStyle == null ? void 0 : highlightedStyle.strokeWidth) != null ? _e : this.properties.strokeWidth;
    const idFn = (datum) => datum.angleValue;
    selection.update(selectionData, void 0, idFn).each((node, datum) => {
      var _a3, _b2, _c2, _d2;
      const format = this.properties.formatter ? this.ctx.callbackCache.call(this.properties.formatter, {
        datum,
        fill,
        stroke,
        strokeWidth,
        highlighted: highlight,
        angleKey: this.properties.angleKey,
        radiusKey: this.properties.radiusKey,
        seriesId: this.id
      }) : void 0;
      this.updateItemPath(node, datum, highlight, format);
      node.fill = (_a3 = format == null ? void 0 : format.fill) != null ? _a3 : fill;
      node.fillOpacity = (_b2 = format == null ? void 0 : format.fillOpacity) != null ? _b2 : fillOpacity;
      node.stroke = (_c2 = format == null ? void 0 : format.stroke) != null ? _c2 : stroke;
      node.strokeOpacity = strokeOpacity;
      node.strokeWidth = (_d2 = format == null ? void 0 : format.strokeWidth) != null ? _d2 : strokeWidth;
      node.lineDash = this.properties.lineDash;
      node.lineJoin = "round";
    });
  }
  updateLabels() {
    const { label } = this.properties;
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (label.enabled && datum.label) {
        node.x = datum.label.x;
        node.y = datum.label.y;
        node.fill = label.color;
        node.fontFamily = label.fontFamily;
        node.fontSize = label.fontSize;
        node.fontStyle = label.fontStyle;
        node.fontWeight = label.fontWeight;
        node.text = datum.label.text;
        node.textAlign = datum.label.textAlign;
        node.textBaseline = datum.label.textBaseline;
        node.visible = true;
      } else {
        node.visible = false;
      }
    });
  }
  animateEmptyUpdateReady() {
    const { labelSelection } = this;
    const fns = this.getColumnTransitionFunctions();
    motion2.fromToMotion(this.id, "datums", this.ctx.animationManager, [this.itemSelection], fns);
    seriesLabelFadeInAnimation2(this, "labels", this.ctx.animationManager, [labelSelection]);
  }
  animateClearingUpdateEmpty() {
    const { itemSelection } = this;
    const { animationManager } = this.ctx;
    const fns = this.getColumnTransitionFunctions();
    motion2.fromToMotion(this.id, "datums", animationManager, [itemSelection], fns);
    seriesLabelFadeOutAnimation$1(this, "labels", animationManager, [this.labelSelection]);
  }
  getTooltipHtml(nodeDatum) {
    var _a2;
    const { id: seriesId, axes, dataModel } = this;
    const { angleKey, radiusKey, angleName, radiusName, fill, stroke, strokeWidth, formatter, tooltip } = this.properties;
    const { angleValue, radiusValue, datum } = nodeDatum;
    const xAxis = axes[ChartAxisDirection10.X];
    const yAxis = axes[ChartAxisDirection10.Y];
    if (!this.properties.isValid() || !(xAxis && yAxis && isNumber$1(radiusValue)) || !dataModel) {
      return "";
    }
    const angleString = xAxis.formatDatum(angleValue);
    const radiusString = yAxis.formatDatum(radiusValue);
    const title = sanitizeHtml3(radiusName);
    const content = sanitizeHtml3(`${angleString}: ${radiusString}`);
    const { fill: color } = (_a2 = formatter && this.ctx.callbackCache.call(formatter, {
      seriesId,
      datum,
      fill,
      stroke,
      strokeWidth,
      highlighted: false,
      angleKey,
      radiusKey
    })) != null ? _a2 : { fill };
    return tooltip.toTooltipHtml(
      { title, backgroundColor: fill, content },
      { seriesId, datum, color, title, angleKey, radiusKey, angleName, radiusName }
    );
  }
  getLegendData(legendType) {
    var _a2;
    if (!((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { radiusKey, radiusName, fill, stroke, fillOpacity, strokeOpacity, strokeWidth, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: radiusKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: radiusName != null ? radiusName : radiusKey
        },
        marker: {
          fill: fill != null ? fill : "rgba(0, 0, 0, 0)",
          stroke: stroke != null ? stroke : "rgba(0, 0, 0, 0)",
          fillOpacity: fillOpacity != null ? fillOpacity : 1,
          strokeOpacity: strokeOpacity != null ? strokeOpacity : 1,
          strokeWidth
        }
      }
    ];
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && numVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  computeLabelsBBox() {
    return null;
  }
};
var { Label: Label2 } = integrated_charts_scene_exports;
var {
  SeriesProperties: SeriesProperties$1,
  SeriesTooltip: SeriesTooltip4,
  Validate: Validate26,
  COLOR_STRING: COLOR_STRING8,
  DEGREE: DEGREE3,
  FUNCTION: FUNCTION6,
  LINE_DASH: LINE_DASH6,
  NUMBER: NUMBER8,
  OBJECT: OBJECT7,
  POSITIVE_NUMBER: POSITIVE_NUMBER11,
  RATIO: RATIO12,
  STRING: STRING8
} = module_support_exports;
var RadialColumnSeriesBaseProperties = class extends SeriesProperties$1 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.rotation = 0;
    this.label = new Label2();
    this.tooltip = new SeriesTooltip4();
  }
};
__decorateClass$1([
  Validate26(STRING8)
], RadialColumnSeriesBaseProperties.prototype, "angleKey", 2);
__decorateClass$1([
  Validate26(STRING8, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "angleName", 2);
__decorateClass$1([
  Validate26(STRING8)
], RadialColumnSeriesBaseProperties.prototype, "radiusKey", 2);
__decorateClass$1([
  Validate26(STRING8, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "radiusName", 2);
__decorateClass$1([
  Validate26(COLOR_STRING8)
], RadialColumnSeriesBaseProperties.prototype, "fill", 2);
__decorateClass$1([
  Validate26(RATIO12)
], RadialColumnSeriesBaseProperties.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate26(COLOR_STRING8)
], RadialColumnSeriesBaseProperties.prototype, "stroke", 2);
__decorateClass$1([
  Validate26(POSITIVE_NUMBER11)
], RadialColumnSeriesBaseProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate26(RATIO12)
], RadialColumnSeriesBaseProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate26(LINE_DASH6)
], RadialColumnSeriesBaseProperties.prototype, "lineDash", 2);
__decorateClass$1([
  Validate26(POSITIVE_NUMBER11)
], RadialColumnSeriesBaseProperties.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate26(FUNCTION6, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "formatter", 2);
__decorateClass$1([
  Validate26(DEGREE3)
], RadialColumnSeriesBaseProperties.prototype, "rotation", 2);
__decorateClass$1([
  Validate26(STRING8, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "stackGroup", 2);
__decorateClass$1([
  Validate26(NUMBER8, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "normalizedTo", 2);
__decorateClass$1([
  Validate26(OBJECT7)
], RadialColumnSeriesBaseProperties.prototype, "label", 2);
__decorateClass$1([
  Validate26(OBJECT7)
], RadialColumnSeriesBaseProperties.prototype, "tooltip", 2);
var { motion: motion3 } = integrated_charts_scene_exports;
function createAngleMotionCalculator() {
  const angles = {
    startAngle: /* @__PURE__ */ new Map(),
    endAngle: /* @__PURE__ */ new Map()
  };
  const angleKeys = ["startAngle", "endAngle"];
  const calculate = (node, datum, status) => {
    angleKeys.forEach((key) => {
      var _a2, _b;
      const map = angles[key];
      let from2 = (status === "removed" || status === "updated" ? node : datum)[key];
      let to2 = (status === "removed" ? node : datum)[key];
      if (isNaN(to2)) {
        to2 = (_b = (_a2 = node.previousDatum) == null ? void 0 : _a2[key]) != null ? _b : NaN;
      }
      const diff7 = from2 - to2;
      if (Math.abs(diff7) > Math.PI) {
        from2 -= Math.sign(diff7) * 2 * Math.PI;
      }
      map.set(datum, { from: from2, to: to2 });
    });
  };
  const getAngles = (datum, fromToKey) => {
    return {
      startAngle: angles.startAngle.get(datum)[fromToKey],
      endAngle: angles.endAngle.get(datum)[fromToKey]
    };
  };
  const from = (datum) => getAngles(datum, "from");
  const to = (datum) => getAngles(datum, "to");
  return { calculate, from, to };
}
function fixRadialColumnAnimationStatus(node, datum, status) {
  if (status === "updated") {
    if (node.previousDatum == null || isNaN(node.previousDatum.startAngle) || isNaN(node.previousDatum.endAngle)) {
      return "added";
    }
    if (isNaN(datum.startAngle) || isNaN(datum.endAngle)) {
      return "removed";
    }
  }
  if (status === "added" && node.previousDatum != null) {
    return "updated";
  }
  return status;
}
function prepareRadialColumnAnimationFunctions(axisZeroRadius) {
  const angles = createAngleMotionCalculator();
  const fromFn = (node, datum, status) => {
    status = fixRadialColumnAnimationStatus(node, datum, status);
    angles.calculate(node, datum, status);
    const { startAngle, endAngle } = angles.from(datum);
    let innerRadius;
    let outerRadius;
    let columnWidth;
    let axisInnerRadius;
    let axisOuterRadius;
    if (status === "removed" || status === "updated") {
      innerRadius = node.innerRadius;
      outerRadius = node.outerRadius;
      columnWidth = node.columnWidth;
      axisInnerRadius = node.axisInnerRadius;
      axisOuterRadius = node.axisOuterRadius;
    } else {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
      columnWidth = datum.columnWidth;
      axisInnerRadius = datum.axisInnerRadius;
      axisOuterRadius = datum.axisOuterRadius;
    }
    const phase = motion3.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return {
      innerRadius,
      outerRadius,
      columnWidth,
      axisInnerRadius,
      axisOuterRadius,
      startAngle,
      endAngle,
      phase
    };
  };
  const toFn = (node, datum, status) => {
    const { startAngle, endAngle } = angles.to(datum);
    let innerRadius;
    let outerRadius;
    let columnWidth;
    let axisInnerRadius;
    let axisOuterRadius;
    if (status === "removed") {
      innerRadius = node.innerRadius;
      outerRadius = node.innerRadius;
      columnWidth = node.columnWidth;
      axisInnerRadius = node.axisInnerRadius;
      axisOuterRadius = node.axisOuterRadius;
    } else {
      innerRadius = isNaN(datum.innerRadius) ? axisZeroRadius : datum.innerRadius;
      outerRadius = isNaN(datum.outerRadius) ? axisZeroRadius : datum.outerRadius;
      columnWidth = isNaN(datum.columnWidth) ? node.columnWidth : datum.columnWidth;
      axisInnerRadius = datum.axisInnerRadius;
      axisOuterRadius = datum.axisOuterRadius;
    }
    return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };
  };
  return { toFn, fromFn };
}
function resetRadialColumnSelectionFn(_node, {
  innerRadius,
  outerRadius,
  columnWidth,
  axisInnerRadius,
  axisOuterRadius,
  startAngle,
  endAngle
}) {
  return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };
}

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleUtil.ts
var { motion: motion4 } = integrated_charts_scene_exports;
function prepareNightingaleAnimationFunctions(axisZeroRadius) {
  const angles = createAngleMotionCalculator();
  const fromFn = (sect, datum, status) => {
    status = fixRadialColumnAnimationStatus(sect, datum, status);
    angles.calculate(sect, datum, status);
    const { startAngle, endAngle } = angles.from(datum);
    let innerRadius;
    let outerRadius;
    if (status === "removed" || status === "updated") {
      innerRadius = sect.innerRadius;
      outerRadius = sect.outerRadius;
    } else {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
    }
    const phase = motion4.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { innerRadius, outerRadius, startAngle, endAngle, phase };
  };
  const toFn = (_sect, datum, status) => {
    const { startAngle, endAngle } = angles.to(datum);
    let innerRadius;
    let outerRadius;
    if (status === "removed") {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
    } else {
      innerRadius = isNaN(datum.innerRadius) ? axisZeroRadius : datum.innerRadius;
      outerRadius = isNaN(datum.outerRadius) ? axisZeroRadius : datum.outerRadius;
    }
    return { innerRadius, outerRadius, startAngle, endAngle };
  };
  return { toFn, fromFn };
}
function resetNightingaleSelectionFn(_sect, { innerRadius, outerRadius, startAngle, endAngle }) {
  return { innerRadius, outerRadius, startAngle, endAngle };
}

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleSeries.ts
var { Sector: Sector3 } = integrated_charts_scene_exports;
var NightingaleSeries = class extends RadialColumnSeriesBase {
  // TODO: Enable once the options contract has been revisited
  // @Validate(POSITIVE_NUMBER)
  // sectorSpacing = 1;
  constructor(moduleCtx) {
    super(moduleCtx, { animationResetFns: { item: resetNightingaleSelectionFn } });
    this.properties = new RadialColumnSeriesBaseProperties();
  }
  getStackId() {
    var _a2, _b;
    const groupIndex = (_b = (_a2 = this.seriesGrouping) == null ? void 0 : _a2.groupIndex) != null ? _b : this.id;
    return `nightingale-stack-${groupIndex}-yValues`;
  }
  nodeFactory() {
    return new Sector3();
  }
  updateItemPath(node, datum, highlight, _format) {
    node.centerX = 0;
    node.centerY = 0;
    if (highlight) {
      node.innerRadius = datum.innerRadius;
      node.outerRadius = datum.outerRadius;
      node.startAngle = datum.startAngle;
      node.endAngle = datum.endAngle;
    }
  }
  getColumnTransitionFunctions() {
    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();
    return prepareNightingaleAnimationFunctions(axisZeroRadius);
  }
};
NightingaleSeries.className = "NightingaleSeries";
NightingaleSeries.type = "nightingale";
var NIGHTINGALE_SERIES_THEME = {
  series: {
    __extends__: integrated_charts_theme_exports.EXTENDS_SERIES_DEFAULTS,
    strokeWidth: 1,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: integrated_charts_theme_exports.DEFAULT_FONT_FAMILY,
      color: integrated_charts_theme_exports.DEFAULT_LABEL_COLOUR,
      __overrides__: integrated_charts_theme_exports.OVERRIDE_SERIES_LABEL_DEFAULTS
    }
  },
  axes: {
    [integrated_charts_theme_exports.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {
      shape: integrated_charts_theme_exports.POLAR_AXIS_SHAPE.CIRCLE,
      groupPaddingInner: 0,
      paddingInner: 0,
      label: {
        padding: 10
      }
    },
    [integrated_charts_theme_exports.POLAR_AXIS_TYPE.RADIUS_NUMBER]: {
      shape: integrated_charts_theme_exports.POLAR_AXIS_SHAPE.CIRCLE
    }
  }
};

// packages/ag-charts-enterprise/src/series/nightingale/nightingaleModule.ts
var NightingaleModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "nightingale",
  instanceConstructor: NightingaleSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.ANGLE_CATEGORY
      },
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.RADIUS_NUMBER
      }
    ]
  },
  themeTemplate: NIGHTINGALE_SERIES_THEME,
  paletteFactory({ takeColors, userPalette }) {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill,
      stroke: userPalette ? stroke : integrated_charts_theme_exports.DEFAULT_POLAR_SERIES_STROKE
    };
  },
  stackable: true,
  groupable: true,
  stackedByDefault: true
};
var BASE_RADAR_SERIES_THEME = {
  series: {
    __extends__: integrated_charts_theme_exports.EXTENDS_SERIES_DEFAULTS,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: integrated_charts_theme_exports.DEFAULT_FONT_FAMILY,
      color: integrated_charts_theme_exports.DEFAULT_LABEL_COLOUR,
      __overrides__: integrated_charts_theme_exports.OVERRIDE_SERIES_LABEL_DEFAULTS
    },
    marker: {
      enabled: true,
      fillOpacity: 1,
      shape: "circle",
      size: 6,
      strokeOpacity: 1,
      strokeWidth: 0
    }
  },
  axes: {
    [integrated_charts_theme_exports.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {
      label: {
        padding: 10
      }
    }
  }
};
var RADAR_LINE_SERIES_THEME = module_support_exports.mergeDefaults(
  {
    series: {
      strokeWidth: 2
    }
  },
  BASE_RADAR_SERIES_THEME
);
var RADAR_AREA_SERIES_THEME = module_support_exports.mergeDefaults(
  {
    series: {
      fillOpacity: 0.8,
      strokeWidth: 2,
      marker: {
        enabled: false
      }
    }
  },
  BASE_RADAR_SERIES_THEME
);
var { Label: Label3 } = integrated_charts_scene_exports;
var {
  SeriesMarker: SeriesMarker$1,
  SeriesProperties: SeriesProperties2,
  SeriesTooltip: SeriesTooltip5,
  Validate: Validate27,
  BOOLEAN: BOOLEAN13,
  COLOR_STRING: COLOR_STRING9,
  DEGREE: DEGREE4,
  FUNCTION: FUNCTION7,
  LINE_DASH: LINE_DASH7,
  OBJECT: OBJECT8,
  POSITIVE_NUMBER: POSITIVE_NUMBER12,
  RATIO: RATIO13,
  STRING: STRING9
} = module_support_exports;
var RadarSeriesProperties = class extends SeriesProperties2 {
  constructor() {
    super(...arguments);
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.rotation = 0;
    this.marker = new SeriesMarker$1();
    this.label = new Label3();
    this.tooltip = new SeriesTooltip5();
    this.connectMissingData = false;
  }
};
__decorateClass$1([
  Validate27(STRING9)
], RadarSeriesProperties.prototype, "angleKey", 2);
__decorateClass$1([
  Validate27(STRING9)
], RadarSeriesProperties.prototype, "radiusKey", 2);
__decorateClass$1([
  Validate27(STRING9, { optional: true })
], RadarSeriesProperties.prototype, "angleName", 2);
__decorateClass$1([
  Validate27(STRING9, { optional: true })
], RadarSeriesProperties.prototype, "radiusName", 2);
__decorateClass$1([
  Validate27(COLOR_STRING9)
], RadarSeriesProperties.prototype, "stroke", 2);
__decorateClass$1([
  Validate27(POSITIVE_NUMBER12)
], RadarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate27(RATIO13)
], RadarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate27(LINE_DASH7)
], RadarSeriesProperties.prototype, "lineDash", 2);
__decorateClass$1([
  Validate27(POSITIVE_NUMBER12)
], RadarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate27(FUNCTION7, { optional: true })
], RadarSeriesProperties.prototype, "formatter", 2);
__decorateClass$1([
  Validate27(DEGREE4)
], RadarSeriesProperties.prototype, "rotation", 2);
__decorateClass$1([
  Validate27(OBJECT8)
], RadarSeriesProperties.prototype, "marker", 2);
__decorateClass$1([
  Validate27(OBJECT8)
], RadarSeriesProperties.prototype, "label", 2);
__decorateClass$1([
  Validate27(OBJECT8)
], RadarSeriesProperties.prototype, "tooltip", 2);
__decorateClass$1([
  Validate27(BOOLEAN13)
], RadarSeriesProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-enterprise/src/series/radar/radarSeries.ts
var {
  ChartAxisDirection: ChartAxisDirection11,
  PolarAxis: PolarAxis2,
  SeriesNodePickMode: SeriesNodePickMode3,
  valueProperty: valueProperty6,
  fixNumericExtent: fixNumericExtent4,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation3,
  markerFadeInAnimation: markerFadeInAnimation$1,
  resetMarkerFn: resetMarkerFn$1,
  animationValidation: animationValidation4
} = module_support_exports;
var { BBox: BBox6, Group: Group6, Path: Path5, PointerEvents: PointerEvents2, Selection: Selection2, Text: Text6, getMarker: getMarker$1 } = integrated_charts_scene_exports;
var { extent: extent2, isNumber: isNumber2, isNumberEqual: isNumberEqual8, sanitizeHtml: sanitizeHtml4, toFixed: toFixed$1 } = sparklines_util_exports;
var RadarSeriesNodeClickEvent = class extends module_support_exports.SeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadarSeries = class extends module_support_exports.PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode3.NEAREST_NODE, SeriesNodePickMode3.EXACT_SHAPE_MATCH],
      canHaveAxes: true,
      animationResetFns: {
        item: resetMarkerFn$1
      }
    });
    this.properties = new RadarSeriesProperties();
    this.NodeClickEvent = RadarSeriesNodeClickEvent;
    this.nodeData = [];
    this.resetInvalidToZero = false;
    this.circleCache = { r: 0, cx: 0, cy: 0 };
    const lineGroup = new Group6();
    this.contentGroup.append(lineGroup);
    this.lineSelection = Selection2.select(lineGroup, Path5);
    lineGroup.zIndexSubOrder = [() => this._declarationOrder, 1];
  }
  nodeFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker$1(shape);
    return new MarkerShape();
  }
  addChartEventListeners() {
    var _a2, _b;
    this.destroyFns.push(
      (_a2 = this.ctx.chartEventManager) == null ? void 0 : _a2.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      (_b = this.ctx.chartEventManager) == null ? void 0 : _b.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection11.X) {
      return dataModel.getDomain(this, `angleValue`, "value", processedData);
    } else {
      const domain = dataModel.getDomain(this, `radiusValue`, "value", processedData);
      const ext = extent2(domain.length === 0 ? domain : [0].concat(domain));
      return fixNumericExtent4(ext);
    }
  }
  processData(dataController) {
    return __async$1(this, null, function* () {
      var _a2;
      if (!this.properties.isValid()) {
        return;
      }
      const { angleKey, radiusKey } = this.properties;
      const extraProps = [];
      if (!this.ctx.animationManager.isSkipped()) {
        extraProps.push(animationValidation4(this));
      }
      yield this.requestDataModel(dataController, (_a2 = this.data) != null ? _a2 : [], {
        props: [
          valueProperty6(this, angleKey, false, { id: "angleValue" }),
          valueProperty6(this, radiusKey, false, { id: "radiusValue", invalidValue: void 0 }),
          ...extraProps
        ]
      });
      this.animationState.transition("updateData");
    });
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection11.Y];
    return radiusAxis instanceof PolarAxis2 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  maybeRefreshNodeData() {
    return __async$1(this, null, function* () {
      const didCircleChange = this.didCircleChange();
      if (!didCircleChange && !this.nodeDataRefresh)
        return;
      const [{ nodeData = [] } = {}] = yield this.createNodeData();
      this.nodeData = nodeData;
      this.nodeDataRefresh = false;
    });
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      var _a2, _b;
      const { processedData, dataModel } = this;
      if (!processedData || !dataModel || !this.properties.isValid()) {
        return [];
      }
      const { angleKey, radiusKey, angleName, radiusName, marker, label } = this.properties;
      const angleScale = (_a2 = this.axes[ChartAxisDirection11.X]) == null ? void 0 : _a2.scale;
      const radiusScale = (_b = this.axes[ChartAxisDirection11.Y]) == null ? void 0 : _b.scale;
      if (!angleScale || !radiusScale) {
        return [];
      }
      const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`).index;
      const radiusIdx = dataModel.resolveProcessedDataIndexById(this, `radiusValue`).index;
      const axisInnerRadius = this.getAxisInnerRadius();
      const nodeData = processedData.data.map((group) => {
        const { datum, values } = group;
        const angleDatum = values[angleIdx];
        const radiusDatum = values[radiusIdx];
        const angle = angleScale.convert(angleDatum);
        const radius = this.radius + axisInnerRadius - radiusScale.convert(radiusDatum);
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = cos * radius;
        const y = sin * radius;
        let labelNodeDatum;
        if (label.enabled) {
          const labelText = this.getLabelText(
            label,
            { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName },
            (value) => isNumber2(value) ? value.toFixed(2) : String(value)
          );
          if (labelText) {
            labelNodeDatum = {
              x: x + cos * marker.size,
              y: y + sin * marker.size,
              text: labelText,
              textAlign: isNumberEqual8(cos, 0) ? "center" : cos > 0 ? "left" : "right",
              textBaseline: isNumberEqual8(sin, 0) ? "middle" : sin > 0 ? "top" : "bottom"
            };
          }
        }
        return {
          series: this,
          datum,
          point: { x, y, size: marker.size },
          midPoint: { x, y },
          label: labelNodeDatum,
          angleValue: angleDatum,
          radiusValue: radiusDatum
        };
      });
      return [{ itemId: radiusKey, nodeData, labelData: nodeData }];
    });
  }
  update(_0) {
    return __async$1(this, arguments, function* ({ seriesRect }) {
      var _a2, _b;
      const resize = this.checkResize(seriesRect);
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const { series } = (_b = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight()) != null ? _b : {};
      this.highlightGroup.visible = (animationEnabled || this.visible) && !!(series === this);
      yield this.maybeRefreshNodeData();
      this.contentGroup.translationX = this.centerX;
      this.contentGroup.translationY = this.centerY;
      this.highlightGroup.translationX = this.centerX;
      this.highlightGroup.translationY = this.centerY;
      if (this.labelGroup) {
        this.labelGroup.translationX = this.centerX;
        this.labelGroup.translationY = this.centerY;
      }
      this.updatePathSelections();
      this.updateMarkerSelection();
      this.updateMarkers(this.itemSelection, false);
      this.updateMarkers(this.highlightSelection, true);
      this.updateLabels();
      if (resize) {
        this.animationState.transition("resize");
      }
      this.animationState.transition("update");
    });
  }
  updatePathSelections() {
    const pathData = this.visible ? [true] : [];
    this.lineSelection.update(pathData);
  }
  updateMarkerSelection() {
    if (this.properties.marker.isDirty()) {
      this.itemSelection.clear();
      this.itemSelection.cleanup();
      this.itemSelection = Selection2.select(this.itemGroup, () => this.nodeFactory(), false);
    }
    this.itemSelection.update(this.properties.marker.enabled ? this.nodeData : []);
  }
  getMarkerFill(highlightedStyle) {
    var _a2;
    return (_a2 = highlightedStyle == null ? void 0 : highlightedStyle.fill) != null ? _a2 : this.properties.marker.fill;
  }
  updateMarkers(selection, highlight) {
    var _a2;
    const { angleKey, radiusKey, marker, visible } = this.properties;
    let selectionData = [];
    if (visible && marker.shape && marker.enabled) {
      if (highlight) {
        const highlighted = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
        if (highlighted == null ? void 0 : highlighted.datum) {
          selectionData = [highlighted];
        }
      } else {
        selectionData = this.nodeData;
      }
    }
    const highlightedStyle = highlight ? this.properties.highlightStyle.item : void 0;
    selection.update(selectionData).each((node, datum) => {
      var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const fill = this.getMarkerFill(highlightedStyle);
      const stroke = (_b = (_a3 = highlightedStyle == null ? void 0 : highlightedStyle.stroke) != null ? _a3 : marker.stroke) != null ? _b : this.properties.stroke;
      const strokeWidth = (_e = (_d = (_c = highlightedStyle == null ? void 0 : highlightedStyle.strokeWidth) != null ? _c : marker.strokeWidth) != null ? _d : this.properties.strokeWidth) != null ? _e : 1;
      const format = marker.formatter ? this.ctx.callbackCache.call(marker.formatter, {
        datum: datum.datum,
        angleKey,
        radiusKey,
        fill,
        stroke,
        strokeWidth,
        size: marker.size,
        highlighted: highlight,
        seriesId: this.id
      }) : void 0;
      node.fill = (_f = format == null ? void 0 : format.fill) != null ? _f : fill;
      node.stroke = (_g = format == null ? void 0 : format.stroke) != null ? _g : stroke;
      node.strokeWidth = (_h = format == null ? void 0 : format.strokeWidth) != null ? _h : strokeWidth;
      node.fillOpacity = (_j = (_i = highlightedStyle == null ? void 0 : highlightedStyle.fillOpacity) != null ? _i : marker.fillOpacity) != null ? _j : 1;
      node.strokeOpacity = (_l = (_k = marker.strokeOpacity) != null ? _k : this.properties.strokeOpacity) != null ? _l : 1;
      node.size = (_m = format == null ? void 0 : format.size) != null ? _m : marker.size;
      const { x, y } = datum.point;
      node.translationX = x;
      node.translationY = y;
      node.visible = visible && node.size > 0 && !isNaN(x) && !isNaN(y);
    });
  }
  updateLabels() {
    const { label } = this.properties;
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (label.enabled && datum.label) {
        node.x = datum.label.x;
        node.y = datum.label.y;
        node.fill = label.color;
        node.fontFamily = label.fontFamily;
        node.fontSize = label.fontSize;
        node.fontStyle = label.fontStyle;
        node.fontWeight = label.fontWeight;
        node.text = datum.label.text;
        node.textAlign = datum.label.textAlign;
        node.textBaseline = datum.label.textBaseline;
        node.visible = true;
      } else {
        node.visible = false;
      }
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a2;
    if (!this.properties.isValid()) {
      return "";
    }
    const { id: seriesId } = this;
    const { angleKey, radiusKey, angleName, radiusName, marker, tooltip } = this.properties;
    const { datum, angleValue, radiusValue } = nodeDatum;
    const formattedAngleValue = typeof angleValue === "number" ? toFixed$1(angleValue) : String(angleValue);
    const formattedRadiusValue = typeof radiusValue === "number" ? toFixed$1(radiusValue) : String(radiusValue);
    const title = sanitizeHtml4(radiusName);
    const content = sanitizeHtml4(`${formattedAngleValue}: ${formattedRadiusValue}`);
    const { formatter: markerFormatter, fill, stroke, strokeWidth: markerStrokeWidth, size } = marker;
    const strokeWidth = markerStrokeWidth != null ? markerStrokeWidth : this.properties.strokeWidth;
    const { fill: color } = (_a2 = markerFormatter && this.ctx.callbackCache.call(markerFormatter, {
      datum,
      angleKey,
      radiusKey,
      fill,
      stroke,
      strokeWidth,
      size,
      highlighted: false,
      seriesId
    })) != null ? _a2 : { fill };
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      { datum, angleKey, angleName, radiusKey, radiusName, title, color, seriesId }
    );
  }
  getLegendData(legendType) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    if (!((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { radiusKey, radiusName, stroke, strokeWidth, strokeOpacity, lineDash, visible, marker } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: radiusKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: radiusName != null ? radiusName : radiusKey
        },
        marker: {
          shape: marker.shape,
          fill: (_d = (_c = (_b = this.getMarkerFill()) != null ? _b : marker.stroke) != null ? _c : stroke) != null ? _d : "rgba(0, 0, 0, 0)",
          stroke: (_f = (_e = marker.stroke) != null ? _e : stroke) != null ? _f : "rgba(0, 0, 0, 0)",
          fillOpacity: (_g = marker.fillOpacity) != null ? _g : 1,
          strokeOpacity: (_i = (_h = marker.strokeOpacity) != null ? _h : strokeOpacity) != null ? _i : 1,
          strokeWidth: (_j = marker.strokeWidth) != null ? _j : 0,
          enabled: marker.enabled || strokeWidth <= 0
        },
        line: {
          stroke,
          strokeOpacity,
          strokeWidth,
          lineDash
        }
      }
    ];
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && numVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  pickNodeClosestDatum(point) {
    var _a2, _b;
    const { x, y } = point;
    const { rootGroup, nodeData, centerX: cx, centerY: cy } = this;
    const hitPoint = rootGroup.transformPoint(x, y);
    const radius = this.radius;
    const distanceFromCenter = Math.sqrt(__pow$1(x - cx, 2) + __pow$1(y - cy, 2));
    if (distanceFromCenter > radius + this.properties.marker.size) {
      return;
    }
    let minDistance = Infinity;
    let closestDatum;
    for (const datum of nodeData) {
      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
      if (isNaN(datumX) || isNaN(datumY)) {
        continue;
      }
      const distance = Math.sqrt(__pow$1(hitPoint.x - datumX - cx, 2) + __pow$1(hitPoint.y - datumY - cy, 2));
      if (distance < minDistance) {
        minDistance = distance;
        closestDatum = datum;
      }
    }
    if (closestDatum) {
      const distance = Math.max(minDistance - ((_b = (_a2 = closestDatum.point) == null ? void 0 : _a2.size) != null ? _b : 0), 0);
      return { datum: closestDatum, distance };
    }
  }
  computeLabelsBBox() {
    return __async$1(this, null, function* () {
      const { label } = this.properties;
      yield this.maybeRefreshNodeData();
      const textBoxes = [];
      const tempText2 = new Text6();
      this.nodeData.forEach((nodeDatum) => {
        if (!label.enabled || !nodeDatum.label) {
          return;
        }
        tempText2.text = nodeDatum.label.text;
        tempText2.x = nodeDatum.label.x;
        tempText2.y = nodeDatum.label.y;
        tempText2.setFont(label);
        tempText2.setAlign(nodeDatum.label);
        const box = tempText2.computeBBox();
        textBoxes.push(box);
      });
      if (textBoxes.length === 0) {
        return null;
      }
      return BBox6.merge(textBoxes);
    });
  }
  getLineNode() {
    return this.lineSelection.nodes()[0];
  }
  beforePathAnimation() {
    const lineNode = this.getLineNode();
    lineNode.fill = void 0;
    lineNode.lineJoin = "round";
    lineNode.lineCap = "round";
    lineNode.pointerEvents = PointerEvents2.None;
    lineNode.stroke = this.properties.stroke;
    lineNode.strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
    lineNode.strokeOpacity = this.properties.strokeOpacity;
    lineNode.lineDash = this.properties.lineDash;
    lineNode.lineDashOffset = this.properties.lineDashOffset;
  }
  getLinePoints() {
    const { nodeData, resetInvalidToZero } = this;
    const { connectMissingData } = this.properties;
    if (nodeData.length === 0) {
      return [];
    }
    const radiusAxis = this.axes[ChartAxisDirection11.Y];
    const angleAxis = this.axes[ChartAxisDirection11.X];
    const reversedAngleAxis = angleAxis == null ? void 0 : angleAxis.isReversed();
    const reversedRadiusAxis = radiusAxis == null ? void 0 : radiusAxis.isReversed();
    const data = reversedRadiusAxis && !reversedAngleAxis ? [...nodeData].reverse() : nodeData;
    const points = [];
    let prevPointInvalid = false;
    let firstValid;
    data.forEach((datum, index) => {
      let { x, y } = datum.point;
      const isPointInvalid = isNaN(x) || isNaN(y);
      if (!isPointInvalid) {
        firstValid != null ? firstValid : firstValid = datum;
      }
      if (isPointInvalid && !connectMissingData) {
        x = 0;
        y = 0;
      }
      const moveTo = index === 0 || !resetInvalidToZero && !connectMissingData && (isPointInvalid || prevPointInvalid);
      points.push({ x, y, moveTo });
      prevPointInvalid = isPointInvalid;
    });
    if (firstValid !== void 0) {
      points.push({ x: firstValid.point.x, y: firstValid.point.y, moveTo: false });
    }
    return points;
  }
  animateSinglePath(pathNode, points, ratio) {
    const { path } = pathNode;
    path.clear({ trackChanges: true });
    const axisInnerRadius = this.getAxisInnerRadius();
    const radiusAxis = this.axes[ChartAxisDirection11.Y];
    const reversedRadiusAxis = radiusAxis == null ? void 0 : radiusAxis.isReversed();
    const radiusZero = reversedRadiusAxis ? this.radius + axisInnerRadius - (radiusAxis == null ? void 0 : radiusAxis.scale.convert(0)) : axisInnerRadius;
    points.forEach((point) => {
      const { x: x1, y: y1, arc, radius = 0, startAngle = 0, endAngle = 0, moveTo } = point;
      const angle = Math.atan2(y1, x1);
      const x0 = radiusZero * Math.cos(angle);
      const y0 = radiusZero * Math.sin(angle);
      const t = ratio;
      const x = x0 * (1 - t) + x1 * t;
      const y = y0 * (1 - t) + y1 * t;
      if (arc) {
        path.arc(x1, y1, radius, startAngle, endAngle);
      } else if (moveTo) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    pathNode.checkPathDirty();
  }
  animatePaths(ratio) {
    const linePoints = this.getLinePoints();
    this.animateSinglePath(this.getLineNode(), linePoints, ratio);
  }
  animateEmptyUpdateReady() {
    const { itemSelection, labelSelection } = this;
    const { animationManager } = this.ctx;
    this.beforePathAnimation();
    animationManager.animate({
      id: `${this.id}_'path`,
      groupId: this.id,
      from: 0,
      to: 1,
      phase: "initial",
      onUpdate: (ratio) => this.animatePaths(ratio),
      onStop: () => this.animatePaths(1)
    });
    markerFadeInAnimation$1(this, animationManager, [itemSelection], "added");
    seriesLabelFadeInAnimation3(this, "labels", animationManager, [labelSelection]);
  }
  animateWaitingUpdateReady(data) {
    super.animateWaitingUpdateReady(data);
    this.resetPaths();
  }
  animateReadyResize(data) {
    super.animateReadyResize(data);
    this.resetPaths();
  }
  resetPaths() {
    const lineNode = this.getLineNode();
    if (lineNode) {
      const { path: linePath } = lineNode;
      const linePoints = this.getLinePoints();
      lineNode.fill = void 0;
      lineNode.stroke = this.properties.stroke;
      lineNode.strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
      lineNode.strokeOpacity = this.properties.strokeOpacity;
      lineNode.lineDash = this.properties.lineDash;
      lineNode.lineDashOffset = this.properties.lineDashOffset;
      linePath.clear({ trackChanges: true });
      linePoints.forEach(({ x, y, moveTo }) => {
        if (moveTo) {
          linePath.moveTo(x, y);
        } else {
          linePath.lineTo(x, y);
        }
      });
      lineNode.checkPathDirty();
    }
  }
};
RadarSeries.className = "RadarSeries";
var { RATIO: RATIO14, COLOR_STRING: COLOR_STRING10, Validate: Validate28 } = module_support_exports;
var RadarAreaSeriesProperties = class extends RadarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
  }
};
__decorateClass$1([
  Validate28(COLOR_STRING10)
], RadarAreaSeriesProperties.prototype, "fill", 2);
__decorateClass$1([
  Validate28(RATIO14)
], RadarAreaSeriesProperties.prototype, "fillOpacity", 2);

// packages/ag-charts-enterprise/src/series/radar-area/radarAreaSeries.ts
var { Group: Group7, Path: Path6, PointerEvents: PointerEvents3, Selection: Selection3 } = integrated_charts_scene_exports;
var { ChartAxisDirection: ChartAxisDirection12 } = module_support_exports;
var RadarAreaSeries = class extends RadarSeries {
  constructor(moduleCtx) {
    super(moduleCtx);
    this.properties = new RadarAreaSeriesProperties();
    this.resetInvalidToZero = true;
    const areaGroup = new Group7();
    areaGroup.zIndexSubOrder = [() => this._declarationOrder, 0];
    this.contentGroup.append(areaGroup);
    this.areaSelection = Selection3.select(areaGroup, Path6);
  }
  updatePathSelections() {
    const pathData = this.visible ? [true] : [];
    this.areaSelection.update(pathData);
    super.updatePathSelections();
  }
  getAreaNode() {
    return this.areaSelection.nodes()[0];
  }
  getMarkerFill(highlightedStyle) {
    var _a2, _b;
    return (_b = (_a2 = highlightedStyle == null ? void 0 : highlightedStyle.fill) != null ? _a2 : this.properties.marker.fill) != null ? _b : this.properties.fill;
  }
  beforePathAnimation() {
    super.beforePathAnimation();
    const areaNode = this.getAreaNode();
    areaNode.fill = this.properties.fill;
    areaNode.fillOpacity = this.properties.fillOpacity;
    areaNode.pointerEvents = PointerEvents3.None;
    areaNode.stroke = void 0;
  }
  animatePaths(ratio) {
    super.animatePaths(ratio);
    this.animateSinglePath(this.getAreaNode(), this.getAreaPoints(), ratio);
  }
  getAreaPoints() {
    var _a2, _b;
    const points = this.getLinePoints();
    const getPolarAxis = (direction) => {
      const axis = this.axes[direction];
      return axis instanceof module_support_exports.PolarAxis ? axis : void 0;
    };
    const radiusAxis = getPolarAxis(ChartAxisDirection12.Y);
    const angleAxis = getPolarAxis(ChartAxisDirection12.X);
    const reversedRadiusAxis = radiusAxis == null ? void 0 : radiusAxis.isReversed();
    if (!reversedRadiusAxis) {
      return points;
    }
    const { points: zeroLinePoints = [] } = (_b = (_a2 = angleAxis == null ? void 0 : angleAxis.getAxisLinePoints) == null ? void 0 : _a2.call(angleAxis)) != null ? _b : {};
    return points.concat(...zeroLinePoints);
  }
  resetPaths() {
    super.resetPaths();
    const areaNode = this.getAreaNode();
    if (areaNode) {
      const { path: areaPath } = areaNode;
      const areaPoints = this.getAreaPoints();
      areaNode.fill = this.properties.fill;
      areaNode.fillOpacity = this.properties.fillOpacity;
      areaNode.stroke = void 0;
      areaNode.lineDash = this.properties.lineDash;
      areaNode.lineDashOffset = this.properties.lineDashOffset;
      areaNode.lineJoin = areaNode.lineCap = "round";
      areaPath.clear({ trackChanges: true });
      areaPoints.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {
        if (arc) {
          areaPath.arc(x, y, radius, startAngle, endAngle);
        } else if (moveTo) {
          areaPath.moveTo(x, y);
        } else {
          areaPath.lineTo(x, y);
        }
      });
      areaPath.closePath();
      areaNode.checkPathDirty();
    }
  }
};
RadarAreaSeries.className = "RadarAreaSeries";
RadarAreaSeries.type = "radar-area";

// packages/ag-charts-enterprise/src/series/radar-area/radarAreaModule.ts
var { markerPaletteFactory: markerPaletteFactory$1 } = module_support_exports;
var RadarAreaModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radar-area",
  instanceConstructor: RadarAreaSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.ANGLE_CATEGORY
      },
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.RADIUS_NUMBER
      }
    ]
  },
  themeTemplate: RADAR_AREA_SERIES_THEME,
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory$1(params);
    return {
      stroke: marker.stroke,
      fill: marker.fill,
      marker
    };
  }
};

// packages/ag-charts-enterprise/src/series/radar-line/radarLineSeries.ts
var RadarLineSeries = class extends RadarSeries {
  updatePathSelections() {
    this.lineSelection.update(this.visible ? [true] : []);
  }
};
RadarLineSeries.className = "RadarLineSeries";
RadarLineSeries.type = "radar-line";

// packages/ag-charts-enterprise/src/series/radar-line/radarLineModule.ts
var RadarLineModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radar-line",
  instanceConstructor: RadarLineSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.ANGLE_CATEGORY
      },
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.RADIUS_NUMBER
      }
    ]
  },
  themeTemplate: RADAR_LINE_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      stroke: fill,
      marker: { fill, stroke }
    };
  }
};
var { Label: Label4 } = integrated_charts_scene_exports;
var {
  SeriesProperties: SeriesProperties3,
  SeriesTooltip: SeriesTooltip6,
  Validate: Validate29,
  COLOR_STRING: COLOR_STRING11,
  DEGREE: DEGREE5,
  FUNCTION: FUNCTION8,
  LINE_DASH: LINE_DASH8,
  NUMBER: NUMBER9,
  OBJECT: OBJECT9,
  POSITIVE_NUMBER: POSITIVE_NUMBER13,
  RATIO: RATIO15,
  STRING: STRING10
} = module_support_exports;
var RadialBarSeriesProperties = class extends SeriesProperties3 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.rotation = 0;
    this.label = new Label4();
    this.tooltip = new SeriesTooltip6();
  }
};
__decorateClass$1([
  Validate29(STRING10)
], RadialBarSeriesProperties.prototype, "angleKey", 2);
__decorateClass$1([
  Validate29(STRING10)
], RadialBarSeriesProperties.prototype, "radiusKey", 2);
__decorateClass$1([
  Validate29(STRING10, { optional: true })
], RadialBarSeriesProperties.prototype, "angleName", 2);
__decorateClass$1([
  Validate29(STRING10, { optional: true })
], RadialBarSeriesProperties.prototype, "radiusName", 2);
__decorateClass$1([
  Validate29(COLOR_STRING11)
], RadialBarSeriesProperties.prototype, "fill", 2);
__decorateClass$1([
  Validate29(RATIO15)
], RadialBarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate29(COLOR_STRING11)
], RadialBarSeriesProperties.prototype, "stroke", 2);
__decorateClass$1([
  Validate29(POSITIVE_NUMBER13)
], RadialBarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate29(RATIO15)
], RadialBarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate29(LINE_DASH8)
], RadialBarSeriesProperties.prototype, "lineDash", 2);
__decorateClass$1([
  Validate29(POSITIVE_NUMBER13)
], RadialBarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate29(FUNCTION8, { optional: true })
], RadialBarSeriesProperties.prototype, "formatter", 2);
__decorateClass$1([
  Validate29(DEGREE5)
], RadialBarSeriesProperties.prototype, "rotation", 2);
__decorateClass$1([
  Validate29(STRING10, { optional: true })
], RadialBarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass$1([
  Validate29(NUMBER9, { optional: true })
], RadialBarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass$1([
  Validate29(OBJECT9)
], RadialBarSeriesProperties.prototype, "label", 2);
__decorateClass$1([
  Validate29(OBJECT9)
], RadialBarSeriesProperties.prototype, "tooltip", 2);
var { motion: motion5 } = integrated_charts_scene_exports;
function fixRadialBarAnimationStatus(node, datum, status) {
  if (status === "updated") {
    if (node.previousDatum == null || isNaN(node.previousDatum.innerRadius) || isNaN(node.previousDatum.outerRadius)) {
      return "added";
    }
    if (isNaN(datum.innerRadius) || isNaN(datum.outerRadius)) {
      return "removed";
    }
  }
  if (status === "added" && node.previousDatum != null) {
    return "updated";
  }
  return status;
}
function prepareRadialBarSeriesAnimationFunctions(axisZeroAngle) {
  const fromFn = (sect, datum, status) => {
    status = fixRadialBarAnimationStatus(sect, datum, status);
    let startAngle;
    let endAngle;
    let innerRadius;
    let outerRadius;
    if (status === "removed" || status === "updated") {
      startAngle = sect.startAngle;
      endAngle = sect.endAngle;
      innerRadius = sect.innerRadius;
      outerRadius = sect.outerRadius;
    } else {
      startAngle = axisZeroAngle;
      endAngle = axisZeroAngle;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    }
    const phase = motion5.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { startAngle, endAngle, innerRadius, outerRadius, phase };
  };
  const toFn = (sect, datum, status) => {
    let startAngle;
    let endAngle;
    let innerRadius;
    let outerRadius;
    if (status === "removed") {
      startAngle = axisZeroAngle;
      endAngle = axisZeroAngle;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    } else {
      startAngle = datum.startAngle;
      endAngle = datum.endAngle;
      innerRadius = isNaN(datum.innerRadius) ? sect.innerRadius : datum.innerRadius;
      outerRadius = isNaN(datum.outerRadius) ? sect.outerRadius : datum.outerRadius;
    }
    return { startAngle, endAngle, innerRadius, outerRadius };
  };
  return { toFn, fromFn };
}
function resetRadialBarSelectionsFn(_node, datum) {
  return {
    centerX: 0,
    centerY: 0,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    startAngle: datum.startAngle,
    endAngle: datum.endAngle
  };
}

// packages/ag-charts-enterprise/src/series/radial-bar/radialBarSeries.ts
var {
  ChartAxisDirection: ChartAxisDirection13,
  PolarAxis: PolarAxis3,
  diff: diff4,
  isDefined: isDefined3,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty3,
  keyProperty: keyProperty4,
  normaliseGroupTo: normaliseGroupTo2,
  valueProperty: valueProperty7,
  fixNumericExtent: fixNumericExtent5,
  resetLabelFn: resetLabelFn2,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation4,
  seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation2,
  animationValidation: animationValidation5
} = module_support_exports;
var { BandScale: BandScale4 } = sparklines_scale_exports;
var { Sector: Sector4, motion: motion6 } = integrated_charts_scene_exports;
var { angleBetween: angleBetween3, isNumber: isNumber3, sanitizeHtml: sanitizeHtml5 } = sparklines_util_exports;
var RadialBarSeriesNodeClickEvent = class extends module_support_exports.SeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadialBarSeries = class extends module_support_exports.PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      useLabelLayer: true,
      canHaveAxes: true,
      animationResetFns: {
        item: resetRadialBarSelectionsFn,
        label: resetLabelFn2
      }
    });
    this.properties = new RadialBarSeriesProperties();
    this.NodeClickEvent = RadialBarSeriesNodeClickEvent;
    this.nodeData = [];
    this.groupScale = new BandScale4();
    this.circleCache = { r: 0, cx: 0, cy: 0 };
  }
  nodeFactory() {
    return new Sector4();
  }
  addChartEventListeners() {
    var _a2, _b;
    this.destroyFns.push(
      (_a2 = this.ctx.chartEventManager) == null ? void 0 : _a2.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      (_b = this.ctx.chartEventManager) == null ? void 0 : _b.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getSeriesDomain(direction) {
    const { axes, dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection13.X) {
      const angleAxis = axes[ChartAxisDirection13.X];
      const xExtent = dataModel.getDomain(this, "angleValue-end", "value", processedData);
      const fixedXExtent = [xExtent[0] > 0 ? 0 : xExtent[0], xExtent[1] < 0 ? 0 : xExtent[1]];
      return fixNumericExtent5(fixedXExtent, angleAxis);
    } else {
      return dataModel.getDomain(this, "radiusValue", "key", processedData);
    }
  }
  processData(dataController) {
    return __async$1(this, null, function* () {
      var _a2;
      if (!this.properties.isValid()) {
        return;
      }
      const stackGroupId = this.getStackId();
      const stackGroupTrailingId = `${stackGroupId}-trailing`;
      const { angleKey, radiusKey, normalizedTo, visible } = this.properties;
      const extraProps = [];
      if (isDefined3(normalizedTo)) {
        extraProps.push(
          normaliseGroupTo2(this, [stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo), "range")
        );
      }
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      if (animationEnabled) {
        if (this.processedData) {
          extraProps.push(diff4(this.processedData));
        }
        extraProps.push(animationValidation5(this));
      }
      const visibleProps = this.visible || !animationEnabled ? {} : { forceValue: 0 };
      yield this.requestDataModel(dataController, (_a2 = this.data) != null ? _a2 : [], {
        props: [
          keyProperty4(this, radiusKey, false, { id: "radiusValue" }),
          valueProperty7(this, angleKey, true, __spreadValues$1({
            id: "angleValue-raw",
            invalidValue: null
          }, visibleProps)),
          ...groupAccumulativeValueProperty3(this, angleKey, true, "normal", "current", __spreadValues$1({
            id: `angleValue-end`,
            invalidValue: null,
            groupId: stackGroupId
          }, visibleProps)),
          ...groupAccumulativeValueProperty3(this, angleKey, true, "trailing", "current", __spreadValues$1({
            id: `angleValue-start`,
            invalidValue: null,
            groupId: stackGroupTrailingId
          }, visibleProps)),
          ...extraProps
        ],
        dataVisible: visible || animationEnabled
      });
      this.animationState.transition("updateData");
    });
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  maybeRefreshNodeData() {
    return __async$1(this, null, function* () {
      const circleChanged = this.didCircleChange();
      if (!circleChanged && !this.nodeDataRefresh)
        return;
      const [{ nodeData = [] } = {}] = yield this.createNodeData();
      this.nodeData = nodeData;
      this.nodeDataRefresh = false;
    });
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection13.Y];
    return radiusAxis instanceof PolarAxis3 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      var _a2, _b;
      const { processedData, dataModel } = this;
      if (!processedData || !dataModel || !this.properties.isValid()) {
        return [];
      }
      const angleAxis = this.axes[ChartAxisDirection13.X];
      const radiusAxis = this.axes[ChartAxisDirection13.Y];
      const angleScale = angleAxis == null ? void 0 : angleAxis.scale;
      const radiusScale = radiusAxis == null ? void 0 : radiusAxis.scale;
      if (!angleScale || !radiusScale) {
        return [];
      }
      const angleStartIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-start`).index;
      const angleEndIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-end`).index;
      const angleRawIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-raw`).index;
      let groupPaddingInner = 0;
      if (radiusAxis instanceof RadiusCategoryAxis) {
        groupPaddingInner = radiusAxis.groupPaddingInner;
      }
      const { groupScale } = this;
      const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
      groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));
      groupScale.range = [0, Math.abs((_a2 = radiusScale.bandwidth) != null ? _a2 : 0)];
      groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;
      const barWidth = groupScale.bandwidth >= 1 ? groupScale.bandwidth : groupScale.rawBandwidth;
      const radiusAxisReversed = (_b = this.axes[ChartAxisDirection13.Y]) == null ? void 0 : _b.isReversed();
      const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();
      const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;
      const axisTotalRadius = axisOuterRadius + axisInnerRadius;
      const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;
      const getLabelNodeDatum = (datum, angleDatum, x, y) => {
        const labelText = this.getLabelText(
          label,
          { value: angleDatum, datum, angleKey, radiusKey, angleName, radiusName },
          (value) => isNumber3(value) ? value.toFixed(2) : String(value)
        );
        if (labelText) {
          return { x, y, text: labelText, textAlign: "center", textBaseline: "middle" };
        }
      };
      const nodeData = processedData.data.map((group, index) => {
        const { datum, keys, values } = group;
        const radiusDatum = keys[0];
        const angleDatum = values[angleRawIndex];
        const angleStartDatum = values[angleStartIndex];
        const angleEndDatum = values[angleEndIndex];
        let startAngle = Math.max(angleScale.convert(angleStartDatum), angleScale.range[0]);
        let endAngle = Math.min(angleScale.convert(angleEndDatum), angleScale.range[1]);
        if (startAngle > endAngle) {
          [startAngle, endAngle] = [endAngle, startAngle];
        }
        if (angleDatum < 0) {
          [startAngle, endAngle] = [endAngle, startAngle];
        }
        const dataRadius = axisTotalRadius - radiusScale.convert(radiusDatum);
        const innerRadius = dataRadius + groupScale.convert(String(groupIndex));
        const outerRadius = innerRadius + barWidth;
        const midRadius = (innerRadius + outerRadius) / 2;
        const midAngle = startAngle + angleBetween3(startAngle, endAngle) / 2;
        const x = Math.cos(midAngle) * midRadius;
        const y = Math.sin(midAngle) * midRadius;
        const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, angleDatum, x, y) : void 0;
        return {
          series: this,
          datum,
          point: { x, y, size: 0 },
          midPoint: { x, y },
          label: labelNodeDatum,
          angleValue: angleDatum,
          radiusValue: radiusDatum,
          innerRadius,
          outerRadius,
          startAngle,
          endAngle,
          index
        };
      });
      return [{ itemId: radiusKey, nodeData, labelData: nodeData }];
    });
  }
  update(_0) {
    return __async$1(this, arguments, function* ({ seriesRect }) {
      const resize = this.checkResize(seriesRect);
      yield this.maybeRefreshNodeData();
      this.contentGroup.translationX = this.centerX;
      this.contentGroup.translationY = this.centerY;
      this.highlightGroup.translationX = this.centerX;
      this.highlightGroup.translationY = this.centerY;
      if (this.labelGroup) {
        this.labelGroup.translationX = this.centerX;
        this.labelGroup.translationY = this.centerY;
      }
      this.updateSectorSelection(this.itemSelection, false);
      this.updateSectorSelection(this.highlightSelection, true);
      this.updateLabels();
      if (resize) {
        this.animationState.transition("resize");
      }
      this.animationState.transition("update");
    });
  }
  updateSectorSelection(selection, highlight) {
    var _a2, _b, _c, _d, _e;
    let selectionData = [];
    if (highlight) {
      const highlighted = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
      if ((highlighted == null ? void 0 : highlighted.datum) && highlighted.series === this) {
        selectionData = [highlighted];
      }
    } else {
      selectionData = this.nodeData;
    }
    const highlightedStyle = highlight ? this.properties.highlightStyle.item : void 0;
    const fill = (_b = highlightedStyle == null ? void 0 : highlightedStyle.fill) != null ? _b : this.properties.fill;
    const fillOpacity = (_c = highlightedStyle == null ? void 0 : highlightedStyle.fillOpacity) != null ? _c : this.properties.fillOpacity;
    const stroke = (_d = highlightedStyle == null ? void 0 : highlightedStyle.stroke) != null ? _d : this.properties.stroke;
    const strokeOpacity = this.properties.strokeOpacity;
    const strokeWidth = (_e = highlightedStyle == null ? void 0 : highlightedStyle.strokeWidth) != null ? _e : this.properties.strokeWidth;
    const idFn = (datum) => datum.radiusValue;
    selection.update(selectionData, void 0, idFn).each((node, datum) => {
      var _a3, _b2, _c2, _d2, _e2;
      const format = this.properties.formatter ? this.ctx.callbackCache.call(this.properties.formatter, {
        datum,
        fill,
        stroke,
        strokeWidth,
        highlighted: highlight,
        angleKey: this.properties.angleKey,
        radiusKey: this.properties.radiusKey,
        seriesId: this.id
      }) : void 0;
      node.fill = (_a3 = format == null ? void 0 : format.fill) != null ? _a3 : fill;
      node.fillOpacity = (_b2 = format == null ? void 0 : format.fillOpacity) != null ? _b2 : fillOpacity;
      node.stroke = (_c2 = format == null ? void 0 : format.stroke) != null ? _c2 : stroke;
      node.strokeOpacity = strokeOpacity;
      node.strokeWidth = (_d2 = format == null ? void 0 : format.strokeWidth) != null ? _d2 : strokeWidth;
      node.lineDash = this.properties.lineDash;
      node.lineJoin = "round";
      node.inset = stroke != null ? ((_e2 = format == null ? void 0 : format.strokeWidth) != null ? _e2 : strokeWidth) / 2 : 0;
      if (highlight) {
        node.startAngle = datum.startAngle;
        node.endAngle = datum.endAngle;
        node.innerRadius = datum.innerRadius;
        node.outerRadius = datum.outerRadius;
      }
    });
  }
  updateLabels() {
    const { label } = this.properties;
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (label.enabled && datum.label) {
        node.x = datum.label.x;
        node.y = datum.label.y;
        node.fill = label.color;
        node.fontFamily = label.fontFamily;
        node.fontSize = label.fontSize;
        node.fontStyle = label.fontStyle;
        node.fontWeight = label.fontWeight;
        node.text = datum.label.text;
        node.textAlign = datum.label.textAlign;
        node.textBaseline = datum.label.textBaseline;
        node.visible = true;
      } else {
        node.visible = false;
      }
    });
  }
  getBarTransitionFunctions() {
    var _a2;
    const angleScale = (_a2 = this.axes[ChartAxisDirection13.X]) == null ? void 0 : _a2.scale;
    let axisZeroAngle = 0;
    if (!angleScale) {
      return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);
    }
    const d0 = Math.min(angleScale.domain[0], angleScale.domain[1]);
    const d1 = Math.max(angleScale.domain[0], angleScale.domain[1]);
    if (d0 <= 0 && d1 >= 0) {
      axisZeroAngle = angleScale.convert(0);
    }
    return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);
  }
  animateEmptyUpdateReady() {
    const { labelSelection } = this;
    const fns = this.getBarTransitionFunctions();
    motion6.fromToMotion(this.id, "datums", this.ctx.animationManager, [this.itemSelection], fns);
    seriesLabelFadeInAnimation4(this, "labels", this.ctx.animationManager, [labelSelection]);
  }
  animateClearingUpdateEmpty() {
    const { itemSelection } = this;
    const { animationManager } = this.ctx;
    const fns = this.getBarTransitionFunctions();
    motion6.fromToMotion(this.id, "datums", animationManager, [itemSelection], fns);
    seriesLabelFadeOutAnimation2(this, "labels", animationManager, [this.labelSelection]);
  }
  getTooltipHtml(nodeDatum) {
    var _a2;
    const { id: seriesId, axes, dataModel } = this;
    const { angleKey, angleName, radiusKey, radiusName, fill, stroke, strokeWidth, formatter, tooltip } = this.properties;
    const { angleValue, radiusValue, datum } = nodeDatum;
    const xAxis = axes[ChartAxisDirection13.X];
    const yAxis = axes[ChartAxisDirection13.Y];
    if (!this.properties.isValid() || !(xAxis && yAxis && isNumber3(angleValue)) || !dataModel) {
      return "";
    }
    const angleString = xAxis.formatDatum(angleValue);
    const radiusString = yAxis.formatDatum(radiusValue);
    const title = sanitizeHtml5(angleName);
    const content = sanitizeHtml5(`${radiusString}: ${angleString}`);
    const { fill: color } = (_a2 = formatter && this.ctx.callbackCache.call(formatter, {
      datum,
      fill,
      stroke,
      strokeWidth,
      highlighted: false,
      angleKey,
      radiusKey,
      seriesId
    })) != null ? _a2 : { fill };
    return tooltip.toTooltipHtml(
      { title, backgroundColor: fill, content },
      { seriesId, datum, color, title, angleKey, radiusKey, angleName, radiusName }
    );
  }
  getLegendData(legendType) {
    var _a2;
    if (!((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { angleKey, angleName, fill, stroke, fillOpacity, strokeOpacity, strokeWidth, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: angleKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: angleName != null ? angleName : angleKey
        },
        marker: {
          fill: fill != null ? fill : "rgba(0, 0, 0, 0)",
          stroke: stroke != null ? stroke : "rgba(0, 0, 0, 0)",
          fillOpacity: fillOpacity != null ? fillOpacity : 1,
          strokeOpacity: strokeOpacity != null ? strokeOpacity : 1,
          strokeWidth
        }
      }
    ];
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && numVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  computeLabelsBBox() {
    return null;
  }
  getStackId() {
    var _a2, _b;
    const groupIndex = (_b = (_a2 = this.seriesGrouping) == null ? void 0 : _a2.groupIndex) != null ? _b : this.id;
    return `radialBar-stack-${groupIndex}-xValues`;
  }
};
RadialBarSeries.className = "RadialBarSeries";
RadialBarSeries.type = "radial-bar";
var RADIAL_BAR_SERIES_THEME = {
  series: {
    __extends__: integrated_charts_theme_exports.EXTENDS_SERIES_DEFAULTS,
    strokeWidth: 0,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: integrated_charts_theme_exports.DEFAULT_FONT_FAMILY,
      color: integrated_charts_theme_exports.DEFAULT_INVERTED_LABEL_COLOUR,
      __overrides__: integrated_charts_theme_exports.OVERRIDE_SERIES_LABEL_DEFAULTS
    }
  },
  axes: {
    [integrated_charts_theme_exports.POLAR_AXIS_TYPE.RADIUS_CATEGORY]: {
      innerRadiusRatio: 0.2,
      groupPaddingInner: 0.2,
      paddingInner: 0.2,
      paddingOuter: 0.1
    }
  }
};

// packages/ag-charts-enterprise/src/series/radial-bar/radialBarModule.ts
var RadialBarModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radial-bar",
  instanceConstructor: RadialBarSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.ANGLE_NUMBER
      },
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.RADIUS_CATEGORY
      }
    ]
  },
  themeTemplate: RADIAL_BAR_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill,
      stroke
    };
  },
  stackable: true,
  groupable: true
};
var { Validate: Validate30, RATIO: RATIO16 } = module_support_exports;
var RadialColumnSeriesProperties = class extends RadialColumnSeriesBaseProperties {
};
__decorateClass$1([
  Validate30(RATIO16, { optional: true })
], RadialColumnSeriesProperties.prototype, "columnWidthRatio", 2);
__decorateClass$1([
  Validate30(RATIO16, { optional: true })
], RadialColumnSeriesProperties.prototype, "maxColumnWidthRatio", 2);

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnSeries.ts
var { ChartAxisDirection: ChartAxisDirection14, PolarAxis: PolarAxis4 } = module_support_exports;
var { RadialColumnShape: RadialColumnShape$1, getRadialColumnWidth: getRadialColumnWidth$1 } = integrated_charts_scene_exports;
var RadialColumnSeries = class extends RadialColumnSeriesBase {
  constructor(moduleCtx) {
    super(moduleCtx, {
      animationResetFns: {
        item: resetRadialColumnSelectionFn
      }
    });
    this.properties = new RadialColumnSeriesProperties();
  }
  getStackId() {
    var _a2, _b;
    const groupIndex = (_b = (_a2 = this.seriesGrouping) == null ? void 0 : _a2.groupIndex) != null ? _b : this.id;
    return `radarColumn-stack-${groupIndex}-yValues`;
  }
  nodeFactory() {
    return new RadialColumnShape$1();
  }
  getColumnTransitionFunctions() {
    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();
    return prepareRadialColumnAnimationFunctions(axisZeroRadius);
  }
  isRadiusAxisCircle() {
    const radiusAxis = this.axes[ChartAxisDirection14.Y];
    return radiusAxis instanceof PolarAxis4 ? radiusAxis.shape === "circle" : false;
  }
  updateItemPath(node, datum, highlight) {
    node.isBeveled = this.isRadiusAxisCircle();
    node.isRadiusAxisReversed = this.isRadiusAxisReversed();
    if (highlight) {
      node.innerRadius = datum.innerRadius;
      node.outerRadius = datum.outerRadius;
      node.startAngle = datum.startAngle;
      node.endAngle = datum.endAngle;
      node.columnWidth = datum.columnWidth;
      node.axisInnerRadius = datum.axisInnerRadius;
      node.axisOuterRadius = datum.axisOuterRadius;
    }
  }
  getColumnWidth(startAngle, endAngle) {
    const { columnWidthRatio = 0.5, maxColumnWidthRatio = 0.5 } = this.properties;
    return getRadialColumnWidth$1(startAngle, endAngle, this.radius, columnWidthRatio, maxColumnWidthRatio);
  }
};
RadialColumnSeries.className = "RadialColumnSeries";
RadialColumnSeries.type = "radial-column";
var RADIAL_COLUMN_SERIES_THEME = {
  series: {
    __extends__: integrated_charts_theme_exports.EXTENDS_SERIES_DEFAULTS,
    columnWidthRatio: 0.5,
    maxColumnWidthRatio: 0.5,
    strokeWidth: 0,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: integrated_charts_theme_exports.DEFAULT_FONT_FAMILY,
      color: integrated_charts_theme_exports.DEFAULT_LABEL_COLOUR,
      __overrides__: integrated_charts_theme_exports.OVERRIDE_SERIES_LABEL_DEFAULTS
    }
  },
  axes: {
    [integrated_charts_theme_exports.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {
      shape: integrated_charts_theme_exports.POLAR_AXIS_SHAPE.CIRCLE,
      groupPaddingInner: 0,
      paddingInner: 0,
      label: {
        padding: 10
      }
    },
    [integrated_charts_theme_exports.POLAR_AXIS_TYPE.RADIUS_NUMBER]: {
      shape: integrated_charts_theme_exports.POLAR_AXIS_SHAPE.CIRCLE,
      innerRadiusRatio: 0.5
    }
  }
};

// packages/ag-charts-enterprise/src/series/radial-column/radialColumnModule.ts
var RadialColumnModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radial-column",
  instanceConstructor: RadialColumnSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.ANGLE_CATEGORY
      },
      {
        type: integrated_charts_theme_exports.POLAR_AXIS_TYPE.RADIUS_NUMBER
      }
    ]
  },
  themeTemplate: RADIAL_COLUMN_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill,
      stroke
    };
  },
  stackable: true,
  groupable: true
};
var { DropShadow: DropShadow$1, Label: Label5 } = integrated_charts_scene_exports;
var {
  CartesianSeriesProperties: CartesianSeriesProperties2,
  SeriesMarker: SeriesMarker2,
  SeriesTooltip: SeriesTooltip7,
  Validate: Validate31,
  BOOLEAN: BOOLEAN14,
  COLOR_STRING: COLOR_STRING12,
  LINE_DASH: LINE_DASH9,
  OBJECT: OBJECT10,
  PLACEMENT: PLACEMENT$1,
  POSITIVE_NUMBER: POSITIVE_NUMBER14,
  RATIO: RATIO17,
  STRING: STRING11
} = module_support_exports;
var RangeAreaSeriesLabel = class extends Label5 {
  constructor() {
    super(...arguments);
    this.placement = "outside";
    this.padding = 6;
  }
};
__decorateClass$1([
  Validate31(PLACEMENT$1)
], RangeAreaSeriesLabel.prototype, "placement", 2);
__decorateClass$1([
  Validate31(POSITIVE_NUMBER14)
], RangeAreaSeriesLabel.prototype, "padding", 2);
var RangeAreaProperties = class extends CartesianSeriesProperties2 {
  constructor() {
    super(...arguments);
    this.fill = "#99CCFF";
    this.fillOpacity = 1;
    this.stroke = "#99CCFF";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.shadow = new DropShadow$1().set({ enabled: false });
    this.marker = new SeriesMarker2();
    this.label = new RangeAreaSeriesLabel();
    this.tooltip = new SeriesTooltip7();
    this.connectMissingData = false;
  }
};
__decorateClass$1([
  Validate31(STRING11)
], RangeAreaProperties.prototype, "xKey", 2);
__decorateClass$1([
  Validate31(STRING11)
], RangeAreaProperties.prototype, "yLowKey", 2);
__decorateClass$1([
  Validate31(STRING11)
], RangeAreaProperties.prototype, "yHighKey", 2);
__decorateClass$1([
  Validate31(STRING11, { optional: true })
], RangeAreaProperties.prototype, "xName", 2);
__decorateClass$1([
  Validate31(STRING11, { optional: true })
], RangeAreaProperties.prototype, "yName", 2);
__decorateClass$1([
  Validate31(STRING11, { optional: true })
], RangeAreaProperties.prototype, "yLowName", 2);
__decorateClass$1([
  Validate31(STRING11, { optional: true })
], RangeAreaProperties.prototype, "yHighName", 2);
__decorateClass$1([
  Validate31(COLOR_STRING12)
], RangeAreaProperties.prototype, "fill", 2);
__decorateClass$1([
  Validate31(RATIO17)
], RangeAreaProperties.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate31(COLOR_STRING12)
], RangeAreaProperties.prototype, "stroke", 2);
__decorateClass$1([
  Validate31(POSITIVE_NUMBER14)
], RangeAreaProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate31(RATIO17)
], RangeAreaProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate31(LINE_DASH9)
], RangeAreaProperties.prototype, "lineDash", 2);
__decorateClass$1([
  Validate31(POSITIVE_NUMBER14)
], RangeAreaProperties.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate31(OBJECT10)
], RangeAreaProperties.prototype, "shadow", 2);
__decorateClass$1([
  Validate31(OBJECT10)
], RangeAreaProperties.prototype, "marker", 2);
__decorateClass$1([
  Validate31(OBJECT10)
], RangeAreaProperties.prototype, "label", 2);
__decorateClass$1([
  Validate31(OBJECT10)
], RangeAreaProperties.prototype, "tooltip", 2);
__decorateClass$1([
  Validate31(BOOLEAN14)
], RangeAreaProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-enterprise/src/series/range-area/rangeArea.ts
var {
  valueProperty: valueProperty8,
  trailingValueProperty: trailingValueProperty$1,
  keyProperty: keyProperty5,
  ChartAxisDirection: ChartAxisDirection15,
  mergeDefaults: mergeDefaults5,
  updateLabelNode: updateLabelNode$1,
  fixNumericExtent: fixNumericExtent6,
  AreaSeriesTag: AreaSeriesTag$1,
  buildResetPathFn: buildResetPathFn$1,
  resetLabelFn: resetLabelFn3,
  resetMarkerFn: resetMarkerFn2,
  resetMarkerPositionFn: resetMarkerPositionFn$1,
  pathSwipeInAnimation: pathSwipeInAnimation$1,
  resetMotion: resetMotion$1,
  markerSwipeScaleInAnimation: markerSwipeScaleInAnimation$1,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation5,
  animationValidation: animationValidation6,
  diff: diff5,
  updateClipPath: updateClipPath$1
} = module_support_exports;
var { getMarker: getMarker2, PointerEvents: PointerEvents4 } = integrated_charts_scene_exports;
var { sanitizeHtml: sanitizeHtml6, extent: extent3, isNumber: isNumber4 } = sparklines_util_exports;
var DEFAULT_DIRECTION_KEYS$1 = {
  [module_support_exports.ChartAxisDirection.X]: ["xKey"],
  [module_support_exports.ChartAxisDirection.Y]: ["yLowKey", "yHighKey"]
};
var DEFAULT_DIRECTION_NAMES$1 = {
  [ChartAxisDirection15.X]: ["xName"],
  [ChartAxisDirection15.Y]: ["yLowName", "yHighName", "yName"]
};
var RangeAreaSeriesNodeClickEvent = class extends module_support_exports.SeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yLowKey = series.properties.yLowKey;
    this.yHighKey = series.properties.yHighKey;
  }
};
var _RangeAreaSeries = class _RangeAreaSeries extends module_support_exports.CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      hasMarkers: true,
      pathsPerSeries: 2,
      directionKeys: DEFAULT_DIRECTION_KEYS$1,
      directionNames: DEFAULT_DIRECTION_NAMES$1,
      animationResetFns: {
        path: buildResetPathFn$1({ getOpacity: () => this.getOpacity() }),
        label: resetLabelFn3,
        marker: (node, datum) => __spreadValues$1(__spreadValues$1({}, resetMarkerFn2(node)), resetMarkerPositionFn$1(node, datum))
      }
    });
    this.properties = new RangeAreaProperties();
    this.NodeClickEvent = RangeAreaSeriesNodeClickEvent;
  }
  processData(dataController) {
    return __async$1(this, null, function* () {
      var _a2;
      if (!this.properties.isValid()) {
        return;
      }
      const { xKey, yLowKey, yHighKey } = this.properties;
      const { isContinuousX, isContinuousY } = this.isContinuous();
      const extraProps = [];
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      if (!this.ctx.animationManager.isSkipped() && this.processedData) {
        extraProps.push(diff5(this.processedData));
      }
      if (animationEnabled) {
        extraProps.push(animationValidation6(this));
      }
      yield this.requestDataModel(dataController, (_a2 = this.data) != null ? _a2 : [], {
        props: [
          keyProperty5(this, xKey, isContinuousX, { id: `xValue` }),
          valueProperty8(this, yLowKey, isContinuousY, { id: `yLowValue`, invalidValue: void 0 }),
          valueProperty8(this, yHighKey, isContinuousY, { id: `yHighValue`, invalidValue: void 0 }),
          trailingValueProperty$1(this, yLowKey, isContinuousY, {
            id: `yLowTrailingValue`,
            invalidValue: void 0
          }),
          trailingValueProperty$1(this, yHighKey, isContinuousY, {
            id: `yHighTrailingValue`,
            invalidValue: void 0
          }),
          ...extraProps
        ],
        dataVisible: this.visible
      });
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel, axes } = this;
    if (!(processedData && dataModel))
      return [];
    const {
      domain: {
        keys: [keys],
        values
      }
    } = processedData;
    if (direction === ChartAxisDirection15.X) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const xAxis = axes[ChartAxisDirection15.X];
      if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return fixNumericExtent6(extent3(keys), xAxis);
    } else {
      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, "yLowValue").index;
      const yLowExtent = values[yLowIndex];
      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, "yHighValue").index;
      const yHighExtent = values[yHighIndex];
      const fixedYExtent = [
        yLowExtent[0] > yHighExtent[0] ? yHighExtent[0] : yLowExtent[0],
        yHighExtent[1] < yLowExtent[1] ? yLowExtent[1] : yHighExtent[1]
      ];
      return fixNumericExtent6(fixedYExtent);
    }
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      var _a2, _b;
      const { data, dataModel, axes, visible } = this;
      const xAxis = axes[ChartAxisDirection15.X];
      const yAxis = axes[ChartAxisDirection15.Y];
      if (!(data && visible && xAxis && yAxis && dataModel)) {
        return [];
      }
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const { xKey, yLowKey, yHighKey, connectMissingData, marker } = this.properties;
      const itemId = `${yLowKey}-${yHighKey}`;
      const xOffset = ((_a2 = xScale.bandwidth) != null ? _a2 : 0) / 2;
      const defs = dataModel.resolveProcessedDataDefsByIds(this, [
        `xValue`,
        `yHighValue`,
        `yLowValue`,
        `yHighTrailingValue`,
        `yLowTrailingValue`
      ]);
      const createCoordinates = (xValue, yHigh, yLow) => {
        const x = xScale.convert(xValue) + xOffset;
        const yHighCoordinate = yScale.convert(yHigh);
        const yLowCoordinate = yScale.convert(yLow);
        return [
          { point: { x, y: yHighCoordinate }, size: marker.size, itemId: `high`, yValue: yHigh, xValue },
          { point: { x, y: yLowCoordinate }, size: marker.size, itemId: `low`, yValue: yLow, xValue }
        ];
      };
      const createMovePoint = (plainPoint) => {
        const _a3 = plainPoint, { point } = _a3, stroke = __objRest$1(_a3, ["point"]);
        return __spreadProps$1(__spreadValues$1({}, stroke), { point: __spreadProps$1(__spreadValues$1({}, point), { moveTo: true }) });
      };
      const labelData = [];
      const markerData = [];
      const strokeData = { itemId, points: [] };
      const fillData = { itemId, points: [] };
      const context = {
        itemId,
        labelData,
        nodeData: markerData,
        fillData,
        strokeData,
        scales: __superGet$1(_RangeAreaSeries.prototype, this, "calculateScaling").call(this),
        visible: this.visible
      };
      const fillHighPoints = fillData.points;
      const fillLowPoints = [];
      const strokeHighPoints = strokeData.points;
      const strokeLowPoints = [];
      let lastXValue;
      let lastYHighDatum = -Infinity;
      let lastYLowDatum = -Infinity;
      (_b = this.processedData) == null ? void 0 : _b.data.forEach(({ keys, datum, values }, datumIdx) => {
        const dataValues = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });
        const { xValue, yHighValue, yLowValue } = dataValues;
        const invalidRange = yHighValue == null || yLowValue == null;
        const points = invalidRange ? [] : createCoordinates(xValue, yHighValue, yLowValue);
        const inverted = yLowValue > yHighValue;
        points.forEach(({ point: { x, y }, size, itemId: itemId2 = "", yValue }) => {
          markerData.push({
            index: datumIdx,
            series: this,
            itemId: itemId2,
            datum,
            midPoint: { x, y },
            yHighValue,
            yLowValue,
            xValue,
            xKey,
            yLowKey,
            yHighKey,
            point: { x, y, size }
          });
          const labelDatum = this.createLabelData({
            point: { x, y },
            value: yValue,
            yLowValue,
            yHighValue,
            itemId: itemId2,
            inverted,
            datum,
            series: this
          });
          labelData.push(labelDatum);
        });
        const lastYValid = lastYHighDatum != null && lastYLowDatum != null;
        const lastValid = lastXValue != null && lastYValid;
        const xValid = xValue != null;
        const yValid = yHighValue != null && yLowValue != null;
        let [high, low] = createCoordinates(xValue, yHighValue != null ? yHighValue : 0, yLowValue != null ? yLowValue : 0);
        if (!connectMissingData) {
          if (!yValid) {
            const [prevHigh, prevLow] = createCoordinates(lastXValue, 0, 0);
            fillHighPoints.push(prevHigh);
            fillLowPoints.push(prevLow);
          } else if (!lastYValid) {
            const [prevHigh, prevLow] = createCoordinates(xValue, 0, 0);
            fillHighPoints.push(prevHigh);
            fillLowPoints.push(prevLow);
          }
        }
        if (xValid && yValid) {
          fillHighPoints.push(high);
          fillLowPoints.push(low);
        }
        const move = xValid && yValid && !lastValid && !connectMissingData && datumIdx > 0;
        if (move) {
          high = createMovePoint(high);
          low = createMovePoint(low);
        }
        if (xValid && yValid) {
          strokeHighPoints.push(high);
          strokeLowPoints.push(low);
        }
        lastXValue = xValue;
        lastYHighDatum = yHighValue;
        lastYLowDatum = yLowValue;
      });
      if (fillHighPoints.length > 0) {
        fillHighPoints[0] = createMovePoint(fillHighPoints[0]);
      }
      fillHighPoints.push(...fillLowPoints.reverse());
      if (strokeLowPoints.length > 0) {
        strokeLowPoints[0] = createMovePoint(strokeLowPoints[0]);
      }
      strokeHighPoints.push(...strokeLowPoints);
      return [context];
    });
  }
  createLabelData({
    point,
    value,
    itemId,
    inverted,
    datum,
    series
  }) {
    const { xKey, yLowKey, yHighKey, xName, yName, yLowName, yHighName, label } = this.properties;
    const { placement, padding = 10 } = label;
    const actualItemId = inverted ? itemId === "low" ? "high" : "low" : itemId;
    const direction = placement === "outside" && actualItemId === "high" || placement === "inside" && actualItemId === "low" ? -1 : 1;
    return {
      x: point.x,
      y: point.y + padding * direction,
      series,
      itemId,
      datum,
      text: this.getLabelText(
        label,
        { value, datum, itemId, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName },
        (value2) => isNumber4(value2) ? value2.toFixed(2) : String(value2)
      ),
      textAlign: "center",
      textBaseline: direction === -1 ? "bottom" : "top"
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker2(shape);
    return new MarkerShape();
  }
  updatePathNodes(opts) {
    return __async$1(this, null, function* () {
      const { opacity, visible } = opts;
      const [fill, stroke] = opts.paths;
      const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
      stroke.setProperties({
        tag: AreaSeriesTag$1.Stroke,
        fill: void 0,
        lineJoin: stroke.lineCap = "round",
        pointerEvents: PointerEvents4.None,
        stroke: this.properties.stroke,
        strokeWidth,
        strokeOpacity: this.properties.strokeOpacity,
        lineDash: this.properties.lineDash,
        lineDashOffset: this.properties.lineDashOffset,
        opacity,
        visible
      });
      fill.setProperties({
        tag: AreaSeriesTag$1.Fill,
        stroke: void 0,
        lineJoin: "round",
        pointerEvents: PointerEvents4.None,
        fill: this.properties.fill,
        fillOpacity: this.properties.fillOpacity,
        lineDash: this.properties.lineDash,
        lineDashOffset: this.properties.lineDashOffset,
        strokeOpacity: this.properties.strokeOpacity,
        fillShadow: this.properties.shadow,
        strokeWidth,
        opacity,
        visible
      });
      updateClipPath$1(this, stroke);
      updateClipPath$1(this, fill);
    });
  }
  updatePaths(opts) {
    return __async$1(this, null, function* () {
      this.updateAreaPaths([opts.paths], [opts.contextData]);
    });
  }
  updateAreaPaths(paths, contextData) {
    this.updateFillPath(paths, contextData);
    this.updateStrokePath(paths, contextData);
  }
  updateFillPath(paths, contextData) {
    contextData.forEach(({ fillData }, contextDataIndex) => {
      const [fill] = paths[contextDataIndex];
      const { path: fillPath } = fill;
      fillPath.clear({ trackChanges: true });
      for (const { point } of fillData.points) {
        if (point.moveTo) {
          fillPath.moveTo(point.x, point.y);
        } else {
          fillPath.lineTo(point.x, point.y);
        }
      }
      fillPath.closePath();
      fill.checkPathDirty();
    });
  }
  updateStrokePath(paths, contextData) {
    contextData.forEach(({ strokeData }, contextDataIndex) => {
      const [, stroke] = paths[contextDataIndex];
      const { path: strokePath } = stroke;
      strokePath.clear({ trackChanges: true });
      for (const { point } of strokeData.points) {
        if (point.moveTo) {
          strokePath.moveTo(point.x, point.y);
        } else {
          strokePath.lineTo(point.x, point.y);
        }
      }
      stroke.checkPathDirty();
    });
  }
  updateMarkerSelection(opts) {
    return __async$1(this, null, function* () {
      const { nodeData, markerSelection } = opts;
      if (this.properties.marker.isDirty()) {
        markerSelection.clear();
        markerSelection.cleanup();
      }
      return markerSelection.update(this.properties.marker.enabled ? nodeData : []);
    });
  }
  updateMarkerNodes(opts) {
    return __async$1(this, null, function* () {
      const { markerSelection, isHighlight: highlighted } = opts;
      const { xKey, yLowKey, yHighKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity } = this.properties;
      const baseStyle = mergeDefaults5(highlighted && this.properties.highlightStyle.item, marker.getStyle(), {
        fill,
        fillOpacity,
        stroke,
        strokeWidth,
        strokeOpacity
      });
      markerSelection.each((node, datum) => {
        this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yHighKey, yLowKey }, baseStyle);
      });
      if (!highlighted) {
        this.properties.marker.markClean();
      }
    });
  }
  updateLabelSelection(opts) {
    return __async$1(this, null, function* () {
      const { labelData, labelSelection } = opts;
      return labelSelection.update(labelData, (text) => {
        text.tag = AreaSeriesTag$1.Label;
        text.pointerEvents = PointerEvents4.None;
      });
    });
  }
  updateLabelNodes(opts) {
    return __async$1(this, null, function* () {
      opts.labelSelection.each((textNode, datum) => {
        updateLabelNode$1(textNode, this.properties.label, datum);
      });
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);
    return labelItems.length > 0 ? labelItems : void 0;
  }
  getHighlightData(nodeData, highlightedItem) {
    const highlightItems = nodeData.filter((nodeDatum) => nodeDatum.datum === highlightedItem.datum);
    return highlightItems.length > 0 ? highlightItems : void 0;
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes[ChartAxisDirection15.X];
    const yAxis = this.axes[ChartAxisDirection15.Y];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return "";
    }
    const { id: seriesId } = this;
    const { xKey, yLowKey, yHighKey, xName, yName, yLowName, yHighName, fill, tooltip } = this.properties;
    const { datum, itemId, xValue, yLowValue, yHighValue } = nodeDatum;
    const color = fill != null ? fill : "gray";
    const xString = sanitizeHtml6(xAxis.formatDatum(xValue));
    const yLowString = sanitizeHtml6(yAxis.formatDatum(yLowValue));
    const yHighString = sanitizeHtml6(yAxis.formatDatum(yHighValue));
    const xSubheading = xName != null ? xName : xKey;
    const yLowSubheading = yLowName != null ? yLowName : yLowKey;
    const yHighSubheading = yHighName != null ? yHighName : yHighKey;
    const title = sanitizeHtml6(yName);
    const content = yName ? `<b>${sanitizeHtml6(xSubheading)}</b>: ${xString}<br><b>${sanitizeHtml6(yLowSubheading)}</b>: ${yLowString}<br><b>${sanitizeHtml6(yHighSubheading)}</b>: ${yHighString}<br>` : `${xString}: ${yLowString} - ${yHighString}`;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      { seriesId, itemId, datum, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName, color }
    );
  }
  getLegendData(legendType) {
    var _a2, _b;
    if (legendType !== "category") {
      return [];
    }
    const {
      yLowKey,
      yHighKey,
      yName,
      yLowName,
      yHighName,
      fill,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      visible,
      marker
    } = this.properties;
    const legendItemText = yName != null ? yName : `${yLowName != null ? yLowName : yLowKey} - ${yHighName != null ? yHighName : yHighKey}`;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: `${yLowKey}-${yHighKey}`,
        seriesId: this.id,
        enabled: visible,
        label: { text: `${legendItemText}` },
        marker: {
          shape: marker.shape,
          fill: (_a2 = marker.fill) != null ? _a2 : fill,
          stroke: (_b = marker.stroke) != null ? _b : stroke,
          fillOpacity: marker.fillOpacity,
          strokeOpacity: marker.strokeOpacity,
          strokeWidth: marker.strokeWidth
        },
        line: {
          stroke,
          strokeOpacity,
          strokeWidth,
          lineDash
        }
      }
    ];
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  onDataChange() {
  }
  nodeFactory() {
    return new integrated_charts_scene_exports.Group();
  }
  animateEmptyUpdateReady(animationData) {
    const { markerSelections, labelSelections, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateAreaPaths(paths, contextData);
    pathSwipeInAnimation$1(this, animationManager, paths.flat());
    resetMotion$1(markerSelections, resetMarkerPositionFn$1);
    markerSwipeScaleInAnimation$1(this, animationManager, markerSelections);
    seriesLabelFadeInAnimation5(this, "labels", animationManager, labelSelections);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateAreaPaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { contextData, paths } = animationData;
    super.animateWaitingUpdateReady(animationData);
    this.updateAreaPaths(paths, contextData);
  }
};
_RangeAreaSeries.className = "RangeAreaSeries";
_RangeAreaSeries.type = "range-area";
var RangeAreaSeries = _RangeAreaSeries;
var RANGE_AREA_SERIES_THEME = {
  series: {
    __extends__: integrated_charts_theme_exports.EXTENDS_SERIES_DEFAULTS,
    fillOpacity: 0.7,
    nodeClickRange: "nearest",
    marker: {
      __extends__: integrated_charts_theme_exports.EXTENDS_CARTESIAN_MARKER_DEFAULTS,
      enabled: false,
      fillOpacity: 1,
      strokeWidth: 2,
      size: 6
    },
    label: {
      enabled: false,
      placement: "outside",
      padding: 10,
      fontSize: 12,
      fontFamily: integrated_charts_theme_exports.DEFAULT_FONT_FAMILY,
      color: integrated_charts_theme_exports.DEFAULT_LABEL_COLOUR,
      __overrides__: integrated_charts_theme_exports.OVERRIDE_SERIES_LABEL_DEFAULTS
    }
  },
  axes: {
    [integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        enabled: true,
        snap: false
      }
    }
  }
};

// packages/ag-charts-enterprise/src/series/range-area/rangeAreaModule.ts
var { markerPaletteFactory: markerPaletteFactory2 } = module_support_exports;
var RangeAreaModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "range-area",
  instanceConstructor: RangeAreaSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.NUMBER,
        position: integrated_charts_theme_exports.POSITION.LEFT,
        crosshair: {
          enabled: true,
          snap: false
        }
      },
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.CATEGORY,
        position: integrated_charts_theme_exports.POSITION.BOTTOM
      }
    ]
  },
  themeTemplate: RANGE_AREA_SERIES_THEME,
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory2(params);
    return {
      fill: marker.fill,
      stroke: marker.stroke,
      marker
    };
  }
};
var { DropShadow: DropShadow2, Label: Label6 } = integrated_charts_scene_exports;
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties3,
  SeriesTooltip: SeriesTooltip8,
  Validate: Validate32,
  COLOR_STRING: COLOR_STRING13,
  FUNCTION: FUNCTION9,
  LINE_DASH: LINE_DASH10,
  OBJECT: OBJECT11,
  PLACEMENT: PLACEMENT2,
  POSITIVE_NUMBER: POSITIVE_NUMBER15,
  RATIO: RATIO18,
  STRING: STRING12
} = module_support_exports;
var RangeBarSeriesLabel = class extends Label6 {
  constructor() {
    super(...arguments);
    this.placement = "inside";
    this.padding = 6;
  }
};
__decorateClass$1([
  Validate32(PLACEMENT2)
], RangeBarSeriesLabel.prototype, "placement", 2);
__decorateClass$1([
  Validate32(POSITIVE_NUMBER15)
], RangeBarSeriesLabel.prototype, "padding", 2);
var RangeBarProperties = class extends AbstractBarSeriesProperties3 {
  constructor() {
    super(...arguments);
    this.fill = "#99CCFF";
    this.fillOpacity = 1;
    this.stroke = "#99CCFF";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.shadow = new DropShadow2().set({ enabled: false });
    this.label = new RangeBarSeriesLabel();
    this.tooltip = new SeriesTooltip8();
  }
};
__decorateClass$1([
  Validate32(STRING12)
], RangeBarProperties.prototype, "xKey", 2);
__decorateClass$1([
  Validate32(STRING12)
], RangeBarProperties.prototype, "yLowKey", 2);
__decorateClass$1([
  Validate32(STRING12)
], RangeBarProperties.prototype, "yHighKey", 2);
__decorateClass$1([
  Validate32(STRING12, { optional: true })
], RangeBarProperties.prototype, "xName", 2);
__decorateClass$1([
  Validate32(STRING12, { optional: true })
], RangeBarProperties.prototype, "yName", 2);
__decorateClass$1([
  Validate32(STRING12, { optional: true })
], RangeBarProperties.prototype, "yLowName", 2);
__decorateClass$1([
  Validate32(STRING12, { optional: true })
], RangeBarProperties.prototype, "yHighName", 2);
__decorateClass$1([
  Validate32(COLOR_STRING13)
], RangeBarProperties.prototype, "fill", 2);
__decorateClass$1([
  Validate32(RATIO18)
], RangeBarProperties.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate32(COLOR_STRING13)
], RangeBarProperties.prototype, "stroke", 2);
__decorateClass$1([
  Validate32(POSITIVE_NUMBER15)
], RangeBarProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate32(RATIO18)
], RangeBarProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate32(LINE_DASH10)
], RangeBarProperties.prototype, "lineDash", 2);
__decorateClass$1([
  Validate32(POSITIVE_NUMBER15)
], RangeBarProperties.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate32(POSITIVE_NUMBER15)
], RangeBarProperties.prototype, "cornerRadius", 2);
__decorateClass$1([
  Validate32(FUNCTION9, { optional: true })
], RangeBarProperties.prototype, "formatter", 2);
__decorateClass$1([
  Validate32(OBJECT11)
], RangeBarProperties.prototype, "shadow", 2);
__decorateClass$1([
  Validate32(OBJECT11)
], RangeBarProperties.prototype, "label", 2);
__decorateClass$1([
  Validate32(OBJECT11)
], RangeBarProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/range-bar/rangeBar.ts
var {
  SeriesNodePickMode: SeriesNodePickMode4,
  valueProperty: valueProperty9,
  keyProperty: keyProperty6,
  ChartAxisDirection: ChartAxisDirection16,
  getRectConfig: getRectConfig$1,
  updateRect: updateRect$1,
  checkCrisp: checkCrisp$1,
  updateLabelNode: updateLabelNode2,
  CategoryAxis: CategoryAxis2,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL2,
  diff: diff6,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions2,
  midpointStartingBarPosition: midpointStartingBarPosition$1,
  resetBarSelectionsFn: resetBarSelectionsFn2,
  fixNumericExtent: fixNumericExtent7,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation6,
  resetLabelFn: resetLabelFn4,
  animationValidation: animationValidation7,
  createDatumId: createDatumId2
} = module_support_exports;
var { ContinuousScale: ContinuousScale$1, BandScale: BandScale5, Rect: Rect3, PointerEvents: PointerEvents5, motion: motion7 } = integrated_charts_scene_exports;
var { sanitizeHtml: sanitizeHtml7, isNumber: isNumber5, extent: extent4 } = sparklines_util_exports;
var DEFAULT_DIRECTION_KEYS2 = {
  [module_support_exports.ChartAxisDirection.X]: ["xKey"],
  [module_support_exports.ChartAxisDirection.Y]: ["yLowKey", "yHighKey"]
};
var DEFAULT_DIRECTION_NAMES2 = {
  [ChartAxisDirection16.X]: ["xName"],
  [ChartAxisDirection16.Y]: ["yLowName", "yHighName", "yName"]
};
var RangeBarSeriesNodeClickEvent = class extends module_support_exports.SeriesNodeClickEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yLowKey = series.properties.yLowKey;
    this.yHighKey = series.properties.yHighKey;
  }
};
var _RangeBarSeries = class _RangeBarSeries extends module_support_exports.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode4.EXACT_SHAPE_MATCH],
      hasHighlightedLabels: true,
      directionKeys: DEFAULT_DIRECTION_KEYS2,
      directionNames: DEFAULT_DIRECTION_NAMES2,
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        datum: resetBarSelectionsFn2,
        label: resetLabelFn4
      }
    });
    this.properties = new RangeBarProperties();
    this.NodeClickEvent = RangeBarSeriesNodeClickEvent;
    /**
     * Used to get the position of bars within each group.
     */
    this.groupScale = new BandScale5();
    this.smallestDataInterval = void 0;
  }
  resolveKeyDirection(direction) {
    if (this.getBarDirection() === ChartAxisDirection16.X) {
      if (direction === ChartAxisDirection16.X) {
        return ChartAxisDirection16.Y;
      }
      return ChartAxisDirection16.X;
    }
    return direction;
  }
  processData(dataController) {
    return __async$1(this, null, function* () {
      var _a2, _b, _c, _d, _e;
      if (!this.properties.isValid()) {
        return;
      }
      const { xKey, yLowKey, yHighKey } = this.properties;
      const isContinuousX = ContinuousScale$1.is((_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale);
      const isContinuousY = ContinuousScale$1.is((_b = this.getValueAxis()) == null ? void 0 : _b.scale);
      const extraProps = [];
      if (!this.ctx.animationManager.isSkipped()) {
        if (this.processedData) {
          extraProps.push(diff6(this.processedData));
        }
        extraProps.push(animationValidation7(this));
      }
      const visibleProps = !this.visible ? { forceValue: 0 } : {};
      const { processedData } = yield this.requestDataModel(dataController, (_c = this.data) != null ? _c : [], {
        props: [
          keyProperty6(this, xKey, isContinuousX, { id: "xValue" }),
          valueProperty9(this, yLowKey, isContinuousY, __spreadValues$1({ id: `yLowValue` }, visibleProps)),
          valueProperty9(this, yHighKey, isContinuousY, __spreadValues$1({ id: `yHighValue` }, visibleProps)),
          ...isContinuousX ? [SMALLEST_KEY_INTERVAL2] : [],
          ...extraProps
        ],
        groupByKeys: true
      });
      this.smallestDataInterval = {
        x: (_e = (_d = processedData.reduced) == null ? void 0 : _d.smallestKeyInterval) != null ? _e : Infinity,
        y: Infinity
      };
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    var _a2;
    const { processedData, dataModel } = this;
    if (!(processedData && dataModel))
      return [];
    const {
      domain: {
        keys: [keys],
        values
      }
    } = processedData;
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && (keyDef == null ? void 0 : keyDef.def.valueType) === "category") {
        return keys;
      }
      const { reduced: { [SMALLEST_KEY_INTERVAL2.property]: smallestX } = {} } = processedData;
      const scalePadding = smallestX != null && isFinite(smallestX) ? smallestX : 0;
      const keysExtent = (_a2 = extent4(keys)) != null ? _a2 : [NaN, NaN];
      const categoryAxis = this.getCategoryAxis();
      const isReversed = categoryAxis == null ? void 0 : categoryAxis.isReversed();
      if (direction === ChartAxisDirection16.Y) {
        const d02 = keysExtent[0] + (isReversed ? 0 : -scalePadding);
        const d12 = keysExtent[1] + (isReversed ? scalePadding : 0);
        return fixNumericExtent7([d02, d12], categoryAxis);
      }
      const d0 = keysExtent[0] + (isReversed ? -scalePadding : 0);
      const d1 = keysExtent[1] + (isReversed ? 0 : scalePadding);
      return fixNumericExtent7([d0, d1], categoryAxis);
    } else {
      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, "yLowValue").index;
      const yLowExtent = values[yLowIndex];
      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, "yHighValue").index;
      const yHighExtent = values[yHighIndex];
      const fixedYExtent = [
        yLowExtent[0] > yHighExtent[0] ? yHighExtent[0] : yLowExtent[0],
        yHighExtent[1] < yLowExtent[1] ? yLowExtent[1] : yHighExtent[1]
      ];
      return fixNumericExtent7(fixedYExtent);
    }
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      const {
        data,
        dataModel,
        groupScale,
        processedData,
        smallestDataInterval,
        ctx: { seriesStateManager },
        properties: { visible }
      } = this;
      const xAxis = this.getCategoryAxis();
      const yAxis = this.getValueAxis();
      if (!(data && visible && xAxis && yAxis && dataModel)) {
        return [];
      }
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const barAlongX = this.getBarDirection() === ChartAxisDirection16.X;
      const { xKey, yLowKey, yHighKey, fill, stroke, strokeWidth } = this.properties;
      const itemId = `${yLowKey}-${yHighKey}`;
      const contexts = [];
      const domain = [];
      const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);
      for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {
        domain.push(String(groupIdx));
      }
      const xBandWidth = ContinuousScale$1.is(xScale) ? xScale.calcBandwidth(smallestDataInterval == null ? void 0 : smallestDataInterval.x) : xScale.bandwidth;
      groupScale.domain = domain;
      groupScale.range = [0, xBandWidth != null ? xBandWidth : 0];
      if (xAxis instanceof CategoryAxis2) {
        groupScale.paddingInner = xAxis.groupPaddingInner;
      } else {
        groupScale.padding = 0;
      }
      groupScale.round = groupScale.padding !== 0;
      const barWidth = groupScale.bandwidth >= 1 ? (
        // Pixel-rounded value for low-volume range charts.
        groupScale.bandwidth
      ) : (
        // Handle high-volume range charts gracefully.
        groupScale.rawBandwidth
      );
      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, `yLowValue`).index;
      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, `yHighValue`).index;
      const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;
      processedData == null ? void 0 : processedData.data.forEach(({ keys, datum, values }, dataIndex) => {
        values.forEach((value, contextIndex) => {
          var _a2;
          (_a2 = contexts[contextIndex]) != null ? _a2 : contexts[contextIndex] = {
            itemId,
            nodeData: [],
            labelData: [],
            scales: __superGet$1(_RangeBarSeries.prototype, this, "calculateScaling").call(this),
            visible: this.visible
          };
          const xDatum = keys[xIndex];
          const x = Math.round(xScale.convert(xDatum)) + groupScale.convert(String(groupIndex));
          const rawLowValue = value[yLowIndex];
          const rawHighValue = value[yHighIndex];
          const yLowValue = Math.min(rawLowValue, rawHighValue);
          const yHighValue = Math.max(rawLowValue, rawHighValue);
          const yLow = Math.round(yScale.convert(yLowValue));
          const yHigh = Math.round(yScale.convert(yHighValue));
          const y = yHigh;
          const bottomY = yLow;
          const barHeight = Math.max(strokeWidth, Math.abs(bottomY - y));
          const rect = {
            x: barAlongX ? Math.min(y, bottomY) : x,
            y: barAlongX ? x : Math.min(y, bottomY),
            width: barAlongX ? barHeight : barWidth,
            height: barAlongX ? barWidth : barHeight
          };
          const nodeMidPoint = {
            x: rect.x + rect.width / 2,
            y: rect.y + rect.height / 2
          };
          const labelData = this.createLabelData({
            rect,
            barAlongX,
            yLowValue,
            yHighValue,
            datum: datum[contextIndex],
            series: this
          });
          const nodeDatum = {
            index: dataIndex,
            series: this,
            itemId,
            datum: datum[contextIndex],
            xValue: xDatum,
            yLowValue: rawLowValue,
            yHighValue: rawHighValue,
            yLowKey,
            yHighKey,
            xKey,
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height,
            midPoint: nodeMidPoint,
            fill,
            stroke,
            strokeWidth,
            opacity: 1,
            labels: labelData
          };
          contexts[contextIndex].nodeData.push(nodeDatum);
          contexts[contextIndex].labelData.push(...labelData);
        });
      });
      return contexts;
    });
  }
  createLabelData({
    rect,
    barAlongX,
    yLowValue,
    yHighValue,
    datum,
    series
  }) {
    const { xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName, label } = this.properties;
    const labelParams = { datum, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName };
    const { placement, padding } = label;
    const paddingDirection = placement === "outside" ? 1 : -1;
    const labelPadding = padding * paddingDirection;
    const yLowLabel = {
      x: rect.x + (barAlongX ? -labelPadding : rect.width / 2),
      y: rect.y + (barAlongX ? rect.height / 2 : rect.height + labelPadding),
      textAlign: barAlongX ? "left" : "center",
      textBaseline: barAlongX ? "middle" : "bottom",
      text: this.getLabelText(
        label,
        __spreadValues$1({ itemId: "low", value: yLowValue }, labelParams),
        (value) => isNumber5(value) ? value.toFixed(2) : ""
      ),
      itemId: "low",
      datum,
      series
    };
    const yHighLabel = {
      x: rect.x + (barAlongX ? rect.width + labelPadding : rect.width / 2),
      y: rect.y + (barAlongX ? rect.height / 2 : -labelPadding),
      textAlign: barAlongX ? "right" : "center",
      textBaseline: barAlongX ? "middle" : "top",
      text: this.getLabelText(
        label,
        __spreadValues$1({ itemId: "high", value: yHighValue }, labelParams),
        (value) => isNumber5(value) ? value.toFixed(2) : ""
      ),
      itemId: "high",
      datum,
      series
    };
    if (placement === "outside") {
      yLowLabel.textAlign = barAlongX ? "right" : "center";
      yLowLabel.textBaseline = barAlongX ? "middle" : "top";
      yHighLabel.textAlign = barAlongX ? "left" : "center";
      yHighLabel.textBaseline = barAlongX ? "middle" : "bottom";
    }
    return [yLowLabel, yHighLabel];
  }
  nodeFactory() {
    return new Rect3();
  }
  updateDatumSelection(opts) {
    return __async$1(this, null, function* () {
      const { nodeData, datumSelection } = opts;
      const data = nodeData != null ? nodeData : [];
      return datumSelection.update(data, void 0, (datum) => this.getDatumId(datum));
    });
  }
  updateDatumNodes(opts) {
    return __async$1(this, null, function* () {
      const { datumSelection, isHighlight } = opts;
      const { id: seriesId, ctx } = this;
      const {
        yLowKey,
        yHighKey,
        highlightStyle: { item: itemHighlightStyle }
      } = this.properties;
      const xAxis = this.axes[ChartAxisDirection16.X];
      const crisp = checkCrisp$1(xAxis == null ? void 0 : xAxis.visibleRange);
      const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection16.X;
      datumSelection.each((rect, datum) => {
        const {
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset,
          formatter,
          shadow: fillShadow
        } = this.properties;
        const style = {
          fill: datum.fill,
          stroke: datum.stroke,
          fillOpacity,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          fillShadow,
          strokeWidth: this.getStrokeWidth(strokeWidth),
          cornerRadius: this.properties.cornerRadius,
          cornerRadiusBbox: void 0
        };
        const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
        const config = getRectConfig$1({
          datum,
          lowValue: datum.yLowValue,
          highValue: datum.yHighValue,
          isHighlighted: isHighlight,
          style,
          highlightStyle: itemHighlightStyle,
          formatter,
          seriesId,
          itemId: datum.itemId,
          ctx,
          yLowKey,
          yHighKey
        });
        config.crisp = crisp;
        config.visible = visible;
        updateRect$1({ rect, config });
      });
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);
    return labelItems.length > 0 ? labelItems : void 0;
  }
  updateLabelSelection(opts) {
    return __async$1(this, null, function* () {
      const labelData = this.properties.label.enabled ? opts.labelData : [];
      return opts.labelSelection.update(labelData, (text) => {
        text.pointerEvents = PointerEvents5.None;
      });
    });
  }
  updateLabelNodes(opts) {
    return __async$1(this, null, function* () {
      opts.labelSelection.each((textNode, datum) => {
        updateLabelNode2(textNode, this.properties.label, datum);
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a2, _b;
    const {
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return "";
    }
    const { xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName, fill, strokeWidth, formatter, tooltip } = this.properties;
    const { datum, itemId, xValue, yLowValue, yHighValue } = nodeDatum;
    let format;
    if (formatter) {
      format = callbackCache.call(formatter, {
        datum,
        xKey,
        yLowKey,
        yHighKey,
        fill,
        strokeWidth,
        highlighted: false,
        seriesId,
        itemId
      });
    }
    const color = (_b = (_a2 = format == null ? void 0 : format.fill) != null ? _a2 : fill) != null ? _b : "gray";
    const xString = sanitizeHtml7(xAxis.formatDatum(xValue));
    const yLowString = sanitizeHtml7(yAxis.formatDatum(yLowValue));
    const yHighString = sanitizeHtml7(yAxis.formatDatum(yHighValue));
    const xSubheading = xName != null ? xName : xKey;
    const yLowSubheading = yLowName != null ? yLowName : yLowKey;
    const yHighSubheading = yHighName != null ? yHighName : yHighKey;
    const title = sanitizeHtml7(yName);
    const content = yName ? `<b>${sanitizeHtml7(xSubheading)}</b>: ${xString}<br><b>${sanitizeHtml7(yLowSubheading)}</b>: ${yLowString}<br><b>${sanitizeHtml7(yHighSubheading)}</b>: ${yHighString}<br>` : `${xString}: ${yLowString} - ${yHighString}`;
    const defaults = {
      title,
      content,
      backgroundColor: color
    };
    return tooltip.toTooltipHtml(defaults, {
      datum,
      xKey,
      xName,
      yLowKey,
      yLowName,
      yHighKey,
      yHighName,
      yName,
      color,
      seriesId,
      itemId
    });
  }
  getLegendData(legendType) {
    const { id, visible } = this;
    if (legendType !== "category") {
      return [];
    }
    const { fill, stroke, strokeWidth, fillOpacity, strokeOpacity, yName, yLowName, yHighName, yLowKey, yHighKey } = this.properties;
    const legendItemText = yName != null ? yName : `${yLowName != null ? yLowName : yLowKey} - ${yHighName != null ? yHighName : yHighKey}`;
    return [
      {
        legendType: "category",
        id,
        itemId: `${yLowKey}-${yHighKey}`,
        seriesId: id,
        enabled: visible,
        label: { text: `${legendItemText}` },
        marker: { fill, stroke, fillOpacity, strokeOpacity, strokeWidth }
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelections, labelSelections }) {
    const fns = prepareBarAnimationFunctions2(midpointStartingBarPosition$1(this.isVertical(), "normal"));
    motion7.fromToMotion(this.id, "datums", this.ctx.animationManager, datumSelections, fns);
    seriesLabelFadeInAnimation6(this, "labels", this.ctx.animationManager, labelSelections);
  }
  animateWaitingUpdateReady(data) {
    var _a2;
    const { datumSelections, labelSelections } = data;
    const { processedData } = this;
    const diff7 = (_a2 = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _a2.diff;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const fns = prepareBarAnimationFunctions2(midpointStartingBarPosition$1(this.isVertical(), "fade"));
    motion7.fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      datumSelections,
      fns,
      (_, datum) => createDatumId2(datum.xValue),
      diff7
    );
    seriesLabelFadeInAnimation6(this, "labels", this.ctx.animationManager, labelSelections);
  }
  getDatumId(datum) {
    return `${datum.xValue}`;
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  onDataChange() {
  }
};
_RangeBarSeries.className = "RangeBarSeries";
_RangeBarSeries.type = "range-bar";
var RangeBarSeries = _RangeBarSeries;
var RANGE_BAR_SERIES_THEME = {
  series: {
    __extends__: integrated_charts_theme_exports.EXTENDS_SERIES_DEFAULTS,
    direction: "vertical",
    strokeWidth: 0,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: integrated_charts_theme_exports.DEFAULT_FONT_FAMILY,
      color: integrated_charts_theme_exports.DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
      placement: "inside",
      __overrides__: integrated_charts_theme_exports.OVERRIDE_SERIES_LABEL_DEFAULTS
    }
  },
  axes: {
    [integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        enabled: true,
        snap: false
      }
    }
  }
};

// packages/ag-charts-enterprise/src/series/range-bar/rangeBarModule.ts
var RangeBarModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "range-bar",
  instanceConstructor: RangeBarSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.CATEGORY,
        position: integrated_charts_theme_exports.POSITION.BOTTOM
      },
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.NUMBER,
        position: integrated_charts_theme_exports.POSITION.LEFT
      }
    ]
  },
  themeTemplate: RANGE_BAR_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill,
      stroke
    };
  },
  groupable: true,
  swapDefaultAxesCondition: ({ direction }) => direction === "horizontal"
};
var {
  HierarchySeriesProperties: HierarchySeriesProperties$1,
  HighlightStyle: HighlightStyle$1,
  SeriesTooltip: SeriesTooltip9,
  Validate: Validate33,
  COLOR_STRING: COLOR_STRING14,
  FUNCTION: FUNCTION10,
  NUMBER: NUMBER10,
  OBJECT: OBJECT12,
  POSITIVE_NUMBER: POSITIVE_NUMBER16,
  RATIO: RATIO19,
  STRING: STRING13
} = module_support_exports;
var SunburstSeriesTileHighlightStyle = class extends HighlightStyle$1 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedLabel();
  }
};
__decorateClass$1([
  Validate33(STRING13, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "fill", 2);
__decorateClass$1([
  Validate33(RATIO19, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate33(COLOR_STRING14, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "stroke", 2);
__decorateClass$1([
  Validate33(POSITIVE_NUMBER16, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate33(RATIO19, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate33(OBJECT12)
], SunburstSeriesTileHighlightStyle.prototype, "label", 2);
__decorateClass$1([
  Validate33(OBJECT12)
], SunburstSeriesTileHighlightStyle.prototype, "secondaryLabel", 2);
var SunburstSeriesProperties = class extends HierarchySeriesProperties$1 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.highlightStyle = new SunburstSeriesTileHighlightStyle();
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizeableSecondaryLabel();
    this.tooltip = new SeriesTooltip9();
  }
};
__decorateClass$1([
  Validate33(STRING13, { optional: true })
], SunburstSeriesProperties.prototype, "sizeName", 2);
__decorateClass$1([
  Validate33(STRING13, { optional: true })
], SunburstSeriesProperties.prototype, "labelKey", 2);
__decorateClass$1([
  Validate33(STRING13, { optional: true })
], SunburstSeriesProperties.prototype, "secondaryLabelKey", 2);
__decorateClass$1([
  Validate33(RATIO19)
], SunburstSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate33(POSITIVE_NUMBER16)
], SunburstSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate33(RATIO19)
], SunburstSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate33(NUMBER10, { optional: true })
], SunburstSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass$1([
  Validate33(NUMBER10, { optional: true })
], SunburstSeriesProperties.prototype, "padding", 2);
__decorateClass$1([
  Validate33(FUNCTION10, { optional: true })
], SunburstSeriesProperties.prototype, "formatter", 2);
__decorateClass$1([
  Validate33(OBJECT12)
], SunburstSeriesProperties.prototype, "highlightStyle", 2);
__decorateClass$1([
  Validate33(OBJECT12)
], SunburstSeriesProperties.prototype, "label", 2);
__decorateClass$1([
  Validate33(OBJECT12)
], SunburstSeriesProperties.prototype, "secondaryLabel", 2);
__decorateClass$1([
  Validate33(OBJECT12)
], SunburstSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/sunburst/sunburstSeries.ts
var { fromToMotion: fromToMotion2 } = module_support_exports;
var { Sector: Sector5, Group: Group8, Selection: Selection4, Text: Text7 } = integrated_charts_scene_exports;
var { sanitizeHtml: sanitizeHtml8 } = sparklines_util_exports;
var getAngleData = (node, startAngle = 0, angleScale = 2 * Math.PI / node.sumSize, angleData = Array.from(node, () => void 0)) => {
  let currentAngle = startAngle;
  for (const child of node.children) {
    const start = currentAngle;
    const end = currentAngle + child.sumSize * angleScale;
    angleData[child.index] = { start, end };
    getAngleData(child, start, angleScale, angleData);
    currentAngle = end;
  }
  return angleData;
};
var _SunburstSeries = class _SunburstSeries extends module_support_exports.HierarchySeries {
  constructor() {
    super(...arguments);
    this.properties = new SunburstSeriesProperties();
    this.groupSelection = Selection4.select(this.contentGroup, Group8);
    this.highlightSelection = Selection4.select(
      this.highlightGroup,
      Group8
    );
    this.angleData = [];
  }
  processData() {
    return __async$1(this, null, function* () {
      const { childrenKey, colorKey, colorName, labelKey, secondaryLabelKey, sizeKey, sizeName } = this.properties;
      __superGet$1(_SunburstSeries.prototype, this, "processData").call(this);
      this.angleData = getAngleData(this.rootNode);
      const defaultLabelFormatter = (value) => {
        if (typeof value === "number") {
          return value.toFixed(2);
        } else if (typeof value === "string") {
          return value;
        } else {
          return "";
        }
      };
      this.labelData = Array.from(this.rootNode, ({ datum, depth }) => {
        let label;
        if (datum != null && depth != null && labelKey != null) {
          const value = datum[labelKey];
          label = this.getLabelText(
            this.properties.label,
            {
              depth,
              datum,
              childrenKey,
              colorKey,
              colorName,
              labelKey,
              secondaryLabelKey,
              sizeKey,
              sizeName,
              value
            },
            defaultLabelFormatter
          );
        }
        if (label === "") {
          label = void 0;
        }
        let secondaryLabel;
        if (datum != null && depth != null && secondaryLabelKey != null) {
          const value = datum[secondaryLabelKey];
          secondaryLabel = this.getLabelText(
            this.properties.secondaryLabel,
            {
              depth,
              datum,
              childrenKey,
              colorKey,
              colorName,
              labelKey,
              secondaryLabelKey,
              sizeKey,
              sizeName,
              value
            },
            defaultLabelFormatter
          );
        }
        if (secondaryLabel === "") {
          secondaryLabel = void 0;
        }
        return label != null || secondaryLabel != null ? { label, secondaryLabel } : void 0;
      });
    });
  }
  updateSelections() {
    return __async$1(this, null, function* () {
      if (!this.nodeDataRefresh)
        return;
      this.nodeDataRefresh = false;
      const { chart } = this;
      if (chart == null)
        return;
      const seriesRect = chart.seriesRect;
      if (seriesRect == null)
        return;
      const descendants = Array.from(this.rootNode);
      const updateGroup = (group) => {
        group.append([
          new Sector5(),
          new Text7({ tag: 0 /* Primary */ }),
          new Text7({ tag: 1 /* Secondary */ })
        ]);
      };
      this.groupSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
      this.highlightSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
    });
  }
  updateNodes() {
    return __async$1(this, null, function* () {
      var _a2;
      const { chart, data, maxDepth, labelData } = this;
      if (chart == null || data == null || labelData == null) {
        return;
      }
      const { width, height } = chart.seriesRect;
      const { sectorSpacing = 0, padding = 0, highlightStyle } = this.properties;
      this.contentGroup.translationX = width / 2;
      this.contentGroup.translationY = height / 2;
      this.highlightGroup.translationX = width / 2;
      this.highlightGroup.translationY = height / 2;
      const baseInset = sectorSpacing * 0.5;
      const radius = Math.min(width, height) / 2;
      const radiusScale = radius / (maxDepth + 1);
      const angleOffset = -Math.PI / 2;
      const highlightedNode = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
      const labelTextNode = new Text7();
      labelTextNode.setFont(this.properties.label);
      this.rootNode.walk((node) => {
        const angleDatum = this.angleData[node.index];
        if (node.depth != null && angleDatum != null) {
          const midAngle = angleDatum.end - angleDatum.start;
          const midRadius = (node.depth + 0.5) * radiusScale;
          node.midPoint.x = Math.cos(midAngle) * midRadius;
          node.midPoint.y = Math.sin(midAngle) * midRadius;
        }
      });
      const updateSector = (node, sector, highlighted) => {
        var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const { depth } = node;
        const angleDatum = this.angleData[node.index];
        if (depth == null || angleDatum == null) {
          sector.visible = false;
          return;
        }
        sector.visible = true;
        let highlightedFill;
        let highlightedFillOpacity;
        let highlightedStroke;
        let highlightedStrokeWidth;
        let highlightedStrokeOpacity;
        if (highlighted) {
          highlightedFill = highlightStyle.fill;
          highlightedFillOpacity = highlightStyle.fillOpacity;
          highlightedStroke = highlightStyle.stroke;
          highlightedStrokeWidth = highlightStyle.strokeWidth;
          highlightedStrokeOpacity = highlightStyle.strokeOpacity;
        }
        const format = this.getSectorFormat(node, highlighted);
        const fill = (_b = (_a3 = format == null ? void 0 : format.fill) != null ? _a3 : highlightedFill) != null ? _b : node.fill;
        const fillOpacity = (_d = (_c = format == null ? void 0 : format.fillOpacity) != null ? _c : highlightedFillOpacity) != null ? _d : this.properties.fillOpacity;
        const stroke = (_f = (_e = format == null ? void 0 : format.stroke) != null ? _e : highlightedStroke) != null ? _f : node.stroke;
        const strokeWidth = (_h = (_g = format == null ? void 0 : format.strokeWidth) != null ? _g : highlightedStrokeWidth) != null ? _h : this.properties.strokeWidth;
        const strokeOpacity = (_j = (_i = format == null ? void 0 : format.strokeOpacity) != null ? _i : highlightedStrokeOpacity) != null ? _j : this.properties.strokeOpacity;
        sector.fill = fill;
        sector.fillOpacity = fillOpacity;
        sector.stroke = stroke;
        sector.strokeWidth = strokeWidth;
        sector.strokeOpacity = strokeOpacity;
        sector.centerX = 0;
        sector.centerY = 0;
        sector.innerRadius = depth * radiusScale;
        sector.outerRadius = (depth + 1) * radiusScale;
        sector.angleOffset = angleOffset;
        sector.startAngle = angleDatum.start;
        sector.endAngle = angleDatum.end;
        sector.inset = baseInset + strokeWidth * 0.5;
      };
      this.groupSelection.selectByClass(Sector5).forEach((sector) => {
        updateSector(sector.datum, sector, false);
      });
      this.highlightSelection.selectByClass(Sector5).forEach((sector) => {
        const node = sector.datum;
        const isHighlighted = highlightedNode === node;
        sector.visible = isHighlighted;
        if (sector.visible) {
          updateSector(sector.datum, sector, isHighlighted);
        }
      });
      const labelMeta = Array.from(this.rootNode, (node, index) => {
        const { depth } = node;
        const labelDatum = labelData[index];
        const angleData = this.angleData[index];
        if (depth == null || angleData == null)
          return void 0;
        const innerRadius = depth * radiusScale + baseInset;
        const outerRadius = (depth + 1) * radiusScale - baseInset;
        const innerAngleOffset = innerRadius > baseInset ? baseInset / innerRadius : baseInset;
        const outerAngleOffset = outerRadius > baseInset ? baseInset / outerRadius : baseInset;
        const innerStartAngle = angleData.start + innerAngleOffset;
        const innerEndAngle = angleData.end + innerAngleOffset;
        const deltaInnerAngle = innerEndAngle - innerStartAngle;
        const outerStartAngle = angleData.start + outerAngleOffset;
        const outerEndAngle = angleData.end + outerAngleOffset;
        const deltaOuterAngle = outerEndAngle - outerStartAngle;
        const sizeFittingHeight = (height3) => {
          var _a3;
          const isCenterCircle = depth === 0 && ((_a3 = node.parent) == null ? void 0 : _a3.sumSize) === node.sumSize;
          if (isCenterCircle) {
            const width3 = 2 * Math.sqrt(__pow$1(outerRadius, 2) - __pow$1(height3 * 0.5, 2));
            return { width: width3, height: height3, meta: 0 /* CenterCircle */ };
          }
          const parallelHeight = height3;
          const availableWidthUntilItHitsTheOuterRadius = 2 * Math.sqrt(__pow$1(outerRadius, 2) - __pow$1(innerRadius + parallelHeight, 2));
          const availableWidthUntilItHitsTheStraightEdges = deltaInnerAngle < Math.PI ? 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5) : Infinity;
          const parallelWidth = Math.min(
            availableWidthUntilItHitsTheOuterRadius,
            availableWidthUntilItHitsTheStraightEdges
          );
          let perpendicularHeight;
          let perpendicularWidth;
          if (depth === 0) {
            perpendicularHeight = height3;
            perpendicularWidth = Math.sqrt(__pow$1(outerRadius, 2) - __pow$1(perpendicularHeight / 2, 2)) - height3 / (2 * Math.tan(deltaOuterAngle * 0.5));
          } else {
            perpendicularHeight = 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5);
            perpendicularWidth = Math.sqrt(__pow$1(outerRadius, 2) - __pow$1(perpendicularHeight / 2, 2)) - innerRadius;
          }
          return parallelWidth >= perpendicularWidth ? { width: parallelWidth, height: parallelHeight, meta: 1 /* Parallel */ } : { width: perpendicularWidth, height: perpendicularHeight, meta: 2 /* Perpendicular */ };
        };
        const formatting = formatLabels(
          labelDatum == null ? void 0 : labelDatum.label,
          this.properties.label,
          labelDatum == null ? void 0 : labelDatum.secondaryLabel,
          this.properties.secondaryLabel,
          { padding },
          sizeFittingHeight
        );
        if (formatting == null)
          return void 0;
        const { width: width2, height: height2, meta: labelPlacement, label, secondaryLabel } = formatting;
        const theta = angleOffset + (angleData.start + angleData.end) / 2;
        const top = Math.sin(theta) >= 0;
        const right = Math.cos(theta) >= 0;
        const circleQuarter = (top ? 3 /* Top */ : 12 /* Bottom */) & (right ? 6 /* Right */ : 9 /* Left */);
        let radius2;
        switch (labelPlacement) {
          case 0 /* CenterCircle */:
            radius2 = 0;
            break;
          case 1 /* Parallel */: {
            const opticalCentering = 0.58;
            const idealRadius = outerRadius - (radiusScale - height2) * opticalCentering;
            const maximumRadius = Math.sqrt(__pow$1(outerRadius - padding, 2) - __pow$1(width2 / 2, 2));
            radius2 = Math.min(idealRadius, maximumRadius);
            break;
          }
          case 2 /* Perpendicular */:
            if (depth === 0) {
              const minimumRadius = height2 / (2 * Math.tan(deltaInnerAngle * 0.5)) + width2 * 0.5;
              const maximumRadius = Math.sqrt(__pow$1(outerRadius, 2) - __pow$1(height2 * 0.5, 2)) - width2 * 0.5;
              radius2 = (minimumRadius + maximumRadius) * 0.5;
            } else {
              radius2 = (innerRadius + outerRadius) * 0.5;
            }
            break;
        }
        return { width: width2, height: height2, labelPlacement, circleQuarter, radius: radius2, theta, label, secondaryLabel };
      });
      const updateText = (node, text, tag, highlighted) => {
        const { index, depth } = node;
        const meta = labelMeta == null ? void 0 : labelMeta[index];
        const labelStyle = tag === 0 /* Primary */ ? this.properties.label : this.properties.secondaryLabel;
        const label = tag === 0 /* Primary */ ? meta == null ? void 0 : meta.label : meta == null ? void 0 : meta.secondaryLabel;
        if (depth == null || meta == null || label == null) {
          text.visible = false;
          return;
        }
        const { height: height2, labelPlacement, circleQuarter, radius: radius2, theta } = meta;
        let highlightedColor;
        if (highlighted) {
          const highlightedLabelStyle = tag === 0 /* Primary */ ? this.properties.highlightStyle.label : this.properties.highlightStyle.secondaryLabel;
          highlightedColor = highlightedLabelStyle.color;
        }
        text.text = label.text;
        text.fontSize = label.fontSize;
        text.lineHeight = label.lineHeight;
        text.fontStyle = labelStyle.fontStyle;
        text.fontFamily = labelStyle.fontFamily;
        text.fontWeight = labelStyle.fontWeight;
        text.fill = highlightedColor != null ? highlightedColor : labelStyle.color;
        switch (labelPlacement) {
          case 0 /* CenterCircle */:
            text.textAlign = "center";
            text.textBaseline = "top";
            text.translationX = 0;
            text.translationY = (tag === 0 /* Primary */ ? 0 : height2 - label.height) - height2 * 0.5;
            text.rotation = 0;
            break;
          case 1 /* Parallel */: {
            const topHalf = (circleQuarter & 3 /* Top */) !== 0;
            const translationRadius = tag === 0 /* Primary */ === !topHalf ? radius2 : radius2 - (height2 - label.height);
            text.textAlign = "center";
            text.textBaseline = topHalf ? "bottom" : "top";
            text.translationX = Math.cos(theta) * translationRadius;
            text.translationY = Math.sin(theta) * translationRadius;
            text.rotation = topHalf ? theta - Math.PI * 0.5 : theta + Math.PI * 0.5;
            break;
          }
          case 2 /* Perpendicular */: {
            const rightHalf = (circleQuarter & 6 /* Right */) !== 0;
            const translation = tag === 0 /* Primary */ === !rightHalf ? (height2 - label.height) * 0.5 : (label.height - height2) * 0.5;
            text.textAlign = "center";
            text.textBaseline = "middle";
            text.translationX = Math.cos(theta) * radius2 + Math.cos(theta + Math.PI / 2) * translation;
            text.translationY = Math.sin(theta) * radius2 + Math.sin(theta + Math.PI / 2) * translation;
            text.rotation = rightHalf ? theta : theta + Math.PI;
            break;
          }
        }
        text.visible = true;
      };
      this.groupSelection.selectByClass(Text7).forEach((text) => {
        updateText(text.datum, text, text.tag, false);
      });
      this.highlightSelection.selectByClass(Text7).forEach((text) => {
        const node = text.datum;
        const isHighlighted = highlightedNode === node;
        text.visible = isHighlighted;
        if (text.visible) {
          updateText(text.datum, text, text.tag, isHighlighted);
        }
      });
    });
  }
  getSectorFormat(node, isHighlighted) {
    const { datum, fill, stroke, depth } = node;
    const {
      ctx: { callbackCache },
      properties: { formatter }
    } = this;
    if (!formatter || datum == null || depth == null) {
      return {};
    }
    const { colorKey, labelKey, sizeKey, strokeWidth } = this.properties;
    const result = callbackCache.call(formatter, {
      seriesId: this.id,
      depth,
      datum,
      colorKey,
      labelKey,
      sizeKey,
      fill,
      stroke,
      strokeWidth,
      highlighted: isHighlighted
    });
    return result != null ? result : {};
  }
  getTooltipHtml(node) {
    var _a2;
    const { id: seriesId } = this;
    const {
      tooltip,
      colorKey,
      colorName = colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      sizeName = sizeKey
    } = this.properties;
    const { datum, depth } = node;
    if (datum == null || depth == null) {
      return "";
    }
    const title = labelKey != null ? datum[labelKey] : void 0;
    const format = this.getSectorFormat(node, false);
    const color = (_a2 = format == null ? void 0 : format.fill) != null ? _a2 : node.fill;
    if (!tooltip.renderer && !title) {
      return "";
    }
    const contentArray = [];
    const datumSecondaryLabel = secondaryLabelKey != null ? datum[secondaryLabelKey] : void 0;
    if (datumSecondaryLabel != null && secondaryLabelKey !== colorKey && secondaryLabelKey !== sizeKey) {
      contentArray.push(sanitizeHtml8(datumSecondaryLabel));
    }
    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;
    if (datumSize != null) {
      contentArray.push(`${sizeName}: ${sanitizeHtml8(datumSize)}`);
    }
    const datumColor = colorKey != null ? datum[colorKey] : void 0;
    if (datumColor != null) {
      contentArray.push(`${colorName}: ${sanitizeHtml8(datumColor)}`);
    }
    const content = contentArray.join("<br>");
    const defaults = {
      title,
      color: this.properties.label.color,
      backgroundColor: color,
      content
    };
    return tooltip.toTooltipHtml(defaults, {
      depth,
      datum,
      colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      title,
      color,
      seriesId
    });
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      return [];
    });
  }
  animateEmptyUpdateReady({
    datumSelections
  }) {
    fromToMotion2(this.id, "nodes", this.ctx.animationManager, datumSelections, {
      toFn(_group, _datum, _status) {
        return { scalingX: 1, scalingY: 1 };
      },
      fromFn(group, datum, status) {
        if (status === "unknown" && datum != null && group.previousDatum == null) {
          return { scalingX: 0, scalingY: 0 };
        } else {
          return { scalingX: 1, scalingY: 1 };
        }
      }
    });
  }
};
_SunburstSeries.className = "SunburstSeries";
_SunburstSeries.type = "sunburst";
var SunburstSeries = _SunburstSeries;

// packages/ag-charts-enterprise/src/series/sunburst/sunburstSeriesModule.ts
var { EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS$1, DEFAULT_INSIDE_SERIES_LABEL_COLOUR: DEFAULT_INSIDE_SERIES_LABEL_COLOUR$1 } = integrated_charts_theme_exports;
var SunburstSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["hierarchy"],
  identifier: "sunburst",
  instanceConstructor: SunburstSeries,
  seriesDefaults: {},
  solo: true,
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS$1,
      label: {
        fontSize: 14,
        minimumFontSize: 9,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR$1,
        overflowStrategy: "ellipsis",
        wrapping: "never",
        spacing: 2
      },
      secondaryLabel: {
        fontSize: 8,
        minimumFontSize: 7,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR$1,
        overflowStrategy: "ellipsis",
        wrapping: "never"
      },
      sectorSpacing: 2,
      padding: 3,
      highlightStyle: {
        label: {
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR$1
        },
        secondaryLabel: {
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR$1
        },
        stroke: `rgba(0, 0, 0, 0.4)`,
        strokeWidth: 2
      }
    },
    gradientLegend: {
      enabled: true
    }
  },
  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {
    const { properties } = themeTemplateParameters;
    const { fills, strokes } = takeColors(colorsCount);
    const defaultColorRange = properties.get(integrated_charts_theme_exports.DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);
    return { fills, strokes, colorRange: defaultColorRange };
  }
};
var { Label: Label7 } = integrated_charts_scene_exports;
var {
  BaseProperties: BaseProperties7,
  HierarchySeriesProperties: HierarchySeriesProperties2,
  HighlightStyle: HighlightStyle2,
  SeriesTooltip: SeriesTooltip10,
  Validate: Validate34,
  BOOLEAN: BOOLEAN15,
  COLOR_STRING: COLOR_STRING15,
  FUNCTION: FUNCTION11,
  NUMBER: NUMBER11,
  OBJECT: OBJECT13,
  POSITIVE_NUMBER: POSITIVE_NUMBER17,
  RATIO: RATIO20,
  STRING: STRING14,
  STRING_ARRAY: STRING_ARRAY$1,
  TEXT_ALIGN: TEXT_ALIGN2,
  VERTICAL_ALIGN: VERTICAL_ALIGN2
} = module_support_exports;
var TreemapGroupLabel = class extends Label7 {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass$1([
  Validate34(NUMBER11)
], TreemapGroupLabel.prototype, "spacing", 2);
var TreemapSeriesGroup = class extends BaseProperties7 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.textAlign = "center";
    this.gap = 0;
    this.padding = 0;
    this.interactive = true;
    this.label = new TreemapGroupLabel();
  }
};
__decorateClass$1([
  Validate34(STRING14, { optional: true })
], TreemapSeriesGroup.prototype, "fill", 2);
__decorateClass$1([
  Validate34(RATIO20)
], TreemapSeriesGroup.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate34(COLOR_STRING15, { optional: true })
], TreemapSeriesGroup.prototype, "stroke", 2);
__decorateClass$1([
  Validate34(POSITIVE_NUMBER17)
], TreemapSeriesGroup.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate34(RATIO20)
], TreemapSeriesGroup.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate34(TEXT_ALIGN2)
], TreemapSeriesGroup.prototype, "textAlign", 2);
__decorateClass$1([
  Validate34(POSITIVE_NUMBER17)
], TreemapSeriesGroup.prototype, "gap", 2);
__decorateClass$1([
  Validate34(POSITIVE_NUMBER17)
], TreemapSeriesGroup.prototype, "padding", 2);
__decorateClass$1([
  Validate34(BOOLEAN15)
], TreemapSeriesGroup.prototype, "interactive", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesGroup.prototype, "label", 2);
var TreemapSeriesTile = class extends BaseProperties7 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.gap = 0;
    this.padding = 0;
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizeableSecondaryLabel();
  }
};
__decorateClass$1([
  Validate34(STRING14, { optional: true })
], TreemapSeriesTile.prototype, "fill", 2);
__decorateClass$1([
  Validate34(RATIO20)
], TreemapSeriesTile.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate34(COLOR_STRING15, { optional: true })
], TreemapSeriesTile.prototype, "stroke", 2);
__decorateClass$1([
  Validate34(POSITIVE_NUMBER17, { optional: true })
], TreemapSeriesTile.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate34(RATIO20)
], TreemapSeriesTile.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate34(TEXT_ALIGN2)
], TreemapSeriesTile.prototype, "textAlign", 2);
__decorateClass$1([
  Validate34(VERTICAL_ALIGN2)
], TreemapSeriesTile.prototype, "verticalAlign", 2);
__decorateClass$1([
  Validate34(POSITIVE_NUMBER17)
], TreemapSeriesTile.prototype, "gap", 2);
__decorateClass$1([
  Validate34(POSITIVE_NUMBER17)
], TreemapSeriesTile.prototype, "padding", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesTile.prototype, "label", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesTile.prototype, "secondaryLabel", 2);
var TreemapSeriesGroupHighlightStyle = class extends BaseProperties7 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
  }
};
__decorateClass$1([
  Validate34(STRING14, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "fill", 2);
__decorateClass$1([
  Validate34(RATIO20, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate34(COLOR_STRING15, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "stroke", 2);
__decorateClass$1([
  Validate34(POSITIVE_NUMBER17, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate34(RATIO20, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesGroupHighlightStyle.prototype, "label", 2);
var TreemapSeriesTileHighlightStyle = class extends BaseProperties7 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizeableSecondaryLabel();
  }
};
__decorateClass$1([
  Validate34(STRING14, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "fill", 2);
__decorateClass$1([
  Validate34(RATIO20, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate34(COLOR_STRING15, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "stroke", 2);
__decorateClass$1([
  Validate34(POSITIVE_NUMBER17, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate34(RATIO20, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesTileHighlightStyle.prototype, "label", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesTileHighlightStyle.prototype, "secondaryLabel", 2);
var TreemapSeriesHighlightStyle = class extends HighlightStyle2 {
  constructor() {
    super(...arguments);
    this.group = new TreemapSeriesGroupHighlightStyle();
    this.tile = new TreemapSeriesTileHighlightStyle();
  }
};
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesHighlightStyle.prototype, "group", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesHighlightStyle.prototype, "tile", 2);
var TreemapSeriesProperties = class extends HierarchySeriesProperties2 {
  constructor() {
    super(...arguments);
    this.highlightStyle = new TreemapSeriesHighlightStyle();
    this.tooltip = new SeriesTooltip10();
    this.group = new TreemapSeriesGroup();
    this.tile = new TreemapSeriesTile();
    this.undocumentedGroupFills = [];
    this.undocumentedGroupStrokes = [];
  }
};
__decorateClass$1([
  Validate34(STRING14, { optional: true })
], TreemapSeriesProperties.prototype, "sizeName", 2);
__decorateClass$1([
  Validate34(STRING14, { optional: true })
], TreemapSeriesProperties.prototype, "labelKey", 2);
__decorateClass$1([
  Validate34(STRING14, { optional: true })
], TreemapSeriesProperties.prototype, "secondaryLabelKey", 2);
__decorateClass$1([
  Validate34(FUNCTION11, { optional: true })
], TreemapSeriesProperties.prototype, "formatter", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesProperties.prototype, "highlightStyle", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesProperties.prototype, "tooltip", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesProperties.prototype, "group", 2);
__decorateClass$1([
  Validate34(OBJECT13)
], TreemapSeriesProperties.prototype, "tile", 2);
__decorateClass$1([
  Validate34(STRING_ARRAY$1)
], TreemapSeriesProperties.prototype, "undocumentedGroupFills", 2);
__decorateClass$1([
  Validate34(STRING_ARRAY$1)
], TreemapSeriesProperties.prototype, "undocumentedGroupStrokes", 2);

// packages/ag-charts-enterprise/src/series/treemap/treemapSeries.ts
var { Rect: Rect4, Group: Group9, BBox: BBox7, Selection: Selection5, Text: Text8 } = integrated_charts_scene_exports;
var { Color: Color2, Logger: Logger6, isEqual: isEqual$1, sanitizeHtml: sanitizeHtml9 } = sparklines_util_exports;
var tempText = new Text8();
function getTextSize(text, style) {
  const { fontStyle, fontWeight, fontSize, fontFamily } = style;
  tempText.setProperties({
    text,
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    textAlign: "left",
    textBaseline: "top"
  });
  const { width, height } = tempText.computeBBox();
  return { width, height };
}
function validateColor(color) {
  if (typeof color === "string" && !Color2.validColorString(color)) {
    const fallbackColor = "black";
    Logger6.warnOnce(
      `invalid Treemap tile colour string "${color}". Affected treemap tiles will be coloured ${fallbackColor}.`
    );
    return fallbackColor;
  }
  return color;
}
function nodeSize(node) {
  return node.children.length > 0 ? node.sumSize - node.size : node.size;
}
var textAlignFactors2 = {
  left: 0,
  center: 0.5,
  right: 1
};
var verticalAlignFactors2 = {
  top: 0,
  middle: 0.5,
  bottom: 1
};
var _TreemapSeries = class _TreemapSeries extends module_support_exports.HierarchySeries {
  constructor() {
    super(...arguments);
    this.properties = new TreemapSeriesProperties();
    this.groupSelection = Selection5.select(this.contentGroup, Group9);
    this.highlightSelection = Selection5.select(
      this.highlightGroup,
      Group9
    );
  }
  groupTitleHeight(node, bbox) {
    var _a2, _b;
    const label = (_b = (_a2 = this.labelData) == null ? void 0 : _a2[node.index]) == null ? void 0 : _b.label;
    const { label: font } = this.properties.group;
    const heightRatioThreshold = 3;
    if (label == null) {
      return void 0;
    } else if (font.fontSize > bbox.width / heightRatioThreshold || font.fontSize > bbox.height / heightRatioThreshold) {
      return void 0;
    } else {
      const { height: fontHeight } = getTextSize(label, font);
      return Math.max(fontHeight, font.fontSize);
    }
  }
  getNodePadding(node, bbox) {
    if (node.index === 0) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    } else if (node.children.length === 0) {
      const { padding: padding2 } = this.properties.tile;
      return {
        top: padding2,
        right: padding2,
        bottom: padding2,
        left: padding2
      };
    }
    const {
      label: { spacing },
      padding
    } = this.properties.group;
    const fontHeight = this.groupTitleHeight(node, bbox);
    const titleHeight = fontHeight != null ? fontHeight + spacing : 0;
    return {
      top: padding + titleHeight,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  processData() {
    return __async$1(this, null, function* () {
      var _a2;
      yield __superGet$1(_TreemapSeries.prototype, this, "processData").call(this);
      const { childrenKey, colorKey, colorName, labelKey, secondaryLabelKey, sizeKey, sizeName, tile, group } = this.properties;
      if (!((_a2 = this.data) == null ? void 0 : _a2.length)) {
        this.labelData = void 0;
        return;
      }
      const defaultLabelFormatter = (value) => {
        if (typeof value === "number") {
          return value.toFixed(2);
        } else if (typeof value === "string") {
          return value;
        } else {
          return "";
        }
      };
      this.labelData = Array.from(this.rootNode, ({ datum, depth, children }) => {
        const isLeaf = children.length === 0;
        const labelStyle = isLeaf ? tile.label : group.label;
        let label;
        if (datum != null && depth != null && labelKey != null) {
          const value = datum[labelKey];
          label = this.getLabelText(
            labelStyle,
            {
              depth,
              datum,
              childrenKey,
              colorKey,
              colorName,
              labelKey,
              secondaryLabelKey,
              sizeKey,
              sizeName,
              value
            },
            defaultLabelFormatter
          );
        }
        if (label === "") {
          label = void 0;
        }
        let secondaryLabel;
        if (isLeaf && datum != null && depth != null && secondaryLabelKey != null) {
          const value = datum[secondaryLabelKey];
          secondaryLabel = this.getLabelText(
            tile.secondaryLabel,
            {
              depth,
              datum,
              childrenKey,
              colorKey,
              colorName,
              labelKey,
              secondaryLabelKey,
              sizeKey,
              sizeName,
              value
            },
            defaultLabelFormatter
          );
        }
        if (secondaryLabel === "") {
          secondaryLabel = void 0;
        }
        return label != null || secondaryLabel != null ? { label, secondaryLabel } : void 0;
      });
    });
  }
  /**
   * Squarified Treemap algorithm
   * https://www.win.tue.nl/~vanwijk/stm.pdf
   */
  squarify(node, bbox, outputBoxes) {
    const { index, datum, children } = node;
    if (bbox.width <= 0 || bbox.height <= 0) {
      outputBoxes[index] = void 0;
      return;
    }
    outputBoxes[index] = index !== 0 ? bbox : void 0;
    const sortedChildrenIndices = Array.from(children, (_, index2) => index2).filter((index2) => nodeSize(children[index2]) > 0).sort((aIndex, bIndex) => nodeSize(children[bIndex]) - nodeSize(children[aIndex]));
    const childAt = (index2) => {
      const sortedIndex = sortedChildrenIndices[index2];
      return children[sortedIndex];
    };
    const allLeafNodes = sortedChildrenIndices.every((sortedIndex) => children[sortedIndex].children.length === 0);
    const targetTileAspectRatio = 1;
    const padding = datum != null ? this.getNodePadding(node, bbox) : { top: 0, right: 0, bottom: 0, left: 0 };
    const width = bbox.width - padding.left - padding.right;
    const height = bbox.height - padding.top - padding.bottom;
    if (width <= 0 || height <= 0)
      return;
    const numChildren = sortedChildrenIndices.length;
    let stackSum = 0;
    let startIndex = 0;
    let minRatioDiff = Infinity;
    let partitionSum = sortedChildrenIndices.reduce((sum, sortedIndex) => sum + nodeSize(children[sortedIndex]), 0);
    const innerBox = new BBox7(bbox.x + padding.left, bbox.y + padding.top, width, height);
    const partition = innerBox.clone();
    for (let i = 0; i < numChildren; i++) {
      const value = nodeSize(childAt(i));
      const firstValue = nodeSize(childAt(startIndex));
      const isVertical2 = partition.width < partition.height;
      stackSum += value;
      const partThickness = isVertical2 ? partition.height : partition.width;
      const partLength = isVertical2 ? partition.width : partition.height;
      const firstTileLength = partLength * firstValue / stackSum;
      let stackThickness = partThickness * stackSum / partitionSum;
      const ratio = Math.max(firstTileLength, stackThickness) / Math.min(firstTileLength, stackThickness);
      const diff7 = Math.abs(targetTileAspectRatio - ratio);
      if (diff7 < minRatioDiff) {
        minRatioDiff = diff7;
        continue;
      }
      stackSum -= value;
      stackThickness = partThickness * stackSum / partitionSum;
      let start2 = isVertical2 ? partition.x : partition.y;
      for (let j = startIndex; j < i; j++) {
        const child = childAt(j);
        const childSize = nodeSize(child);
        const x = isVertical2 ? start2 : partition.x;
        const y = isVertical2 ? partition.y : start2;
        const length = partLength * childSize / stackSum;
        const width2 = isVertical2 ? length : stackThickness;
        const height2 = isVertical2 ? stackThickness : length;
        const childBbox = new BBox7(x, y, width2, height2);
        this.applyGap(innerBox, childBbox, allLeafNodes);
        this.squarify(child, childBbox, outputBoxes);
        partitionSum -= childSize;
        start2 += length;
      }
      if (isVertical2) {
        partition.y += stackThickness;
        partition.height -= stackThickness;
      } else {
        partition.x += stackThickness;
        partition.width -= stackThickness;
      }
      startIndex = i;
      stackSum = 0;
      minRatioDiff = Infinity;
      i--;
    }
    const isVertical = partition.width < partition.height;
    let start = isVertical ? partition.x : partition.y;
    for (let i = startIndex; i < numChildren; i++) {
      const child = childAt(i);
      const x = isVertical ? start : partition.x;
      const y = isVertical ? partition.y : start;
      const part = nodeSize(child) / partitionSum;
      const width2 = partition.width * (isVertical ? part : 1);
      const height2 = partition.height * (isVertical ? 1 : part);
      const childBox = new BBox7(x, y, width2, height2);
      this.applyGap(innerBox, childBox, allLeafNodes);
      this.squarify(child, childBox, outputBoxes);
      start += isVertical ? width2 : height2;
    }
  }
  applyGap(innerBox, childBox, allLeafNodes) {
    const gap = allLeafNodes ? this.properties.tile.gap * 0.5 : this.properties.group.gap * 0.5;
    const getBounds = (box) => ({
      left: box.x,
      top: box.y,
      right: box.x + box.width,
      bottom: box.y + box.height
    });
    const innerBounds = getBounds(innerBox);
    const childBounds = getBounds(childBox);
    const sides = ["top", "right", "bottom", "left"];
    sides.forEach((side) => {
      if (!isEqual$1(innerBounds[side], childBounds[side])) {
        childBox.shrink(gap, side);
      }
    });
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      return [];
    });
  }
  updateSelections() {
    return __async$1(this, null, function* () {
      var _a2;
      if (!this.nodeDataRefresh) {
        return;
      }
      this.nodeDataRefresh = false;
      const { seriesRect } = (_a2 = this.chart) != null ? _a2 : {};
      if (!seriesRect)
        return;
      const descendants = Array.from(this.rootNode);
      const updateGroup = (group) => {
        group.append([
          new Rect4(),
          new Text8({ tag: 0 /* Primary */ }),
          new Text8({ tag: 1 /* Secondary */ })
        ]);
      };
      this.groupSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
      this.highlightSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
    });
  }
  getTileFormat(node, isHighlighted) {
    var _a2, _b;
    const { datum, depth, children } = node;
    const { colorKey, labelKey, secondaryLabelKey, sizeKey, tile, group, formatter } = this.properties;
    if (!formatter || datum == null || depth == null) {
      return {};
    }
    const isLeaf = children.length === 0;
    const fill = (_a2 = isLeaf ? tile.fill : group.fill) != null ? _a2 : node.fill;
    const stroke = (_b = isLeaf ? tile.stroke : group.stroke) != null ? _b : node.stroke;
    const strokeWidth = isLeaf ? tile.strokeWidth : group.strokeWidth;
    const result = this.ctx.callbackCache.call(formatter, {
      seriesId: this.id,
      depth,
      datum,
      colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      fill,
      stroke,
      strokeWidth,
      highlighted: isHighlighted
    });
    return result != null ? result : {};
  }
  getNodeFill(node) {
    var _a2, _b, _c;
    const isLeaf = node.children.length === 0;
    if (isLeaf) {
      return (_a2 = this.properties.tile.fill) != null ? _a2 : node.fill;
    }
    const { undocumentedGroupFills } = this.properties;
    const defaultFill = undocumentedGroupFills[Math.min((_b = node.depth) != null ? _b : 0, undocumentedGroupFills.length)];
    return (_c = this.properties.group.fill) != null ? _c : defaultFill;
  }
  getNodeStroke(node) {
    var _a2, _b, _c;
    const isLeaf = node.children.length === 0;
    if (isLeaf) {
      return (_a2 = this.properties.tile.stroke) != null ? _a2 : node.stroke;
    }
    const { undocumentedGroupStrokes } = this.properties;
    const defaultStroke = undocumentedGroupStrokes[Math.min((_b = node.depth) != null ? _b : 0, undocumentedGroupStrokes.length)];
    return (_c = this.properties.group.stroke) != null ? _c : defaultStroke;
  }
  updateNodes() {
    return __async$1(this, null, function* () {
      var _a2, _b;
      const { rootNode, data } = this;
      const { highlightStyle, tile, group } = this.properties;
      const { seriesRect } = (_a2 = this.chart) != null ? _a2 : {};
      if (!seriesRect || !data)
        return;
      const { width, height } = seriesRect;
      const bboxes = Array.from(this.rootNode, () => void 0);
      this.squarify(rootNode, new BBox7(0, 0, width, height), bboxes);
      let highlightedNode = (_b = this.ctx.highlightManager) == null ? void 0 : _b.getActiveHighlight();
      if (highlightedNode != null && !this.properties.group.interactive && highlightedNode.children.length !== 0) {
        highlightedNode = void 0;
      }
      this.updateNodeMidPoint(bboxes);
      const updateRectFn = (node, rect, highlighted) => {
        var _a3, _b2, _c, _d, _e, _f, _g, _h, _i, _j;
        const bbox = bboxes[node.index];
        if (bbox == null) {
          rect.visible = false;
          return;
        }
        const isLeaf = node.children.length === 0;
        let highlightedFill;
        let highlightedFillOpacity;
        let highlightedStroke;
        let highlightedStrokeWidth;
        let highlightedStrokeOpacity;
        if (highlighted) {
          const { tile: tile2, group: group2 } = highlightStyle;
          highlightedFill = isLeaf ? tile2.fill : group2.fill;
          highlightedFillOpacity = isLeaf ? tile2.fillOpacity : group2.fillOpacity;
          highlightedStroke = isLeaf ? tile2.stroke : group2.stroke;
          highlightedStrokeWidth = isLeaf ? tile2.strokeWidth : group2.strokeWidth;
          highlightedStrokeOpacity = isLeaf ? tile2.strokeOpacity : group2.strokeOpacity;
        }
        const format = this.getTileFormat(node, highlighted);
        const fill = (_b2 = (_a3 = format == null ? void 0 : format.fill) != null ? _a3 : highlightedFill) != null ? _b2 : this.getNodeFill(node);
        const fillOpacity = (_d = (_c = format == null ? void 0 : format.fillOpacity) != null ? _c : highlightedFillOpacity) != null ? _d : isLeaf ? tile.fillOpacity : group.fillOpacity;
        const stroke = (_f = (_e = format == null ? void 0 : format.stroke) != null ? _e : highlightedStroke) != null ? _f : this.getNodeStroke(node);
        const strokeWidth = (_h = (_g = format == null ? void 0 : format.strokeWidth) != null ? _g : highlightedStrokeWidth) != null ? _h : isLeaf ? tile.strokeWidth : group.strokeWidth;
        const strokeOpacity = (_j = (_i = format == null ? void 0 : format.strokeOpacity) != null ? _i : highlightedStrokeOpacity) != null ? _j : isLeaf ? tile.strokeOpacity : group.strokeOpacity;
        rect.fill = validateColor(fill);
        rect.fillOpacity = fillOpacity;
        rect.stroke = validateColor(stroke);
        rect.strokeWidth = strokeWidth;
        rect.strokeOpacity = strokeOpacity;
        rect.crisp = true;
        rect.x = bbox.x;
        rect.y = bbox.y;
        rect.width = bbox.width;
        rect.height = bbox.height;
        rect.visible = true;
      };
      this.groupSelection.selectByClass(Rect4).forEach((rect) => updateRectFn(rect.datum, rect, false));
      this.highlightSelection.selectByClass(Rect4).forEach((rect) => {
        var _a3;
        const isDatumHighlighted = rect.datum === highlightedNode;
        rect.visible = isDatumHighlighted || ((_a3 = highlightedNode == null ? void 0 : highlightedNode.contains(rect.datum)) != null ? _a3 : false);
        if (rect.visible) {
          updateRectFn(rect.datum, rect, isDatumHighlighted);
        }
      });
      const labelMeta = Array.from(this.rootNode, (node) => {
        var _a3, _b2, _c, _d;
        const { index, children } = node;
        const bbox = bboxes[index];
        const labelDatum = (_a3 = this.labelData) == null ? void 0 : _a3[index];
        if (bbox == null || labelDatum == null)
          return void 0;
        if (children.length === 0) {
          const layout = {
            width: bbox.width,
            height: bbox.height,
            meta: null
          };
          const formatting = formatLabels(
            labelDatum.label,
            this.properties.tile.label,
            labelDatum.secondaryLabel,
            this.properties.tile.secondaryLabel,
            { padding: tile.padding },
            () => layout
          );
          if (formatting == null)
            return void 0;
          const { height: height2, label, secondaryLabel } = formatting;
          const { textAlign, verticalAlign, padding } = tile;
          const textAlignFactor = (_b2 = textAlignFactors2[textAlign]) != null ? _b2 : 0.5;
          const labelX = bbox.x + padding + (bbox.width - 2 * padding) * textAlignFactor;
          const verticalAlignFactor = (_c = verticalAlignFactors2[verticalAlign]) != null ? _c : 0.5;
          const labelYStart = bbox.y + padding + height2 * 0.5 + (bbox.height - 2 * padding - height2) * verticalAlignFactor;
          return {
            label: label != null ? {
              text: label.text,
              fontSize: label.fontSize,
              lineHeight: label.lineHeight,
              style: this.properties.tile.label,
              x: labelX,
              y: labelYStart - (height2 - label.height) * 0.5
            } : void 0,
            secondaryLabel: secondaryLabel != null ? {
              text: secondaryLabel.text,
              fontSize: secondaryLabel.fontSize,
              lineHeight: secondaryLabel.fontSize,
              style: this.properties.tile.secondaryLabel,
              x: labelX,
              y: labelYStart + (height2 - secondaryLabel.height) * 0.5
            } : void 0,
            verticalAlign: "middle",
            textAlign
          };
        } else if ((labelDatum == null ? void 0 : labelDatum.label) != null) {
          const { padding, textAlign } = group;
          const groupTitleHeight = this.groupTitleHeight(node, bbox);
          if (groupTitleHeight == null)
            return void 0;
          const innerWidth = bbox.width - 2 * padding;
          const { text } = Text8.wrap(labelDatum.label, bbox.width - 2 * padding, Infinity, group.label, "never");
          const textAlignFactor = (_d = textAlignFactors2[textAlign]) != null ? _d : 0.5;
          return {
            label: {
              text,
              fontSize: group.label.fontSize,
              lineHeight: AutoSizedLabel.lineHeight(group.label.fontSize),
              style: this.properties.group.label,
              x: bbox.x + padding + innerWidth * textAlignFactor,
              y: bbox.y + padding + groupTitleHeight * 0.5
            },
            secondaryLabel: void 0,
            verticalAlign: "middle",
            textAlign
          };
        } else {
          return void 0;
        }
      });
      const updateLabelFn = (node, text, tag, highlighted) => {
        const isLeaf = node.children.length === 0;
        const meta = labelMeta[node.index];
        const label = tag === 0 /* Primary */ ? meta == null ? void 0 : meta.label : meta == null ? void 0 : meta.secondaryLabel;
        if (meta == null || label == null) {
          text.visible = false;
          return;
        }
        let highlightedColor;
        if (highlighted) {
          const { tile: tile2, group: group2 } = highlightStyle;
          highlightedColor = !isLeaf ? group2.label.color : tag === 0 /* Primary */ ? tile2.label.color : tile2.secondaryLabel.color;
        }
        text.text = label.text;
        text.fontSize = label.fontSize;
        text.lineHeight = label.lineHeight;
        text.fontStyle = label.style.fontStyle;
        text.fontFamily = label.style.fontFamily;
        text.fontWeight = label.style.fontWeight;
        text.fill = highlightedColor != null ? highlightedColor : label.style.color;
        text.textAlign = meta.textAlign;
        text.textBaseline = meta.verticalAlign;
        text.x = label.x;
        text.y = label.y;
        text.visible = true;
      };
      this.groupSelection.selectByClass(Text8).forEach((text) => {
        updateLabelFn(text.datum, text, text.tag, false);
      });
      this.highlightSelection.selectByClass(Text8).forEach((text) => {
        var _a3;
        const isDatumHighlighted = text.datum === highlightedNode;
        text.visible = isDatumHighlighted || ((_a3 = highlightedNode == null ? void 0 : highlightedNode.contains(text.datum)) != null ? _a3 : false);
        if (text.visible) {
          updateLabelFn(text.datum, text, text.tag, isDatumHighlighted);
        }
      });
    });
  }
  updateNodeMidPoint(bboxes) {
    this.rootNode.walk((node) => {
      const bbox = bboxes[node.index];
      if (bbox != null) {
        node.midPoint.x = bbox.x + bbox.width / 2;
        node.midPoint.y = bbox.y;
      }
    });
  }
  getTooltipHtml(node) {
    var _a2;
    const { datum, depth } = node;
    const { id: seriesId } = this;
    const {
      tooltip,
      colorKey,
      colorName = colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      sizeName = sizeKey
    } = this.properties;
    const isLeaf = node.children.length === 0;
    const interactive = isLeaf || this.properties.group.interactive;
    if (datum == null || depth == null || !interactive) {
      return "";
    }
    const title = labelKey != null ? datum[labelKey] : void 0;
    const format = this.getTileFormat(node, false);
    const color = (_a2 = format == null ? void 0 : format.fill) != null ? _a2 : this.getNodeFill(node);
    if (!tooltip.renderer && !title) {
      return "";
    }
    const contentArray = [];
    const datumSecondaryLabel = secondaryLabelKey != null ? datum[secondaryLabelKey] : void 0;
    if (datumSecondaryLabel != null && secondaryLabelKey !== colorKey && secondaryLabelKey !== sizeKey) {
      contentArray.push(sanitizeHtml9(datumSecondaryLabel));
    }
    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;
    if (datumSize != null) {
      contentArray.push(`${sizeName}: ${sanitizeHtml9(datumSize)}`);
    }
    const datumColor = colorKey != null ? datum[colorKey] : void 0;
    if (datumColor != null) {
      contentArray.push(`${colorName}: ${sanitizeHtml9(datumColor)}`);
    }
    const content = contentArray.join("<br>");
    const defaults = {
      title,
      color: isLeaf ? this.properties.tile.label.color : this.properties.group.label.color,
      backgroundColor: color,
      content
    };
    return tooltip.toTooltipHtml(defaults, {
      depth,
      datum,
      colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      title,
      color,
      seriesId
    });
  }
};
_TreemapSeries.className = "TreemapSeries";
_TreemapSeries.type = "treemap";
var TreemapSeries = _TreemapSeries;

// packages/ag-charts-enterprise/src/series/treemap/treemapSeriesModule.ts
var {
  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE$1,
  DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY$1,
  DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS$1,
  DEFAULT_HIERARCHY_STROKES: DEFAULT_HIERARCHY_STROKES$1,
  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,
  EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS2,
  DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR$1,
  FONT_WEIGHT: FONT_WEIGHT2$1
} = integrated_charts_theme_exports;
var TreemapSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["hierarchy"],
  identifier: "treemap",
  instanceConstructor: TreemapSeries,
  seriesDefaults: {},
  solo: true,
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS2,
      group: {
        label: {
          enabled: true,
          color: DEFAULT_LABEL_COLOUR$1,
          fontStyle: void 0,
          fontWeight: FONT_WEIGHT2$1.NORMAL,
          fontSize: 12,
          fontFamily: DEFAULT_FONT_FAMILY$1,
          spacing: 4
        },
        fill: void 0,
        // Override default fill
        stroke: void 0,
        // Override default stroke
        strokeWidth: 1,
        padding: 4,
        gap: 2,
        textAlign: "left"
      },
      tile: {
        label: {
          enabled: true,
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,
          fontStyle: void 0,
          fontWeight: FONT_WEIGHT2$1.NORMAL,
          fontSize: 18,
          minimumFontSize: 10,
          fontFamily: DEFAULT_FONT_FAMILY$1,
          wrapping: "on-space",
          overflowStrategy: "ellipsis",
          spacing: 2
        },
        secondaryLabel: {
          enabled: true,
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 12,
          minimumFontSize: 10,
          fontFamily: DEFAULT_FONT_FAMILY$1,
          wrapping: "never",
          overflowStrategy: "ellipsis"
        },
        fill: void 0,
        // Override default fill
        stroke: void 0,
        // Override default stroke
        strokeWidth: 0,
        padding: 3,
        gap: 1
      },
      // Override defaults
      highlightStyle: {
        group: {
          label: {
            color: DEFAULT_LABEL_COLOUR$1
          },
          fill: void 0,
          stroke: `rgba(0, 0, 0, 0.4)`,
          strokeWidth: 2
        },
        tile: {
          label: {
            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2
          },
          secondaryLabel: {
            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2
          },
          fill: void 0,
          stroke: `rgba(0, 0, 0, 0.4)`,
          strokeWidth: 2
        }
      }
    },
    gradientLegend: {
      enabled: true
    }
  },
  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {
    const { properties } = themeTemplateParameters;
    const { fills, strokes } = takeColors(colorsCount);
    const defaultColorRange = properties.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE$1);
    const groupFills = properties.get(DEFAULT_HIERARCHY_FILLS$1);
    const groupStrokes = properties.get(DEFAULT_HIERARCHY_STROKES$1);
    return {
      fills,
      strokes,
      colorRange: defaultColorRange,
      undocumentedGroupFills: groupFills,
      undocumentedGroupStrokes: groupStrokes
    };
  }
};
var { DropShadow: DropShadow3, Label: Label8 } = integrated_charts_scene_exports;
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties4,
  BaseProperties: BaseProperties8,
  PropertiesArray: PropertiesArray2,
  SeriesTooltip: SeriesTooltip11,
  Validate: Validate35,
  BOOLEAN: BOOLEAN16,
  COLOR_STRING: COLOR_STRING16,
  FUNCTION: FUNCTION12,
  LINE_DASH: LINE_DASH11,
  NUMBER: NUMBER12,
  OBJECT: OBJECT14,
  OBJECT_ARRAY: OBJECT_ARRAY$1,
  POSITIVE_NUMBER: POSITIVE_NUMBER18,
  RATIO: RATIO21,
  STRING: STRING15,
  UNION: UNION5
} = module_support_exports;
var WaterfallSeriesTotal = class extends BaseProperties8 {
};
__decorateClass$1([
  Validate35(UNION5(["subtotal", "total"], "a total type"))
], WaterfallSeriesTotal.prototype, "totalType", 2);
__decorateClass$1([
  Validate35(NUMBER12)
], WaterfallSeriesTotal.prototype, "index", 2);
__decorateClass$1([
  Validate35(STRING15)
], WaterfallSeriesTotal.prototype, "axisLabel", 2);
var WaterfallSeriesItemTooltip = class extends BaseProperties8 {
};
__decorateClass$1([
  Validate35(FUNCTION12, { optional: true })
], WaterfallSeriesItemTooltip.prototype, "renderer", 2);
var WaterfallSeriesLabel = class extends Label8 {
  constructor() {
    super(...arguments);
    this.placement = "end";
    this.padding = 6;
  }
};
__decorateClass$1([
  Validate35(UNION5(["start", "end", "inside"], "a placement"))
], WaterfallSeriesLabel.prototype, "placement", 2);
__decorateClass$1([
  Validate35(POSITIVE_NUMBER18)
], WaterfallSeriesLabel.prototype, "padding", 2);
var WaterfallSeriesItem = class extends BaseProperties8 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.stroke = "#c16068";
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.strokeWidth = 1;
    this.cornerRadius = 0;
    this.shadow = new DropShadow3().set({ enabled: false });
    this.label = new WaterfallSeriesLabel();
    this.tooltip = new WaterfallSeriesItemTooltip();
  }
};
__decorateClass$1([
  Validate35(STRING15, { optional: true })
], WaterfallSeriesItem.prototype, "name", 2);
__decorateClass$1([
  Validate35(COLOR_STRING16)
], WaterfallSeriesItem.prototype, "fill", 2);
__decorateClass$1([
  Validate35(COLOR_STRING16)
], WaterfallSeriesItem.prototype, "stroke", 2);
__decorateClass$1([
  Validate35(RATIO21)
], WaterfallSeriesItem.prototype, "fillOpacity", 2);
__decorateClass$1([
  Validate35(RATIO21)
], WaterfallSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate35(LINE_DASH11)
], WaterfallSeriesItem.prototype, "lineDash", 2);
__decorateClass$1([
  Validate35(POSITIVE_NUMBER18)
], WaterfallSeriesItem.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate35(POSITIVE_NUMBER18)
], WaterfallSeriesItem.prototype, "strokeWidth", 2);
__decorateClass$1([
  Validate35(POSITIVE_NUMBER18)
], WaterfallSeriesItem.prototype, "cornerRadius", 2);
__decorateClass$1([
  Validate35(FUNCTION12, { optional: true })
], WaterfallSeriesItem.prototype, "formatter", 2);
__decorateClass$1([
  Validate35(OBJECT14)
], WaterfallSeriesItem.prototype, "shadow", 2);
__decorateClass$1([
  Validate35(OBJECT14)
], WaterfallSeriesItem.prototype, "label", 2);
__decorateClass$1([
  Validate35(OBJECT14)
], WaterfallSeriesItem.prototype, "tooltip", 2);
var WaterfallSeriesConnectorLine = class extends BaseProperties8 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.strokeWidth = 2;
  }
};
__decorateClass$1([
  Validate35(BOOLEAN16)
], WaterfallSeriesConnectorLine.prototype, "enabled", 2);
__decorateClass$1([
  Validate35(COLOR_STRING16)
], WaterfallSeriesConnectorLine.prototype, "stroke", 2);
__decorateClass$1([
  Validate35(RATIO21)
], WaterfallSeriesConnectorLine.prototype, "strokeOpacity", 2);
__decorateClass$1([
  Validate35(LINE_DASH11)
], WaterfallSeriesConnectorLine.prototype, "lineDash", 2);
__decorateClass$1([
  Validate35(POSITIVE_NUMBER18)
], WaterfallSeriesConnectorLine.prototype, "lineDashOffset", 2);
__decorateClass$1([
  Validate35(POSITIVE_NUMBER18)
], WaterfallSeriesConnectorLine.prototype, "strokeWidth", 2);
var WaterfallSeriesItems = class extends BaseProperties8 {
  constructor() {
    super(...arguments);
    this.positive = new WaterfallSeriesItem();
    this.negative = new WaterfallSeriesItem();
    this.total = new WaterfallSeriesItem();
  }
};
__decorateClass$1([
  Validate35(OBJECT14)
], WaterfallSeriesItems.prototype, "positive", 2);
__decorateClass$1([
  Validate35(OBJECT14)
], WaterfallSeriesItems.prototype, "negative", 2);
__decorateClass$1([
  Validate35(OBJECT14)
], WaterfallSeriesItems.prototype, "total", 2);
var WaterfallSeriesProperties = class extends AbstractBarSeriesProperties4 {
  constructor() {
    super(...arguments);
    this.item = new WaterfallSeriesItems();
    this.totals = new PropertiesArray2(WaterfallSeriesTotal);
    this.line = new WaterfallSeriesConnectorLine();
    this.tooltip = new SeriesTooltip11();
  }
};
__decorateClass$1([
  Validate35(STRING15)
], WaterfallSeriesProperties.prototype, "xKey", 2);
__decorateClass$1([
  Validate35(STRING15)
], WaterfallSeriesProperties.prototype, "yKey", 2);
__decorateClass$1([
  Validate35(STRING15, { optional: true })
], WaterfallSeriesProperties.prototype, "xName", 2);
__decorateClass$1([
  Validate35(STRING15, { optional: true })
], WaterfallSeriesProperties.prototype, "yName", 2);
__decorateClass$1([
  Validate35(OBJECT14)
], WaterfallSeriesProperties.prototype, "item", 2);
__decorateClass$1([
  Validate35(OBJECT_ARRAY$1)
], WaterfallSeriesProperties.prototype, "totals", 2);
__decorateClass$1([
  Validate35(OBJECT14)
], WaterfallSeriesProperties.prototype, "line", 2);
__decorateClass$1([
  Validate35(OBJECT14)
], WaterfallSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-enterprise/src/series/waterfall/waterfallSeries.ts
var {
  adjustLabelPlacement: adjustLabelPlacement$1,
  SeriesNodePickMode: SeriesNodePickMode5,
  fixNumericExtent: fixNumericExtent8,
  valueProperty: valueProperty10,
  keyProperty: keyProperty7,
  accumulativeValueProperty: accumulativeValueProperty$1,
  trailingAccumulatedValueProperty: trailingAccumulatedValueProperty$1,
  ChartAxisDirection: ChartAxisDirection17,
  getRectConfig: getRectConfig2,
  updateRect: updateRect2,
  checkCrisp: checkCrisp2,
  updateLabelNode: updateLabelNode3,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions3,
  collapsedStartingBarPosition: collapsedStartingBarPosition2,
  resetBarSelectionsFn: resetBarSelectionsFn3,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation7,
  resetLabelFn: resetLabelFn5,
  animationValidation: animationValidation8
} = module_support_exports;
var { ContinuousScale: ContinuousScale2, Rect: Rect5, motion: motion8 } = integrated_charts_scene_exports;
var { sanitizeHtml: sanitizeHtml10, isContinuous: isContinuous$1, isNumber: isNumber6 } = sparklines_util_exports;
var _WaterfallSeries = class _WaterfallSeries extends module_support_exports.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode5.EXACT_SHAPE_MATCH],
      pathsPerSeries: 1,
      hasHighlightedLabels: true,
      pathsZIndexSubOrderOffset: [-1, -1],
      animationResetFns: {
        datum: resetBarSelectionsFn3,
        label: resetLabelFn5
      }
    });
    this.properties = new WaterfallSeriesProperties();
    this.seriesItemTypes = /* @__PURE__ */ new Set(["positive", "negative", "total"]);
    this.smallestDataInterval = void 0;
  }
  resolveKeyDirection(direction) {
    if (this.getBarDirection() === ChartAxisDirection17.X) {
      if (direction === ChartAxisDirection17.X) {
        return ChartAxisDirection17.Y;
      }
      return ChartAxisDirection17.X;
    }
    return direction;
  }
  processData(dataController) {
    return __async$1(this, null, function* () {
      var _a2, _b, _c;
      const { xKey, yKey, totals } = this.properties;
      const { data = [] } = this;
      if (!this.properties.isValid()) {
        return;
      }
      const positiveNumber = (v) => {
        return isContinuous$1(v) && v >= 0;
      };
      const negativeNumber = (v) => {
        return isContinuous$1(v) && v < 0;
      };
      const totalTypeValue = (v) => {
        return v === "total" || v === "subtotal";
      };
      const propertyDefinition = {
        missingValue: void 0,
        invalidValue: void 0
      };
      const dataWithTotals = [];
      const totalsMap = totals.reduce((totalsMap2, total) => {
        const totalsAtIndex = totalsMap2.get(total.index);
        if (totalsAtIndex) {
          totalsAtIndex.push(total);
        } else {
          totalsMap2.set(total.index, [total]);
        }
        return totalsMap2;
      }, /* @__PURE__ */ new Map());
      data.forEach((datum, i) => {
        var _a3;
        dataWithTotals.push(datum);
        (_a3 = totalsMap.get(i)) == null ? void 0 : _a3.forEach((total) => dataWithTotals.push(__spreadProps$1(__spreadValues$1({}, total.toJson()), { [xKey]: total.axisLabel })));
      });
      const isContinuousX = ContinuousScale2.is((_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale);
      const extraProps = [];
      if (!this.ctx.animationManager.isSkipped()) {
        extraProps.push(animationValidation8(this));
      }
      const { processedData } = yield this.requestDataModel(dataController, dataWithTotals, {
        props: [
          keyProperty7(this, xKey, isContinuousX, { id: `xValue` }),
          accumulativeValueProperty$1(this, yKey, true, __spreadProps$1(__spreadValues$1({}, propertyDefinition), {
            id: `yCurrent`
          })),
          accumulativeValueProperty$1(this, yKey, true, __spreadProps$1(__spreadValues$1({}, propertyDefinition), {
            missingValue: 0,
            id: `yCurrentTotal`
          })),
          accumulativeValueProperty$1(this, yKey, true, __spreadProps$1(__spreadValues$1({}, propertyDefinition), {
            id: `yCurrentPositive`,
            validation: positiveNumber
          })),
          accumulativeValueProperty$1(this, yKey, true, __spreadProps$1(__spreadValues$1({}, propertyDefinition), {
            id: `yCurrentNegative`,
            validation: negativeNumber
          })),
          trailingAccumulatedValueProperty$1(this, yKey, true, __spreadProps$1(__spreadValues$1({}, propertyDefinition), {
            id: `yPrevious`
          })),
          valueProperty10(this, yKey, true, { id: `yRaw` }),
          // Raw value pass-through.
          valueProperty10(this, "totalType", false, {
            id: `totalTypeValue`,
            missingValue: void 0,
            validation: totalTypeValue
          }),
          ...isContinuousX ? [module_support_exports.SMALLEST_KEY_INTERVAL] : [],
          ...extraProps
        ],
        dataVisible: this.visible
      });
      this.smallestDataInterval = {
        x: (_c = (_b = processedData.reduced) == null ? void 0 : _b.smallestKeyInterval) != null ? _c : Infinity,
        y: Infinity
      };
      this.updateSeriesItemTypes();
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    var _a2;
    const { processedData, dataModel } = this;
    if (!(processedData && dataModel))
      return [];
    const {
      domain: {
        keys: [keys],
        values
      },
      reduced: { [module_support_exports.SMALLEST_KEY_INTERVAL.property]: smallestX } = {}
    } = processedData;
    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
    if (direction === this.getCategoryDirection()) {
      if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && (keyDef == null ? void 0 : keyDef.def.valueType) === "category") {
        return keys;
      }
      const scalePadding = smallestX != null && isFinite(smallestX) ? smallestX : 0;
      const keysExtent = (_a2 = module_support_exports.extent(keys)) != null ? _a2 : [NaN, NaN];
      const categoryAxis = this.getCategoryAxis();
      const isReversed = categoryAxis == null ? void 0 : categoryAxis.isReversed();
      if (direction === ChartAxisDirection17.Y) {
        const d02 = keysExtent[0] + (isReversed ? 0 : -scalePadding);
        const d12 = keysExtent[1] + (isReversed ? scalePadding : 0);
        return fixNumericExtent8([d02, d12], categoryAxis);
      }
      const d0 = keysExtent[0] + (isReversed ? -scalePadding : 0);
      const d1 = keysExtent[1] + (isReversed ? 0 : scalePadding);
      return fixNumericExtent8([d0, d1], categoryAxis);
    } else {
      const yCurrIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrent").index;
      const yExtent = values[yCurrIndex];
      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];
      return fixNumericExtent8(fixedYExtent);
    }
  }
  createNodeData() {
    return __async$1(this, null, function* () {
      var _a2, _b, _c;
      const { data, dataModel, smallestDataInterval } = this;
      const { visible, line } = this.properties;
      const categoryAxis = this.getCategoryAxis();
      const valueAxis = this.getValueAxis();
      if (!(data && visible && categoryAxis && valueAxis && dataModel)) {
        return [];
      }
      const xScale = categoryAxis.scale;
      const yScale = valueAxis.scale;
      const categoryAxisReversed = categoryAxis.isReversed();
      const barAlongX = this.getBarDirection() === ChartAxisDirection17.X;
      const barWidth = (_a2 = ContinuousScale2.is(xScale) ? xScale.calcBandwidth(smallestDataInterval == null ? void 0 : smallestDataInterval.x) : xScale.bandwidth) != null ? _a2 : 10;
      if (((_b = this.processedData) == null ? void 0 : _b.type) !== "ungrouped") {
        return [];
      }
      const contexts = [];
      const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yRaw`).index;
      const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;
      const totalTypeIndex = dataModel.resolveProcessedDataIndexById(this, `totalTypeValue`).index;
      const contextIndexMap = /* @__PURE__ */ new Map();
      const pointData = [];
      const yCurrIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrent").index;
      const yPrevIndex = dataModel.resolveProcessedDataIndexById(this, "yPrevious").index;
      const yCurrTotalIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentTotal").index;
      function getValues(isTotal, isSubtotal, values) {
        if (isTotal || isSubtotal) {
          return {
            cumulativeValue: values[yCurrTotalIndex],
            trailingValue: isSubtotal ? trailingSubtotal : 0
          };
        }
        return {
          cumulativeValue: values[yCurrIndex],
          trailingValue: values[yPrevIndex]
        };
      }
      function getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue) {
        if (isTotal) {
          return cumulativeValue;
        }
        if (isSubtotal) {
          return (cumulativeValue != null ? cumulativeValue : 0) - (trailingValue != null ? trailingValue : 0);
        }
        return rawValue;
      }
      let trailingSubtotal = 0;
      const { xKey, yKey, xName, yName } = this.properties;
      (_c = this.processedData) == null ? void 0 : _c.data.forEach(({ keys, datum, values }, dataIndex) => {
        var _a3;
        const datumType = values[totalTypeIndex];
        const isSubtotal = this.isSubtotal(datumType);
        const isTotal = this.isTotal(datumType);
        const isTotalOrSubtotal = isTotal || isSubtotal;
        const xDatum = keys[xIndex];
        const x = Math.round(xScale.convert(xDatum));
        const rawValue = values[yRawIndex];
        const { cumulativeValue, trailingValue } = getValues(isTotal, isSubtotal, values);
        if (isTotalOrSubtotal) {
          trailingSubtotal = cumulativeValue != null ? cumulativeValue : 0;
        }
        const currY = Math.round(yScale.convert(cumulativeValue));
        const trailY = Math.round(yScale.convert(trailingValue));
        const value = getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue);
        const isPositive = (value != null ? value : 0) >= 0;
        const seriesItemType = this.getSeriesItemType(isPositive, datumType);
        const { fill, stroke, strokeWidth, label } = this.getItemConfig(seriesItemType);
        const y = isPositive ? currY : trailY;
        const bottomY = isPositive ? trailY : currY;
        const barHeight = Math.max(strokeWidth, Math.abs(bottomY - y));
        const itemId = seriesItemType;
        let contextIndex = contextIndexMap.get(itemId);
        if (contextIndex === void 0) {
          contextIndex = contexts.length;
          contextIndexMap.set(itemId, contextIndex);
        }
        (_a3 = contexts[contextIndex]) != null ? _a3 : contexts[contextIndex] = {
          itemId,
          nodeData: [],
          labelData: [],
          pointData: [],
          scales: __superGet$1(_WaterfallSeries.prototype, this, "calculateScaling").call(this),
          visible: this.visible
        };
        const rect = {
          x: barAlongX ? Math.min(y, bottomY) : x,
          y: barAlongX ? x : Math.min(y, bottomY),
          width: barAlongX ? barHeight : barWidth,
          height: barAlongX ? barWidth : barHeight
        };
        const nodeMidPoint = {
          x: rect.x + rect.width / 2,
          y: rect.y + rect.height / 2
        };
        const pointY = isTotalOrSubtotal ? currY : trailY;
        const pixelAlignmentOffset = Math.floor(line.strokeWidth) % 2 / 2;
        const startY = categoryAxisReversed ? currY : pointY;
        const stopY = categoryAxisReversed ? pointY : currY;
        let startCoordinates;
        let stopCoordinates;
        if (barAlongX) {
          startCoordinates = {
            x: startY + pixelAlignmentOffset,
            y: rect.y
          };
          stopCoordinates = {
            x: stopY + pixelAlignmentOffset,
            y: rect.y + rect.height
          };
        } else {
          startCoordinates = {
            x: rect.x,
            y: startY + pixelAlignmentOffset
          };
          stopCoordinates = {
            x: rect.x + rect.width,
            y: stopY + pixelAlignmentOffset
          };
        }
        const pathPoint = {
          // lineTo
          x: categoryAxisReversed ? stopCoordinates.x : startCoordinates.x,
          y: categoryAxisReversed ? stopCoordinates.y : startCoordinates.y,
          // moveTo
          x2: categoryAxisReversed ? startCoordinates.x : stopCoordinates.x,
          y2: categoryAxisReversed ? startCoordinates.y : stopCoordinates.y,
          size: 0
        };
        pointData.push(pathPoint);
        const labelText = this.getLabelText(
          label,
          {
            itemId: itemId === "subtotal" ? "total" : itemId,
            value,
            datum,
            xKey,
            yKey,
            xName,
            yName
          },
          (value2) => isNumber6(value2) ? value2.toFixed(2) : String(value2)
        );
        const nodeDatum = {
          index: dataIndex,
          series: this,
          itemId,
          datum,
          cumulativeValue: cumulativeValue != null ? cumulativeValue : 0,
          xValue: xDatum,
          yValue: value,
          yKey,
          xKey,
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height,
          midPoint: nodeMidPoint,
          fill,
          stroke,
          strokeWidth,
          opacity: 1,
          label: __spreadValues$1({
            text: labelText
          }, adjustLabelPlacement$1({
            isPositive: (value != null ? value : -1) >= 0,
            isVertical: !barAlongX,
            placement: label.placement,
            padding: label.padding,
            rect
          }))
        };
        contexts[contextIndex].nodeData.push(nodeDatum);
        contexts[contextIndex].labelData.push(nodeDatum);
      });
      const connectorLinesEnabled = this.properties.line.enabled;
      if (contexts.length > 0 && yCurrIndex !== void 0 && connectorLinesEnabled) {
        contexts[0].pointData = pointData;
      }
      return contexts;
    });
  }
  updateSeriesItemTypes() {
    var _a2, _b;
    const { dataModel, seriesItemTypes, processedData } = this;
    if (!dataModel || !processedData) {
      return;
    }
    seriesItemTypes.clear();
    const yPositiveIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentPositive").index;
    const yNegativeIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentNegative").index;
    const totalTypeIndex = dataModel.resolveProcessedDataIndexById(this, `totalTypeValue`).index;
    const positiveDomain = (_a2 = processedData.domain.values[yPositiveIndex]) != null ? _a2 : [];
    const negativeDomain = (_b = processedData.domain.values[yNegativeIndex]) != null ? _b : [];
    if (positiveDomain.length > 0) {
      seriesItemTypes.add("positive");
    }
    if (negativeDomain.length > 0) {
      seriesItemTypes.add("negative");
    }
    const itemTypes = processedData == null ? void 0 : processedData.domain.values[totalTypeIndex];
    if (!itemTypes) {
      return;
    }
    itemTypes.forEach((type) => {
      if (type === "total" || type === "subtotal") {
        seriesItemTypes.add("total");
      }
    });
  }
  isSubtotal(datumType) {
    return datumType === "subtotal";
  }
  isTotal(datumType) {
    return datumType === "total";
  }
  nodeFactory() {
    return new Rect5();
  }
  getSeriesItemType(isPositive, datumType) {
    return datumType != null ? datumType : isPositive ? "positive" : "negative";
  }
  getItemConfig(seriesItemType) {
    switch (seriesItemType) {
      case "positive": {
        return this.properties.item.positive;
      }
      case "negative": {
        return this.properties.item.negative;
      }
      case "subtotal":
      case "total": {
        return this.properties.item.total;
      }
    }
  }
  updateDatumSelection(opts) {
    return __async$1(this, null, function* () {
      const { nodeData, datumSelection } = opts;
      const data = nodeData != null ? nodeData : [];
      return datumSelection.update(data);
    });
  }
  updateDatumNodes(opts) {
    return __async$1(this, null, function* () {
      const { datumSelection, isHighlight } = opts;
      const { id: seriesId, ctx } = this;
      const {
        yKey,
        highlightStyle: { item: itemHighlightStyle }
      } = this.properties;
      const categoryAxis = this.getCategoryAxis();
      const crisp = checkCrisp2(categoryAxis == null ? void 0 : categoryAxis.visibleRange);
      const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection17.X;
      datumSelection.each((rect, datum) => {
        const seriesItemType = datum.itemId;
        const {
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset,
          cornerRadius,
          formatter,
          shadow: fillShadow
        } = this.getItemConfig(seriesItemType);
        const style = {
          fill: datum.fill,
          stroke: datum.stroke,
          fillOpacity,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          fillShadow,
          strokeWidth: this.getStrokeWidth(strokeWidth),
          cornerRadius,
          cornerRadiusBbox: void 0
        };
        const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
        const config = getRectConfig2({
          datum,
          isHighlighted: isHighlight,
          style,
          highlightStyle: itemHighlightStyle,
          formatter,
          seriesId,
          itemId: datum.itemId,
          ctx,
          value: datum.yValue,
          yKey
        });
        config.crisp = crisp;
        config.visible = visible;
        updateRect2({ rect, config });
      });
    });
  }
  updateLabelSelection(opts) {
    return __async$1(this, null, function* () {
      const { labelData, labelSelection } = opts;
      if (labelData.length === 0) {
        return labelSelection.update([]);
      }
      const itemId = labelData[0].itemId;
      const { label } = this.getItemConfig(itemId);
      const data = label.enabled ? labelData : [];
      return labelSelection.update(data);
    });
  }
  updateLabelNodes(opts) {
    return __async$1(this, null, function* () {
      opts.labelSelection.each((textNode, datum) => {
        updateLabelNode3(textNode, this.getItemConfig(datum.itemId).label, datum.label);
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a2, _b, _c;
    const categoryAxis = this.getCategoryAxis();
    const valueAxis = this.getValueAxis();
    if (!this.properties.isValid() || !categoryAxis || !valueAxis) {
      return "";
    }
    const { id: seriesId } = this;
    const { xKey, yKey, xName, yName, tooltip } = this.properties;
    const { datum, itemId, xValue, yValue } = nodeDatum;
    const { fill, strokeWidth, name, formatter } = this.getItemConfig(itemId);
    let format;
    if (formatter) {
      format = this.ctx.callbackCache.call(formatter, {
        datum,
        value: yValue,
        xKey,
        yKey,
        fill,
        strokeWidth,
        highlighted: false,
        seriesId,
        itemId: nodeDatum.itemId
      });
    }
    const color = (_b = (_a2 = format == null ? void 0 : format.fill) != null ? _a2 : fill) != null ? _b : "gray";
    const xString = sanitizeHtml10(categoryAxis.formatDatum(xValue));
    const yString = sanitizeHtml10(valueAxis.formatDatum(yValue));
    const isTotal = this.isTotal(itemId);
    const isSubtotal = this.isSubtotal(itemId);
    const ySubheading = isTotal ? "Total" : isSubtotal ? "Subtotal" : (_c = name != null ? name : yName) != null ? _c : yKey;
    const title = sanitizeHtml10(yName);
    const content = `<b>${sanitizeHtml10(xName != null ? xName : xKey)}</b>: ${xString}<br/><b>${sanitizeHtml10(ySubheading)}</b>: ${yString}`;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      { seriesId, itemId, datum, xKey, yKey, xName, yName, color }
    );
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const { id, seriesItemTypes } = this;
    const legendData = [];
    const capitalise = (text) => text.charAt(0).toUpperCase() + text.substring(1);
    seriesItemTypes.forEach((item) => {
      const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth, name } = this.getItemConfig(item);
      legendData.push({
        legendType: "category",
        id,
        itemId: item,
        seriesId: id,
        enabled: true,
        label: { text: name != null ? name : capitalise(item) },
        marker: { fill, stroke, fillOpacity, strokeOpacity, strokeWidth }
      });
    });
    return legendData;
  }
  toggleSeriesItem() {
  }
  animateEmptyUpdateReady({ datumSelections, labelSelections, contextData, paths }) {
    const fns = prepareBarAnimationFunctions3(collapsedStartingBarPosition2(this.isVertical(), this.axes, "normal"));
    motion8.fromToMotion(this.id, "datums", this.ctx.animationManager, datumSelections, fns);
    seriesLabelFadeInAnimation7(this, "labels", this.ctx.animationManager, labelSelections);
    contextData.forEach(({ pointData }, contextDataIndex) => {
      if (contextDataIndex !== 0 || !pointData) {
        return;
      }
      const [lineNode] = paths[contextDataIndex];
      if (this.isVertical()) {
        this.animateConnectorLinesVertical(lineNode, pointData);
      } else {
        this.animateConnectorLinesHorizontal(lineNode, pointData);
      }
    });
  }
  animateConnectorLinesHorizontal(lineNode, pointData) {
    const { path: linePath } = lineNode;
    this.updateLineNode(lineNode);
    const valueAxis = this.getValueAxis();
    const valueAxisReversed = valueAxis == null ? void 0 : valueAxis.isReversed();
    const compare = valueAxisReversed ? (v, v2) => v < v2 : (v, v2) => v > v2;
    const startX = valueAxis == null ? void 0 : valueAxis.scale.convert(0);
    const endX = pointData.reduce(
      (end, point) => {
        if (compare(point.x, end)) {
          end = point.x;
        }
        return end;
      },
      valueAxisReversed ? Infinity : 0
    );
    const scale = (value, start1, end1, start2, end2) => {
      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;
    };
    this.ctx.animationManager.animate({
      id: `${this.id}_datums`,
      groupId: this.id,
      phase: "initial",
      from: startX,
      to: endX,
      ease: module_support_exports.Motion.easeOut,
      onUpdate(pointX) {
        linePath.clear({ trackChanges: true });
        pointData.forEach((point, index) => {
          const x = scale(pointX, startX, endX, startX, point.x);
          const x2 = scale(pointX, startX, endX, startX, point.x2);
          if (index !== 0) {
            linePath.lineTo(x, point.y);
          }
          linePath.moveTo(x2, point.y2);
        });
        lineNode.checkPathDirty();
      }
    });
  }
  animateConnectorLinesVertical(lineNode, pointData) {
    const { path: linePath } = lineNode;
    this.updateLineNode(lineNode);
    const valueAxis = this.getValueAxis();
    const valueAxisReversed = valueAxis == null ? void 0 : valueAxis.isReversed();
    const compare = valueAxisReversed ? (v, v2) => v > v2 : (v, v2) => v < v2;
    const startY = valueAxis == null ? void 0 : valueAxis.scale.convert(0);
    const endY = pointData.reduce(
      (end, point) => {
        if (compare(point.y, end)) {
          end = point.y;
        }
        return end;
      },
      valueAxisReversed ? 0 : Infinity
    );
    const scale = (value, start1, end1, start2, end2) => {
      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;
    };
    this.ctx.animationManager.animate({
      id: `${this.id}_datums`,
      groupId: this.id,
      phase: "initial",
      from: startY,
      to: endY,
      ease: module_support_exports.Motion.easeOut,
      onUpdate(pointY) {
        linePath.clear({ trackChanges: true });
        pointData.forEach((point, index) => {
          const y = scale(pointY, startY, endY, startY, point.y);
          const y2 = scale(pointY, startY, endY, startY, point.y2);
          if (index !== 0) {
            linePath.lineTo(point.x, y);
          }
          linePath.moveTo(point.x2, y2);
        });
        lineNode.checkPathDirty();
      }
    });
  }
  animateReadyResize(data) {
    super.animateReadyResize(data);
    this.resetConnectorLinesPath(data);
  }
  updatePaths(opts) {
    return __async$1(this, null, function* () {
      this.resetConnectorLinesPath({ contextData: [opts.contextData], paths: [opts.paths] });
    });
  }
  resetConnectorLinesPath({
    contextData,
    paths
  }) {
    if (paths.length === 0) {
      return;
    }
    const [lineNode] = paths[0];
    this.updateLineNode(lineNode);
    const { path: linePath } = lineNode;
    linePath.clear({ trackChanges: true });
    const { pointData } = contextData[0];
    if (!pointData) {
      return;
    }
    pointData.forEach((point, index) => {
      if (index !== 0) {
        linePath.lineTo(point.x, point.y);
      }
      linePath.moveTo(point.x2, point.y2);
    });
    lineNode.checkPathDirty();
  }
  updateLineNode(lineNode) {
    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.properties.line;
    lineNode.setProperties({
      fill: void 0,
      stroke,
      strokeWidth: this.getStrokeWidth(strokeWidth),
      strokeOpacity,
      lineDash,
      lineDashOffset,
      lineJoin: "round",
      pointerEvents: integrated_charts_scene_exports.PointerEvents.None
    });
  }
  isLabelEnabled() {
    const { positive, negative, total } = this.properties.item;
    return positive.label.enabled || negative.label.enabled || total.label.enabled;
  }
  onDataChange() {
  }
};
_WaterfallSeries.className = "WaterfallSeries";
_WaterfallSeries.type = "waterfall";
var WaterfallSeries = _WaterfallSeries;
var WATERFALL_SERIES_THEME = {
  series: {
    __extends__: integrated_charts_theme_exports.EXTENDS_SERIES_DEFAULTS,
    item: {
      positive: {
        strokeWidth: 0,
        label: {
          enabled: false
        }
      },
      negative: {
        strokeWidth: 0,
        label: {
          enabled: false
        }
      },
      total: {
        strokeWidth: 0,
        label: {
          enabled: false
        }
      }
    },
    line: {
      stroke: integrated_charts_theme_exports.DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      strokeWidth: 2
    }
  },
  legend: {
    enabled: true,
    item: {
      toggleSeriesVisible: false
    }
  }
};

// packages/ag-charts-enterprise/src/series/waterfall/waterfallModule.ts
var WaterfallModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "waterfall",
  solo: true,
  instanceConstructor: WaterfallSeries,
  seriesDefaults: {
    axes: [
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.CATEGORY,
        position: integrated_charts_theme_exports.POSITION.BOTTOM
      },
      {
        type: integrated_charts_theme_exports.CARTESIAN_AXIS_TYPE.NUMBER,
        position: integrated_charts_theme_exports.POSITION.LEFT
      }
    ]
  },
  themeTemplate: WATERFALL_SERIES_THEME,
  swapDefaultAxesCondition: ({ direction }) => direction === "horizontal",
  paletteFactory: ({ takeColors, colorsCount, userPalette, themeTemplateParameters }) => {
    const { properties } = themeTemplateParameters;
    const { fills, strokes } = takeColors(colorsCount);
    return userPalette ? {
      item: {
        positive: {
          fill: fills[0],
          stroke: strokes[0]
        },
        negative: {
          fill: fills[1],
          stroke: strokes[1]
        },
        total: {
          fill: fills[2],
          stroke: strokes[2]
        }
      }
    } : {
      item: {
        positive: properties.get(integrated_charts_theme_exports.DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS),
        negative: properties.get(integrated_charts_theme_exports.DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS),
        total: properties.get(integrated_charts_theme_exports.DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS)
      }
    };
  }
};

// packages/ag-charts-enterprise/src/setup.ts
function setupEnterpriseModules() {
  module_support_exports.registerModule(AngleCategoryAxisModule);
  module_support_exports.registerModule(AngleNumberAxisModule);
  module_support_exports.registerModule(AnimationModule);
  module_support_exports.registerModule(BackgroundModule$1);
  module_support_exports.registerModule(BoxPlotModule);
  module_support_exports.registerModule(BulletModule);
  module_support_exports.registerModule(ContextMenuModule);
  module_support_exports.registerModule(CrosshairModule);
  module_support_exports.registerModule(DataSourceModule);
  module_support_exports.registerModule(ErrorBarsModule);
  module_support_exports.registerModule(NavigatorModule$1);
  module_support_exports.registerModule(GradientLegendModule);
  module_support_exports.registerModule(HeatmapModule);
  module_support_exports.registerModule(NightingaleModule);
  module_support_exports.registerModule(RadarAreaModule);
  module_support_exports.registerModule(RadarLineModule);
  module_support_exports.registerModule(RadialBarModule);
  module_support_exports.registerModule(RadialColumnModule);
  module_support_exports.registerModule(RadiusCategoryAxisModule);
  module_support_exports.registerModule(RadiusNumberAxisModule);
  module_support_exports.registerModule(RangeBarModule);
  module_support_exports.registerModule(RangeAreaModule);
  module_support_exports.registerModule(SunburstSeriesModule);
  module_support_exports.registerModule(SyncModule);
  module_support_exports.registerModule(TreemapSeriesModule);
  module_support_exports.registerModule(WaterfallModule);
  module_support_exports.registerModule(ZoomModule);
  module_support_exports.enterpriseModule.isEnterprise = true;
  module_support_exports.enterpriseModule.licenseManager = (options) => {
    var _a2, _b;
    return new LicenseManager$1(
      (_b = (_a2 = options.container) == null ? void 0 : _a2.ownerDocument) != null ? _b : typeof document !== "undefined" ? document : void 0
    );
  };
  module_support_exports.enterpriseModule.injectWatermark = injectWatermark;
}
setupEnterpriseModules();

const VALID_SERIES_TYPES = [
    'area',
    'bar',
    'column',
    'histogram',
    'line',
    'pie',
    'donut',
    'scatter',
    'bubble',
    'radial-column',
    'radial-bar',
    'radar-line',
    'radar-area',
    'nightingale',
    'range-bar',
    'range-area',
    'box-plot',
    'treemap',
    'sunburst',
    'heatmap',
    'waterfall',
];
function isEnterpriseChartType(chartType) {
    switch (chartType) {
        case 'rangeBar':
        case 'rangeArea':
        case 'waterfall':
        case 'boxPlot':
        case 'radarLine':
        case 'radarArea':
        case 'nightingale':
        case 'radialColumn':
        case 'radialBar':
        case 'sunburst':
        case 'treemap':
        case 'heatmap':
            return true;
        default:
            return false;
    }
}
const horizontalChartTypes = new Set(['bar', 'groupedBar', 'stackedBar', 'normalizedBar']);
function isHorizontal(chartType) {
    return horizontalChartTypes.has(chartType);
}
const stackedChartTypes = new Set(['stackedColumn', 'normalizedColumn', 'stackedBar', 'normalizedBar']);
function isStacked(chartType) {
    return stackedChartTypes.has(chartType);
}
function isPolar(chartType) {
    switch (chartType) {
        case 'radialColumn':
        case 'radialBar':
        case 'radarLine':
        case 'radarArea':
        case 'nightingale':
            return true;
        default:
            return false;
    }
}
function isRadial(chartType) {
    switch (chartType) {
        case 'radialColumn':
        case 'radialBar':
            return true;
        default:
            return false;
    }
}
function isHierarchical(chartType) {
    switch (chartType) {
        case 'treemap':
        case 'sunburst':
            return true;
        default:
            return false;
    }
}
function hasGradientLegend(chartType) {
    switch (chartType) {
        case 'treemap':
        case 'sunburst':
        case 'heatmap':
            return true;
        default:
            return false;
    }
}
function getCanonicalChartType(chartType) {
    switch (chartType) {
        case 'doughnut':
            return 'donut';
        default:
            return chartType;
    }
}
function getSeriesType(chartType) {
    switch (chartType) {
        case 'bar':
        case 'groupedBar':
        case 'stackedBar':
        case 'normalizedBar':
            return 'bar';
        case 'column':
        case 'groupedColumn':
        case 'stackedColumn':
        case 'normalizedColumn':
            return 'bar';
        case 'line':
            return 'line';
        case 'area':
        case 'stackedArea':
        case 'normalizedArea':
            return 'area';
        case 'bubble':
            return 'bubble';
        case 'scatter':
            return 'scatter';
        case 'histogram':
            return 'histogram';
        case 'radialColumn':
            return 'radial-column';
        case 'radialBar':
            return 'radial-bar';
        case 'radarLine':
            return 'radar-line';
        case 'radarArea':
            return 'radar-area';
        case 'nightingale':
            return 'nightingale';
        case 'rangeBar':
            return 'range-bar';
        case 'rangeArea':
            return 'range-area';
        case 'boxPlot':
            return 'box-plot';
        case 'treemap':
            return 'treemap';
        case 'sunburst':
            return 'sunburst';
        case 'pie':
            return 'pie';
        case 'donut':
        case 'doughnut':
            return 'donut';
        case 'heatmap':
            return 'heatmap';
        case 'waterfall':
            return 'waterfall';
        default:
            return 'cartesian';
    }
}
function isPieChartSeries(seriesType) {
    switch (seriesType) {
        case 'pie':
        case 'donut':
            return true;
        default:
            return false;
    }
}

const ALL_AXIS_TYPES = ['number', 'category', 'grouped-category', 'log', 'time'];
function getLegacyAxisType(chartType) {
    switch (chartType) {
        case 'bar':
        case 'stackedBar':
        case 'normalizedBar':
            return ['number', 'category'];
        case 'groupedBar':
            return ['number', 'grouped-category'];
        case 'column':
        case 'stackedColumn':
        case 'normalizedColumn':
        case 'line':
        case 'area':
        case 'stackedArea':
        case 'normalizedArea':
        case 'histogram':
            return ['category', 'number'];
        case 'groupedColumn':
            return ['grouped-category', 'number'];
        case 'scatter':
        case 'bubble':
            return ['number', 'number'];
        default:
            return undefined;
    }
}

// deepMerge
function emptyTarget(value) {
    return Array.isArray(value) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
    return (options.clone !== false && options.isMergeableObject(value))
        ? deepMerge$1(emptyTarget(value), value, options)
        : value;
}
function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function (element) {
        return cloneUnlessOtherwiseSpecified(element, options);
    });
}
function getMergeFunction(key, options) {
    if (!options.customMerge) {
        return deepMerge$1;
    }
    const customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepMerge$1;
}
function getEnumerableOwnPropertySymbols(target) {
    // @ts-ignore
    return Object.getOwnPropertySymbols
        // @ts-ignore
        ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
            return target.propertyIsEnumerable(symbol);
        })
        : [];
}
function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
    try {
        return property in object;
    }
    catch (_) {
        return false;
    }
}
// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
        && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
            && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
}
function mergeObject(target = {}, source = {}, options) {
    const destination = {};
    if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function (key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
    }
    getKeys(source).forEach(function (key) {
        if (propertyIsUnsafe(target, key)) {
            return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        }
        else {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
    });
    return destination;
}
function defaultIsMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
}
function isNonNullObject(value) {
    return !!value && typeof value === 'object';
}
function isSpecial(value) {
    const stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]';
}
function deepMerge$1(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    const sourceIsArray = Array.isArray(source);
    const targetIsArray = Array.isArray(target);
    const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
    }
    else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
    }
    else {
        return mergeObject(target, source, options);
    }
}
// END - deep merge
function get(source, expression, defaultValue) {
    if (source == null) {
        return defaultValue;
    }
    const keys = expression.split('.');
    let objectToRead = source;
    while (keys.length > 1) {
        objectToRead = objectToRead[keys.shift()];
        if (objectToRead == null) {
            return defaultValue;
        }
    }
    const value = objectToRead[keys[0]];
    return value != null ? value : defaultValue;
}
function set(target, expression, value) {
    if (target == null) {
        return;
    }
    const keys = expression.split('.');
    let objectToUpdate = target;
    // Create empty objects
    keys.forEach((key, i) => {
        if (!objectToUpdate[key]) {
            objectToUpdate[key] = {};
        }
        if (i < keys.length - 1) {
            objectToUpdate = objectToUpdate[key];
        }
    });
    objectToUpdate[keys[keys.length - 1]] = value;
}

function createAgChartTheme(chartProxyParams, proxy) {
    var _a;
    const { chartOptionsToRestore, chartPaletteToRestore, chartThemeToRestore } = chartProxyParams;
    const themeName = getSelectedTheme(chartProxyParams);
    const stockTheme = isStockTheme(themeName);
    const rootTheme = stockTheme
        ? { baseTheme: themeName }
        : (_a = lookupCustomChartTheme(chartProxyParams, themeName)) !== null && _a !== void 0 ? _a : {};
    const gridOptionsThemeOverrides = chartProxyParams.getGridOptionsChartThemeOverrides();
    const apiThemeOverrides = chartProxyParams.apiChartThemeOverrides;
    const standaloneChartType = getSeriesType(chartProxyParams.chartType);
    const crossFilterThemeOverridePoint = isPieChartSeries(standaloneChartType) ? standaloneChartType : 'cartesian';
    const crossFilteringOverrides = chartProxyParams.crossFiltering
        ? createCrossFilterThemeOverrides(proxy, chartProxyParams, crossFilterThemeOverridePoint)
        : undefined;
    const formattingPanelOverrides = Object.assign({}, (chartOptionsToRestore !== null && chartOptionsToRestore !== void 0 ? chartOptionsToRestore : {}));
    const isTitleEnabled = () => {
        const isTitleEnabled = (obj) => {
            if (!obj) {
                return false;
            }
            return Object.keys(obj).some(key => get(obj[key], 'title.enabled', false));
        };
        return isTitleEnabled(gridOptionsThemeOverrides) || isTitleEnabled(apiThemeOverrides);
    };
    // Overrides in ascending precedence ordering.
    const overrides = [
        stockTheme ? inbuiltStockThemeOverrides(chartProxyParams, isTitleEnabled()) : undefined,
        crossFilteringOverrides,
        gridOptionsThemeOverrides,
        apiThemeOverrides,
        formattingPanelOverrides,
    ];
    // Recursively nest theme overrides so they are applied with correct precedence in
    // Standalone Charts - this is an undocumented feature.
    // Outermost theme overrides will be the formatting panel configured values, so they are
    // differentiated from grid-config and inbuilt overrides.
    const theme = overrides
        .filter((v) => !!v)
        .reduce((r, n) => ({
        baseTheme: r,
        overrides: n,
    }), rootTheme);
    // Avoid explicitly setting the `theme.palette` property unless we're using the restored theme
    // AND the palette is actually different.
    if (chartPaletteToRestore && themeName === chartThemeToRestore) {
        const rootThemePalette = integrated_charts_theme_exports.getChartTheme(rootTheme).palette;
        if (!isIdenticalPalette(chartPaletteToRestore, rootThemePalette)) {
            theme.palette = chartPaletteToRestore;
        }
    }
    return theme;
}
function applyThemeOverrides(baseTheme, overrides) {
    return overrides.reduce((baseTheme, overrides) => {
        if (!overrides)
            return baseTheme;
        return {
            baseTheme: baseTheme,
            overrides,
        };
    }, baseTheme);
}
function isIdenticalPalette(paletteA, paletteB) {
    const arrayCompare = (arrA, arrB) => {
        if (arrA.length !== arrB.length)
            return false;
        return arrA.every((v, i) => v === arrB[i]);
    };
    return arrayCompare(paletteA.fills, paletteB.fills) &&
        arrayCompare(paletteA.strokes, paletteB.strokes);
}
function isStockTheme(themeName) {
    return _.includes(Object.keys(integrated_charts_theme_exports.themes), themeName);
}
function createCrossFilterThemeOverrides(proxy, chartProxyParams, overrideType) {
    const legend = {
        listeners: {
            legendItemClick: (e) => {
                const chart = proxy.getChart();
                chart.series.forEach((s) => {
                    s.toggleSeriesItem(e.itemId, e.enabled);
                    s.toggleSeriesItem(`${e.itemId}-filtered-out`, e.enabled);
                });
            },
        },
    };
    const series = {};
    return {
        [overrideType]: {
            tooltip: {
                delay: 500,
            },
            legend,
            listeners: {
                click: (e) => chartProxyParams.crossFilterCallback(e, true),
            },
            series,
        },
    };
}
const STATIC_INBUILT_STOCK_THEME_AXES_OVERRIDES = ALL_AXIS_TYPES.reduce((r, n) => (Object.assign(Object.assign({}, r), { [n]: { title: { _enabledFromTheme: true } } })), {});
function inbuiltStockThemeOverrides(params, titleEnabled) {
    const extraPadding = params.getExtraPaddingDirections();
    return {
        common: {
            animation: {
                duration: 500,
            },
            axes: STATIC_INBUILT_STOCK_THEME_AXES_OVERRIDES,
            padding: {
                // don't add extra padding when a title is present!
                top: !titleEnabled && extraPadding.includes('top') ? 40 : 20,
                right: extraPadding.includes('right') ? 30 : 20,
                bottom: extraPadding.includes('bottom') ? 40 : 20,
                left: extraPadding.includes('left') ? 30 : 20,
            },
        },
        pie: {
            series: {
                title: { _enabledFromTheme: true },
                calloutLabel: { _enabledFromTheme: true },
                sectorLabel: {
                    enabled: false,
                    _enabledFromTheme: true,
                },
            },
        },
        donut: {
            series: {
                title: { _enabledFromTheme: true },
                calloutLabel: { _enabledFromTheme: true },
                sectorLabel: {
                    enabled: false,
                    _enabledFromTheme: true,
                },
            },
        },
    };
}
function getSelectedTheme(chartProxyParams) {
    let chartThemeName = chartProxyParams.getChartThemeName();
    const availableThemes = chartProxyParams.getChartThemes();
    if (!_.includes(availableThemes, chartThemeName)) {
        chartThemeName = availableThemes[0];
    }
    return chartThemeName;
}
function lookupCustomChartTheme(chartProxyParams, name) {
    const { customChartThemes } = chartProxyParams;
    const customChartTheme = customChartThemes && customChartThemes[name];
    if (!customChartTheme) {
        console.warn(`AG Grid: no stock theme exists with the name '${name}' and no ` +
            "custom chart theme with that name was supplied to 'customChartThemes'");
    }
    return customChartTheme;
}

var _a$1;
const validateIfDefined = (validationFn) => {
    return (value) => {
        if (value == undefined)
            return true;
        return validationFn(value);
    };
};
const isString$1 = (value) => typeof value === 'string';
const isBoolean$1 = (value) => typeof value === 'boolean';
const isValidSeriesChartType = (value) => typeof value === 'object';
const createWarnMessage = (property, expectedType) => (value) => `AG Grid - unable to update chart as invalid params supplied:  \`${property}: ${value}\`, expected ${expectedType}.`;
class UpdateParamsValidator {
    static isValidChartType(value) {
        return UpdateParamsValidator.validChartTypes.includes(value);
    }
    static isLegacyChartType(value) {
        return UpdateParamsValidator.legacyChartTypes.includes(value);
    }
    static validateChartParams(params) {
        let paramsToValidate = params;
        switch (paramsToValidate.type) {
            case 'rangeChartUpdate':
                return UpdateParamsValidator.validateUpdateRangeChartParams(params);
            case 'pivotChartUpdate':
                return UpdateParamsValidator.validateUpdatePivotChartParams(params);
            case 'crossFilterChartUpdate':
                return UpdateParamsValidator.validateUpdateCrossFilterChartParams(params);
            default:
                console.warn(`AG Grid - Invalid value supplied for 'type': ${params.type}. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.`);
                return false;
        }
    }
    static validateUpdateRangeChartParams(params) {
        const validations = [
            ...UpdateParamsValidator.commonValidations,
            ...UpdateParamsValidator.cellRangeValidations,
            {
                property: 'seriesChartTypes',
                validationFn: (value) => value === undefined || (Array.isArray(value) && value.every(isValidSeriesChartType)),
                warnMessage: createWarnMessage('seriesChartTypes', 'Array of SeriesChartType'),
            },
        ];
        return UpdateParamsValidator.validateProperties(params, validations, ['type', 'chartId', 'chartType', 'chartThemeName', 'chartThemeOverrides', 'unlinkChart', 'cellRange', 'suppressChartRanges', 'aggFunc', 'seriesChartTypes'], 'UpdateRangeChartParams');
    }
    static validateUpdatePivotChartParams(params) {
        const validations = [
            ...UpdateParamsValidator.commonValidations,
        ];
        return UpdateParamsValidator.validateProperties(params, validations, ['type', 'chartId', 'chartType', 'chartThemeName', 'chartThemeOverrides', 'unlinkChart'], 'UpdatePivotChartParams');
    }
    static validateUpdateCrossFilterChartParams(params) {
        const validations = [
            ...UpdateParamsValidator.commonValidations,
            ...UpdateParamsValidator.cellRangeValidations,
        ];
        return UpdateParamsValidator.validateProperties(params, validations, ['type', 'chartId', 'chartType', 'chartThemeName', 'chartThemeOverrides', 'unlinkChart', 'cellRange', 'suppressChartRanges', 'aggFunc'], 'UpdateCrossFilterChartParams');
    }
    static validateProperties(params, validations, validPropertyNames, paramsType) {
        let validatedProperties = undefined;
        for (const validation of validations) {
            const { property, validationFn, warnMessage } = validation;
            if (property in params) {
                const value = params[property];
                const validationResult = validationFn(value);
                if (validationResult === true)
                    continue;
                if (validationResult === false) {
                    console.warn(warnMessage(value));
                    return false;
                }
                // If the validation function returned a 'fix' value, we need to return an updated property set.
                // First we clone the input set if there has not been a 'fix' encountered in a previous iteration:
                validatedProperties = validatedProperties || Object.assign({}, params);
                /// Then we update the cloned object with the 'fixed' value
                validatedProperties[property] = validationResult;
            }
        }
        // Check for unexpected properties
        for (const property in params) {
            if (!validPropertyNames.includes(property)) {
                console.warn(`AG Grid - Unexpected property supplied. ${paramsType} does not contain: \`${property}\`.`);
                return false;
            }
        }
        // If one or more 'fixed' values were encountered, return the updated property set
        if (validatedProperties)
            return validatedProperties;
        return true;
    }
}
_a$1 = UpdateParamsValidator;
UpdateParamsValidator.validChartTypes = [
    'column',
    'groupedColumn',
    'stackedColumn',
    'normalizedColumn',
    'bar',
    'groupedBar',
    'stackedBar',
    'normalizedBar',
    'line',
    'scatter',
    'bubble',
    'pie',
    'donut',
    'area',
    'stackedArea',
    'normalizedArea',
    'histogram',
    'radialColumn',
    'radialBar',
    'radarLine',
    'radarArea',
    'nightingale',
    'rangeBar',
    'rangeArea',
    'boxPlot',
    'treemap',
    'sunburst',
    'heatmap',
    'waterfall',
    'columnLineCombo',
    'areaColumnCombo',
    'customCombo'
];
UpdateParamsValidator.legacyChartTypes = [
    'doughnut',
];
UpdateParamsValidator.validateChartType = validateIfDefined((chartType) => {
    if (_a$1.isValidChartType(chartType))
        return true;
    if (_a$1.isLegacyChartType(chartType)) {
        const renamedChartType = getCanonicalChartType(chartType);
        console.warn(`AG Grid - The chart type '${chartType}' has been deprecated. Please use '${renamedChartType}' instead.`);
        return renamedChartType;
    }
    return false;
});
UpdateParamsValidator.validateAgChartThemeOverrides = validateIfDefined((themeOverrides) => {
    // ensure supplied AgChartThemeOverrides is an object - can be improved if necessary?
    return typeof themeOverrides === 'object';
});
UpdateParamsValidator.validateChartParamsCellRange = validateIfDefined((cellRange) => {
    // ensure supplied ChartParamsCellRange is an object - can be improved if necessary?
    return typeof cellRange === 'object';
});
UpdateParamsValidator.validateAggFunc = validateIfDefined((aggFunc) => {
    // ensure supplied aggFunc is a `string` or `function` - can be improved if necessary?
    return typeof aggFunc === 'string' || typeof aggFunc === 'function';
});
UpdateParamsValidator.commonValidations = [
    { property: 'chartId', validationFn: isString$1, warnMessage: createWarnMessage('chartId', 'string') },
    {
        property: 'chartType',
        validationFn: UpdateParamsValidator.validateChartType,
        warnMessage: createWarnMessage('chartType', UpdateParamsValidator.validChartTypes.join(', '))
    },
    {
        property: 'chartThemeName',
        validationFn: isString$1,
        warnMessage: createWarnMessage('chartThemeName', 'string')
    },
    {
        property: 'chartThemeOverrides',
        validationFn: UpdateParamsValidator.validateAgChartThemeOverrides,
        warnMessage: createWarnMessage('chartThemeOverrides', 'AgChartThemeOverrides')
    },
    { property: 'unlinkChart', validationFn: isBoolean$1, warnMessage: createWarnMessage('unlinkChart', 'boolean') },
];
UpdateParamsValidator.cellRangeValidations = [
    {
        property: 'cellRange',
        validationFn: UpdateParamsValidator.validateChartParamsCellRange,
        warnMessage: createWarnMessage('cellRange', 'ChartParamsCellRange')
    },
    {
        property: 'suppressChartRanges',
        validationFn: isBoolean$1,
        warnMessage: createWarnMessage('suppressChartRanges', 'boolean')
    },
    {
        property: 'aggFunc',
        validationFn: UpdateParamsValidator.validateAggFunc,
        warnMessage: createWarnMessage('aggFunc', 'string or IAggFunc')
    },
];

var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const DEFAULT_THEMES = ['ag-default', 'ag-material', 'ag-sheets', 'ag-polychroma', 'ag-vivid'];
class ChartController extends BeanStub {
    constructor(model) {
        super();
        this.model = model;
        this.isEnterprise = () => module_support_exports.enterpriseModule.isEnterprise;
    }
    init() {
        this.setChartRange();
        this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, event => {
            if (event.id && event.id === this.model.chartId) {
                this.updateForRangeChange();
            }
        });
        if (this.model.unlinked) {
            if (this.rangeService) {
                this.rangeService.setCellRanges([]);
            }
        }
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, this.updateForGridChange.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, this.updateForGridChange.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, this.updateForGridChange.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.updateForGridChange.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, this.updateForGridChange.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_CELL_VALUE_CHANGED, this.updateForDataChange.bind(this));
    }
    update(params) {
        if (!this.validUpdateType(params))
            return false;
        const validationResult = UpdateParamsValidator.validateChartParams(params);
        if (!validationResult)
            return false;
        const validParams = validationResult === true ? params : validationResult;
        this.applyValidatedChartParams(validParams);
        return true;
    }
    applyValidatedChartParams(params) {
        var _a, _b, _c, _d, _e, _f, _g;
        const { chartId, chartType, chartThemeName, unlinkChart } = params;
        // create a common base for the chart model parameters (this covers pivot chart updates)
        const common = {
            chartId: chartId,
            pivotChart: this.model.pivotChart,
            chartType: chartType !== null && chartType !== void 0 ? chartType : this.model.chartType,
            chartThemeName: chartThemeName !== null && chartThemeName !== void 0 ? chartThemeName : this.model.chartThemeName,
            unlinkChart: unlinkChart !== null && unlinkChart !== void 0 ? unlinkChart : this.model.unlinked,
            cellRange: this.model.suppliedCellRange,
            aggFunc: this.model.aggFunc,
            seriesChartTypes: undefined,
            suppressChartRanges: false,
            crossFiltering: false,
        };
        let chartModelParams = Object.assign({}, common);
        // modify the chart model properties based on the type of update
        switch (params.type) {
            case 'rangeChartUpdate':
                chartModelParams.cellRange = (_a = this.createCellRange(params)) !== null && _a !== void 0 ? _a : this.model.suppliedCellRange;
                chartModelParams.aggFunc = (_b = params.aggFunc) !== null && _b !== void 0 ? _b : this.model.aggFunc;
                chartModelParams.seriesChartTypes = params.seriesChartTypes;
                chartModelParams.suppressChartRanges = (_c = params.suppressChartRanges) !== null && _c !== void 0 ? _c : this.model.suppressChartRanges;
                break;
            case 'crossFilterChartUpdate':
                chartModelParams.cellRange = (_d = this.createCellRange(params)) !== null && _d !== void 0 ? _d : this.model.suppliedCellRange;
                chartModelParams.aggFunc = (_e = params.aggFunc) !== null && _e !== void 0 ? _e : this.model.aggFunc;
                chartModelParams.crossFiltering = true;
                chartModelParams.suppressChartRanges = (_f = params.suppressChartRanges) !== null && _f !== void 0 ? _f : this.model.suppressChartRanges;
                break;
        }
        this.model.updateModel(chartModelParams);
        // if the chart should be unlinked or chart ranges suppressed, remove all cell ranges; otherwise, set the chart range
        const removeChartCellRanges = chartModelParams.unlinkChart || chartModelParams.suppressChartRanges;
        removeChartCellRanges ? (_g = this.rangeService) === null || _g === void 0 ? void 0 : _g.setCellRanges([]) : this.setChartRange();
    }
    updateForGridChange() {
        if (this.model.unlinked) {
            return;
        }
        this.model.updateCellRanges();
        this.model.updateData();
        this.setChartRange();
    }
    updateForDataChange() {
        if (this.model.unlinked) {
            return;
        }
        this.model.updateData();
        this.raiseChartModelUpdateEvent();
    }
    updateForRangeChange() {
        this.updateForGridChange();
        this.raiseChartRangeSelectionChangedEvent();
    }
    updateForPanelChange(updatedCol) {
        this.model.updateCellRanges(updatedCol);
        this.model.updateData();
        this.setChartRange();
        this.raiseChartRangeSelectionChangedEvent();
    }
    getChartUpdateParams(updatedOverrides) {
        const selectedCols = this.getSelectedValueColState();
        const fields = selectedCols.map(c => ({ colId: c.colId, displayName: c.displayName }));
        const data = this.getChartData();
        const selectedDimensions = this.getSelectedDimensions();
        return {
            data,
            grouping: this.isGrouping(),
            categories: selectedDimensions.map((selectedDimension) => ({
                id: selectedDimension.colId,
                name: selectedDimension.displayName,
                chartDataType: this.model.getChartDataType(selectedDimension.colId)
            })),
            fields,
            chartId: this.getChartId(),
            getCrossFilteringContext: () => ({ lastSelectedChartId: 'xxx' }),
            seriesChartTypes: this.getSeriesChartTypes(),
            updatedOverrides: updatedOverrides
        };
    }
    getChartModel() {
        const modelType = this.model.pivotChart ? 'pivot' : 'range';
        const seriesChartTypes = this.isComboChart() ? this.model.comboChartModel.seriesChartTypes : undefined;
        return {
            modelType,
            chartId: this.model.chartId,
            chartType: this.model.chartType,
            chartThemeName: this.getChartThemeName(),
            chartOptions: this.chartProxy.getChartThemeOverrides(),
            chartPalette: this.chartProxy.getChartPalette(),
            cellRange: this.getCellRangeParams(),
            suppressChartRanges: this.model.suppressChartRanges,
            aggFunc: this.model.aggFunc,
            unlinkChart: this.model.unlinked,
            seriesChartTypes
        };
    }
    getChartId() {
        return this.model.chartId;
    }
    getChartData() {
        return this.model.chartData;
    }
    getChartType() {
        return this.model.chartType;
    }
    setChartType(chartType) {
        // If we are changing from a multi-dimensional chart type to a single-dimensional chart type,
        // ensure that only the first selected dimension column remains selected
        const previousChartType = this.model.chartType;
        if (isHierarchical(previousChartType) && !isHierarchical(chartType)) {
            let hasSelectedDimension = false;
            for (const colState of this.model.dimensionColState) {
                if (!colState.selected)
                    continue;
                if (hasSelectedDimension)
                    colState.selected = false;
                hasSelectedDimension = true;
            }
        }
        this.model.chartType = chartType;
        this.model.comboChartModel.updateSeriesChartTypes();
        this.raiseChartModelUpdateEvent();
        this.raiseChartOptionsChangedEvent();
    }
    setChartThemeName(chartThemeName, silent) {
        this.model.chartThemeName = chartThemeName;
        if (!silent) {
            this.raiseChartModelUpdateEvent();
            this.raiseChartOptionsChangedEvent();
        }
    }
    getChartThemeName() {
        return this.model.chartThemeName;
    }
    isPivotChart() {
        return this.model.pivotChart;
    }
    isPivotMode() {
        return this.model.isPivotMode();
    }
    isGrouping() {
        return this.model.isGrouping();
    }
    isCrossFilterChart() {
        return this.model.crossFiltering;
    }
    getThemeNames() {
        return this.gridOptionsService.get('chartThemes') || DEFAULT_THEMES;
    }
    getThemes() {
        const themeNames = this.getThemeNames();
        return themeNames.map((themeName) => {
            const stockTheme = isStockTheme(themeName);
            const theme = stockTheme ? themeName : this.chartProxy.lookupCustomChartTheme(themeName);
            return integrated_charts_theme_exports.getChartTheme(theme);
        });
    }
    getPalettes() {
        const themes = this.getThemes();
        return themes.map((theme) => {
            return theme.palette;
        });
    }
    getThemeTemplateParameters() {
        const themes = this.getThemes();
        return themes.map((theme) => {
            return theme.getTemplateParameters();
        });
    }
    getValueColState() {
        return this.model.valueColState.map(this.displayNameMapper.bind(this));
    }
    getSelectedValueColState() {
        return this.getValueColState().filter(cs => cs.selected);
    }
    getSelectedDimensions() {
        return this.model.getSelectedDimensions();
    }
    displayNameMapper(col) {
        const columnNames = this.model.columnNames[col.colId];
        col.displayName = columnNames ? columnNames.join(' - ') : this.model.getColDisplayName(col.column);
        return col;
    }
    getColStateForMenu() {
        return { dimensionCols: this.model.dimensionColState, valueCols: this.getValueColState() };
    }
    setChartRange(silent = false) {
        if (this.rangeService && !this.model.suppressChartRanges && !this.model.unlinked) {
            this.rangeService.setCellRanges(this.getCellRanges());
        }
        if (!silent) {
            this.raiseChartModelUpdateEvent();
        }
    }
    detachChartRange() {
        // when chart is detached it won't listen to changes from the grid
        this.model.unlinked = !this.model.unlinked;
        if (this.model.unlinked) {
            // remove range from grid
            if (this.rangeService) {
                this.rangeService.setCellRanges([]);
            }
        }
        else {
            // update chart data may have changed
            this.updateForGridChange();
        }
    }
    setChartProxy(chartProxy) {
        this.chartProxy = chartProxy;
    }
    getChartProxy() {
        return this.chartProxy;
    }
    isActiveXYChart() {
        return _.includes(['scatter', 'bubble'], this.getChartType());
    }
    isChartLinked() {
        return !this.model.unlinked;
    }
    customComboExists() {
        const savedCustomSeriesChartTypes = this.model.comboChartModel.savedCustomSeriesChartTypes;
        return savedCustomSeriesChartTypes && savedCustomSeriesChartTypes.length > 0;
    }
    getSeriesChartTypes() {
        return this.model.comboChartModel.seriesChartTypes;
    }
    isComboChart() {
        return this.model.isComboChart();
    }
    updateSeriesChartType(colId, chartType, secondaryAxis) {
        const seriesChartType = this.model.comboChartModel.seriesChartTypes.find(s => s.colId === colId);
        if (seriesChartType) {
            // once a combo chart has been modified it is now a 'customCombo' chart
            const updateChartType = this.model.chartType !== 'customCombo';
            if (updateChartType) {
                this.model.chartType = 'customCombo';
            }
            const prevSeriesChartType = seriesChartType.chartType;
            if (chartType != null) {
                seriesChartType.chartType = chartType;
            }
            if (secondaryAxis != null) {
                seriesChartType.secondaryAxis = secondaryAxis;
            }
            // replace existing custom series types with this latest version
            this.model.comboChartModel.savedCustomSeriesChartTypes = this.model.comboChartModel.seriesChartTypes;
            // series chart types can be modified, i.e. column chart types should be moved to primary axis
            this.model.comboChartModel.updateSeriesChartTypes();
            this.updateForDataChange();
            if (updateChartType) {
                // update the settings panel by raising an EVENT_CHART_TYPE_CHANGED event
                this.dispatchEvent({
                    type: ChartController.EVENT_CHART_TYPE_CHANGED
                });
            }
            if (prevSeriesChartType !== chartType) {
                // update the format panel by raising an EVENT_CHART_SERIES_CHART_TYPE_CHANGED event
                this.dispatchEvent({
                    type: ChartController.EVENT_CHART_SERIES_CHART_TYPE_CHANGED
                });
            }
            this.raiseChartOptionsChangedEvent();
        }
    }
    getActiveSeriesChartTypes() {
        const selectedColIds = this.getSelectedValueColState().map(c => c.colId);
        return this.getSeriesChartTypes().filter(s => selectedColIds.includes(s.colId));
    }
    getChartSeriesTypes() {
        const supportedComboSeriesTypes = ['line', 'bar', 'area'];
        return this.isComboChart() ? supportedComboSeriesTypes : [getSeriesType(this.getChartType())];
    }
    getCellRanges() {
        return [this.model.dimensionCellRange, this.model.valueCellRange].filter(r => r);
    }
    createCellRange(params) {
        var _a;
        return params.cellRange && ((_a = this.rangeService) === null || _a === void 0 ? void 0 : _a.createCellRangeFromCellRangeParams(params.cellRange));
    }
    validUpdateType(params) {
        var _a;
        if (!params.type) {
            console.warn(`AG Grid - Unable to update chart as the 'type' is missing. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.`);
            return false;
        }
        const chartTypeMap = {
            'Range Chart': () => !this.isPivotChart() && !this.isCrossFilterChart(),
            'Pivot Chart': () => this.isPivotChart(),
            'Cross Filter Chart': () => this.isCrossFilterChart()
        };
        const currentChartType = (_a = Object.keys(chartTypeMap).find(type => chartTypeMap[type]())) !== null && _a !== void 0 ? _a : 'Range Chart';
        const valid = params.type ===
            `${currentChartType[0].toLowerCase()}${currentChartType.slice(1).replace(/ /g, '')}Update`;
        if (!valid) {
            console.warn(`AG Grid - Unable to update chart as a '${params.type}' update type is not permitted on a ${currentChartType}.`);
        }
        return valid;
    }
    getCellRangeParams() {
        const cellRanges = this.getCellRanges();
        const firstCellRange = cellRanges[0];
        const startRow = (firstCellRange && firstCellRange.startRow) || null;
        const endRow = (firstCellRange && firstCellRange.endRow) || null;
        return {
            rowStartIndex: startRow && startRow.rowIndex,
            rowStartPinned: startRow && startRow.rowPinned,
            rowEndIndex: endRow && endRow.rowIndex,
            rowEndPinned: endRow && endRow.rowPinned,
            columns: cellRanges.reduce((columns, value) => columns.concat(value.columns.map(c => c.getId())), [])
        };
    }
    raiseChartModelUpdateEvent() {
        const event = {
            type: ChartController.EVENT_CHART_MODEL_UPDATE
        };
        this.dispatchEvent(event);
    }
    raiseChartUpdatedEvent() {
        const event = {
            type: ChartController.EVENT_CHART_UPDATED
        };
        this.dispatchEvent(event);
    }
    raiseChartApiUpdateEvent() {
        const event = {
            type: ChartController.EVENT_CHART_API_UPDATE
        };
        this.dispatchEvent(event);
    }
    raiseChartOptionsChangedEvent() {
        const { chartId, chartType } = this.getChartModel();
        const event = {
            type: Events.EVENT_CHART_OPTIONS_CHANGED,
            chartId,
            chartType,
            chartThemeName: this.getChartThemeName(),
            chartOptions: this.chartProxy.getChartThemeOverrides()
        };
        this.eventService.dispatchEvent(event);
    }
    raiseChartRangeSelectionChangedEvent() {
        const event = {
            type: Events.EVENT_CHART_RANGE_SELECTION_CHANGED,
            id: this.model.chartId,
            chartId: this.model.chartId,
            cellRange: this.getCellRangeParams()
        };
        this.eventService.dispatchEvent(event);
    }
    destroy() {
        super.destroy();
        if (this.rangeService) {
            this.rangeService.setCellRanges([]);
        }
    }
}
ChartController.EVENT_CHART_UPDATED = 'chartUpdated';
ChartController.EVENT_CHART_API_UPDATE = 'chartApiUpdate';
ChartController.EVENT_CHART_MODEL_UPDATE = 'chartModelUpdate';
ChartController.EVENT_CHART_TYPE_CHANGED = 'chartTypeChanged';
ChartController.EVENT_CHART_SERIES_CHART_TYPE_CHANGED = 'chartSeriesChartTypeChanged';
__decorate$f([
    Autowired('rangeService')
], ChartController.prototype, "rangeService", void 0);
__decorate$f([
    PostConstruct
], ChartController.prototype, "init", null);

var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const DefaultDataPanelDef = {
    groups: [
        { type: 'categories', isOpen: true },
        { type: 'series', isOpen: true },
        { type: 'seriesChartType', isOpen: true }
    ]
};
class ChartDataPanel extends Component {
    constructor(chartController, chartOptionsService) {
        super(ChartDataPanel.TEMPLATE);
        this.chartController = chartController;
        this.chartOptionsService = chartOptionsService;
        this.columnComps = new Map();
    }
    init() {
        this.updatePanels();
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_MODEL_UPDATE, this.updatePanels.bind(this));
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_API_UPDATE, this.updatePanels.bind(this));
        this.createAutoScrollService();
    }
    destroy() {
        this.clearComponents();
        super.destroy();
    }
    updatePanels() {
        var _a, _b;
        const currentChartType = this.chartType;
        const { dimensionCols, valueCols } = this.chartController.getColStateForMenu();
        const colIds = dimensionCols.map(c => c.colId).concat(valueCols.map(c => c.colId));
        this.chartType = this.chartController.getChartType();
        const groupExpandedState = this.getGroupExpandedState();
        if (_.areEqual(_.keys(this.columnComps), colIds) && this.chartType === currentChartType) {
            // if possible, we just update existing components
            [...dimensionCols, ...valueCols].forEach(col => {
                this.columnComps.get(col.colId).setValue(col.selected, true);
            });
            if (this.chartController.isActiveXYChart()) {
                const getSeriesLabel = this.generateGetSeriesLabel();
                valueCols.forEach(col => {
                    this.columnComps.get(col.colId).setLabel(getSeriesLabel(col));
                });
            }
            // recreate series chart type group if it exists as series may be added or removed via series group panel
            _.removeFromParent(this.getGui().querySelector('#seriesChartTypeGroup'));
            this.seriesChartTypeGroupComp = this.destroyBean(this.seriesChartTypeGroupComp);
            const seriesChartTypeIndex = (_a = this.getDataPanelDef().groups) === null || _a === void 0 ? void 0 : _a.reduce((prevVal, { type }, index) => {
                if (type === 'seriesChartType') {
                    return index;
                }
                return prevVal;
            }, -1);
            if (seriesChartTypeIndex !== -1) {
                this.createSeriesChartTypeGroup(valueCols, seriesChartTypeIndex);
            }
        }
        else {
            // otherwise, we re-create everything
            this.clearComponents();
            (_b = this.getDataPanelDef().groups) === null || _b === void 0 ? void 0 : _b.forEach(({ type }) => {
                if (type === 'categories') {
                    this.createCategoriesGroup(dimensionCols);
                }
                else if (type === 'series') {
                    this.createSeriesGroup(valueCols);
                }
                else if (type === 'seriesChartType') {
                    this.createSeriesChartTypeGroup(valueCols);
                }
                else {
                    console.warn(`AG Grid: invalid charts data panel group name supplied: '${type}'`);
                }
            });
        }
        this.restoreGroupExpandedState(groupExpandedState);
    }
    getGroupExpandedState() {
        const groups = [
            { groupType: 'categories', comp: this.categoriesGroupComp },
            { groupType: 'series', comp: this.seriesGroupComp },
            { groupType: 'seriesChartType', comp: this.seriesChartTypeGroupComp }
        ];
        return groups.map(({ groupType, comp }) => {
            var _a, _b;
            const defaultExpanded = Boolean((_b = (_a = this.getDataPanelDef().groups) === null || _a === void 0 ? void 0 : _a.find(({ type }) => type === groupType)) === null || _b === void 0 ? void 0 : _b.isOpen);
            return !comp ? defaultExpanded : comp.isExpanded();
        });
    }
    restoreGroupExpandedState(groupExpandedState) {
        [
            this.categoriesGroupComp,
            this.seriesGroupComp,
            this.seriesChartTypeGroupComp
        ].forEach((group, idx) => {
            if (!group) {
                return;
            }
            group.toggleGroupExpand(groupExpandedState[idx]);
        });
    }
    createAutoScrollService() {
        const eGui = this.getGui();
        this.autoScrollService = new AutoScrollService({
            scrollContainer: eGui,
            scrollAxis: 'y',
            getVerticalPosition: () => eGui.scrollTop,
            setVerticalPosition: (position) => eGui.scrollTop = position
        });
    }
    createComponent(component, id) {
        const eDiv = document.createElement('div');
        eDiv.id = id;
        eDiv.className = 'ag-chart-data-section';
        eDiv.appendChild(component.getGui());
        return eDiv;
    }
    addComponent(parent, component, id) {
        const eDiv = this.createComponent(component, id);
        parent.appendChild(eDiv);
    }
    addComponentAtIndex(parent, component, id, index) {
        const eDiv = this.createComponent(component, id);
        parent.insertBefore(eDiv, parent.children[index]);
    }
    addChangeListener(component, columnState) {
        this.addManagedListener(component, Events.EVENT_FIELD_VALUE_CHANGED, () => {
            columnState.selected = component.getValue();
            this.chartController.updateForPanelChange(columnState);
        });
    }
    createCategoriesGroup(columns) {
        this.categoriesGroupComp = this.createBean(new AgGroupComponent({
            title: this.getCategoryGroupTitle(),
            enabled: true,
            suppressEnabledCheckbox: true,
            suppressOpenCloseIcons: false,
            cssIdentifier: 'charts-data'
        }));
        const inputName = `chartDimension${this.categoriesGroupComp.getCompId()}`;
        // Display either radio buttons or checkboxes
        // depending on whether the current chart type supports multiple category columns
        const chartType = this.chartController.getChartType();
        const supportsMultipleCategoryColumns = isHierarchical(chartType);
        columns.forEach(col => {
            const comp = this.categoriesGroupComp.createManagedBean(supportsMultipleCategoryColumns
                ? (() => {
                    const checkboxComp = new AgCheckbox();
                    checkboxComp.addCssClass('ag-data-select-checkbox');
                    return checkboxComp;
                })()
                : new AgRadioButton());
            comp.setLabel(_.escapeString(col.displayName));
            comp.setValue(col.selected);
            comp.setInputName(inputName);
            this.addChangeListener(comp, col);
            this.categoriesGroupComp.addItem(comp);
            this.columnComps.set(col.colId, comp);
            if (supportsMultipleCategoryColumns)
                this.addDragHandle(comp, col);
        });
        this.addComponent(this.getGui(), this.categoriesGroupComp, 'categoriesGroup');
        if (supportsMultipleCategoryColumns) {
            const categoriesGroupGui = this.categoriesGroupComp.getGui();
            const dropTarget = {
                getIconName: () => DragAndDropService.ICON_MOVE,
                getContainer: () => categoriesGroupGui,
                onDragging: (params) => this.onDragging(params),
                onDragLeave: () => this.onDragLeave(),
                isInterestedIn: this.isInterestedIn.bind(this),
                targetContainsSource: true
            };
            this.dragAndDropService.addDropTarget(dropTarget);
            this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(dropTarget));
        }
    }
    createSeriesGroup(columns) {
        this.seriesGroupComp = this.createManagedBean(new AgGroupComponent({
            title: this.getSeriesGroupTitle(),
            enabled: true,
            suppressEnabledCheckbox: true,
            suppressOpenCloseIcons: false,
            cssIdentifier: 'charts-data'
        }));
        if (this.chartController.isActiveXYChart()) {
            const pairedModeToggle = this.seriesGroupComp.createManagedBean(new AgToggleButton());
            pairedModeToggle
                .setLabel(this.chartTranslationService.translate('paired'))
                .setLabelAlignment('left')
                .setLabelWidth('flex')
                .setInputWidth('flex')
                .setValue(this.chartOptionsService.getPairedMode())
                .onValueChange(newValue => {
                this.chartOptionsService.setPairedMode(!!newValue);
                this.chartController.updateForGridChange();
            });
            this.seriesGroupComp.addItem(pairedModeToggle);
        }
        const getSeriesLabel = this.generateGetSeriesLabel();
        columns.forEach(col => {
            const comp = this.seriesGroupComp.createManagedBean(new AgCheckbox());
            comp.addCssClass('ag-data-select-checkbox');
            const label = getSeriesLabel(col);
            comp.setLabel(label);
            comp.setValue(col.selected);
            this.addChangeListener(comp, col);
            this.seriesGroupComp.addItem(comp);
            this.columnComps.set(col.colId, comp);
            this.addDragHandle(comp, col);
        });
        const eGui = this.getGui();
        const seriesGroupGui = this.seriesGroupComp.getGui();
        this.addComponent(eGui, this.seriesGroupComp, 'seriesGroup');
        const dropTarget = {
            getIconName: () => DragAndDropService.ICON_MOVE,
            getContainer: () => seriesGroupGui,
            onDragging: (params) => this.onDragging(params),
            onDragLeave: () => this.onDragLeave(),
            isInterestedIn: this.isInterestedIn.bind(this),
            targetContainsSource: true
        };
        this.dragAndDropService.addDropTarget(dropTarget);
        this.addDestroyFunc(() => this.dragAndDropService.removeDropTarget(dropTarget));
    }
    createSeriesChartTypeGroup(columns, index) {
        if (!this.chartController.isComboChart()) {
            return;
        }
        this.seriesChartTypeGroupComp = this.createManagedBean(new AgGroupComponent({
            title: this.chartTranslationService.translate('seriesChartType'),
            enabled: true,
            suppressEnabledCheckbox: true,
            suppressOpenCloseIcons: false,
            cssIdentifier: 'charts-data'
        }));
        const seriesChartTypes = this.chartController.getSeriesChartTypes();
        columns.forEach(col => {
            if (!col.selected) {
                return;
            }
            const seriesChartType = seriesChartTypes.filter(s => s.colId === col.colId)[0];
            if (!seriesChartType) {
                return;
            }
            const seriesItemGroup = this.seriesChartTypeGroupComp.createManagedBean(new AgGroupComponent({
                title: col.displayName,
                enabled: true,
                suppressEnabledCheckbox: true,
                suppressOpenCloseIcons: true,
                cssIdentifier: 'charts-format-sub-level'
            }));
            const secondaryAxisComp = this.seriesChartTypeGroupComp
                .createManagedBean(new AgCheckbox())
                .setLabel(this.chartTranslationService.translate('secondaryAxis'))
                .setLabelWidth("flex")
                .setDisabled(['groupedColumn', 'stackedColumn', 'stackedArea'].includes(seriesChartType.chartType))
                .setValue(!!seriesChartType.secondaryAxis)
                .onValueChange((enabled) => this.chartController.updateSeriesChartType(col.colId, undefined, enabled));
            seriesItemGroup.addItem(secondaryAxisComp);
            const translate = (key, defaultText) => {
                return this.chartTranslationService.translate(key, defaultText);
            };
            const availableChartTypes = [
                { value: 'line', text: translate('line', 'Line') },
                { value: 'area', text: translate('area', 'Area') },
                { value: 'stackedArea', text: translate('stackedArea', 'StackedArea') },
                { value: 'groupedColumn', text: translate('groupedColumn', 'Grouped Column') },
                { value: 'stackedColumn', text: translate('stackedColumn', 'Stacked Column') },
            ];
            const chartTypeComp = seriesItemGroup.createManagedBean(new AgSelect());
            chartTypeComp
                .setLabelAlignment('left')
                .setLabelWidth("flex")
                .addOptions(availableChartTypes)
                .setValue(seriesChartType.chartType)
                .onValueChange((chartType) => this.chartController.updateSeriesChartType(col.colId, chartType));
            seriesItemGroup.addItem(chartTypeComp);
            this.seriesChartTypeGroupComp.addItem(seriesItemGroup);
        });
        if (index === undefined) {
            this.addComponent(this.getGui(), this.seriesChartTypeGroupComp, 'seriesChartTypeGroup');
        }
        else {
            this.addComponentAtIndex(this.getGui(), this.seriesChartTypeGroupComp, 'seriesChartTypeGroup', index);
        }
    }
    addDragHandle(comp, col) {
        const eDragHandle = _.createIconNoSpan('columnDrag', this.gridOptionsService);
        eDragHandle.classList.add('ag-drag-handle', 'ag-chart-data-column-drag-handle');
        comp.getGui().insertAdjacentElement('beforeend', eDragHandle);
        const dragSource = {
            type: DragSourceType.ChartPanel,
            eElement: eDragHandle,
            dragItemName: col.displayName,
            getDragItem: () => ({ columns: [col.column] }),
            onDragStopped: () => this.onDragStop()
        };
        this.dragAndDropService.addDragSource(dragSource, true);
        this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(dragSource));
    }
    generateGetSeriesLabel() {
        if (!this.chartController.isActiveXYChart()) {
            return col => _.escapeString(col.displayName);
        }
        const isBubble = this.chartType === 'bubble';
        const isInPairedMode = this.isInPairedMode();
        let selectedValuesCount = 0;
        const indexToAxisLabel = new Map();
        indexToAxisLabel.set(0, 'X');
        indexToAxisLabel.set(1, 'Y');
        indexToAxisLabel.set(2, 'size');
        return (col) => {
            const escapedLabel = _.escapeString(col.displayName);
            if (!col.selected) {
                return escapedLabel;
            }
            let axisLabel;
            if (isInPairedMode) {
                axisLabel = indexToAxisLabel.get(selectedValuesCount % (isBubble ? 3 : 2));
            }
            else {
                if (selectedValuesCount === 0) {
                    axisLabel = 'X';
                }
                else {
                    axisLabel = isBubble && selectedValuesCount % 2 === 0 ? 'size' : 'Y';
                }
            }
            selectedValuesCount++;
            return `${escapedLabel} (${axisLabel})`;
        };
    }
    getCategoryGroupTitle() {
        return this.chartTranslationService.translate(this.chartController.isActiveXYChart() ? 'labels' : 'categories');
    }
    getSeriesGroupTitle() {
        return this.chartTranslationService.translate(this.chartController.isActiveXYChart() ? 'xyValues' : 'series');
    }
    getDataPanelDef() {
        var _a;
        const userProvidedDataPanelDef = (_a = this.gridOptionsService.get('chartToolPanelsDef')) === null || _a === void 0 ? void 0 : _a.dataPanel;
        return userProvidedDataPanelDef ? userProvidedDataPanelDef : DefaultDataPanelDef;
    }
    isInPairedMode() {
        return this.chartController.isActiveXYChart() && this.chartOptionsService.getSeriesOption('paired', 'scatter');
    }
    clearComponents() {
        _.clearElement(this.getGui());
        this.categoriesGroupComp = this.destroyBean(this.categoriesGroupComp);
        this.seriesGroupComp = this.destroyBean(this.seriesGroupComp);
        this.seriesChartTypeGroupComp = this.destroyBean(this.seriesChartTypeGroupComp);
        this.columnComps.clear();
    }
    onDragging(draggingEvent) {
        const itemHovered = this.checkHoveredItem(draggingEvent);
        if (!itemHovered) {
            return;
        }
        this.lastDraggedColumn = draggingEvent.dragItem.columns[0];
        const { comp, position } = itemHovered;
        const { comp: lastHoveredComp, position: lastHoveredPosition } = this.lastHoveredItem || {};
        if (comp === lastHoveredComp && position === lastHoveredPosition) {
            return;
        }
        this.autoScrollService.check(draggingEvent.event);
        this.clearHoveredItems();
        this.lastHoveredItem = { comp, position };
        const eGui = comp.getGui();
        eGui.classList.add('ag-list-item-hovered', `ag-item-highlight-${position}`);
    }
    checkHoveredItem(draggingEvent) {
        if (_.missing(draggingEvent.vDirection)) {
            return null;
        }
        const mouseEvent = draggingEvent.event;
        for (const comp of this.columnComps.values()) {
            const eGui = comp.getGui();
            if (!eGui.querySelector('.ag-chart-data-column-drag-handle')) {
                continue;
            }
            const rect = eGui.getBoundingClientRect();
            const isOverComp = mouseEvent.clientY >= rect.top && mouseEvent.clientY <= rect.bottom;
            if (isOverComp) {
                const height = eGui.clientHeight;
                const position = mouseEvent.clientY > rect.top + (height / 2) ? 'bottom' : 'top';
                return { comp, position };
            }
        }
        return null;
    }
    onDragLeave() {
        this.clearHoveredItems();
    }
    onDragStop() {
        if (this.lastHoveredItem) {
            const { dimensionCols, valueCols } = this.chartController.getColStateForMenu();
            const draggedColumnState = [...dimensionCols, ...valueCols]
                .find(state => state.column === this.lastDraggedColumn);
            if (draggedColumnState) {
                let targetIndex = Array.from(this.columnComps.values()).indexOf(this.lastHoveredItem.comp);
                if (this.lastHoveredItem.position === 'bottom') {
                    targetIndex++;
                }
                draggedColumnState.order = targetIndex;
                this.chartController.updateForPanelChange(draggedColumnState);
            }
        }
        this.clearHoveredItems();
        this.lastDraggedColumn = undefined;
        this.autoScrollService.ensureCleared();
    }
    clearHoveredItems() {
        this.columnComps.forEach(columnComp => {
            columnComp.getGui().classList.remove('ag-list-item-hovered', 'ag-item-highlight-top', 'ag-item-highlight-bottom');
        });
        this.lastHoveredItem = undefined;
    }
    isInterestedIn(type) {
        return type === DragSourceType.ChartPanel;
    }
}
ChartDataPanel.TEMPLATE = `<div class="ag-chart-data-wrapper ag-scrollable-container"></div>`;
__decorate$g([
    Autowired('dragAndDropService')
], ChartDataPanel.prototype, "dragAndDropService", void 0);
__decorate$g([
    Autowired('chartTranslationService')
], ChartDataPanel.prototype, "chartTranslationService", void 0);
__decorate$g([
    PostConstruct
], ChartDataPanel.prototype, "init", null);

var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class FontPanel extends Component {
    constructor(params) {
        super();
        this.activeComps = [];
        this.params = params;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true
        };
        this.setTemplate(FontPanel.TEMPLATE, { fontGroup: groupParams });
        this.initGroup();
        this.initFontFamilySelect();
        this.initFontWeightStyleSelect();
        this.initFontSizeSelect();
        this.initFontColorPicker();
    }
    addCompToPanel(comp) {
        this.fontGroup.addItem(comp);
        this.activeComps.push(comp);
    }
    setEnabled(enabled) {
        this.fontGroup.setEnabled(enabled);
    }
    initGroup() {
        this.fontGroup
            .setTitle(this.params.name || this.chartTranslationService.translate('font'))
            .setEnabled(this.params.enabled)
            .hideEnabledCheckbox(!!this.params.suppressEnabledCheckbox)
            .hideOpenCloseIcons(true)
            .onEnableChange(enabled => {
            if (this.params.setEnabled) {
                this.params.setEnabled(enabled);
            }
        });
    }
    initFontFamilySelect() {
        const families = [
            'Arial, sans-serif',
            'Aria Black, sans-serif',
            'Book Antiqua,  serif',
            'Charcoal, sans-serif',
            'Comic Sans MS, cursive',
            'Courier, monospace',
            'Courier New, monospace',
            'Gadget, sans-serif',
            'Geneva, sans-serif',
            'Helvetica, sans-serif',
            'Impact, sans-serif',
            'Lucida Console, monospace',
            'Lucida Grande, sans-serif',
            'Lucida Sans Unicode,  sans-serif',
            'Monaco, monospace',
            'Palatino Linotype, serif',
            'Palatino, serif',
            'Times New Roman, serif',
            'Times, serif',
            'Verdana, sans-serif'
        ];
        const { family } = this.params.initialFont;
        let initialValue = families[0];
        if (family) {
            // check for known values using lowercase
            const lowerCaseValues = families.map(f => f.toLowerCase());
            const valueIndex = lowerCaseValues.indexOf(family.toLowerCase());
            if (valueIndex >= 0) {
                initialValue = families[valueIndex];
            }
            else {
                // add user provided value to list
                const capitalisedFontValue = _.capitalise(family);
                families.push(capitalisedFontValue);
                initialValue = capitalisedFontValue;
            }
        }
        const options = families.sort().map(value => ({ value, text: value }));
        this.familySelect.addOptions(options)
            .setInputWidth('flex')
            .setValue(`${initialValue}`)
            .onValueChange(newValue => this.params.setFont({ family: newValue }));
    }
    initFontSizeSelect() {
        const sizes = [8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36];
        const { size } = this.params.initialFont;
        if (!_.includes(sizes, size)) {
            sizes.push(size);
        }
        const options = sizes.sort((a, b) => a - b).map(value => ({ value: `${value}`, text: `${value}` }));
        this.sizeSelect.addOptions(options)
            .setInputWidth('flex')
            .setValue(`${size}`)
            .onValueChange(newValue => this.params.setFont({ size: parseInt(newValue, 10) }));
        this.sizeSelect.setLabel(this.chartTranslationService.translate('size'));
    }
    initFontWeightStyleSelect() {
        const { weight = 'normal', style = 'normal' } = this.params.initialFont;
        const weightStyles = [
            { name: 'normal', weight: 'normal', style: 'normal' },
            { name: 'bold', weight: 'bold', style: 'normal' },
            { name: 'italic', weight: 'normal', style: 'italic' },
            { name: 'boldItalic', weight: 'bold', style: 'italic' }
        ];
        let selectedOption = weightStyles.find(x => x.weight === weight && x.style === style);
        if (!selectedOption) {
            selectedOption = { name: 'predefined', weight, style };
            weightStyles.unshift(selectedOption);
        }
        const options = weightStyles.map(ws => ({
            value: ws.name,
            text: this.chartTranslationService.translate(ws.name),
        }));
        this.weightStyleSelect.addOptions(options)
            .setInputWidth('flex')
            .setValue(selectedOption.name)
            .onValueChange(newValue => {
            const selectedWeightStyle = weightStyles.find(x => x.name === newValue);
            this.params.setFont({ weight: selectedWeightStyle.weight, style: selectedWeightStyle.style });
        });
    }
    initFontColorPicker() {
        this.colorPicker
            .setLabel(this.chartTranslationService.translate('color'))
            .setInputWidth('flex')
            .setValue(`${this.params.initialFont.color}`)
            .onValueChange(newColor => this.params.setFont({ color: newColor }));
    }
    addItemToPanel(item) {
        this.fontGroup.addItem(item);
        this.activeComps.push(item);
    }
    destroyActiveComps() {
        this.activeComps.forEach(comp => {
            _.removeFromParent(comp.getGui());
            this.destroyBean(comp);
        });
    }
    destroy() {
        this.destroyActiveComps();
        super.destroy();
    }
}
FontPanel.TEMPLATE = `<div class="ag-font-panel">
            <ag-group-component ref="fontGroup">
                <ag-select ref="familySelect"></ag-select>
                <ag-select ref="weightStyleSelect"></ag-select>
                <div class="ag-charts-font-size-color">
                    <ag-select ref="sizeSelect"></ag-select>
                    <ag-color-picker ref="colorPicker"></ag-color-picker>
                </div>
            </ag-group-component>
        </div>`;
__decorate$h([
    RefSelector('fontGroup')
], FontPanel.prototype, "fontGroup", void 0);
__decorate$h([
    RefSelector('familySelect')
], FontPanel.prototype, "familySelect", void 0);
__decorate$h([
    RefSelector('weightStyleSelect')
], FontPanel.prototype, "weightStyleSelect", void 0);
__decorate$h([
    RefSelector('sizeSelect')
], FontPanel.prototype, "sizeSelect", void 0);
__decorate$h([
    RefSelector('colorPicker')
], FontPanel.prototype, "colorPicker", void 0);
__decorate$h([
    Autowired('chartTranslationService')
], FontPanel.prototype, "chartTranslationService", void 0);
__decorate$h([
    PostConstruct
], FontPanel.prototype, "init", null);

var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class LegendPanel extends Component {
    constructor({ chartOptionsService, isExpandedOnInit = false }) {
        super();
        this.activePanels = [];
        this.chartOptionsService = chartOptionsService;
        this.isExpandedOnInit = isExpandedOnInit;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical'
        };
        this.setTemplate(LegendPanel.TEMPLATE, { legendGroup: groupParams });
        this.initLegendGroup();
        this.initLegendPosition();
        this.initLegendPadding();
        this.initLegendItems();
        this.initLabelPanel();
    }
    initLegendGroup() {
        this.legendGroup
            .setTitle(this.chartTranslationService.translate("legend"))
            .hideEnabledCheckbox(false)
            .setEnabled(this.chartOptionsService.getChartOption("legend.enabled") || false)
            .toggleGroupExpand(this.isExpandedOnInit)
            .onEnableChange(enabled => {
            this.chartOptionsService.setChartOption("legend.enabled", enabled);
            this.legendGroup.toggleGroupExpand(true);
        });
    }
    initLegendPosition() {
        const positions = ['top', 'right', 'bottom', 'left'];
        this.legendPositionSelect
            .setLabel(this.chartTranslationService.translate("position"))
            .setLabelWidth("flex")
            .setInputWidth('flex')
            .addOptions(positions.map(position => ({
            value: position,
            text: this.chartTranslationService.translate(position)
        })))
            .setValue(this.chartOptionsService.getChartOption("legend.position"))
            .onValueChange(newValue => this.chartOptionsService.setChartOption("legend.position", newValue));
    }
    initLegendPadding() {
        const currentValue = this.chartOptionsService.getChartOption("legend.spacing");
        this.legendPaddingSlider
            .setLabel(this.chartTranslationService.translate("spacing"))
            .setMaxValue(getMaxValue(currentValue, 200))
            .setValue(`${currentValue}`)
            .setTextFieldWidth(45)
            .onValueChange(newValue => this.chartOptionsService.setChartOption("legend.spacing", newValue));
    }
    initLegendItems() {
        const initSlider = (expression, labelKey, input, defaultMaxValue) => {
            var _a;
            const currentValue = (_a = this.chartOptionsService.getChartOption(`legend.${expression}`)) !== null && _a !== void 0 ? _a : 0;
            input.setLabel(this.chartTranslationService.translate(labelKey))
                .setMaxValue(getMaxValue(currentValue, defaultMaxValue))
                .setValue(`${currentValue}`)
                .setTextFieldWidth(45)
                .onValueChange(newValue => {
                this.chartOptionsService.setChartOption(`legend.${expression}`, newValue);
            });
        };
        initSlider("item.marker.size", "markerSize", this.markerSizeSlider, 40);
        initSlider("item.marker.strokeWidth", "markerStroke", this.markerStrokeSlider, 10);
        initSlider("item.marker.padding", "itemSpacing", this.markerPaddingSlider, 20);
        initSlider("item.paddingX", "layoutHorizontalSpacing", this.itemPaddingXSlider, 50);
        initSlider("item.paddingY", "layoutVerticalSpacing", this.itemPaddingYSlider, 50);
    }
    initLabelPanel() {
        const chartProxy = this.chartOptionsService;
        const initialFont = {
            family: chartProxy.getChartOption("legend.item.label.fontFamily"),
            style: chartProxy.getChartOption("legend.item.label.fontStyle"),
            weight: chartProxy.getChartOption("legend.item.label.fontWeight"),
            size: chartProxy.getChartOption("legend.item.label.fontSize"),
            color: chartProxy.getChartOption("legend.item.label.color")
        };
        const setFont = (font) => {
            const proxy = this.chartOptionsService;
            if (font.family) {
                proxy.setChartOption("legend.item.label.fontFamily", font.family);
            }
            if (font.weight) {
                proxy.setChartOption("legend.item.label.fontWeight", font.weight);
            }
            if (font.style) {
                proxy.setChartOption("legend.item.label.fontStyle", font.style);
            }
            if (font.size) {
                proxy.setChartOption("legend.item.label.fontSize", font.size);
            }
            if (font.color) {
                proxy.setChartOption("legend.item.label.color", font.color);
            }
        };
        const params = {
            enabled: true,
            suppressEnabledCheckbox: true,
            initialFont: initialFont,
            setFont: setFont
        };
        const fontPanelComp = this.createBean(new FontPanel(params));
        this.legendGroup.addItem(fontPanelComp);
        this.activePanels.push(fontPanelComp);
    }
    destroyActivePanels() {
        this.activePanels.forEach(panel => {
            _.removeFromParent(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
LegendPanel.TEMPLATE = `<div>
            <ag-group-component ref="legendGroup">
                <ag-select ref="legendPositionSelect"></ag-select>
                <ag-slider ref="legendPaddingSlider"></ag-slider>
                <ag-slider ref="markerSizeSlider"></ag-slider>
                <ag-slider ref="markerStrokeSlider"></ag-slider>
                <ag-slider ref="markerPaddingSlider"></ag-slider>
                <ag-slider ref="itemPaddingXSlider"></ag-slider>
                <ag-slider ref="itemPaddingYSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$i([
    RefSelector('legendGroup')
], LegendPanel.prototype, "legendGroup", void 0);
__decorate$i([
    RefSelector('legendPositionSelect')
], LegendPanel.prototype, "legendPositionSelect", void 0);
__decorate$i([
    RefSelector('legendPaddingSlider')
], LegendPanel.prototype, "legendPaddingSlider", void 0);
__decorate$i([
    RefSelector('markerSizeSlider')
], LegendPanel.prototype, "markerSizeSlider", void 0);
__decorate$i([
    RefSelector('markerStrokeSlider')
], LegendPanel.prototype, "markerStrokeSlider", void 0);
__decorate$i([
    RefSelector('markerPaddingSlider')
], LegendPanel.prototype, "markerPaddingSlider", void 0);
__decorate$i([
    RefSelector('itemPaddingXSlider')
], LegendPanel.prototype, "itemPaddingXSlider", void 0);
__decorate$i([
    RefSelector('itemPaddingYSlider')
], LegendPanel.prototype, "itemPaddingYSlider", void 0);
__decorate$i([
    Autowired('chartTranslationService')
], LegendPanel.prototype, "chartTranslationService", void 0);
__decorate$i([
    PostConstruct
], LegendPanel.prototype, "init", null);

var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AxisTicksPanel extends Component {
    constructor(chartOptionsService) {
        super();
        this.chartOptionsService = chartOptionsService;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true
        };
        this.setTemplate(AxisTicksPanel.TEMPLATE, { axisTicksGroup: groupParams });
        this.initAxisTicks();
    }
    initAxisTicks() {
        this.axisTicksGroup
            .setTitle(this.chartTranslationService.translate("ticks"))
            .setEnabled(this.chartOptionsService.getAxisProperty("tick.enabled"))
            .hideOpenCloseIcons(true)
            .hideEnabledCheckbox(false)
            .onEnableChange(newValue => this.chartOptionsService.setAxisProperty("tick.enabled", newValue));
        this.axisTicksColorPicker
            .setLabel(this.chartTranslationService.translate("color"))
            .setLabelWidth("flex")
            .setInputWidth('flex')
            .setValue(this.chartOptionsService.getAxisProperty("tick.color"))
            .onValueChange(newColor => this.chartOptionsService.setAxisProperty("tick.color", newColor));
        const initInput = (expression, input, label, defaultMaxValue) => {
            const currentValue = this.chartOptionsService.getAxisProperty(expression);
            input.setLabel(label)
                .setMaxValue(getMaxValue(currentValue, defaultMaxValue))
                .setValue(`${currentValue}`)
                .setTextFieldWidth(45)
                .onValueChange(newValue => this.chartOptionsService.setAxisProperty(expression, newValue));
        };
        initInput("tick.width", this.axisTicksWidthSlider, this.chartTranslationService.translate("width"), 10);
        initInput("tick.size", this.axisTicksSizeSlider, this.chartTranslationService.translate("length"), 30);
    }
}
AxisTicksPanel.TEMPLATE = `<div>
            <ag-group-component ref="axisTicksGroup">
                <ag-color-picker ref="axisTicksColorPicker"></ag-color-picker>
                <ag-slider ref="axisTicksWidthSlider"></ag-slider>
                <ag-slider ref="axisTicksSizeSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$j([
    RefSelector('axisTicksGroup')
], AxisTicksPanel.prototype, "axisTicksGroup", void 0);
__decorate$j([
    RefSelector('axisTicksColorPicker')
], AxisTicksPanel.prototype, "axisTicksColorPicker", void 0);
__decorate$j([
    RefSelector('axisTicksWidthSlider')
], AxisTicksPanel.prototype, "axisTicksWidthSlider", void 0);
__decorate$j([
    RefSelector('axisTicksSizeSlider')
], AxisTicksPanel.prototype, "axisTicksSizeSlider", void 0);
__decorate$j([
    Autowired('chartTranslationService')
], AxisTicksPanel.prototype, "chartTranslationService", void 0);
__decorate$j([
    PostConstruct
], AxisTicksPanel.prototype, "init", null);

var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AgAngleSelect extends AgAbstractLabel {
    constructor(config) {
        super(config, AgAngleSelect.TEMPLATE);
        this.radius = 0;
        this.offsetX = 0;
        this.offsetY = 0;
    }
    postConstruct() {
        super.postConstruct();
        this.dragListener = {
            eElement: this.eParentCircle,
            dragStartPixels: 0,
            onDragStart: (e) => {
                this.parentCircleRect = this.eParentCircle.getBoundingClientRect();
            },
            onDragging: (e) => this.calculateAngleDrag(e),
            onDragStop: () => { }
        };
        this.dragService.addDragSource(this.dragListener);
        this.eAngleValue
            .setLabel('')
            .setLabelWidth(5)
            .setInputWidth(45)
            .setMin(0)
            .setMax(360)
            .setValue(`${this.degrees}`)
            .onValueChange((value) => {
            if (value == null || value === '') {
                value = '0';
            }
            value = this.eAngleValue.normalizeValue(value);
            let floatValue = parseFloat(value);
            if (floatValue > 180) {
                floatValue = floatValue - 360;
            }
            this.setValue(floatValue);
        });
        this.updateNumberInput();
        if (_.exists(this.getValue())) {
            this.eAngleValue.setValue(this.normalizeNegativeValue(this.getValue()).toString());
        }
        this.addManagedListener(this, Events.EVENT_FIELD_VALUE_CHANGED, () => {
            const eDocument = this.gridOptionsService.getDocument();
            if (this.eAngleValue.getInputElement().contains(eDocument.activeElement)) {
                return;
            }
            this.updateNumberInput();
        });
    }
    updateNumberInput() {
        const normalizedValue = this.normalizeNegativeValue(this.getValue());
        this.eAngleValue.setValue(normalizedValue.toString());
    }
    positionChildCircle(radians) {
        const rect = this.parentCircleRect || { width: 24, height: 24 };
        const eChildCircle = this.eChildCircle;
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        eChildCircle.style.left = `${centerX + Math.cos(radians) * 8}px`;
        eChildCircle.style.top = `${centerY + Math.sin(radians) * 8}px`;
    }
    calculatePolar() {
        const x = this.offsetX;
        const y = this.offsetY;
        const radians = Math.atan2(y, x);
        this.degrees = this.toDegrees(radians);
        this.radius = Math.sqrt((x * x) + (y * y));
        this.positionChildCircle(radians);
    }
    calculateCartesian() {
        const radians = this.toRadians(this.getValue());
        const radius = this.getRadius();
        this
            .setOffsetX(Math.cos(radians) * radius)
            .setOffsetY(Math.sin(radians) * radius);
    }
    setOffsetX(offset) {
        if (this.offsetX !== offset) {
            this.offsetX = offset;
            this.calculatePolar();
        }
        return this;
    }
    setOffsetY(offset) {
        if (this.offsetY !== offset) {
            this.offsetY = offset;
            this.calculatePolar();
        }
        return this;
    }
    calculateAngleDrag(e) {
        const rect = this.parentCircleRect;
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const dx = x - centerX;
        const dy = y - centerY;
        const radians = Math.atan2(dy, dx);
        this.setValue(radians, true);
    }
    toDegrees(radians) {
        return radians / Math.PI * 180;
    }
    toRadians(degrees) {
        return degrees / 180 * Math.PI;
    }
    normalizeNegativeValue(degrees) {
        return degrees < 0 ? 360 + degrees : degrees;
    }
    normalizeAngle180(radians) {
        radians %= Math.PI * 2;
        if (radians < -Math.PI) {
            radians += Math.PI * 2;
        }
        else if (radians >= Math.PI) {
            radians -= Math.PI * 2;
        }
        return radians;
    }
    getRadius() {
        return this.radius;
    }
    setRadius(r) {
        if (this.radius === r) {
            return this;
        }
        this.radius = r;
        this.calculateCartesian();
        return this;
    }
    onValueChange(callbackFn) {
        this.addManagedListener(this, Events.EVENT_FIELD_VALUE_CHANGED, () => {
            callbackFn(this.degrees);
        });
        return this;
    }
    getValue(radians) {
        return radians ? this.toRadians(this.degrees) : this.degrees;
    }
    setValue(degrees, radians) {
        let radiansValue;
        if (!radians) {
            radiansValue = this.normalizeAngle180(this.toRadians(degrees));
        }
        else {
            radiansValue = degrees;
        }
        degrees = this.toDegrees(radiansValue);
        if (this.degrees !== degrees) {
            this.degrees = Math.floor(degrees);
            this.calculateCartesian();
            this.positionChildCircle(radiansValue);
            this.dispatchEvent({ type: Events.EVENT_FIELD_VALUE_CHANGED });
        }
        return this;
    }
    setWidth(width) {
        _.setFixedWidth(this.getGui(), width);
        return this;
    }
    setDisabled(disabled) {
        super.setDisabled(disabled);
        this.eAngleValue.setDisabled(disabled);
        return this;
    }
    destroy() {
        this.dragService.removeDragSource(this.dragListener);
        super.destroy();
    }
}
AgAngleSelect.TEMPLATE = `<div class="ag-angle-select">
            <div ref="eLabel"></div>
            <div class="ag-wrapper ag-angle-select-wrapper">
                <div ref="eAngleSelectField" class="ag-angle-select-field">
                    <div ref="eParentCircle" class="ag-angle-select-parent-circle">
                        <div ref="eChildCircle" class="ag-angle-select-child-circle"></div>
                    </div>
                </div>
                <ag-input-number-field ref="eAngleValue"></ag-input-number-field>
            </div>
        </div>`;
__decorate$k([
    RefSelector('eLabel')
], AgAngleSelect.prototype, "eLabel", void 0);
__decorate$k([
    RefSelector('eParentCircle')
], AgAngleSelect.prototype, "eParentCircle", void 0);
__decorate$k([
    RefSelector('eChildCircle')
], AgAngleSelect.prototype, "eChildCircle", void 0);
__decorate$k([
    RefSelector('eAngleValue')
], AgAngleSelect.prototype, "eAngleValue", void 0);
__decorate$k([
    Autowired('dragService')
], AgAngleSelect.prototype, "dragService", void 0);

var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class CartesianAxisPanel extends Component {
    constructor({ chartController, chartOptionsService, isExpandedOnInit = false }) {
        super();
        this.activePanels = [];
        this.axisLabelUpdateFuncs = [];
        this.prevXRotation = 0;
        this.prevYRotation = 0;
        this.chartController = chartController;
        this.chartOptionsService = chartOptionsService;
        this.isExpandedOnInit = isExpandedOnInit;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical'
        };
        this.setTemplate(CartesianAxisPanel.TEMPLATE, { axisGroup: groupParams });
        this.initAxis();
        this.initAxisTicks();
        this.initAxisLabels();
        const updateAxisLabelRotations = () => this.axisLabelUpdateFuncs.forEach(func => func());
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_UPDATED, updateAxisLabelRotations);
    }
    initAxis() {
        this.axisGroup
            .setTitle(this.translate("axis"))
            .toggleGroupExpand(this.isExpandedOnInit)
            .hideEnabledCheckbox(true);
        // Note that there is no separate checkbox for enabling/disabling the axis line. Whenever the line settings are
        // changed, the value for `line.enabled` is inferred based on the current `line.width` value.
        this.axisColorInput
            .setLabel(this.translate("color"))
            .setLabelWidth("flex")
            .setInputWidth("flex")
            .setValue(this.chartOptionsService.getAxisProperty("line.color"))
            .onValueChange(newColor => {
            const isLineEnabled = this.chartOptionsService.getAxisProperty("line.width") > 0;
            this.chartOptionsService.setAxisProperties([
                { expression: "line.enabled", value: isLineEnabled },
                { expression: "line.color", value: newColor },
            ]);
        });
        const currentValue = this.chartOptionsService.getAxisProperty("line.width");
        this.axisLineWidthSlider
            .setMaxValue(getMaxValue(currentValue, 10))
            .setLabel(this.translate("thickness"))
            .setTextFieldWidth(45)
            .setValue(`${currentValue}`)
            .onValueChange(newValue => this.chartOptionsService.setAxisProperties([
            { expression: "line.enabled", value: (newValue !== 0) },
            { expression: "line.width", value: newValue },
        ]));
    }
    initAxisTicks() {
        if (!this.hasConfigurableAxisTicks())
            return;
        const axisTicksComp = this.createBean(new AxisTicksPanel(this.chartOptionsService));
        this.axisGroup.addItem(axisTicksComp);
        this.activePanels.push(axisTicksComp);
    }
    hasConfigurableAxisTicks() {
        // Axis ticks are disabled for some chart types
        const chartType = this.chartController.getChartType();
        switch (chartType) {
            case 'radarLine':
            case 'radarArea':
            case 'rangeBar':
            case 'boxPlot':
            case 'waterfall':
                return false;
            default:
                return true;
        }
    }
    initAxisLabels() {
        const initialFont = {
            family: this.chartOptionsService.getAxisProperty("label.fontFamily"),
            style: this.chartOptionsService.getAxisProperty("label.fontStyle"),
            weight: this.chartOptionsService.getAxisProperty("label.fontWeight"),
            size: this.chartOptionsService.getAxisProperty("label.fontSize"),
            color: this.chartOptionsService.getAxisProperty("label.color")
        };
        const setFont = (font) => {
            if (font.family) {
                this.chartOptionsService.setAxisProperty("label.fontFamily", font.family);
            }
            if (font.weight) {
                this.chartOptionsService.setAxisProperty("label.fontWeight", font.weight);
            }
            if (font.style) {
                this.chartOptionsService.setAxisProperty("label.fontStyle", font.style);
            }
            if (font.size) {
                this.chartOptionsService.setAxisProperty("label.fontSize", font.size);
            }
            if (font.color) {
                this.chartOptionsService.setAxisProperty("label.color", font.color);
            }
        };
        const params = {
            name: this.translate("labels"),
            enabled: true,
            suppressEnabledCheckbox: true,
            initialFont,
            setFont
        };
        const labelPanelComp = this.createBean(new FontPanel(params));
        this.axisGroup.addItem(labelPanelComp);
        this.activePanels.push(labelPanelComp);
        this.addAdditionalLabelComps(labelPanelComp);
    }
    addAdditionalLabelComps(labelPanelComp) {
        this.addLabelPadding(labelPanelComp);
        const { xRotationComp, yRotationComp } = this.createRotationWidgets();
        const autoRotateCb = this.initLabelRotations(xRotationComp, yRotationComp);
        labelPanelComp.addCompToPanel(autoRotateCb);
        labelPanelComp.addCompToPanel(xRotationComp);
        labelPanelComp.addCompToPanel(yRotationComp);
    }
    initLabelRotations(xRotationComp, yRotationComp) {
        const getLabelRotation = (axisType) => {
            return this.chartOptionsService.getLabelRotation(axisType);
        };
        const setLabelRotation = (axisType, value) => {
            this.chartOptionsService.setLabelRotation(axisType, value);
        };
        const updateAutoRotate = (autoRotate) => {
            this.chartOptionsService.setAxisProperty("label.autoRotate", autoRotate);
            if (autoRotate) {
                // store prev rotations before we remove them from the options
                this.prevXRotation = getLabelRotation("xAxis");
                this.prevYRotation = getLabelRotation("yAxis");
                // `autoRotate` is only
                setLabelRotation("xAxis", undefined);
                setLabelRotation("yAxis", undefined);
            }
            else {
                // reinstate prev rotations
                setLabelRotation("xAxis", this.prevXRotation);
                setLabelRotation("yAxis", this.prevYRotation);
            }
            xRotationComp.setDisabled(autoRotate);
            yRotationComp.setDisabled(autoRotate);
        };
        const getAutoRotateValue = () => {
            const xRotation = getLabelRotation("xAxis");
            const yRotation = getLabelRotation("yAxis");
            if (xRotation == undefined && yRotation == undefined) {
                return this.chartOptionsService.getAxisProperty("label.autoRotate");
            }
            return false;
        };
        const autoRotate = getAutoRotateValue();
        const autoRotateCheckbox = this.createBean(new AgCheckbox())
            .setLabel(this.translate('autoRotate'))
            .setValue(autoRotate)
            .onValueChange(updateAutoRotate);
        // init rotation comp state
        xRotationComp.setDisabled(autoRotate);
        yRotationComp.setDisabled(autoRotate);
        return autoRotateCheckbox;
    }
    createRotationWidgets() {
        const degreesSymbol = String.fromCharCode(176);
        const createRotationComp = (labelKey, axisType) => {
            const label = `${this.chartTranslationService.translate(labelKey)} ${degreesSymbol}`;
            const value = this.chartOptionsService.getLabelRotation(axisType);
            const angleSelect = new AgAngleSelect()
                .setLabel(label)
                .setLabelWidth("flex")
                .setValue(value || 0)
                .onValueChange(newValue => this.chartOptionsService.setLabelRotation(axisType, newValue));
            // the axis label rotation needs to be updated when the default category changes in the data panel
            this.axisLabelUpdateFuncs.push(() => {
                const value = this.chartOptionsService.getLabelRotation(axisType);
                angleSelect.setValue(value || 0);
            });
            return this.createBean(angleSelect);
        };
        return {
            xRotationComp: createRotationComp("xRotation", "xAxis"),
            yRotationComp: createRotationComp("yRotation", "yAxis")
        };
    }
    addLabelPadding(labelPanelComp) {
        const labelPaddingSlider = this.createBean(new AgSlider());
        const currentValue = this.chartOptionsService.getAxisProperty("label.padding");
        labelPaddingSlider.setLabel(this.chartTranslationService.translate("padding"))
            .setMaxValue(getMaxValue(currentValue, 30))
            .setValue(`${currentValue}`)
            .setTextFieldWidth(45)
            .onValueChange(newValue => this.chartOptionsService.setAxisProperty("label.padding", newValue));
        labelPanelComp.addCompToPanel(labelPaddingSlider);
    }
    translate(key, defaultText) {
        return this.chartTranslationService.translate(key, defaultText);
    }
    destroyActivePanels() {
        this.activePanels.forEach(panel => {
            _.removeFromParent(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
CartesianAxisPanel.TEMPLATE = `<div>
            <ag-group-component ref="axisGroup">
                <ag-color-picker ref="axisColorInput"></ag-color-picker>
                <ag-slider ref="axisLineWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$l([
    RefSelector('axisGroup')
], CartesianAxisPanel.prototype, "axisGroup", void 0);
__decorate$l([
    RefSelector('axisColorInput')
], CartesianAxisPanel.prototype, "axisColorInput", void 0);
__decorate$l([
    RefSelector('axisLineWidthSlider')
], CartesianAxisPanel.prototype, "axisLineWidthSlider", void 0);
__decorate$l([
    Autowired('chartTranslationService')
], CartesianAxisPanel.prototype, "chartTranslationService", void 0);
__decorate$l([
    PostConstruct
], CartesianAxisPanel.prototype, "init", null);

var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class PolarAxisPanel extends Component {
    constructor({ chartController, chartOptionsService, isExpandedOnInit = false }) {
        super();
        this.dynamicComponents = [];
        this.chartController = chartController;
        this.chartOptionsService = chartOptionsService;
        this.isExpandedOnInit = isExpandedOnInit;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical',
        };
        this.setTemplate(PolarAxisPanel.TEMPLATE, { axisGroup: groupParams });
        this.initAxis();
        this.initAxisLabels();
        this.initRadiusAxis();
    }
    initAxis() {
        this.axisGroup
            .setTitle(this.translate('axis'))
            .toggleGroupExpand(this.isExpandedOnInit)
            .hideEnabledCheckbox(true);
        this.axisColorInput
            .setLabel(this.translate('color'))
            .setLabelWidth('flex')
            .setInputWidth('flex')
            .setValue(this.chartOptionsService.getAxisProperty('line.color'))
            .onValueChange((newColor) => this.chartOptionsService.setAxisProperty('line.color', newColor));
        const currentValue = this.chartOptionsService.getAxisProperty('line.width');
        this.axisLineWidthSlider
            .setMaxValue(getMaxValue(currentValue, 10))
            .setLabel(this.translate('thickness'))
            .setTextFieldWidth(45)
            .setValue(`${currentValue}`)
            .onValueChange((newValue) => this.chartOptionsService.setAxisProperty('line.width', newValue));
        const chartType = this.chartController.getChartType();
        const hasConfigurableAxisShape = ['radarLine', 'radarArea'].includes(chartType);
        if (hasConfigurableAxisShape) {
            const options = [
                { value: 'circle', text: this.translate('circle') },
                { value: 'polygon', text: this.translate('polygon') },
            ];
            this.axisGroup.addItem(this.initSelect({
                label: 'shape',
                options: options,
                currentValue: this.chartOptionsService.getAxisProperty('shape'),
                onValueChange: newValue => this.chartOptionsService.setAxisProperty('shape', newValue)
            }));
        }
        if (isPolar(chartType)) {
            const currentValue = this.chartOptionsService.getAxisProperty('innerRadiusRatio');
            this.axisGroup.addItem(this.initSlider({
                label: 'innerRadius',
                maxValue: 1,
                currentValue: currentValue !== null && currentValue !== void 0 ? currentValue : 0,
                onValueChange: newValue => this.chartOptionsService.setAxisProperty('innerRadiusRatio', newValue)
            }));
        }
    }
    initAxisLabels() {
        const initialFont = {
            family: this.chartOptionsService.getAxisProperty('label.fontFamily'),
            style: this.chartOptionsService.getAxisProperty('label.fontStyle'),
            weight: this.chartOptionsService.getAxisProperty('label.fontWeight'),
            size: this.chartOptionsService.getAxisProperty('label.fontSize'),
            color: this.chartOptionsService.getAxisProperty('label.color'),
        };
        const setFont = (font) => {
            if (font.family) {
                this.chartOptionsService.setAxisProperty('label.fontFamily', font.family);
            }
            if (font.weight) {
                this.chartOptionsService.setAxisProperty('label.fontWeight', font.weight);
            }
            if (font.style) {
                this.chartOptionsService.setAxisProperty('label.fontStyle', font.style);
            }
            if (font.size) {
                this.chartOptionsService.setAxisProperty('label.fontSize', font.size);
            }
            if (font.color) {
                this.chartOptionsService.setAxisProperty('label.color', font.color);
            }
        };
        const params = {
            name: this.translate('labels'),
            enabled: true,
            suppressEnabledCheckbox: true,
            initialFont,
            setFont,
        };
        const labelPanelComp = this.createBean(new FontPanel(params));
        const labelOrientationComp = this.createOrientationWidget();
        labelPanelComp.addItemToPanel(labelOrientationComp);
        this.axisGroup.addItem(labelPanelComp);
        this.dynamicComponents.push(labelPanelComp);
    }
    createOrientationWidget() {
        const options = [
            { value: 'fixed', text: this.translate('fixed') },
            { value: 'parallel', text: this.translate('parallel') },
            { value: 'perpendicular', text: this.translate('perpendicular') },
        ];
        return this.initSelect({
            label: 'orientation',
            options: options,
            currentValue: this.chartOptionsService.getAxisProperty('label.orientation'),
            onValueChange: newValue => this.chartOptionsService.setAxisProperty('label.orientation', newValue),
        });
    }
    initRadiusAxis() {
        var _a, _b;
        const chartType = this.chartController.getChartType();
        if (!isRadial(chartType))
            return;
        const paddingPanelComp = this.createBean(new AgGroupComponent({
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true,
            enabled: true,
            suppressEnabledCheckbox: true,
            title: this.translate('padding'),
        })).hideEnabledCheckbox(true).hideOpenCloseIcons(true);
        paddingPanelComp.addItem(this.initSlider({
            label: 'groupPadding',
            maxValue: 1,
            currentValue: (_a = this.chartOptionsService.getAxisProperty('paddingInner')) !== null && _a !== void 0 ? _a : 0,
            onValueChange: newValue => this.chartOptionsService.setAxisProperty('paddingInner', newValue)
        }));
        paddingPanelComp.addItem(this.initSlider({
            label: 'seriesPadding',
            maxValue: 1,
            currentValue: (_b = this.chartOptionsService.getAxisProperty('groupPaddingInner')) !== null && _b !== void 0 ? _b : 0,
            onValueChange: newValue => this.chartOptionsService.setAxisProperty('groupPaddingInner', newValue)
        }));
        this.axisGroup.addItem(paddingPanelComp);
        this.dynamicComponents.push(paddingPanelComp);
    }
    initSlider(config) {
        const { label, maxValue, minValue = 0, step = 0.05, currentValue, onValueChange } = config;
        const slider = this.createManagedBean(new AgSlider());
        slider
            .setLabel(this.translate(label))
            .setLabelWidth('flex')
            .setMinValue(minValue)
            .setMaxValue(maxValue)
            .setStep(step)
            .setValue(`${currentValue}`)
            .onValueChange(onValueChange);
        this.dynamicComponents.push(slider);
        return slider;
    }
    initSelect(config) {
        const { label, options, currentValue, onValueChange } = config;
        const select = this.createManagedBean(new AgSelect());
        select
            .setLabel(this.translate(label))
            .setLabelAlignment('left')
            .setLabelWidth('flex')
            .setInputWidth('flex')
            .addOptions(options);
        if (currentValue !== undefined) {
            select.setValue(currentValue);
        }
        select.onValueChange(onValueChange);
        this.dynamicComponents.push(select);
        return select;
    }
    translate(key, defaultText) {
        return this.chartTranslationService.translate(key, defaultText);
    }
    destroyDynamicComponents() {
        this.dynamicComponents.forEach(component => {
            _.removeFromParent(component.getGui());
            this.destroyBean(component);
        });
        this.dynamicComponents = [];
    }
    destroy() {
        this.destroyDynamicComponents();
        super.destroy();
    }
}
PolarAxisPanel.TEMPLATE = `<div>
            <ag-group-component ref="axisGroup">
                <ag-color-picker ref="axisColorInput"></ag-color-picker>
                <ag-slider ref="axisLineWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$m([
    RefSelector('axisGroup')
], PolarAxisPanel.prototype, "axisGroup", void 0);
__decorate$m([
    RefSelector('axisColorInput')
], PolarAxisPanel.prototype, "axisColorInput", void 0);
__decorate$m([
    RefSelector('axisLineWidthSlider')
], PolarAxisPanel.prototype, "axisLineWidthSlider", void 0);
__decorate$m([
    Autowired('chartTranslationService')
], PolarAxisPanel.prototype, "chartTranslationService", void 0);
__decorate$m([
    PostConstruct
], PolarAxisPanel.prototype, "init", null);

var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class NavigatorPanel extends Component {
    constructor({ chartOptionsService, isExpandedOnInit = false }) {
        super();
        this.chartOptionsService = chartOptionsService;
        this.isExpandedOnInit = isExpandedOnInit;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical'
        };
        this.setTemplate(NavigatorPanel.TEMPLATE, { navigatorGroup: groupParams });
        this.initNavigator();
    }
    initNavigator() {
        const { chartTranslationService } = this;
        this.navigatorGroup
            .setTitle(chartTranslationService.translate("navigator"))
            .hideEnabledCheckbox(false)
            .setEnabled(this.chartOptionsService.getChartOption("navigator.enabled") || false)
            .onEnableChange(enabled => {
            this.chartOptionsService.setChartOption("navigator.enabled", enabled);
            this.navigatorGroup.toggleGroupExpand(true);
        })
            .toggleGroupExpand(this.isExpandedOnInit);
        const currentValue = this.chartOptionsService.getChartOption("navigator.height");
        this.navigatorHeightSlider
            .setLabel(chartTranslationService.translate("height"))
            .setMinValue(10)
            .setMaxValue(getMaxValue(currentValue, 60))
            .setTextFieldWidth(45)
            .setValue(`${currentValue || 30}`)
            .onValueChange(height => this.chartOptionsService.setChartOption("navigator.height", height));
    }
    destroy() {
        super.destroy();
    }
}
NavigatorPanel.TEMPLATE = `<div>
            <ag-group-component ref="navigatorGroup">
                <ag-slider ref="navigatorHeightSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$n([
    RefSelector('navigatorGroup')
], NavigatorPanel.prototype, "navigatorGroup", void 0);
__decorate$n([
    RefSelector('navigatorHeightSlider')
], NavigatorPanel.prototype, "navigatorHeightSlider", void 0);
__decorate$n([
    Autowired('chartTranslationService')
], NavigatorPanel.prototype, "chartTranslationService", void 0);
__decorate$n([
    PostConstruct
], NavigatorPanel.prototype, "init", null);

var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class PaddingPanel extends Component {
    constructor(chartOptionsService, chartController) {
        super();
        this.chartOptionsService = chartOptionsService;
        this.chartController = chartController;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true
        };
        this.setTemplate(PaddingPanel.TEMPLATE, { chartPaddingGroup: groupParams });
        this.addManagedListener(this.eventService, Events.EVENT_CHART_OPTIONS_CHANGED, (e) => {
            this.updateTopPadding(e.chartOptions);
        });
        this.initGroup();
        this.initChartPaddingItems();
    }
    initGroup() {
        this.chartPaddingGroup
            .setTitle(this.chartTranslationService.translate("padding"))
            .hideOpenCloseIcons(true)
            .hideEnabledCheckbox(true);
    }
    initChartPaddingItems() {
        const initInput = (property, input) => {
            const currentValue = this.chartOptionsService.getChartOption('padding.' + property);
            input.setLabel(this.chartTranslationService.translate(property))
                .setMaxValue(getMaxValue(currentValue, 200))
                .setValue(`${currentValue}`)
                .setTextFieldWidth(45)
                .onValueChange(newValue => this.chartOptionsService.setChartOption('padding.' + property, newValue));
        };
        initInput('top', this.paddingTopSlider);
        initInput('right', this.paddingRightSlider);
        initInput('bottom', this.paddingBottomSlider);
        initInput('left', this.paddingLeftSlider);
    }
    updateTopPadding(chartOptions) {
        // keep 'top' padding in sync with chart as toggling chart title on / off change the 'top' padding
        const topPadding = [...this.chartController.getChartSeriesTypes(), 'common']
            .map((seriesType) => { var _a, _b; return (_b = (_a = chartOptions[seriesType]) === null || _a === void 0 ? void 0 : _a.padding) === null || _b === void 0 ? void 0 : _b.top; })
            .find((value) => value != null);
        if (topPadding != null) {
            this.paddingTopSlider.setValue(topPadding);
        }
    }
}
PaddingPanel.TEMPLATE = `<div>
            <ag-group-component ref="chartPaddingGroup">
                <ag-slider ref="paddingTopSlider"></ag-slider>
                <ag-slider ref="paddingRightSlider"></ag-slider>
                <ag-slider ref="paddingBottomSlider"></ag-slider>
                <ag-slider ref="paddingLeftSlider"></ag-slider>
            </ag-group-component>
        <div>`;
__decorate$o([
    RefSelector('chartPaddingGroup')
], PaddingPanel.prototype, "chartPaddingGroup", void 0);
__decorate$o([
    RefSelector('paddingTopSlider')
], PaddingPanel.prototype, "paddingTopSlider", void 0);
__decorate$o([
    RefSelector('paddingRightSlider')
], PaddingPanel.prototype, "paddingRightSlider", void 0);
__decorate$o([
    RefSelector('paddingBottomSlider')
], PaddingPanel.prototype, "paddingBottomSlider", void 0);
__decorate$o([
    RefSelector('paddingLeftSlider')
], PaddingPanel.prototype, "paddingLeftSlider", void 0);
__decorate$o([
    Autowired('chartTranslationService')
], PaddingPanel.prototype, "chartTranslationService", void 0);
__decorate$o([
    PostConstruct
], PaddingPanel.prototype, "init", null);

var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class BackgroundPanel extends Component {
    constructor(chartOptionsService) {
        super();
        this.chartOptionsService = chartOptionsService;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true
        };
        this.setTemplate(BackgroundPanel.TEMPLATE, { chartBackgroundGroup: groupParams });
        this.initGroup();
        this.initColorPicker();
    }
    initGroup() {
        this.group
            .setTitle(this.chartTranslationService.translate('background'))
            .setEnabled(this.chartOptionsService.getChartOption('background.visible'))
            .hideOpenCloseIcons(true)
            .hideEnabledCheckbox(false)
            .onEnableChange(enabled => this.chartOptionsService.setChartOption('background.visible', enabled));
    }
    initColorPicker() {
        this.colorPicker
            .setLabel(this.chartTranslationService.translate('color'))
            .setLabelWidth('flex')
            .setInputWidth('flex')
            .setValue(this.chartOptionsService.getChartOption('background.fill'))
            .onValueChange(newColor => this.chartOptionsService.setChartOption('background.fill', newColor));
    }
}
BackgroundPanel.TEMPLATE = `<div>
            <ag-group-component ref="chartBackgroundGroup">
                <ag-color-picker ref="colorPicker"></ag-color-picker>
            </ag-group-component>
        <div>`;
__decorate$p([
    RefSelector('chartBackgroundGroup')
], BackgroundPanel.prototype, "group", void 0);
__decorate$p([
    RefSelector('colorPicker')
], BackgroundPanel.prototype, "colorPicker", void 0);
__decorate$p([
    Autowired('chartTranslationService')
], BackgroundPanel.prototype, "chartTranslationService", void 0);
__decorate$p([
    PostConstruct
], BackgroundPanel.prototype, "init", null);

var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class TitlePanel extends Component {
    constructor(chartOptionsService) {
        super(TitlePanel.TEMPLATE);
        this.chartOptionsService = chartOptionsService;
        this.activePanels = [];
    }
    init() {
        this.initFontPanel();
        this.titlePlaceholder = this.chartTranslationService.translate('titlePlaceholder');
    }
    hasTitle() {
        const title = this.getOption('title');
        return title && title.enabled && title.text && title.text.length > 0;
    }
    initFontPanel() {
        const hasTitle = this.hasTitle();
        const setFont = (font, isSilent) => {
            if (font.family) {
                this.setOption('title.fontFamily', font.family, isSilent);
            }
            if (font.weight) {
                this.setOption('title.fontWeight', font.weight, isSilent);
            }
            if (font.style) {
                this.setOption('title.fontStyle', font.style, isSilent);
            }
            if (font.size) {
                this.setOption('title.fontSize', font.size, isSilent);
            }
            if (font.color) {
                this.setOption('title.color', font.color, isSilent);
            }
        };
        const initialFont = {
            family: this.getOption('title.fontFamily'),
            style: this.getOption('title.fontStyle'),
            weight: this.getOption('title.fontWeight'),
            size: this.getOption('title.fontSize'),
            color: this.getOption('title.color')
        };
        if (!hasTitle) {
            setFont(initialFont, true);
        }
        const fontPanelParams = {
            name: this.chartTranslationService.translate('title'),
            enabled: hasTitle,
            suppressEnabledCheckbox: false,
            initialFont,
            setFont,
            setEnabled: (enabled) => {
                if (this.toolbarExists()) {
                    // extra padding is only included when the toolbar is present
                    const topPadding = this.getOption('padding.top');
                    this.setOption('padding.top', enabled ? topPadding - 20 : topPadding + 20);
                }
                this.setOption('title.enabled', enabled);
                const currentTitleText = this.getOption('title.text');
                const replaceableTitleText = currentTitleText === 'Title' || (currentTitleText === null || currentTitleText === void 0 ? void 0 : currentTitleText.trim().length) === 0;
                if (enabled && replaceableTitleText) {
                    this.setOption('title.text', this.titlePlaceholder);
                }
            }
        };
        const fontPanelComp = this.createBean(new FontPanel(fontPanelParams));
        // add the title spacing slider to font panel
        fontPanelComp.addItemToPanel(this.createSpacingSlicer());
        this.getGui().appendChild(fontPanelComp.getGui());
        this.activePanels.push(fontPanelComp);
        // edits to the title can disable it, so keep the checkbox in sync:
        this.addManagedListener(this.eventService, 'chartTitleEdit', () => {
            fontPanelComp.setEnabled(this.hasTitle());
        });
    }
    createSpacingSlicer() {
        const spacingSlider = this.createBean(new AgSlider());
        const currentValue = this.chartOptionsService.getChartOption('title.spacing') || 10;
        spacingSlider.setLabel(this.chartTranslationService.translate('spacing'))
            .setMaxValue(Math.max(currentValue, 100))
            .setValue(`${currentValue}`)
            .setTextFieldWidth(45)
            .onValueChange(newValue => this.chartOptionsService.setChartOption('title.spacing', newValue));
        return spacingSlider;
    }
    toolbarExists() {
        const toolbarItemsFunc = this.gridOptionsService.getCallback('getChartToolbarItems');
        if (!toolbarItemsFunc) {
            return true;
        }
        const params = {
            defaultItems: ['chartUnlink', 'chartDownload']
        };
        const topItems = ['chartLink', 'chartUnlink', 'chartDownload'];
        return topItems.some(v => { var _a; return (_a = (toolbarItemsFunc && toolbarItemsFunc(params))) === null || _a === void 0 ? void 0 : _a.includes(v); });
    }
    getOption(expression) {
        return this.chartOptionsService.getChartOption(expression);
    }
    setOption(property, value, isSilent) {
        this.chartOptionsService.setChartOption(property, value, isSilent);
    }
    destroyActivePanels() {
        this.activePanels.forEach(panel => {
            _.removeFromParent(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
TitlePanel.TEMPLATE = `<div></div>`;
__decorate$q([
    Autowired('chartTranslationService')
], TitlePanel.prototype, "chartTranslationService", void 0);
__decorate$q([
    PostConstruct
], TitlePanel.prototype, "init", null);

var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ChartPanel extends Component {
    constructor({ chartController, chartOptionsService, isExpandedOnInit = false }) {
        super();
        this.activePanels = [];
        this.chartController = chartController;
        this.chartOptionsService = chartOptionsService;
        this.isExpandedOnInit = isExpandedOnInit;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical'
        };
        this.setTemplate(ChartPanel.TEMPLATE, { chartGroup: groupParams });
        this.initGroup();
        this.initTitles();
        this.initPaddingPanel();
        this.initBackgroundPanel();
    }
    initGroup() {
        this.chartGroup
            .setTitle(this.chartTranslationService.translate('chart'))
            .toggleGroupExpand(this.isExpandedOnInit)
            .hideEnabledCheckbox(true);
    }
    initTitles() {
        const titlePanelComp = this.createBean(new TitlePanel(this.chartOptionsService));
        this.chartGroup.addItem(titlePanelComp);
        this.activePanels.push(titlePanelComp);
    }
    initPaddingPanel() {
        const paddingPanelComp = this.createBean(new PaddingPanel(this.chartOptionsService, this.chartController));
        this.chartGroup.addItem(paddingPanelComp);
        this.activePanels.push(paddingPanelComp);
    }
    initBackgroundPanel() {
        const backgroundPanelComp = this.createBean(new BackgroundPanel(this.chartOptionsService));
        this.chartGroup.addItem(backgroundPanelComp);
        this.activePanels.push(backgroundPanelComp);
    }
    destroyActivePanels() {
        this.activePanels.forEach(panel => {
            _.removeFromParent(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
ChartPanel.TEMPLATE = `<div>
            <ag-group-component ref="chartGroup"></ag-group-component>
        </div>`;
__decorate$r([
    RefSelector('chartGroup')
], ChartPanel.prototype, "chartGroup", void 0);
__decorate$r([
    Autowired('chartTranslationService')
], ChartPanel.prototype, "chartTranslationService", void 0);
__decorate$r([
    PostConstruct
], ChartPanel.prototype, "init", null);

var __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ShadowPanel extends Component {
    constructor(chartOptionsService, getSelectedSeries, propertyKey = "shadow") {
        super();
        this.chartOptionsService = chartOptionsService;
        this.getSelectedSeries = getSelectedSeries;
        this.propertyKey = propertyKey;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            suppressOpenCloseIcons: true
        };
        this.setTemplate(ShadowPanel.TEMPLATE, { shadowGroup: groupParams });
        this.shadowBlurSlider.setTextFieldWidth(45);
        this.shadowXOffsetSlider.setTextFieldWidth(45);
        this.shadowYOffsetSlider.setTextFieldWidth(45);
        this.initSeriesShadow();
    }
    initSeriesShadow() {
        // Determine the path within the series options object to get/set the individual shadow options
        const propertyNamespace = this.propertyKey;
        this.shadowGroup
            .setTitle(this.chartTranslationService.translate("shadow"))
            .setEnabled(this.chartOptionsService.getSeriesOption(`${propertyNamespace}.enabled`, this.getSelectedSeries()))
            .hideOpenCloseIcons(true)
            .hideEnabledCheckbox(false)
            .onEnableChange(newValue => this.chartOptionsService.setSeriesOption(`${propertyNamespace}.enabled`, newValue, this.getSelectedSeries()));
        this.shadowColorPicker
            .setLabel(this.chartTranslationService.translate("color"))
            .setLabelWidth("flex")
            .setInputWidth('flex')
            .setValue(this.chartOptionsService.getSeriesOption(`${propertyNamespace}.color`, this.getSelectedSeries()))
            .onValueChange(newValue => this.chartOptionsService.setSeriesOption(`${propertyNamespace}.color`, newValue, this.getSelectedSeries()));
        const initInput = (input, property, minValue, defaultMaxValue) => {
            const currentValue = this.chartOptionsService.getSeriesOption(`${propertyNamespace}.${property}`, this.getSelectedSeries());
            input.setLabel(this.chartTranslationService.translate(property))
                .setMinValue(minValue)
                .setMaxValue(getMaxValue(currentValue, defaultMaxValue))
                .setValue(`${currentValue}`)
                .onValueChange(newValue => this.chartOptionsService.setSeriesOption(`${propertyNamespace}.${property}`, newValue, this.getSelectedSeries()));
        };
        initInput(this.shadowBlurSlider, "blur", 0, 20);
        initInput(this.shadowXOffsetSlider, "xOffset", -10, 10);
        initInput(this.shadowYOffsetSlider, "yOffset", -10, 10);
    }
}
ShadowPanel.TEMPLATE = `<div>
            <ag-group-component ref="shadowGroup">
                <ag-color-picker ref="shadowColorPicker"></ag-color-picker>
                <ag-slider ref="shadowBlurSlider"></ag-slider>
                <ag-slider ref="shadowXOffsetSlider"></ag-slider>
                <ag-slider ref="shadowYOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$s([
    RefSelector('shadowGroup')
], ShadowPanel.prototype, "shadowGroup", void 0);
__decorate$s([
    RefSelector('shadowColorPicker')
], ShadowPanel.prototype, "shadowColorPicker", void 0);
__decorate$s([
    RefSelector('shadowBlurSlider')
], ShadowPanel.prototype, "shadowBlurSlider", void 0);
__decorate$s([
    RefSelector('shadowXOffsetSlider')
], ShadowPanel.prototype, "shadowXOffsetSlider", void 0);
__decorate$s([
    RefSelector('shadowYOffsetSlider')
], ShadowPanel.prototype, "shadowYOffsetSlider", void 0);
__decorate$s([
    Autowired('chartTranslationService')
], ShadowPanel.prototype, "chartTranslationService", void 0);
__decorate$s([
    PostConstruct
], ShadowPanel.prototype, "init", null);

function initFontPanelParams({ labelName, chartOptionsService, getSelectedSeries, seriesOptionLabelProperty }) {
    const getFontOptionExpression = (fontOption) => {
        return `${seriesOptionLabelProperty}.${fontOption}`;
    };
    const getFontOption = (fontOption) => {
        const expression = getFontOptionExpression(fontOption);
        return chartOptionsService.getSeriesOption(expression, getSelectedSeries());
    };
    const setFontOption = (fontOption, value) => {
        const expression = getFontOptionExpression(fontOption);
        chartOptionsService.setSeriesOption(expression, value, getSelectedSeries());
    };
    const initialFont = {
        family: getFontOption('fontFamily'),
        style: getFontOption('fontStyle'),
        weight: getFontOption('fontWeight'),
        size: getFontOption('fontSize'),
        color: getFontOption('color'),
    };
    const setFont = (font) => {
        if (font.family) {
            setFontOption('fontFamily', font.family);
        }
        if (font.weight) {
            setFontOption('fontWeight', font.weight);
        }
        if (font.style) {
            setFontOption('fontStyle', font.style);
        }
        if (font.size) {
            setFontOption('fontSize', font.size);
        }
        if (font.color) {
            setFontOption('color', font.color);
        }
    };
    const params = {
        name: labelName,
        enabled: getFontOption('enabled') || false,
        setEnabled: (enabled) => setFontOption('enabled', enabled),
        suppressEnabledCheckbox: false,
        initialFont: initialFont,
        setFont: setFont
    };
    return params;
}

var __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class MarkersPanel extends Component {
    constructor(chartOptionsService, getSelectedSeries) {
        super();
        this.chartOptionsService = chartOptionsService;
        this.getSelectedSeries = getSelectedSeries;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical'
        };
        this.setTemplate(MarkersPanel.TEMPLATE, { seriesMarkersGroup: groupParams });
        this.initMarkers();
    }
    initMarkers() {
        const seriesMarkerShapeOptions = [
            {
                value: 'square',
                text: 'Square'
            },
            {
                value: 'circle',
                text: 'Circle'
            },
            {
                value: 'cross',
                text: 'Cross'
            },
            {
                value: 'diamond',
                text: 'Diamond'
            },
            {
                value: 'plus',
                text: 'Plus'
            },
            {
                value: 'triangle',
                text: 'Triangle'
            },
            {
                value: 'heart',
                text: 'Heart'
            }
        ];
        this.seriesMarkerShapeSelect
            .addOptions(seriesMarkerShapeOptions)
            .setLabel(this.chartTranslationService.translate('shape'))
            .setValue(this.getSeriesOption("marker.shape"))
            .onValueChange(value => this.setSeriesOption("marker.shape", value));
        // scatter charts should always show markers
        const chartType = this.chartOptionsService.getChartType();
        const shouldHideEnabledCheckbox = _.includes(['scatter', 'bubble'], chartType);
        this.seriesMarkersGroup
            .setTitle(this.chartTranslationService.translate("markers"))
            .hideEnabledCheckbox(shouldHideEnabledCheckbox)
            .setEnabled(this.getSeriesOption("marker.enabled") || false)
            .hideOpenCloseIcons(true)
            .onEnableChange(newValue => this.setSeriesOption("marker.enabled", newValue));
        const initInput = (expression, input, labelKey, defaultMaxValue) => {
            const currentValue = this.getSeriesOption(expression);
            input.setLabel(this.chartTranslationService.translate(labelKey))
                .setMaxValue(getMaxValue(currentValue, defaultMaxValue))
                .setValue(`${currentValue}`)
                .setTextFieldWidth(45)
                .onValueChange(newValue => this.setSeriesOption(expression, newValue));
        };
        if (chartType === 'bubble') {
            initInput("marker.maxSize", this.seriesMarkerMinSizeSlider, "maxSize", 60);
            initInput("marker.size", this.seriesMarkerSizeSlider, "minSize", 60);
        }
        else {
            this.seriesMarkerMinSizeSlider.setDisplayed(false);
            initInput("marker.size", this.seriesMarkerSizeSlider, "size", 60);
        }
        initInput("marker.strokeWidth", this.seriesMarkerStrokeWidthSlider, "strokeWidth", 10);
    }
    getSeriesOption(expression) {
        return this.chartOptionsService.getSeriesOption(expression, this.getSelectedSeries());
    }
    setSeriesOption(expression, newValue) {
        this.chartOptionsService.setSeriesOption(expression, newValue, this.getSelectedSeries());
    }
}
MarkersPanel.TEMPLATE = `<div>
            <ag-group-component ref="seriesMarkersGroup">
                <ag-select ref="seriesMarkerShapeSelect"></ag-select>
                <ag-slider ref="seriesMarkerMinSizeSlider"></ag-slider>
                <ag-slider ref="seriesMarkerSizeSlider"></ag-slider>
                <ag-slider ref="seriesMarkerStrokeWidthSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$t([
    RefSelector('seriesMarkersGroup')
], MarkersPanel.prototype, "seriesMarkersGroup", void 0);
__decorate$t([
    RefSelector('seriesMarkerShapeSelect')
], MarkersPanel.prototype, "seriesMarkerShapeSelect", void 0);
__decorate$t([
    RefSelector('seriesMarkerSizeSlider')
], MarkersPanel.prototype, "seriesMarkerSizeSlider", void 0);
__decorate$t([
    RefSelector('seriesMarkerMinSizeSlider')
], MarkersPanel.prototype, "seriesMarkerMinSizeSlider", void 0);
__decorate$t([
    RefSelector('seriesMarkerStrokeWidthSlider')
], MarkersPanel.prototype, "seriesMarkerStrokeWidthSlider", void 0);
__decorate$t([
    Autowired('chartTranslationService')
], MarkersPanel.prototype, "chartTranslationService", void 0);
__decorate$t([
    PostConstruct
], MarkersPanel.prototype, "init", null);

var __decorate$u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AgColorPanel extends Component {
    constructor(config) {
        super(AgColorPanel.TEMPLATE);
        this.H = 1; // in the [0, 1] range
        this.S = 1; // in the [0, 1] range
        this.B = 1; // in the [0, 1] range
        this.A = 1; // in the [0, 1] range
        this.isSpectrumDragging = false;
        this.isSpectrumHueDragging = false;
        this.isSpectrumAlphaDragging = false;
        this.colorChanged = false;
        this.picker = config.picker;
    }
    postConstruct() {
        this.initTabIndex();
        this.initRecentColors();
        this.addGuiEventListener('focus', () => this.spectrumColor.focus());
        this.addGuiEventListener('keydown', (e) => {
            if (e.key === KeyCode.ENTER && !e.defaultPrevented) {
                this.destroy();
            }
        });
        this.addManagedListener(this.spectrumColor, 'keydown', e => this.moveDragger(e));
        this.addManagedListener(this.spectrumAlphaSlider, 'keydown', e => this.moveAlphaSlider(e));
        this.addManagedListener(this.spectrumHueSlider, 'keydown', e => this.moveHueSlider(e));
        this.addManagedListener(this.spectrumVal, 'mousedown', this.onSpectrumDraggerDown.bind(this));
        this.addManagedListener(this.spectrumHue, 'mousedown', this.onSpectrumHueDown.bind(this));
        this.addManagedListener(this.spectrumAlpha, 'mousedown', this.onSpectrumAlphaDown.bind(this));
        this.addGuiEventListener('mousemove', (e) => {
            this.onSpectrumDraggerMove(e);
            this.onSpectrumHueMove(e);
            this.onSpectrumAlphaMove(e);
        });
        // Listening to `mouseup` on the document on purpose. The user might release the mouse button
        // outside the UI control. When the mouse returns back to the control's area, the dragging
        // of the thumb is not expected and seen as a bug.
        this.addManagedListener(document, 'mouseup', this.onMouseUp.bind(this));
        this.addManagedListener(this.recentColors, 'click', this.onRecentColorClick.bind(this));
        this.addManagedListener(this.recentColors, 'keydown', (e) => {
            if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {
                e.preventDefault();
                this.onRecentColorClick(e);
            }
        });
    }
    initTabIndex() {
        const tabIndex = this.tabIndex = (this.gridOptionsService.get('tabIndex')).toString();
        this.spectrumColor.setAttribute('tabindex', tabIndex);
        this.spectrumHueSlider.setAttribute('tabindex', tabIndex);
        this.spectrumAlphaSlider.setAttribute('tabindex', tabIndex);
    }
    refreshSpectrumRect() {
        return this.spectrumValRect = this.spectrumVal.getBoundingClientRect();
    }
    refreshHueRect() {
        return this.spectrumHueRect = this.spectrumHue.getBoundingClientRect();
    }
    refreshAlphaRect() {
        return this.spectrumAlphaRect = this.spectrumAlpha.getBoundingClientRect();
    }
    onSpectrumDraggerDown(e) {
        this.refreshSpectrumRect();
        this.isSpectrumDragging = true;
        this.moveDragger(e);
    }
    onSpectrumDraggerMove(e) {
        if (this.isSpectrumDragging) {
            this.moveDragger(e);
        }
    }
    onSpectrumHueDown(e) {
        this.refreshHueRect();
        this.isSpectrumHueDragging = true;
        this.moveHueSlider(e);
    }
    onSpectrumHueMove(e) {
        if (this.isSpectrumHueDragging) {
            this.moveHueSlider(e);
        }
    }
    onSpectrumAlphaDown(e) {
        this.refreshAlphaRect();
        this.isSpectrumAlphaDragging = true;
        this.moveAlphaSlider(e);
    }
    onSpectrumAlphaMove(e) {
        if (this.isSpectrumAlphaDragging) {
            this.moveAlphaSlider(e);
        }
    }
    onMouseUp() {
        this.isSpectrumDragging = false;
        this.isSpectrumHueDragging = false;
        this.isSpectrumAlphaDragging = false;
    }
    moveDragger(e) {
        const valRect = this.spectrumValRect;
        if (!valRect) {
            return;
        }
        let x;
        let y;
        if (e instanceof MouseEvent) {
            x = e.clientX - valRect.left;
            y = e.clientY - valRect.top;
        }
        else {
            const isLeft = e.key === KeyCode.LEFT;
            const isRight = e.key === KeyCode.RIGHT;
            const isUp = e.key === KeyCode.UP;
            const isDown = e.key === KeyCode.DOWN;
            const isVertical = isUp || isDown;
            const isHorizontal = isLeft || isRight;
            if (!isVertical && !isHorizontal) {
                return;
            }
            e.preventDefault();
            const { x: currentX, y: currentY } = this.getSpectrumValue();
            x = currentX + (isHorizontal ? (isLeft ? -5 : 5) : 0);
            y = currentY + (isVertical ? (isUp ? -5 : 5) : 0);
        }
        x = Math.max(x, 0);
        x = Math.min(x, valRect.width);
        y = Math.max(y, 0);
        y = Math.min(y, valRect.height);
        this.setSpectrumValue(x / valRect.width, 1 - y / valRect.height);
    }
    moveHueSlider(e) {
        const rect = this.spectrumHueRect;
        if (!rect) {
            return;
        }
        const x = this.moveSlider(this.spectrumHueSlider, e);
        if (x == null) {
            return;
        }
        this.H = 1 - x / rect.width;
        this.update();
    }
    moveAlphaSlider(e) {
        const rect = this.spectrumAlphaRect;
        if (!rect) {
            return;
        }
        const x = this.moveSlider(this.spectrumAlphaSlider, e);
        if (x == null) {
            return;
        }
        this.A = x / rect.width;
        this.update();
    }
    moveSlider(slider, e) {
        var _a;
        const sliderRect = slider.getBoundingClientRect();
        const parentRect = (_a = slider.parentElement) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
        if (!slider || !parentRect) {
            return null;
        }
        let x;
        if (e instanceof MouseEvent) {
            x = e.clientX - parentRect.left;
        }
        else {
            const isLeft = e.key === KeyCode.LEFT;
            const isRight = e.key === KeyCode.RIGHT;
            if (!isLeft && !isRight) {
                return null;
            }
            e.preventDefault();
            const diff = isLeft ? -5 : 5;
            x = (parseFloat(slider.style.left) - sliderRect.width / 2) + diff;
        }
        x = Math.max(x, 0);
        x = Math.min(x, parentRect.width);
        slider.style.left = (x + sliderRect.width / 2) + 'px';
        return x;
    }
    update() {
        const color = sparklines_util_exports.Color.fromHSB(this.H * 360, this.S, this.B, this.A);
        const spectrumColor = sparklines_util_exports.Color.fromHSB(this.H * 360, 1, 1);
        const rgbaColor = color.toRgbaString();
        // the recent color list needs to know color has actually changed
        const colorPicker = this.picker;
        const existingColor = sparklines_util_exports.Color.fromString(colorPicker.getValue());
        if (existingColor.toRgbaString() !== rgbaColor) {
            this.colorChanged = true;
        }
        colorPicker.setValue(rgbaColor);
        this.spectrumColor.style.backgroundColor = spectrumColor.toRgbaString();
        this.spectrumDragger.style.backgroundColor = rgbaColor;
    }
    /**
     * @param saturation In the [0, 1] interval.
     * @param brightness In the [0, 1] interval.
     */
    setSpectrumValue(saturation, brightness) {
        const valRect = this.spectrumValRect || this.refreshSpectrumRect();
        if (valRect == null) {
            return;
        }
        const dragger = this.spectrumDragger;
        const draggerRect = dragger.getBoundingClientRect();
        saturation = Math.max(0, saturation);
        saturation = Math.min(1, saturation);
        brightness = Math.max(0, brightness);
        brightness = Math.min(1, brightness);
        this.S = saturation;
        this.B = brightness;
        dragger.style.left = (saturation * valRect.width - draggerRect.width / 2) + 'px';
        dragger.style.top = ((1 - brightness) * valRect.height - draggerRect.height / 2) + 'px';
        this.update();
    }
    getSpectrumValue() {
        const dragger = this.spectrumDragger;
        const draggerRect = dragger.getBoundingClientRect();
        const x = parseFloat(dragger.style.left) + draggerRect.width / 2;
        const y = parseFloat(dragger.style.top) + draggerRect.height / 2;
        return { x, y };
    }
    initRecentColors() {
        const recentColors = AgColorPanel.recentColors;
        const innerHtml = recentColors.map((color, index) => {
            return ( /* html */`<div class="ag-recent-color" id=${index} style="background-color: ${color}; width: 15px; height: 15px;" recent-color="${color}" tabIndex="${this.tabIndex}"></div>`);
        });
        this.recentColors.innerHTML = innerHtml.join('');
    }
    setValue(val) {
        const color = sparklines_util_exports.Color.fromString(val);
        const [h, s, b] = color.toHSB();
        this.H = (isNaN(h) ? 0 : h) / 360;
        this.A = color.a;
        const spectrumHueRect = this.spectrumHueRect || this.refreshHueRect();
        const spectrumAlphaRect = this.spectrumAlphaRect || this.refreshAlphaRect();
        this.spectrumHueSlider.style.left = `${((this.H - 1) * -spectrumHueRect.width)}px`;
        this.spectrumAlphaSlider.style.left = `${(this.A * spectrumAlphaRect.width)}px`;
        this.setSpectrumValue(s, b);
    }
    onRecentColorClick(e) {
        const target = e.target;
        if (!_.exists(target.id)) {
            return;
        }
        const id = parseInt(target.id, 10);
        this.setValue(AgColorPanel.recentColors[id]);
        this.destroy();
    }
    addRecentColor() {
        const color = sparklines_util_exports.Color.fromHSB(this.H * 360, this.S, this.B, this.A);
        const rgbaColor = color.toRgbaString();
        let recentColors = AgColorPanel.recentColors;
        if (!this.colorChanged || recentColors[0] === rgbaColor) {
            return;
        }
        // remove duplicate color
        recentColors = recentColors.filter(currentColor => currentColor != rgbaColor);
        // add color to head
        recentColors = [rgbaColor].concat(recentColors);
        // ensure we don't exceed max number of recent colors
        if (recentColors.length > AgColorPanel.maxRecentColors) {
            recentColors = recentColors.slice(0, AgColorPanel.maxRecentColors);
        }
        AgColorPanel.recentColors = recentColors;
    }
    destroy() {
        this.addRecentColor();
        super.destroy();
    }
}
AgColorPanel.maxRecentColors = 8;
AgColorPanel.recentColors = [];
AgColorPanel.TEMPLATE = `<div class="ag-color-panel" tabindex="-1">
            <div ref="spectrumColor" class="ag-spectrum-color">
                <div class="ag-spectrum-sat ag-spectrum-fill">
                    <div ref="spectrumVal" class="ag-spectrum-val ag-spectrum-fill">
                        <div ref="spectrumDragger" class="ag-spectrum-dragger"></div>
                    </div>
                </div>
            </div>
            <div class="ag-spectrum-tools">
                <div ref="spectrumHue" class="ag-spectrum-hue ag-spectrum-tool">
                    <div class="ag-spectrum-hue-background"></div>
                    <div ref="spectrumHueSlider" class="ag-spectrum-slider"></div>
                </div>
                <div ref="spectrumAlpha" class="ag-spectrum-alpha ag-spectrum-tool">
                    <div class="ag-spectrum-alpha-background"></div>
                    <div ref="spectrumAlphaSlider" class="ag-spectrum-slider"></div>
                </div>
                <div ref="recentColors" class="ag-recent-colors"></div>
            </div>
        </div>`;
__decorate$u([
    RefSelector('spectrumColor')
], AgColorPanel.prototype, "spectrumColor", void 0);
__decorate$u([
    RefSelector('spectrumVal')
], AgColorPanel.prototype, "spectrumVal", void 0);
__decorate$u([
    RefSelector('spectrumDragger')
], AgColorPanel.prototype, "spectrumDragger", void 0);
__decorate$u([
    RefSelector('spectrumHue')
], AgColorPanel.prototype, "spectrumHue", void 0);
__decorate$u([
    RefSelector('spectrumHueSlider')
], AgColorPanel.prototype, "spectrumHueSlider", void 0);
__decorate$u([
    RefSelector('spectrumAlpha')
], AgColorPanel.prototype, "spectrumAlpha", void 0);
__decorate$u([
    RefSelector('spectrumAlphaSlider')
], AgColorPanel.prototype, "spectrumAlphaSlider", void 0);
__decorate$u([
    RefSelector('recentColors')
], AgColorPanel.prototype, "recentColors", void 0);
__decorate$u([
    PostConstruct
], AgColorPanel.prototype, "postConstruct", null);

class AgColorPicker extends AgPickerField {
    constructor(config) {
        super(Object.assign({ pickerAriaLabelKey: 'ariaLabelColorPicker', pickerAriaLabelValue: 'Color Picker', pickerType: 'ag-list', className: 'ag-color-picker', pickerIcon: 'colorPicker' }, config));
        if (config && config.color) {
            this.value = config.color;
        }
    }
    postConstruct() {
        super.postConstruct();
        if (this.value) {
            this.setValue(this.value);
        }
    }
    createPickerComponent() {
        const eGuiRect = this.getGui().getBoundingClientRect();
        const colorDialog = this.createBean(new AgDialog({
            closable: false,
            modal: true,
            hideTitleBar: true,
            minWidth: 190,
            width: 190,
            height: 250,
            x: eGuiRect.right - 190,
            y: eGuiRect.top - 250
        }));
        return colorDialog;
    }
    renderAndPositionPicker() {
        const pickerComponent = this.pickerComponent;
        const colorPanel = this.createBean(new AgColorPanel({ picker: this }));
        pickerComponent.addCssClass('ag-color-dialog');
        colorPanel.addDestroyFunc(() => {
            if (pickerComponent.isAlive()) {
                this.destroyBean(pickerComponent);
            }
        });
        pickerComponent.setParentComponent(this);
        pickerComponent.setBodyComponent(colorPanel);
        colorPanel.setValue(this.getValue());
        colorPanel.getGui().focus();
        pickerComponent.addDestroyFunc(() => {
            // here we check if the picker was already being
            // destroyed to avoid a stack overflow
            if (!this.isDestroyingPicker) {
                this.beforeHidePicker();
                this.isDestroyingPicker = true;
                if (colorPanel.isAlive()) {
                    this.destroyBean(colorPanel);
                }
                if (this.isAlive()) {
                    this.getFocusableElement().focus();
                }
            }
            else {
                this.isDestroyingPicker = false;
            }
        });
        return () => { var _a; return (_a = this.pickerComponent) === null || _a === void 0 ? void 0 : _a.close(); };
    }
    setValue(color) {
        if (this.value === color) {
            return this;
        }
        this.eDisplayField.style.backgroundColor = color;
        return super.setValue(color);
    }
    getValue() {
        return this.value;
    }
}

var __decorate$v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class CalloutPanel extends Component {
    constructor(chartOptionsService, getSelectedSeries) {
        super();
        this.chartOptionsService = chartOptionsService;
        this.getSelectedSeries = getSelectedSeries;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical'
        };
        this.setTemplate(CalloutPanel.TEMPLATE, { calloutGroup: groupParams });
        this.initCalloutOptions();
    }
    initCalloutOptions() {
        this.calloutGroup
            .setTitle(this.chartTranslationService.translate("callout"))
            .setEnabled(true)
            .hideOpenCloseIcons(true)
            .hideEnabledCheckbox(true);
        const initInput = (expression, input, labelKey, defaultMaxValue) => {
            const currentValue = this.chartOptionsService.getSeriesOption(expression, this.getSelectedSeries());
            input.setLabel(this.chartTranslationService.translate(labelKey))
                .setMaxValue(getMaxValue(currentValue, defaultMaxValue))
                .setValue(`${currentValue}`)
                .setTextFieldWidth(45)
                .onValueChange(newValue => this.chartOptionsService.setSeriesOption(expression, newValue, this.getSelectedSeries()));
        };
        initInput('calloutLine.length', this.calloutLengthSlider, 'length', 40);
        initInput('calloutLine.strokeWidth', this.calloutStrokeWidthSlider, 'strokeWidth', 10);
        initInput('calloutLabel.offset', this.labelOffsetSlider, 'offset', 30);
    }
}
CalloutPanel.TEMPLATE = `<div>
            <ag-group-component ref="calloutGroup">
                <ag-slider ref="calloutLengthSlider"></ag-slider>
                <ag-slider ref="calloutStrokeWidthSlider"></ag-slider>
                <ag-slider ref="labelOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$v([
    RefSelector('calloutGroup')
], CalloutPanel.prototype, "calloutGroup", void 0);
__decorate$v([
    RefSelector('calloutLengthSlider')
], CalloutPanel.prototype, "calloutLengthSlider", void 0);
__decorate$v([
    RefSelector('calloutStrokeWidthSlider')
], CalloutPanel.prototype, "calloutStrokeWidthSlider", void 0);
__decorate$v([
    RefSelector('labelOffsetSlider')
], CalloutPanel.prototype, "labelOffsetSlider", void 0);
__decorate$v([
    Autowired('chartTranslationService')
], CalloutPanel.prototype, "chartTranslationService", void 0);
__decorate$v([
    PostConstruct
], CalloutPanel.prototype, "init", null);

var __decorate$w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class CapsPanel extends Component {
    constructor(chartOptionsService, getSelectedSeries) {
        super();
        this.chartOptionsService = chartOptionsService;
        this.getSelectedSeries = getSelectedSeries;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslationService.translate("cap"),
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(CapsPanel.TEMPLATE, { capsGroup: groupParams });
        this.initControls();
    }
    initControls() {
        const lengthRatio = this.chartOptionsService.getSeriesOption("cap.lengthRatio", this.getSelectedSeries());
        this.capLengthRatioSlider
            .setLabel(this.chartTranslationService.translate("capLengthRatio"))
            .setStep(0.05)
            .setMinValue(0)
            .setMaxValue(1)
            .setTextFieldWidth(45)
            .setValue(`${lengthRatio}`)
            .onValueChange(newValue => this.chartOptionsService.setSeriesOption("cap.lengthRatio", newValue, this.getSelectedSeries()));
    }
}
CapsPanel.TEMPLATE = `<div>
            <ag-group-component ref="capsGroup">
                <ag-slider ref="capLengthRatioSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$w([
    RefSelector('capsGroup')
], CapsPanel.prototype, "capsGroup", void 0);
__decorate$w([
    RefSelector('capLengthRatioSlider')
], CapsPanel.prototype, "capLengthRatioSlider", void 0);
__decorate$w([
    Autowired('chartTranslationService')
], CapsPanel.prototype, "chartTranslationService", void 0);
__decorate$w([
    PostConstruct
], CapsPanel.prototype, "init", null);

var __decorate$x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ConnectorLinePanel extends Component {
    constructor(chartOptionsService, getSelectedSeries) {
        super();
        this.chartOptionsService = chartOptionsService;
        this.getSelectedSeries = getSelectedSeries;
    }
    init() {
        const lineGroupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslationService.translate("connectorLine"),
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(ConnectorLinePanel.TEMPLATE, { lineGroup: lineGroupParams });
        this.initConnectorLineControls();
    }
    initConnectorLineControls() {
        this.initColorPicker(this.lineColorPicker, "color", "line.stroke");
        this.initSlider(this.lineStrokeWidthSlider, "strokeWidth", 0, 10, 45, "line.strokeWidth");
        this.initSlider(this.lineDashSlider, "lineDash", 0, 30, 45, "line.lineDash", 1, true);
        this.initSlider(this.lineOpacitySlider, "strokeOpacity", 0, 1, 45, "line.strokeOpacity", 0.05, false);
    }
    initColorPicker(colorPicker, labelKey, seriesOptionKey) {
        const color = this.chartOptionsService.getSeriesOption(seriesOptionKey, this.getSelectedSeries());
        colorPicker
            .setLabel(this.chartTranslationService.translate(labelKey))
            .setLabelWidth("flex")
            .setValue(color == null ? 'transparent' : `${color}`)
            .onValueChange(newValue => this.chartOptionsService.setSeriesOption(seriesOptionKey, newValue, this.getSelectedSeries()));
    }
    initSlider(slider, labelKey, minValue, maxValue, textFieldWidth, seriesOptionKey, step = 1, isArray = false) {
        const value = this.chartOptionsService.getSeriesOption(seriesOptionKey, this.getSelectedSeries());
        slider
            .setLabel(this.chartTranslationService.translate(labelKey))
            .setMinValue(minValue)
            .setMaxValue(maxValue)
            .setTextFieldWidth(textFieldWidth)
            .setValue(`${value}`)
            .setStep(step)
            .onValueChange(newValue => {
            const value = isArray ? [newValue] : newValue;
            this.chartOptionsService.setSeriesOption(seriesOptionKey, value, this.getSelectedSeries());
        });
    }
}
ConnectorLinePanel.TEMPLATE = `<div>
            <ag-group-component ref="lineGroup">
                <ag-color-picker ref="lineColorPicker"></ag-color-picker>
                <ag-slider ref="lineStrokeWidthSlider"></ag-slider>
                <ag-slider ref="lineOpacitySlider"></ag-slider>
                <ag-slider ref="lineDashSlider"></ag-slider>                
            </ag-group-component>
        </div>`;
__decorate$x([
    RefSelector('lineColorPicker')
], ConnectorLinePanel.prototype, "lineColorPicker", void 0);
__decorate$x([
    RefSelector('lineStrokeWidthSlider')
], ConnectorLinePanel.prototype, "lineStrokeWidthSlider", void 0);
__decorate$x([
    RefSelector('lineOpacitySlider')
], ConnectorLinePanel.prototype, "lineOpacitySlider", void 0);
__decorate$x([
    RefSelector('lineDashSlider')
], ConnectorLinePanel.prototype, "lineDashSlider", void 0);
__decorate$x([
    Autowired('chartTranslationService')
], ConnectorLinePanel.prototype, "chartTranslationService", void 0);
__decorate$x([
    PostConstruct
], ConnectorLinePanel.prototype, "init", null);

var __decorate$y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class WhiskersPanel extends Component {
    constructor(chartOptionsService, getSelectedSeries) {
        super();
        this.chartOptionsService = chartOptionsService;
        this.getSelectedSeries = getSelectedSeries;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslationService.translate("whisker"),
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(WhiskersPanel.TEMPLATE, { whiskersGroup: groupParams });
        this.initControls();
    }
    initControls() {
        const color = this.chartOptionsService.getSeriesOption("whisker.stroke", this.getSelectedSeries());
        this.whiskerColorPicker
            .setLabel(this.chartTranslationService.translate("color"))
            .setLabelWidth("flex")
            .setValue(color == null ? 'transparent' : `${color}`)
            .onValueChange(newValue => this.chartOptionsService.setSeriesOption("whisker.stroke", newValue, this.getSelectedSeries()));
        const strokeWidth = this.chartOptionsService.getSeriesOption("whisker.strokeWidth", this.getSelectedSeries());
        this.whiskerThicknessSlider
            .setLabel(this.chartTranslationService.translate("strokeWidth"))
            .setMinValue(0)
            .setMaxValue(10)
            .setTextFieldWidth(45)
            .setValue(`${strokeWidth}`)
            .onValueChange(newValue => this.chartOptionsService.setSeriesOption("whisker.strokeWidth", newValue, this.getSelectedSeries()));
        const strokeOpacity = this.chartOptionsService.getSeriesOption("whisker.strokeOpacity", this.getSelectedSeries());
        this.whiskerOpacitySlider
            .setLabel(this.chartTranslationService.translate("strokeOpacity"))
            .setStep(0.05)
            .setMinValue(0)
            .setMaxValue(1)
            .setTextFieldWidth(45)
            .setValue(`${strokeOpacity}`)
            .onValueChange(newValue => this.chartOptionsService.setSeriesOption("whisker.strokeOpacity", newValue, this.getSelectedSeries()));
        const lineDash = this.chartOptionsService.getSeriesOption("whisker.lineDash", this.getSelectedSeries());
        this.whiskerLineDashSlider
            .setLabel(this.chartTranslationService.translate("lineDash"))
            .setMinValue(0)
            .setMaxValue(30)
            .setTextFieldWidth(45)
            .setValue(`${lineDash}`)
            .onValueChange(newValue => this.chartOptionsService.setSeriesOption("whisker.lineDash", [newValue], this.getSelectedSeries()));
        const lineDashOffset = this.chartOptionsService.getSeriesOption("whisker.lineDashOffset", this.getSelectedSeries());
        this.whiskerLineDashOffsetSlider
            .setLabel(this.chartTranslationService.translate("lineDashOffset"))
            .setMinValue(0)
            .setMaxValue(30)
            .setTextFieldWidth(45)
            .setValue(`${lineDashOffset}`)
            .onValueChange(newValue => this.chartOptionsService.setSeriesOption("whisker.lineDashOffset", newValue, this.getSelectedSeries()));
    }
}
WhiskersPanel.TEMPLATE = `<div>
            <ag-group-component ref="whiskersGroup">
                <ag-color-picker ref="whiskerColorPicker"></ag-color-picker>
                <ag-slider ref="whiskerThicknessSlider"></ag-slider>
                <ag-slider ref="whiskerOpacitySlider"></ag-slider>
                <ag-slider ref="whiskerLineDashSlider"></ag-slider>
                <ag-slider ref="whiskerLineDashOffsetSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$y([
    RefSelector('whiskersGroup')
], WhiskersPanel.prototype, "whiskersGroup", void 0);
__decorate$y([
    RefSelector('whiskerColorPicker')
], WhiskersPanel.prototype, "whiskerColorPicker", void 0);
__decorate$y([
    RefSelector('whiskerThicknessSlider')
], WhiskersPanel.prototype, "whiskerThicknessSlider", void 0);
__decorate$y([
    RefSelector('whiskerOpacitySlider')
], WhiskersPanel.prototype, "whiskerOpacitySlider", void 0);
__decorate$y([
    RefSelector('whiskerLineDashSlider')
], WhiskersPanel.prototype, "whiskerLineDashSlider", void 0);
__decorate$y([
    RefSelector('whiskerLineDashOffsetSlider')
], WhiskersPanel.prototype, "whiskerLineDashOffsetSlider", void 0);
__decorate$y([
    Autowired('chartTranslationService')
], WhiskersPanel.prototype, "chartTranslationService", void 0);
__decorate$y([
    PostConstruct
], WhiskersPanel.prototype, "init", null);

var __decorate$z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SeriesItemsPanel extends Component {
    constructor(chartOptionsService, getSelectedSeries) {
        super();
        this.chartOptionsService = chartOptionsService;
        this.getSelectedSeries = getSelectedSeries;
        this.activePanels = [];
    }
    init() {
        const seriesItemsGroupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            title: this.chartTranslationService.translate('seriesItems'),
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(SeriesItemsPanel.TEMPLATE, { seriesItemsGroup: seriesItemsGroupParams });
        this.initSeriesItems();
        this.initSeriesControls();
    }
    initSeriesItems() {
        const selectOptions = [
            { value: 'positive', text: this.chartTranslationService.translate('seriesItemPositive') },
            { value: 'negative', text: this.chartTranslationService.translate('seriesItemNegative') },
        ];
        const seriesItemChangedCallback = (newValue) => {
            this.destroyActivePanels();
            this.initSeriesControls(newValue);
        };
        this.seriesItemSelect
            .setLabel(this.chartTranslationService.translate('seriesItemType'))
            .setLabelAlignment("left")
            .setLabelWidth('flex')
            .setInputWidth('flex')
            .addOptions(selectOptions)
            .setValue('positive')
            .onValueChange(seriesItemChangedCallback);
    }
    initSeriesControls(itemType = 'positive') {
        this.initSlider("strokeWidth", 0, 10, 45, `item.${itemType}.strokeWidth`);
        this.initSlider("lineDash", 0, 30, 45, `item.${itemType}.lineDash`, 1, true);
        this.initSlider("strokeOpacity", 0, 1, 45, `item.${itemType}.strokeOpacity`, 0.05, false);
        this.initSlider("fillOpacity", 0, 1, 45, `item.${itemType}.fillOpacity`, 0.05, false);
        this.initItemLabels(itemType);
    }
    initSlider(labelKey, minValue, maxValue, textFieldWidth, seriesOptionKey, step = 1, isArray = false) {
        const itemSlider = this.seriesItemsGroup.createManagedBean(new AgSlider());
        const value = this.chartOptionsService.getSeriesOption(seriesOptionKey, this.getSelectedSeries());
        const sliderChangedCallback = (newValue) => {
            const value = isArray ? [newValue] : newValue;
            this.chartOptionsService.setSeriesOption(seriesOptionKey, value, this.getSelectedSeries());
        };
        itemSlider
            .setLabel(this.chartTranslationService.translate(labelKey))
            .setMinValue(minValue)
            .setMaxValue(maxValue)
            .setTextFieldWidth(textFieldWidth)
            .setValue(`${value}`)
            .setStep(step)
            .onValueChange(sliderChangedCallback);
        this.seriesItemsGroup.addItem(itemSlider);
        this.activePanels.push(itemSlider);
    }
    initItemLabels(itemType) {
        const sectorParams = initFontPanelParams({
            labelName: this.chartTranslationService.translate('seriesItemLabels'),
            chartOptionsService: this.chartOptionsService,
            getSelectedSeries: () => this.getSelectedSeries(),
            seriesOptionLabelProperty: `item.${itemType}.label`
        });
        const labelPanelComp = this.createBean(new FontPanel(sectorParams));
        this.seriesItemsGroup.addItem(labelPanelComp);
        this.activePanels.push(labelPanelComp);
    }
    destroyActivePanels() {
        this.activePanels.forEach(panel => {
            _.removeFromParent(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
SeriesItemsPanel.TEMPLATE = `<div>
            <ag-group-component ref="seriesItemsGroup">
                <ag-select ref="seriesItemSelect"></ag-select>
            </ag-group-component>
        </div>`;
__decorate$z([
    RefSelector('seriesItemsGroup')
], SeriesItemsPanel.prototype, "seriesItemsGroup", void 0);
__decorate$z([
    RefSelector('seriesItemSelect')
], SeriesItemsPanel.prototype, "seriesItemSelect", void 0);
__decorate$z([
    Autowired('chartTranslationService')
], SeriesItemsPanel.prototype, "chartTranslationService", void 0);
__decorate$z([
    PostConstruct
], SeriesItemsPanel.prototype, "init", null);

var __decorate$A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class TileSpacingPanel extends Component {
    constructor(chartOptionsService, getSelectedSeries) {
        super();
        this.chartOptionsService = chartOptionsService;
        this.getSelectedSeries = getSelectedSeries;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-sub-level',
            direction: 'vertical',
            enabled: true,
            suppressOpenCloseIcons: true,
            suppressEnabledCheckbox: true,
        };
        this.setTemplate(TileSpacingPanel.TEMPLATE, {
            groupSpacing: Object.assign(Object.assign({}, groupParams), { title: this.chartTranslationService.translate("group") }),
            tileSpacing: Object.assign(Object.assign({}, groupParams), { title: this.chartTranslationService.translate("tile") }),
        });
        this.initControls();
    }
    initControls() {
        const optionGroups = [
            {
                optionNamespace: "group",
                components: {
                    paddingSlider: this.groupPaddingSlider,
                    spacingSlider: this.groupSpacingSlider,
                },
            },
            {
                optionNamespace: "tile",
                components: {
                    paddingSlider: this.tilePaddingSlider,
                    spacingSlider: this.tileSpacingSlider,
                },
            },
        ];
        for (const group of optionGroups) {
            const { optionNamespace, components } = group;
            const { paddingSlider, spacingSlider } = components;
            const paddingValue = this.chartOptionsService.getSeriesOption(`${optionNamespace}.padding`, this.getSelectedSeries());
            paddingSlider
                .setLabel(this.chartTranslationService.translate("padding"))
                .setMinValue(0)
                .setMaxValue(10)
                .setTextFieldWidth(45)
                .setValue(`${paddingValue}`)
                .onValueChange(newValue => this.chartOptionsService.setSeriesOption(`${optionNamespace}.padding`, newValue, this.getSelectedSeries()));
            const spacingValue = this.chartOptionsService.getSeriesOption(`${optionNamespace}.gap`, this.getSelectedSeries());
            spacingSlider
                .setLabel(this.chartTranslationService.translate("spacing"))
                .setMinValue(0)
                .setMaxValue(10)
                .setTextFieldWidth(45)
                .setValue(`${spacingValue}`)
                .onValueChange(newValue => this.chartOptionsService.setSeriesOption(`${optionNamespace}.gap`, newValue, this.getSelectedSeries()));
        }
    }
}
TileSpacingPanel.TEMPLATE = `<div>
            <ag-group-component ref="groupSpacing">
                <ag-slider ref="groupPaddingSlider"></ag-slider>
                <ag-slider ref="groupSpacingSlider"></ag-slider>
            </ag-group-component>
            <ag-group-component ref="tileSpacing">
                <ag-slider ref="tilePaddingSlider"></ag-slider>
                <ag-slider ref="tileSpacingSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$A([
    RefSelector('groupSpacing')
], TileSpacingPanel.prototype, "groupSpacing", void 0);
__decorate$A([
    RefSelector('groupPaddingSlider')
], TileSpacingPanel.prototype, "groupPaddingSlider", void 0);
__decorate$A([
    RefSelector('groupSpacingSlider')
], TileSpacingPanel.prototype, "groupSpacingSlider", void 0);
__decorate$A([
    RefSelector('tilePaddingSlider')
], TileSpacingPanel.prototype, "tilePaddingSlider", void 0);
__decorate$A([
    RefSelector('tileSpacingSlider')
], TileSpacingPanel.prototype, "tileSpacingSlider", void 0);
__decorate$A([
    Autowired('chartTranslationService')
], TileSpacingPanel.prototype, "chartTranslationService", void 0);
__decorate$A([
    PostConstruct
], TileSpacingPanel.prototype, "init", null);

var __decorate$B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SeriesPanel extends Component {
    constructor({ chartController, chartOptionsService, seriesType, isExpandedOnInit = false }) {
        super();
        this.activePanels = [];
        this.widgetFuncs = {
            'lineWidth': () => this.initStrokeWidth('lineWidth'),
            'strokeWidth': () => this.initStrokeWidth('strokeWidth'),
            'lineColor': () => this.initLineColor(),
            'lineDash': () => this.initLineDash(),
            'lineOpacity': () => this.initLineOpacity(),
            'fillOpacity': () => this.initFillOpacity(),
            'markers': () => this.initMarkers(),
            'labels': () => this.initLabels(),
            'shadow': () => this.initShadow(),
            'tooltips': () => this.initTooltips(),
            'bins': () => this.initBins(),
            'whiskers': () => this.initWhiskers(),
            'caps': () => this.initCaps(),
            'connectorLine': () => this.initConnectorLine(),
            'seriesItems': () => this.initSeriesItemsPanel(),
            'tileSpacing': () => this.initTileSpacingPanel(),
        };
        this.seriesWidgetMappings = {
            'column': ['tooltips', 'strokeWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'labels', 'shadow'],
            'bar': ['tooltips', 'strokeWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'labels', 'shadow'],
            'pie': ['tooltips', 'strokeWidth', 'lineOpacity', 'fillOpacity', 'labels', 'shadow'],
            'donut': ['tooltips', 'strokeWidth', 'lineOpacity', 'fillOpacity', 'labels', 'shadow'],
            'line': ['tooltips', 'lineWidth', 'lineDash', 'lineOpacity', 'markers', 'labels'],
            'scatter': ['tooltips', 'markers', 'labels'],
            'bubble': ['tooltips', 'markers', 'labels'],
            'area': ['tooltips', 'lineWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'markers', 'labels', 'shadow'],
            'histogram': ['tooltips', 'bins', 'strokeWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'labels', 'shadow'],
            'radial-column': ['tooltips', 'strokeWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'labels'],
            'radial-bar': ['tooltips', 'strokeWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'labels'],
            'radar-line': ['tooltips', 'strokeWidth', 'lineDash', 'lineOpacity', 'markers', 'labels'],
            'radar-area': ['tooltips', 'strokeWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'markers', 'labels'],
            'nightingale': ['tooltips', 'strokeWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'labels'],
            'box-plot': ['tooltips', 'strokeWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'whiskers', 'caps'],
            'range-bar': ['tooltips', 'strokeWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'labels'],
            'range-area': ['tooltips', 'lineWidth', 'lineDash', 'lineOpacity', 'fillOpacity', 'markers', 'labels', 'shadow'],
            'treemap': ['tooltips', 'tileSpacing'],
            'sunburst': ['tooltips'],
            'heatmap': ['tooltips', 'labels', 'lineColor', 'lineWidth', 'lineOpacity'],
            'waterfall': ['tooltips', 'connectorLine', 'seriesItems'],
        };
        this.chartController = chartController;
        this.chartOptionsService = chartOptionsService;
        this.seriesType = seriesType || this.getChartSeriesType();
        this.isExpandedOnInit = isExpandedOnInit;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical'
        };
        this.setTemplate(SeriesPanel.TEMPLATE, { seriesGroup: groupParams });
        this.seriesGroup
            .setTitle(this.translate("series"))
            .toggleGroupExpand(this.isExpandedOnInit)
            .hideEnabledCheckbox(true);
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_SERIES_CHART_TYPE_CHANGED, this.refreshWidgets.bind(this));
        this.refreshWidgets();
    }
    refreshWidgets() {
        this.destroyActivePanels();
        const chart = this.chartController.getChartProxy().getChart();
        chart.waitForUpdate().then(() => {
            var _a;
            const componentWasRemoved = !this.isAlive();
            if (componentWasRemoved) {
                // It's possible that the component was unmounted during the async delay in updating the chart.
                // If this is the case we want to bail out to avoid operating on stale UI components.
                return;
            }
            if (this.chartController.isComboChart()) {
                this.updateSeriesType();
                this.initSeriesSelect();
            }
            ((_a = this.seriesWidgetMappings[this.seriesType]) !== null && _a !== void 0 ? _a : []).forEach((w) => this.widgetFuncs[w]());
        })
            .catch(e => console.error(`AG Grid - chart rendering failed`, e));
    }
    initSeriesSelect() {
        const seriesSelect = this.seriesGroup.createManagedBean(new AgSelect());
        seriesSelect
            .setLabel(this.translate('seriesType'))
            .setLabelAlignment("left")
            .setLabelWidth('flex')
            .setInputWidth('flex')
            .addOptions(this.getSeriesSelectOptions())
            .setValue(`${this.seriesType}`)
            .onValueChange((newValue) => {
            this.seriesType = newValue;
            this.refreshWidgets();
        });
        this.seriesGroup.addItem(seriesSelect);
        this.activePanels.push(seriesSelect);
    }
    initTooltips() {
        const seriesTooltipsToggle = this.createBean(new AgToggleButton());
        seriesTooltipsToggle
            .setLabel(this.translate("tooltips"))
            .setLabelAlignment("left")
            .setLabelWidth("flex")
            .setInputWidth('flex')
            .setValue(this.getSeriesOption("tooltip.enabled") || false)
            .onValueChange(newValue => this.setSeriesOption("tooltip.enabled", newValue));
        this.addWidget(seriesTooltipsToggle);
    }
    initLineColor() {
        const currentValue = this.getSeriesOption("stroke");
        const seriesLineColorPicker = this.createBean(new AgColorPicker());
        seriesLineColorPicker
            .setLabel(this.translate("strokeColor"))
            .setLabelWidth('flex')
            .onValueChange(newValue => this.setSeriesOption("stroke", newValue));
        if (currentValue)
            seriesLineColorPicker.setValue(currentValue);
        this.addWidget(seriesLineColorPicker);
    }
    initStrokeWidth(label) {
        var _a;
        const currentValue = (_a = this.getSeriesOption("strokeWidth")) !== null && _a !== void 0 ? _a : 0;
        const seriesStrokeWidthSlider = this.createBean(new AgSlider());
        seriesStrokeWidthSlider
            .setLabel(this.translate(label))
            .setMaxValue(getMaxValue(currentValue, 10))
            .setTextFieldWidth(45)
            .setValue(`${currentValue}`)
            .onValueChange(newValue => this.setSeriesOption("strokeWidth", newValue));
        this.addWidget(seriesStrokeWidthSlider);
    }
    initLineDash() {
        const lineDash = this.getSeriesOption("lineDash");
        const currentValue = lineDash ? lineDash[0] : 0;
        const seriesLineDashSlider = this.createBean(new AgSlider());
        seriesLineDashSlider
            .setLabel(this.translate('lineDash'))
            .setMaxValue(getMaxValue(currentValue, 30))
            .setTextFieldWidth(45)
            .setValue(`${currentValue}`)
            .onValueChange(newValue => this.setSeriesOption("lineDash", [newValue]));
        this.addWidget(seriesLineDashSlider);
    }
    initLineOpacity() {
        var _a;
        const currentValue = (_a = this.getSeriesOption("strokeOpacity")) !== null && _a !== void 0 ? _a : 0;
        const seriesLineOpacitySlider = this.createBean(new AgSlider());
        seriesLineOpacitySlider
            .setLabel(this.translate("strokeOpacity"))
            .setStep(0.05)
            .setMaxValue(getMaxValue(currentValue, 1))
            .setTextFieldWidth(45)
            .setValue(`${currentValue}`)
            .onValueChange(newValue => this.setSeriesOption("strokeOpacity", newValue));
        this.addWidget(seriesLineOpacitySlider);
    }
    initFillOpacity() {
        var _a;
        const currentValue = (_a = this.getSeriesOption("fillOpacity")) !== null && _a !== void 0 ? _a : 0;
        const seriesFillOpacitySlider = this.createBean(new AgSlider());
        seriesFillOpacitySlider
            .setLabel(this.translate("fillOpacity"))
            .setStep(0.05)
            .setMaxValue(getMaxValue(currentValue, 1))
            .setTextFieldWidth(45)
            .setValue(`${currentValue}`)
            .onValueChange(newValue => this.setSeriesOption("fillOpacity", newValue));
        this.addWidget(seriesFillOpacitySlider);
    }
    initLabels() {
        const isPieChart = isPieChartSeries(this.seriesType);
        const seriesOptionLabelProperty = isPieChart ? 'calloutLabel' : 'label';
        const labelName = isPieChart
            ? this.chartTranslationService.translate('calloutLabels')
            : this.chartTranslationService.translate('labels');
        const labelParams = initFontPanelParams({
            labelName,
            chartOptionsService: this.chartOptionsService,
            getSelectedSeries: () => this.seriesType,
            seriesOptionLabelProperty
        });
        const labelPanelComp = this.createBean(new FontPanel(labelParams));
        if (isPieChart) {
            const calloutPanelComp = this.createBean(new CalloutPanel(this.chartOptionsService, () => this.seriesType));
            labelPanelComp.addCompToPanel(calloutPanelComp);
            this.activePanels.push(calloutPanelComp);
        }
        this.addWidget(labelPanelComp);
        if (isPieChart) {
            const sectorParams = initFontPanelParams({
                labelName: this.chartTranslationService.translate('sectorLabels'),
                chartOptionsService: this.chartOptionsService,
                getSelectedSeries: () => this.seriesType,
                seriesOptionLabelProperty: 'sectorLabel'
            });
            const sectorPanelComp = this.createBean(new FontPanel(sectorParams));
            const positionRatioComp = this.getSectorLabelPositionRatio();
            sectorPanelComp.addCompToPanel(positionRatioComp);
            this.addWidget(sectorPanelComp);
        }
        if (this.seriesType === 'range-bar') {
            // Add label placement dropdown
            const options = [
                { value: 'inside', text: this.translate('inside') },
                { value: 'outside', text: this.translate('outside') },
            ];
            const placementValue = this.chartOptionsService.getSeriesOption('label.placement', this.seriesType);
            const placementSelect = labelPanelComp.createManagedBean(new AgSelect());
            placementSelect
                .setLabel(this.translate('labelPlacement'))
                .setLabelAlignment('left')
                .setLabelWidth('flex')
                .setInputWidth('flex')
                .addOptions(options)
                .setValue(placementValue)
                .onValueChange((newValue) => this.chartOptionsService.setSeriesOption('label.placement', newValue, this.seriesType));
            labelPanelComp.addCompToPanel(placementSelect);
            this.activePanels.push(placementSelect);
            // Add padding slider
            const paddingValue = this.chartOptionsService.getSeriesOption('label.padding', this.seriesType);
            const paddingSlider = labelPanelComp.createManagedBean(new AgSlider());
            paddingSlider.setLabel(this.chartTranslationService.translate('padding'))
                .setMaxValue(getMaxValue(paddingValue, 200))
                .setValue(`${paddingValue}`)
                .setTextFieldWidth(45)
                .onValueChange(newValue => this.chartOptionsService.setSeriesOption('label.padding', newValue, this.seriesType));
            labelPanelComp.addCompToPanel(paddingSlider);
            this.activePanels.push(paddingSlider);
        }
    }
    getSectorLabelPositionRatio() {
        const expression = 'sectorLabel.positionRatio';
        const currentValue = this.chartOptionsService.getSeriesOption(expression, this.seriesType);
        const sectorLabelPositionRatioSlider = this.createBean(new AgSlider());
        return sectorLabelPositionRatioSlider
            .setLabel(this.translate("positionRatio"))
            .setStep(0.05)
            .setMaxValue(getMaxValue(currentValue, 1))
            .setTextFieldWidth(45)
            .setValue(`${currentValue}`)
            .onValueChange(newValue => this.chartOptionsService.setSeriesOption(expression, newValue, this.seriesType));
    }
    initShadow() {
        const shadowPanelComp = this.createBean(new ShadowPanel(this.chartOptionsService, () => this.seriesType));
        this.addWidget(shadowPanelComp);
    }
    initMarkers() {
        const markersPanelComp = this.createBean(new MarkersPanel(this.chartOptionsService, () => this.seriesType));
        this.addWidget(markersPanelComp);
    }
    initBins() {
        var _a;
        const currentValue = ((_a = this.getSeriesOption("bins")) !== null && _a !== void 0 ? _a : this.getSeriesOption("calculatedBins", true)).length;
        const seriesBinCountSlider = this.createBean(new AgSlider());
        seriesBinCountSlider
            .setLabel(this.translate("histogramBinCount"))
            .setMinValue(0)
            .setMaxValue(getMaxValue(currentValue, 20))
            .setTextFieldWidth(45)
            .setValue(`${currentValue}`)
            .onValueChange(newValue => this.setSeriesOption("binCount", newValue));
        this.addWidget(seriesBinCountSlider);
    }
    initWhiskers() {
        const whiskersPanelComp = this.createBean(new WhiskersPanel(this.chartOptionsService, () => this.seriesType));
        this.addWidget(whiskersPanelComp);
    }
    initCaps() {
        const capsPanelComp = this.createBean(new CapsPanel(this.chartOptionsService, () => this.seriesType));
        this.addWidget(capsPanelComp);
    }
    initConnectorLine() {
        const connectorLinePanelComp = this.createBean(new ConnectorLinePanel(this.chartOptionsService, () => this.seriesType));
        this.addWidget(connectorLinePanelComp);
    }
    initSeriesItemsPanel() {
        const seriesItemsPanelComp = this.createBean(new SeriesItemsPanel(this.chartOptionsService, () => this.seriesType));
        this.addWidget(seriesItemsPanelComp);
    }
    initTileSpacingPanel() {
        const tileSpacingPanelComp = this.createBean(new TileSpacingPanel(this.chartOptionsService, () => this.seriesType));
        this.addWidget(tileSpacingPanelComp);
    }
    addWidget(widget) {
        this.seriesGroup.addItem(widget);
        this.activePanels.push(widget);
    }
    getSeriesOption(expression, calculated) {
        return this.chartOptionsService.getSeriesOption(expression, this.seriesType, calculated);
    }
    setSeriesOption(expression, newValue) {
        this.chartOptionsService.setSeriesOption(expression, newValue, this.seriesType);
    }
    getChartSeriesType() {
        if (this.chartController.getSeriesChartTypes().length === 0) {
            return 'column';
        }
        const ct = this.chartController.getSeriesChartTypes()[0].chartType;
        if (ct === 'columnLineCombo') {
            return 'column';
        }
        if (ct === 'areaColumnCombo') {
            return 'area';
        }
        return getSeriesType(ct);
    }
    getSeriesSelectOptions() {
        if (!this.seriesSelectOptions) {
            // lazy init options as they are only required for combo charts
            this.seriesSelectOptions = new Map([
                ['area', { value: 'area', text: this.translate('area', 'Area') }],
                ['bar', { value: 'bar', text: this.translate('bar', 'Bar') }],
                ['column', { value: 'column', text: this.translate('column', 'Column') }],
                ['line', { value: 'line', text: this.translate('line', 'Line') }],
                ['scatter', { value: 'scatter', text: this.translate('scatter', 'Scatter') }],
                ['histogram', { value: 'histogram', text: this.translate('histogram', 'Histogram') }],
                ['radial-column', { value: 'radial-column', text: this.translate('radialColumn', 'Radial Column') }],
                ['radial-bar', { value: 'radial-bar', text: this.translate('radialBar', 'Radial Bar') }],
                ['radar-line', { value: 'radar-line', text: this.translate('radarLine', 'Radar Line') }],
                ['radar-area', { value: 'radar-area', text: this.translate('radarArea', 'Radar Area') }],
                ['nightingale', { value: 'nightingale', text: this.translate('nightingale', 'Nightingale') }],
                ['range-bar', { value: 'range-bar', text: this.translate('rangeBar', 'Range Bar') }],
                ['range-area', { value: 'range-area', text: this.translate('rangeArea', 'Range Area') }],
                ['treemap', { value: 'treemap', text: this.translate('treemap', 'Treemap') }],
                ['sunburst', { value: 'sunburst', text: this.translate('sunburst', 'Sunburst') }],
                ['waterfall', { value: 'waterfall', text: this.translate('waterfall', 'Waterfall') }],
                ['box-plot', { value: 'box-plot', text: this.translate('boxPlot', 'Box Plot') }],
                ['pie', { value: 'pie', text: this.translate('pie', 'Pie') }],
                ['donut', { value: 'donut', text: this.translate('donut', 'Donut') }],
            ]);
        }
        const seriesSelectOptions = new Set();
        this.chartController.getActiveSeriesChartTypes().forEach(s => {
            const chartType = getSeriesType(s.chartType);
            seriesSelectOptions.add(this.seriesSelectOptions.get(chartType));
        });
        return Array.from(seriesSelectOptions);
    }
    updateSeriesType() {
        const activeChartTypes = this.chartController.getActiveSeriesChartTypes().map(s => getSeriesType(s.chartType));
        const invalidSeriesType = !activeChartTypes.includes(this.seriesType);
        if (invalidSeriesType && activeChartTypes.length > 0) {
            this.seriesType = activeChartTypes[0]; // default to first active series type
        }
    }
    translate(key, defaultText) {
        return this.chartTranslationService.translate(key, defaultText);
    }
    destroyActivePanels() {
        this.activePanels.forEach(panel => {
            _.removeFromParent(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
SeriesPanel.TEMPLATE = `<div>
            <ag-group-component ref="seriesGroup">
            </ag-group-component>
        </div>`;
__decorate$B([
    RefSelector('seriesGroup')
], SeriesPanel.prototype, "seriesGroup", void 0);
__decorate$B([
    Autowired('chartTranslationService')
], SeriesPanel.prototype, "chartTranslationService", void 0);
__decorate$B([
    PostConstruct
], SeriesPanel.prototype, "init", null);

var __decorate$C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class GradientLegendPanel extends Component {
    constructor({ chartOptionsService, isExpandedOnInit = false }) {
        super();
        this.activePanels = [];
        this.chartOptionsService = chartOptionsService;
        this.isExpandedOnInit = isExpandedOnInit;
    }
    init() {
        const groupParams = {
            cssIdentifier: 'charts-format-top-level',
            direction: 'vertical'
        };
        this.setTemplate(GradientLegendPanel.TEMPLATE, { legendGroup: groupParams });
        this.initLegendGroup();
        this.initLegendPosition();
        this.initLegendGradient();
        this.initLegendSpacing();
        this.initLabelPanel();
    }
    initLegendGroup() {
        this.legendGroup
            .setTitle(this.chartTranslationService.translate("legend"))
            .hideEnabledCheckbox(false)
            .setEnabled(this.chartOptionsService.getChartOption("gradientLegend.enabled") || false)
            .toggleGroupExpand(this.isExpandedOnInit)
            .onEnableChange(enabled => {
            this.chartOptionsService.setChartOption("gradientLegend.enabled", enabled);
            this.legendGroup.toggleGroupExpand(true);
        });
    }
    initLegendPosition() {
        const positions = ['top', 'right', 'bottom', 'left'];
        this.legendPositionSelect
            .setLabel(this.chartTranslationService.translate("position"))
            .setLabelWidth("flex")
            .setInputWidth('flex')
            .addOptions(positions.map(position => ({
            value: position,
            text: this.chartTranslationService.translate(position)
        })))
            .setValue(this.chartOptionsService.getChartOption("gradientLegend.position"))
            .onValueChange(newValue => this.chartOptionsService.setChartOption("gradientLegend.position", newValue));
    }
    initLegendGradient() {
        this.gradientReverseCheckbox
            .setLabel(this.chartTranslationService.translate("reverseDirection"))
            .setLabelWidth("flex")
            .setValue(this.chartOptionsService.getChartOption("gradientLegend.reverseOrder"))
            .onValueChange(newValue => this.chartOptionsService.setChartOption("gradientLegend.reverseOrder", newValue));
        const initSlider = (expression, labelKey, input, defaultMaxValue) => {
            var _a;
            const currentValue = (_a = this.chartOptionsService.getChartOption(expression)) !== null && _a !== void 0 ? _a : 0;
            input.setLabel(this.chartTranslationService.translate(labelKey))
                .setMaxValue(getMaxValue(currentValue, defaultMaxValue))
                .setValue(`${currentValue}`)
                .setTextFieldWidth(45)
                .onValueChange(newValue => {
                this.chartOptionsService.setChartOption(expression, newValue);
            });
        };
        initSlider("gradientLegend.gradient.thickness", "thickness", this.gradientThicknessSlider, 40);
        initSlider("gradientLegend.gradient.preferredLength", "preferredLength", this.gradientPreferredLengthSlider, 300);
    }
    initLegendSpacing() {
        const currentValue = this.chartOptionsService.getChartOption("gradientLegend.spacing");
        this.legendSpacingSlider
            .setLabel(this.chartTranslationService.translate("spacing"))
            .setMaxValue(getMaxValue(currentValue, 200))
            .setValue(`${currentValue}`)
            .setTextFieldWidth(45)
            .onValueChange(newValue => this.chartOptionsService.setChartOption("gradientLegend.spacing", newValue));
    }
    initLabelPanel() {
        const chartProxy = this.chartOptionsService;
        const initialFont = {
            family: chartProxy.getChartOption("gradientLegend.scale.label.fontFamily"),
            style: chartProxy.getChartOption("gradientLegend.scale.label.fontStyle"),
            weight: chartProxy.getChartOption("gradientLegend.scale.label.fontWeight"),
            size: chartProxy.getChartOption("gradientLegend.scale.label.fontSize"),
            color: chartProxy.getChartOption("gradientLegend.scale.label.color")
        };
        const setFont = (font) => {
            const proxy = this.chartOptionsService;
            if (font.family) {
                proxy.setChartOption("gradientLegend.scale.label.fontFamily", font.family);
            }
            if (font.weight) {
                proxy.setChartOption("gradientLegend.scale.label.fontWeight", font.weight);
            }
            if (font.style) {
                proxy.setChartOption("gradientLegend.scale.label.fontStyle", font.style);
            }
            if (font.size) {
                proxy.setChartOption("gradientLegend.scale.label.fontSize", font.size);
            }
            if (font.color) {
                proxy.setChartOption("gradientLegend.scale.label.color", font.color);
            }
        };
        const params = {
            enabled: true,
            suppressEnabledCheckbox: true,
            initialFont: initialFont,
            setFont: setFont
        };
        const fontPanelComp = this.createBean(new FontPanel(params));
        this.legendGroup.addItem(fontPanelComp);
        this.activePanels.push(fontPanelComp);
    }
    destroyActivePanels() {
        this.activePanels.forEach(panel => {
            _.removeFromParent(panel.getGui());
            this.destroyBean(panel);
        });
    }
    destroy() {
        this.destroyActivePanels();
        super.destroy();
    }
}
GradientLegendPanel.TEMPLATE = `<div>
            <ag-group-component ref="legendGroup">
                <ag-select ref="legendPositionSelect"></ag-select>
                <ag-checkbox ref="gradientReverseCheckbox"></ag-checkbox>
                <ag-slider ref="gradientThicknessSlider"></ag-slider>
                <ag-slider ref="gradientPreferredLengthSlider"></ag-slider>
                <ag-slider ref="legendSpacingSlider"></ag-slider>
            </ag-group-component>
        </div>`;
__decorate$C([
    RefSelector('legendGroup')
], GradientLegendPanel.prototype, "legendGroup", void 0);
__decorate$C([
    RefSelector('gradientReverseCheckbox')
], GradientLegendPanel.prototype, "gradientReverseCheckbox", void 0);
__decorate$C([
    RefSelector('legendPositionSelect')
], GradientLegendPanel.prototype, "legendPositionSelect", void 0);
__decorate$C([
    RefSelector('gradientThicknessSlider')
], GradientLegendPanel.prototype, "gradientThicknessSlider", void 0);
__decorate$C([
    RefSelector('gradientPreferredLengthSlider')
], GradientLegendPanel.prototype, "gradientPreferredLengthSlider", void 0);
__decorate$C([
    RefSelector('legendSpacingSlider')
], GradientLegendPanel.prototype, "legendSpacingSlider", void 0);
__decorate$C([
    Autowired('chartTranslationService')
], GradientLegendPanel.prototype, "chartTranslationService", void 0);
__decorate$C([
    PostConstruct
], GradientLegendPanel.prototype, "init", null);

var __decorate$D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function getMaxValue(currentValue, defaultMaxValue) {
    return Math.max(currentValue, defaultMaxValue);
}
const DefaultFormatPanelDef = {
    groups: [
        { type: 'chart' },
        { type: 'legend' },
        { type: 'series' },
        { type: 'axis' },
        { type: 'navigator' },
    ]
};
class FormatPanel extends Component {
    constructor(chartController, chartOptionsService) {
        super(FormatPanel.TEMPLATE);
        this.chartController = chartController;
        this.chartOptionsService = chartOptionsService;
        this.panels = [];
        this.isGroupPanelShownInSeries = (group, seriesType) => {
            // Determine whether the given panel group is shown depending on the active series type
            var _a, _b;
            // These panel groups are always shown regardless of series type
            const commonGroupPanels = ['chart', 'legend', 'series'];
            if (commonGroupPanels.includes(group)) {
                return true;
            }
            // These panel groups depend on the selected series type
            const extendedGroupPanels = {
                'bar': ['axis', 'navigator'],
                'column': ['axis', 'navigator'],
                'line': ['axis', 'navigator'],
                'area': ['axis', 'navigator'],
                'scatter': ['axis', 'navigator'],
                'bubble': ['axis', 'navigator'],
                'histogram': ['axis', 'navigator'],
                'cartesian': ['axis', 'navigator'],
                'radial-column': ['axis'],
                'radial-bar': ['axis'],
                'radar-line': ['axis'],
                'radar-area': ['axis'],
                'nightingale': ['axis'],
                'range-bar': ['axis', 'navigator'],
                'range-area': ['axis', 'navigator'],
                'treemap': [],
                'sunburst': [],
                'heatmap': ['axis'],
                'waterfall': ['axis', 'navigator'],
                'box-plot': ['axis', 'navigator'],
            };
            return (_b = (_a = extendedGroupPanels[seriesType]) === null || _a === void 0 ? void 0 : _a.includes(group)) !== null && _b !== void 0 ? _b : false;
        };
    }
    init() {
        this.createPanels();
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_UPDATED, () => this.createPanels(true));
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_API_UPDATE, () => this.createPanels(false));
    }
    createPanels(reuse) {
        var _a;
        const chartType = this.chartController.getChartType();
        const isGrouping = this.chartController.isGrouping();
        const seriesType = getSeriesType(chartType);
        if (reuse && chartType === this.chartType && isGrouping === this.isGrouping) {
            // existing panels can be re-used
            return;
        }
        this.destroyPanels();
        (_a = this.getFormatPanelDef().groups) === null || _a === void 0 ? void 0 : _a.forEach((groupDef) => {
            const group = groupDef.type;
            // ensure the group should be displayed for the current series type
            if (!this.isGroupPanelShownInSeries(group, seriesType)) {
                return;
            }
            const opts = {
                chartController: this.chartController,
                chartOptionsService: this.chartOptionsService,
                isExpandedOnInit: groupDef.isOpen,
                seriesType
            };
            if (group === 'chart') {
                this.addComponent(new ChartPanel(opts));
            }
            else if (group === 'legend') {
                // Some chart types require non-standard legend options, so choose the appropriate panel
                const panel = hasGradientLegend(chartType) ? new GradientLegendPanel(opts) : new LegendPanel(opts);
                this.addComponent(panel);
            }
            else if (group === 'axis') {
                // Polar charts have different axis options from cartesian charts, so choose the appropriate panel
                const panel = isPolar(chartType) ? new PolarAxisPanel(opts) : new CartesianAxisPanel(opts);
                this.addComponent(panel);
            }
            else if (group === 'series') {
                this.addComponent(new SeriesPanel(opts));
            }
            else if (group === 'navigator') {
                this.addComponent(new NavigatorPanel(opts));
            }
            else {
                console.warn(`AG Grid: invalid charts format panel group name supplied: '${groupDef.type}'`);
            }
        });
        this.chartType = chartType;
        this.isGrouping = isGrouping;
    }
    getFormatPanelDef() {
        var _a;
        const userProvidedFormatPanelDef = (_a = this.gridOptionsService.get('chartToolPanelsDef')) === null || _a === void 0 ? void 0 : _a.formatPanel;
        return userProvidedFormatPanelDef ? userProvidedFormatPanelDef : DefaultFormatPanelDef;
    }
    addComponent(component) {
        this.createBean(component);
        this.panels.push(component);
        component.addCssClass('ag-chart-format-section');
        this.getGui().appendChild(component.getGui());
    }
    destroyPanels() {
        this.panels.forEach(panel => {
            _.removeFromParent(panel.getGui());
            this.destroyBean(panel);
        });
        this.panels = [];
    }
    destroy() {
        this.destroyPanels();
        super.destroy();
    }
}
FormatPanel.TEMPLATE = `<div class="ag-chart-format-wrapper"></div>`;
__decorate$D([
    PostConstruct
], FormatPanel.prototype, "init", null);

var __decorate$E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const CANVAS_CLASS = 'ag-chart-mini-thumbnail-canvas';
const ERROR_MESSAGE = 'AG Grid - chart update failed';
class MiniChart$1 extends Component {
    constructor(container, tooltipName) {
        super();
        this.size = 58;
        this.padding = 5;
        this.root = new integrated_charts_scene_exports.Group();
        const scene = new integrated_charts_scene_exports.Scene({
            window: window,
            document: window.document,
            width: this.size,
            height: this.size
        });
        scene.canvas.element.classList.add(CANVAS_CLASS);
        scene.root = this.root;
        scene.container = container;
        this.scene = scene;
        this.tooltipName = tooltipName;
    }
    init() {
        this.scene.canvas.element.title = this.chartTranslationService.translate(this.tooltipName);
        // Necessary to force scene graph render as we are not using the standalone factory.
        this.scene.render()
            .catch((e) => {
            console.error(`${ERROR_MESSAGE}`, e);
        });
    }
}
__decorate$E([
    Autowired('chartTranslationService')
], MiniChart$1.prototype, "chartTranslationService", void 0);
__decorate$E([
    PostConstruct
], MiniChart$1.prototype, "init", null);

var __decorate$F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class MiniChartWithAxes extends MiniChart$1 {
    constructor(container, tooltipName) {
        super(container, tooltipName);
        this.stroke = 'gray';
        this.axisOvershoot = 3;
    }
    addAxes() {
        const size = this.size;
        const padding = this.padding;
        const leftAxis = new integrated_charts_scene_exports.Line();
        leftAxis.x1 = padding;
        leftAxis.y1 = padding;
        leftAxis.x2 = padding;
        leftAxis.y2 = size - padding + this.axisOvershoot;
        leftAxis.stroke = this.stroke;
        const bottomAxis = new integrated_charts_scene_exports.Line();
        bottomAxis.x1 = padding - this.axisOvershoot + 1;
        bottomAxis.y1 = size - padding;
        bottomAxis.x2 = size - padding + 1;
        bottomAxis.y2 = size - padding;
        bottomAxis.stroke = this.stroke;
        const root = this.root;
        root.append(leftAxis);
        root.append(bottomAxis);
    }
}
__decorate$F([
    PostConstruct
], MiniChartWithAxes.prototype, "addAxes", null);

function createColumnRects(params) {
    const { stacked, size, padding, xScalePadding, xScaleDomain, yScaleDomain } = params;
    const xScale = new integrated_charts_scene_exports.BandScale();
    xScale.domain = xScaleDomain;
    xScale.range = [padding, size - padding];
    xScale.paddingInner = xScalePadding;
    xScale.paddingOuter = xScalePadding;
    const yScale = new integrated_charts_scene_exports.LinearScale();
    yScale.domain = yScaleDomain;
    yScale.range = [size - padding, padding];
    const createBars = (series, xScale, yScale) => {
        return series.map((datum, i) => {
            const top = yScale.convert(datum);
            const rect = new integrated_charts_scene_exports.Rect();
            rect.x = xScale.convert(i);
            rect.y = top;
            rect.width = xScale.bandwidth;
            rect.height = yScale.convert(0) - top;
            rect.strokeWidth = 0;
            rect.crisp = true;
            return rect;
        });
    };
    if (stacked) {
        return params.data.map((d) => createBars(d, xScale, yScale));
    }
    return createBars(params.data, xScale, yScale);
}
function createLinePaths(root, data, size, padding) {
    const xScale = new integrated_charts_scene_exports.LinearScale();
    xScale.domain = [0, 4];
    xScale.range = [padding, size - padding];
    const yScale = new integrated_charts_scene_exports.LinearScale();
    yScale.domain = [0, 10];
    yScale.range = [size - padding, padding];
    const lines = data.map((series) => {
        const line = new integrated_charts_scene_exports.Path();
        line.strokeWidth = 3;
        line.lineCap = 'round';
        line.fill = undefined;
        series.forEach((datum, i) => {
            line.path[i > 0 ? 'lineTo' : 'moveTo'](xScale.convert(i), yScale.convert(datum));
        });
        return line;
    });
    const linesGroup = new integrated_charts_scene_exports.Group();
    linesGroup.setClipRectInGroupCoordinateSpace(new integrated_charts_scene_exports.BBox(padding, padding, size - padding * 2, size - padding * 2));
    linesGroup.append(lines);
    root.append(linesGroup);
    return lines;
}
function createPolarPaths(root, data, size, radius, innerRadius, markerSize = 0) {
    const angleScale = new integrated_charts_scene_exports.LinearScale();
    angleScale.domain = [0, 7];
    angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);
    const radiusScale = new integrated_charts_scene_exports.LinearScale();
    radiusScale.domain = [0, 10];
    radiusScale.range = [radius, innerRadius];
    const markers = [];
    const paths = data.map((series) => {
        const path = new integrated_charts_scene_exports.Path();
        path.strokeWidth = 1;
        path.strokeOpacity = 0.5;
        path.lineCap = 'round';
        path.fill = undefined;
        path.fillOpacity = 0.8;
        series.forEach((datum, i) => {
            const angle = angleScale.convert(i);
            const r = radius + innerRadius - radiusScale.convert(datum);
            const x = r * Math.cos(angle);
            const y = r * Math.sin(angle);
            path.path[i > 0 ? 'lineTo' : 'moveTo'](x, y);
            if (markerSize > 0) {
                const marker = new integrated_charts_scene_exports.Circle();
                marker.x = x;
                marker.y = y;
                marker.size = markerSize;
                markers.push(marker);
            }
        });
        path.path.closePath();
        return path;
    });
    const group = new integrated_charts_scene_exports.Group();
    const center = size / 2;
    group.translationX = center;
    group.translationY = center;
    group.append([...paths, ...markers]);
    root.append(group);
    return { paths, markers };
}
function accumulateData(data) {
    let [min, max] = [Infinity, -Infinity];
    const processedData = data.reduce((acc, curr, currIndex) => {
        var _a;
        const previous = currIndex > 0 ? acc[currIndex - 1] : undefined;
        (_a = acc[currIndex]) !== null && _a !== void 0 ? _a : (acc[currIndex] = []);
        const current = acc[currIndex];
        curr.forEach((datum, datumIndex) => {
            if (previous) {
                datum += previous[datumIndex];
            }
            current[datumIndex] = datum;
            if (current[datumIndex] < min) {
                min = current[datumIndex];
            }
            if (current[datumIndex] > max) {
                max = current[datumIndex];
            }
        });
        return acc;
    }, []);
    return { processedData, min, max };
}

class MiniColumn extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, "groupedColumnTooltip");
        this.columnData = [2, 3, 4];
        const { root, columnData, size, padding } = this;
        this.columns = createColumnRects({
            stacked: false,
            root,
            data: columnData,
            size,
            padding,
            xScaleDomain: [0, 1, 2],
            yScaleDomain: [0, 4],
            xScalePadding: 0.3
        });
        root.append(this.columns);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.columns.forEach((column, i) => {
            column.fill = fills[i];
            column.stroke = strokes[i];
        });
    }
}
MiniColumn.chartType = 'groupedColumn';

class MiniStackedColumn extends MiniChartWithAxes {
    constructor(container, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniStackedColumn.data, yScaleDomain = [0, 16], tooltipName = "stackedColumnTooltip") {
        super(container, tooltipName);
        const { root, size, padding } = this;
        this.stackedColumns = createColumnRects({
            stacked: true,
            root,
            data,
            size,
            padding,
            xScaleDomain: [0, 1, 2],
            yScaleDomain,
            xScalePadding: 0.3,
        });
        root.append([].concat.apply([], this.stackedColumns));
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.stackedColumns.forEach((series, i) => series.forEach(column => {
            column.fill = fills[i];
            column.stroke = strokes[i];
        }));
    }
}
MiniStackedColumn.chartType = 'stackedColumn';
MiniStackedColumn.data = [
    [8, 12, 16],
    [6, 9, 12],
    [2, 3, 4]
];

class MiniNormalizedColumn extends MiniStackedColumn {
    constructor(container, fills, strokes, themeTemplateParameters, isCustomTheme) {
        super(container, fills, strokes, themeTemplateParameters, isCustomTheme, MiniNormalizedColumn.data, [0, 10], "normalizedColumnTooltip");
    }
}
MiniNormalizedColumn.chartType = 'normalizedColumn';
MiniNormalizedColumn.data = [
    [10, 10, 10],
    [6, 7, 8],
    [2, 4, 6]
];

class MiniBar extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, "groupedBarTooltip");
        const padding = this.padding;
        const size = this.size;
        const data = [2, 3, 4];
        const yScale = new integrated_charts_scene_exports.BandScale();
        yScale.domain = [0, 1, 2];
        yScale.range = [padding, size - padding];
        yScale.paddingInner = 0.3;
        yScale.paddingOuter = 0.3;
        const xScale = new integrated_charts_scene_exports.LinearScale();
        xScale.domain = [0, 4];
        xScale.range = [size - padding, padding];
        const bottom = xScale.convert(0);
        const height = yScale.bandwidth;
        this.bars = data.map((datum, i) => {
            const rect = new integrated_charts_scene_exports.Rect();
            rect.x = padding;
            rect.y = yScale.convert(i);
            rect.width = bottom - xScale.convert(datum);
            rect.height = height;
            rect.strokeWidth = 0;
            rect.crisp = true;
            return rect;
        });
        this.updateColors(fills, strokes);
        this.root.append(this.bars);
    }
    updateColors(fills, strokes) {
        this.bars.forEach((bar, i) => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        });
    }
}
MiniBar.chartType = 'groupedBar';

class MiniStackedBar extends MiniChartWithAxes {
    constructor(container, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniStackedBar.data, xScaleDomain = [0, 16], tooltipName = "stackedBarTooltip") {
        super(container, tooltipName);
        const size = this.size;
        const padding = this.padding;
        const yScale = new integrated_charts_scene_exports.BandScale();
        yScale.domain = [0, 1, 2];
        yScale.range = [padding, size - padding];
        yScale.paddingInner = 0.3;
        yScale.paddingOuter = 0.3;
        const xScale = new integrated_charts_scene_exports.LinearScale();
        xScale.domain = xScaleDomain;
        xScale.range = [size - padding, padding];
        const bottom = xScale.convert(0);
        const height = yScale.bandwidth;
        this.bars = data.map(series => series.map((datum, i) => {
            const rect = new integrated_charts_scene_exports.Rect();
            rect.x = padding;
            rect.y = yScale.convert(i);
            rect.width = bottom - xScale.convert(datum);
            rect.height = height;
            rect.strokeWidth = 0;
            rect.crisp = true;
            return rect;
        }));
        this.updateColors(fills, strokes);
        this.root.append([].concat.apply([], this.bars));
    }
    updateColors(fills, strokes) {
        this.bars.forEach((series, i) => series.forEach(bar => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        }));
    }
}
MiniStackedBar.chartType = 'stackedBar';
MiniStackedBar.data = [
    [8, 12, 16],
    [6, 9, 12],
    [2, 3, 4]
];

class MiniNormalizedBar extends MiniStackedBar {
    constructor(container, fills, strokes, themeTemplateParameters, isCustomTheme) {
        super(container, fills, strokes, themeTemplateParameters, isCustomTheme, MiniNormalizedBar.data, [0, 10], 'normalizedBarTooltip');
    }
}
MiniNormalizedBar.chartType = 'normalizedBar';
MiniNormalizedBar.data = [
    [10, 10, 10],
    [6, 7, 8],
    [2, 4, 6],
];

const toRadians$2 = integrated_charts_scene_exports.toRadians;
class MiniDonut extends MiniChart$1 {
    constructor(container, fills, strokes, _themeTemplateParameters, _isCustomTheme, centerRadiusScaler = 0.6, tooltipName = "donutTooltip") {
        super(container, tooltipName);
        const radius = (this.size - this.padding * 2) / 2;
        const center = radius + this.padding;
        const angles = [
            [toRadians$2(-90), toRadians$2(30)],
            [toRadians$2(30), toRadians$2(120)],
            [toRadians$2(120), toRadians$2(180)],
            [toRadians$2(180), toRadians$2(210)],
            [toRadians$2(210), toRadians$2(240)],
            [toRadians$2(240), toRadians$2(270)]
        ];
        this.sectors = angles.map(([startAngle, endAngle]) => {
            const sector = new integrated_charts_scene_exports.Sector();
            sector.centerX = center;
            sector.centerY = center;
            sector.innerRadius = radius * centerRadiusScaler;
            sector.outerRadius = radius;
            sector.startAngle = startAngle;
            sector.endAngle = endAngle;
            sector.stroke = undefined;
            sector.strokeWidth = 0;
            sector.inset = 0.75;
            return sector;
        });
        this.updateColors(fills, strokes);
        this.root.append(this.sectors);
    }
    updateColors(fills, strokes) {
        this.sectors.forEach((sector, i) => {
            sector.fill = fills[i % fills.length];
            sector.stroke = strokes[i % strokes.length];
        });
    }
}
MiniDonut.chartType = 'donut';

class MiniPie extends MiniDonut {
    constructor(container, fills, strokes, themeTemplateParameters, isCustomTheme) {
        super(container, fills, strokes, themeTemplateParameters, isCustomTheme, 0, "pieTooltip");
    }
}
MiniPie.chartType = 'pie';

class MiniLine extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, "lineTooltip");
        this.data = [
            [9, 7, 8, 5, 6],
            [5, 6, 3, 4, 1],
            [1, 3, 4, 8, 7]
        ];
        this.lines = createLinePaths(this.root, this.data, this.size, this.padding);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.lines.forEach((line, i) => {
            line.stroke = fills[i];
        });
    }
}
MiniLine.chartType = 'line';

class MiniScatter extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, "scatterTooltip");
        const size = this.size;
        const padding = this.padding;
        // [x, y] pairs
        const data = [
            [[0.3, 3], [1.1, 0.9], [2, 0.4], [3.4, 2.4]],
            [[0, 0.3], [1, 2], [2.4, 1.4], [3, 0]]
        ];
        const xScale = new integrated_charts_scene_exports.LinearScale();
        xScale.domain = [-0.5, 4];
        xScale.range = [padding * 2, size - padding];
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.domain = [-0.5, 3.5];
        yScale.range = [size - padding, padding];
        const points = [];
        data.forEach(series => {
            series.forEach(([x, y]) => {
                const arc = new integrated_charts_scene_exports.Arc();
                arc.strokeWidth = 0;
                arc.centerX = xScale.convert(x);
                arc.centerY = yScale.convert(y);
                arc.radius = 2.5;
                points.push(arc);
            });
        });
        this.points = points;
        this.updateColors(fills, strokes);
        const pointsGroup = new integrated_charts_scene_exports.Group();
        pointsGroup.setClipRectInGroupCoordinateSpace(new integrated_charts_scene_exports.BBox(padding, padding, size - padding * 2, size - padding * 2));
        pointsGroup.append(this.points);
        this.root.append(pointsGroup);
    }
    updateColors(fills, strokes) {
        this.points.forEach((line, i) => {
            line.stroke = strokes[i % strokes.length];
            line.fill = fills[i % fills.length];
        });
    }
}
MiniScatter.chartType = 'scatter';

class MiniBubble extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, "bubbleTooltip");
        const size = this.size;
        const padding = this.padding;
        // [x, y, radius] triples
        const data = [
            [[0.1, 0.3, 5], [0.5, 0.4, 7], [0.2, 0.8, 7]], [[0.8, 0.7, 5], [0.7, 0.3, 9]]
        ];
        const xScale = new integrated_charts_scene_exports.LinearScale();
        xScale.domain = [0, 1];
        xScale.range = [padding * 2, size - padding];
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.domain = [0, 1];
        yScale.range = [size - padding, padding];
        const points = [];
        data.forEach(series => {
            series.forEach(([x, y, radius]) => {
                const arc = new integrated_charts_scene_exports.Arc();
                arc.strokeWidth = 0;
                arc.centerX = xScale.convert(x);
                arc.centerY = yScale.convert(y);
                arc.radius = radius;
                arc.fillOpacity = 0.7;
                points.push(arc);
            });
        });
        this.points = points;
        this.updateColors(fills, strokes);
        const pointsGroup = new integrated_charts_scene_exports.Group();
        pointsGroup.setClipRectInGroupCoordinateSpace(new integrated_charts_scene_exports.BBox(padding, padding, size - padding * 2, size - padding * 2));
        pointsGroup.append(this.points);
        this.root.append(pointsGroup);
    }
    updateColors(fills, strokes) {
        this.points.forEach((line, i) => {
            line.stroke = strokes[i % strokes.length];
            line.fill = fills[i % fills.length];
        });
    }
}
MiniBubble.chartType = 'bubble';

class MiniArea extends MiniChartWithAxes {
    constructor(container, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniArea.data) {
        super(container, "groupedAreaTooltip");
        const size = this.size;
        const padding = this.padding;
        const xScale = new integrated_charts_scene_exports.BandScale();
        xScale.domain = [0, 1, 2];
        xScale.paddingInner = 1;
        xScale.paddingOuter = 0;
        xScale.range = [padding + 0.5, size - padding - 0.5];
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.domain = [0, 6];
        yScale.range = [size - padding + 0.5, padding];
        const xCount = data.length;
        const last = xCount * 2 - 1;
        const pathData = [];
        const bottomY = yScale.convert(0);
        data.forEach((datum, i) => {
            const x = xScale.convert(i);
            datum.forEach((yDatum, j) => {
                const y = yScale.convert(yDatum);
                const points = pathData[j] || (pathData[j] = []);
                points[i] = {
                    x,
                    y
                };
                points[last - i] = {
                    x,
                    y: bottomY
                };
            });
        });
        this.areas = pathData.reverse().map(points => {
            const area = new integrated_charts_scene_exports.Path();
            area.strokeWidth = 1;
            area.strokeOpacity = 0.75;
            area.fillOpacity = 0.7;
            const path = area.path;
            path.clear();
            points.forEach((point, i) => path[i > 0 ? "lineTo" : "moveTo"](point.x, point.y));
            path.closePath();
            return area;
        });
        this.updateColors(fills, strokes);
        this.root.append(this.areas);
    }
    updateColors(fills, strokes) {
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
            area.stroke = strokes[i];
        });
    }
}
MiniArea.chartType = 'area';
MiniArea.data = [
    [1, 3, 5],
    [2, 6, 4],
    [5, 3, 1]
];

class MiniStackedArea extends MiniChartWithAxes {
    constructor(container, fills, strokes, _themeTemplateParameters, _isCustomTheme, data = MiniStackedArea.data, tooltipName = "stackedAreaTooltip") {
        super(container, tooltipName);
        const size = this.size;
        const padding = this.padding;
        const xScale = new integrated_charts_scene_exports.BandScale();
        xScale.domain = [0, 1, 2];
        xScale.paddingInner = 1;
        xScale.paddingOuter = 0;
        xScale.range = [padding + 0.5, size - padding - 0.5];
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.domain = [0, 16];
        yScale.range = [size - padding + 0.5, padding + 0.5];
        const xCount = data.length;
        const last = xCount * 2 - 1;
        const pathData = [];
        data.forEach((datum, i) => {
            const x = xScale.convert(i);
            let total = 0;
            datum.forEach((yDatum, j) => {
                const y = yScale.convert(total + yDatum);
                const points = pathData[j] || (pathData[j] = []);
                points[i] = {
                    x,
                    y
                };
                points[last - i] = {
                    x,
                    y: yScale.convert(total) // bottom y
                };
                total += yDatum;
            });
        });
        this.areas = pathData.map(points => {
            const area = new integrated_charts_scene_exports.Path();
            area.strokeWidth = 0;
            const path = area.path;
            path.clear();
            points.forEach((point, i) => path[i > 0 ? "lineTo" : "moveTo"](point.x, point.y));
            path.closePath();
            return area;
        });
        this.updateColors(fills, strokes);
        this.root.append(this.areas);
    }
    updateColors(fills, strokes) {
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
            area.stroke = strokes[i];
        });
    }
}
MiniStackedArea.chartType = 'stackedArea';
MiniStackedArea.data = [
    [2, 3, 2],
    [3, 6, 5],
    [6, 2, 2]
];

class MiniNormalizedArea extends MiniStackedArea {
    constructor(container, fills, strokes, themeTemplateParameters, isCustomTheme, data = MiniNormalizedArea.data) {
        super(container, fills, strokes, themeTemplateParameters, isCustomTheme, data, "normalizedAreaTooltip");
    }
}
MiniNormalizedArea.chartType = 'normalizedArea';
MiniNormalizedArea.data = MiniStackedArea.data.map(stack => {
    const sum = stack.reduce((p, c) => p + c, 0);
    return stack.map(v => v / sum * 16);
});

class MiniHistogram extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, "histogramTooltip");
        const padding = this.padding;
        const size = this.size;
        // approx normal curve
        const data = [2, 5, 11, 13, 10, 6, 1];
        const xScale = new integrated_charts_scene_exports.LinearScale();
        xScale.domain = [0, data.length];
        xScale.range = [padding, size - padding];
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.domain = [0, data.reduce((a, b) => Math.max(a, b), 0)];
        yScale.range = [size - padding, padding];
        const bottom = yScale.convert(0);
        this.bars = data.map((datum, i) => {
            const top = yScale.convert(datum);
            const left = xScale.convert(i);
            const right = xScale.convert(i + 1);
            const rect = new integrated_charts_scene_exports.Rect();
            rect.x = left;
            rect.y = top;
            rect.width = right - left;
            rect.height = bottom - top;
            rect.strokeWidth = 1;
            rect.strokeOpacity = 0.75;
            rect.crisp = true;
            return rect;
        });
        this.updateColors(fills, strokes);
        this.root.append(this.bars);
    }
    updateColors([fill], [stroke]) {
        this.bars.forEach(bar => {
            bar.fill = fill;
            bar.stroke = stroke;
        });
    }
}
MiniHistogram.chartType = 'histogram';

var __decorate$G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class MiniChartWithPolarAxes extends MiniChart$1 {
    constructor(container, tooltipName) {
        super(container, tooltipName);
        this.stroke = 'gray';
        this.showRadiusAxisLine = true;
        this.showAngleAxisLines = true;
    }
    addAxes() {
        const size = this.size;
        const padding = this.padding;
        const combinedPadding = padding * 2;
        const axisLineRadius = (size - combinedPadding) / 2;
        const gridRadii = this.showAngleAxisLines ? [
            axisLineRadius,
            axisLineRadius * 0.8,
            axisLineRadius * 0.6,
            axisLineRadius * 0.4,
        ] : [];
        const radiusAxisLine = new integrated_charts_scene_exports.Line();
        radiusAxisLine.x1 = size / 2;
        radiusAxisLine.y1 = padding;
        radiusAxisLine.x2 = size / 2;
        radiusAxisLine.y2 = size - padding - axisLineRadius - gridRadii[gridRadii.length - 1];
        radiusAxisLine.stroke = this.stroke;
        radiusAxisLine.strokeOpacity = 0.5;
        radiusAxisLine.fill = undefined;
        radiusAxisLine.visible = this.showRadiusAxisLine;
        const x = padding + axisLineRadius;
        this.gridLines = gridRadii.map((radius, index) => {
            const gridLine = new integrated_charts_scene_exports.Path();
            gridLine.path.arc(x, x, radius, 0, 2 * Math.PI);
            gridLine.strokeWidth = 1;
            gridLine.stroke = this.stroke;
            gridLine.strokeOpacity = index === 0 ? 0.5 : 0.2;
            gridLine.fill = undefined;
            return gridLine;
        });
        const root = this.root;
        root.append(radiusAxisLine);
        if (this.gridLines.length > 0)
            root.append(this.gridLines);
    }
}
__decorate$G([
    PostConstruct
], MiniChartWithPolarAxes.prototype, "addAxes", null);

class MiniRadialColumn extends MiniChartWithPolarAxes {
    constructor(container, fills, strokes) {
        super(container, 'radialColumnTooltip');
        this.data = [
            [6, 8, 10, 2, 6, 5],
            [4, 4, 3, 6, 4, 4],
            [5, 4, 2, 9, 8, 9],
        ];
        this.showRadiusAxisLine = false;
        const { padding, size, data } = this;
        const radius = (size - padding * 2) / 2;
        const innerRadiusRatio = 0.4;
        const axisInnerRadius = radius * innerRadiusRatio;
        const angleScale = new integrated_charts_scene_exports.BandScale();
        angleScale.domain = data[0].map((_, index) => index);
        angleScale.range = [0, 2 * Math.PI];
        angleScale.paddingInner = 0;
        angleScale.paddingOuter = 0;
        const bandwidth = angleScale.bandwidth * 0.7;
        const { processedData, max } = accumulateData(data);
        const radiusScale = new integrated_charts_scene_exports.LinearScale();
        radiusScale.domain = [0, max];
        radiusScale.range = [axisInnerRadius, radius];
        const center = this.size / 2;
        this.series = processedData.map((series, seriesIndex) => {
            const firstSeries = seriesIndex === 0;
            const previousSeries = firstSeries ? undefined : processedData[seriesIndex - 1];
            const seriesGroup = new integrated_charts_scene_exports.Group({ zIndex: 1000000 });
            const seriesColumns = series.map((datum, i) => {
                const previousDatum = previousSeries === null || previousSeries === void 0 ? void 0 : previousSeries[i];
                const outerRadius = radiusScale.convert(datum);
                const innerRadius = radiusScale.convert(previousDatum !== null && previousDatum !== void 0 ? previousDatum : 0);
                const startAngle = angleScale.convert(i);
                const endAngle = startAngle + bandwidth;
                const columnWidth = integrated_charts_scene_exports.getRadialColumnWidth(startAngle, endAngle, radius, 0.5, 0.5);
                const column = new integrated_charts_scene_exports.RadialColumnShape();
                column.scalingCenterX = center;
                column.scalingCenterY = center;
                column.columnWidth = columnWidth;
                column.innerRadius = innerRadius;
                column.outerRadius = outerRadius;
                column.startAngle = startAngle;
                column.endAngle = endAngle;
                column.isBeveled = true;
                column.axisInnerRadius = axisInnerRadius;
                column.axisOuterRadius = radius;
                column.stroke = undefined;
                column.strokeWidth = 0;
                return column;
            });
            seriesGroup.append(seriesColumns);
            seriesGroup.translationX = center;
            seriesGroup.translationY = center;
            return seriesGroup;
        });
        this.root.append(this.series);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.series.forEach((group, i) => {
            var _a;
            (_a = group.children) === null || _a === void 0 ? void 0 : _a.forEach((sector) => {
                sector.fill = fills[i % fills.length];
                sector.stroke = strokes[i % strokes.length];
            });
        });
    }
}
MiniRadialColumn.chartType = 'radialColumn';

class MiniRadialBar extends MiniChartWithPolarAxes {
    constructor(container, fills, strokes) {
        super(container, 'radialBarTooltip');
        this.data = [
            [6, 8, 10],
            [4, 4, 3],
            [5, 4, 2],
        ];
        this.showRadiusAxisLine = false;
        const radius = (this.size - this.padding) / 2;
        const innerRadiusRatio = 0.4;
        const innerRadius = radius * innerRadiusRatio;
        const totalRadius = radius + innerRadius;
        const radiusScale = new integrated_charts_scene_exports.BandScale();
        radiusScale.domain = this.data[0].map((_, index) => index);
        radiusScale.range = [radius, innerRadius];
        radiusScale.paddingInner = 0.5;
        radiusScale.paddingOuter = 0;
        const bandwidth = radiusScale.bandwidth;
        const { processedData, max } = accumulateData(this.data);
        const angleScale = new integrated_charts_scene_exports.LinearScale();
        angleScale.domain = [0, Math.ceil(max * 1.5)];
        const start = (3 / 2) * Math.PI;
        const end = start + 2 * Math.PI;
        angleScale.range = [start, end];
        const center = this.size / 2;
        this.series = processedData.map((series, index) => {
            const previousSeries = index < 0 ? undefined : processedData[index - 1];
            const seriesGroup = new integrated_charts_scene_exports.Group({ zIndex: 1000000 });
            const seriesSectors = series.map((datum, i) => {
                var _a;
                const previousDatum = (_a = previousSeries === null || previousSeries === void 0 ? void 0 : previousSeries[i]) !== null && _a !== void 0 ? _a : 0;
                const innerRadius = totalRadius - radiusScale.convert(i);
                const outerRadius = innerRadius + bandwidth;
                const startAngle = angleScale.convert(previousDatum);
                const endAngle = angleScale.convert(datum);
                const sector = new integrated_charts_scene_exports.Sector();
                sector.centerX = center;
                sector.centerY = center;
                sector.innerRadius = innerRadius;
                sector.outerRadius = outerRadius;
                sector.startAngle = startAngle;
                sector.endAngle = endAngle;
                sector.stroke = undefined;
                sector.strokeWidth = 0;
                return sector;
            });
            seriesGroup.append(seriesSectors);
            return seriesGroup;
        });
        this.root.append(this.series);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.series.forEach((group, i) => {
            var _a;
            (_a = group.children) === null || _a === void 0 ? void 0 : _a.forEach((sector) => {
                sector.fill = fills[i % fills.length];
                sector.stroke = strokes[i % strokes.length];
            });
        });
    }
}
MiniRadialBar.chartType = 'radialBar';

class MiniRadarLine extends MiniChartWithPolarAxes {
    constructor(container, fills, strokes) {
        super(container, 'radarLineTooltip');
        this.markerSize = 4;
        this.data = [
            [8, 7, 8, 7, 8, 8, 7, 8],
            [6, 8, 5, 10, 6, 7, 4, 6],
            [0, 3, 3, 5, 4, 4, 2, 0]
        ];
        this.showRadiusAxisLine = false;
        const radius = (this.size - this.padding * 2) / 2;
        const innerRadius = 0;
        const { paths, markers } = createPolarPaths(this.root, this.data, this.size, radius, innerRadius, this.markerSize);
        this.lines = paths;
        this.markers = markers;
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.lines.forEach((line, i) => {
            const n = this.data[i].length;
            line.stroke = fills[i];
            const startIdx = i * n;
            const endIdx = startIdx + n;
            const markers = this.markers.slice(startIdx, endIdx);
            markers.forEach((marker) => {
                marker.stroke = strokes[i];
                marker.fill = fills[i];
            });
        });
    }
}
MiniRadarLine.chartType = 'radarLine';

class MiniRadarArea extends MiniChartWithPolarAxes {
    constructor(container, fills, strokes) {
        super(container, 'radarAreaTooltip');
        this.data = [
            [8, 10, 5, 7, 4, 1, 5, 8],
            [1, 1, 2, 7, 7, 8, 10, 1],
            [4, 5, 9, 9, 4, 2, 3, 4]
        ];
        this.showRadiusAxisLine = false;
        const radius = (this.size - this.padding * 2) / 2;
        const innerRadius = radius - this.size * 0.3;
        this.areas = createPolarPaths(this.root, this.data, this.size, radius, innerRadius).paths;
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
            area.stroke = strokes[i];
        });
    }
}
MiniRadarArea.chartType = 'radarArea';

class MiniNightingale extends MiniChartWithPolarAxes {
    constructor(container, fills, strokes) {
        super(container, 'nightingaleTooltip');
        this.data = [
            [6, 10, 9, 8, 7, 8],
            [4, 6, 5, 4, 5, 5],
            [3, 5, 4, 3, 4, 7],
        ];
        this.showRadiusAxisLine = false;
        const radius = (this.size - this.padding * 2) / 2;
        const angleScale = new integrated_charts_scene_exports.BandScale();
        angleScale.domain = this.data[0].map((_, index) => index);
        angleScale.range = [-Math.PI, Math.PI];
        angleScale.paddingInner = 0;
        angleScale.paddingOuter = 0;
        const bandwidth = angleScale.bandwidth * 0.7;
        const { processedData, max } = accumulateData(this.data);
        const radiusScale = new integrated_charts_scene_exports.LinearScale();
        radiusScale.domain = [0, max];
        radiusScale.range = [0, radius];
        const center = this.size / 2;
        this.series = processedData.map((series, index) => {
            const previousSeries = index < 0 ? undefined : processedData[index - 1];
            const seriesGroup = new integrated_charts_scene_exports.Group({ zIndex: 1000000 });
            const seriesSectors = series.map((datum, i) => {
                const previousDatum = previousSeries === null || previousSeries === void 0 ? void 0 : previousSeries[i];
                const outerRadius = radiusScale.convert(datum);
                const innerRadius = radiusScale.convert(previousDatum !== null && previousDatum !== void 0 ? previousDatum : 0);
                const startAngle = angleScale.convert(i);
                const endAngle = startAngle + bandwidth;
                const sector = new integrated_charts_scene_exports.Sector();
                sector.centerX = center;
                sector.centerY = center;
                sector.innerRadius = innerRadius;
                sector.outerRadius = outerRadius;
                sector.startAngle = startAngle;
                sector.endAngle = endAngle;
                sector.stroke = undefined;
                sector.strokeWidth = 0;
                return sector;
            });
            seriesGroup.append(seriesSectors);
            return seriesGroup;
        });
        this.root.append(this.series);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.series.forEach((group, i) => {
            var _a;
            (_a = group.children) === null || _a === void 0 ? void 0 : _a.forEach((sector) => {
                sector.fill = fills[i % fills.length];
                sector.stroke = strokes[i % strokes.length];
            });
        });
    }
}
MiniNightingale.chartType = 'nightingale';

class MiniRangeBar extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, 'rangeBarTooltip');
        const data = [3, 3.5, 3];
        this.bars = this.createRangeBar(this.root, data, this.size, this.padding, 'vertical');
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.bars.forEach((bar, i) => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        });
    }
    createRangeBar(root, data, size, padding, direction) {
        const barAlongX = direction === 'horizontal';
        const scalePadding = 2 * padding;
        const xScale = new integrated_charts_scene_exports.BandScale();
        xScale.domain = data.map((_, index) => index);
        xScale.range = [padding, size - padding];
        xScale.paddingInner = 0.3;
        xScale.paddingOuter = 0.3;
        const lowRatio = 0.7;
        const highRatio = 1.3;
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.domain = [
            data.reduce((a, b) => Math.min(a, b), Infinity) * lowRatio,
            data.reduce((a, b) => Math.max(a, b), 0) * highRatio,
        ];
        yScale.range = [scalePadding, size - scalePadding];
        const width = xScale.bandwidth;
        const bars = data.map((datum, i) => {
            const [low, high] = [datum * lowRatio, datum * highRatio];
            const x = xScale.convert(i);
            const y = yScale.convert(low);
            const height = yScale.convert(high) - y;
            const rect = new integrated_charts_scene_exports.Rect();
            rect.x = barAlongX ? y : x;
            rect.y = barAlongX ? x : y;
            rect.width = barAlongX ? height : width;
            rect.height = barAlongX ? width : height;
            rect.strokeWidth = 0;
            rect.crisp = true;
            return rect;
        });
        root.append(bars);
        return bars;
    }
}
MiniRangeBar.chartType = 'rangeBar';

class MiniRangeArea extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, 'rangeAreaTooltip');
        // Create a set of repeating zigzag-shaped data series to use as the chart data
        const period = 4;
        const dataSeriesMidpoints = [
            zigzag({ offset: 0.375 * period, length: period, pattern: { low: 3, high: 5, period } }),
            zigzag({ offset: 0.375 * period, length: period, pattern: { low: 2.25, high: 4.25, period } }),
            zigzag({ offset: 0.75 * period, length: period, pattern: { low: 2.5, high: 4.5, period } }),
        ];
        const dataSeriesWidth = 1.75;
        const data = dataSeriesMidpoints.map((series) => series.map(([x, y]) => ({
            x,
            low: y - 0.5 * dataSeriesWidth,
            high: y + 0.5 * dataSeriesWidth,
        })));
        const { lines, areas } = this.createRangeArea(this.root, data, this.size, this.padding);
        this.lines = lines;
        this.areas = areas;
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        // Swap the secondary and tertiary colors to match the designs
        fills = swapArrayItems(fills, 1, 2);
        strokes = swapArrayItems(strokes, 1, 2);
        this.lines.forEach(([highLine, lowLine], i) => {
            highLine.fill = undefined;
            highLine.stroke = strokes[i];
            lowLine.fill = undefined;
            lowLine.stroke = strokes[i];
        });
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
        });
    }
    createRangeArea(root, data, size, padding) {
        const xMin = data.reduce((acc, series) => series.reduce((acc, { x }) => Math.min(acc, x), acc), Infinity);
        const xMax = data.reduce((acc, series) => series.reduce((acc, { x }) => Math.max(acc, x), acc), -Infinity);
        const yMin = data.reduce((acc, series) => series.reduce((acc, { low }) => Math.min(acc, low), acc), Infinity);
        const yMax = data.reduce((acc, series) => series.reduce((acc, { high }) => Math.max(acc, high), acc), -Infinity);
        const xScale = new integrated_charts_scene_exports.LinearScale();
        xScale.domain = [xMin, xMax];
        xScale.range = [padding, size - padding];
        const scalePadding = 2 * padding;
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.domain = [yMin, yMax];
        yScale.range = [size - scalePadding, scalePadding];
        const lines = [];
        const areas = [];
        const lowPoints = data.map((series) => {
            const highLine = new integrated_charts_scene_exports.Path();
            const lowLine = new integrated_charts_scene_exports.Path();
            const area = new integrated_charts_scene_exports.Path();
            lines.push([highLine, lowLine]);
            areas.push(area);
            highLine.strokeWidth = 0;
            lowLine.strokeWidth = 0;
            area.strokeWidth = 0;
            area.fillOpacity = 0.8;
            highLine.path.clear();
            lowLine.path.clear();
            area.path.clear();
            return series.map((datum, datumIndex) => {
                const { x, low, high } = datum;
                const scaledX = xScale.convert(x);
                const yLow = yScale.convert(low);
                const yHigh = yScale.convert(high);
                const command = datumIndex > 0 ? 'lineTo' : 'moveTo';
                highLine.path[command](scaledX, yHigh);
                lowLine.path[command](scaledX, yLow);
                area.path[command](scaledX, yHigh);
                return [scaledX, yLow];
            });
        });
        lowPoints.forEach((seriesLowPoints, seriesIndex) => {
            const n = seriesLowPoints.length - 1;
            const area = areas[seriesIndex];
            for (let datumIndex = n; datumIndex >= 0; datumIndex--) {
                const [x, y] = seriesLowPoints[datumIndex];
                area.path['lineTo'](x, y);
            }
        });
        root.append(areas.concat(...lines));
        return { lines, areas };
    }
}
MiniRangeArea.chartType = 'rangeArea';
function zigzag(options) {
    const { offset, length, pattern } = options;
    // Generate [x, y] points for all inflection points of the zigzag pattern that fall within the range
    const points = getZigzagInflectionPoints(offset, length, pattern);
    // Ensure the first and last points are clamped to the start and end of the range
    const xMin = 0;
    const xMax = length;
    if (points.length === 0 || points[0][0] !== xMin)
        points.unshift(getZigzagPoint(xMin, offset, pattern));
    if (points[points.length - 1][0] !== xMax)
        points.push(getZigzagPoint(xMax, offset, pattern));
    return points;
    function getZigzagInflectionPoints(offset, length, pattern) {
        const { period } = pattern;
        const scaledOffset = offset / period;
        const patternInflectionPoints = [0, 0.5];
        const inflectionPoints = patternInflectionPoints
            .map((x) => x - scaledOffset)
            // Clamp offset points to the unit range [0, 1)
            .map(getRemainderAbs)
            .sort((a, b) => a - b);
        const repeatedPoints = Array.from({ length: Math.floor(inflectionPoints.length * (period / length)) }, (_, i) => inflectionPoints[i % inflectionPoints.length] + Math.floor(i / inflectionPoints.length));
        return repeatedPoints.map((x) => x * period).map((x) => getZigzagPoint(x, offset, pattern));
    }
    function getZigzagPoint(x, offset, pattern) {
        return [x, getZigzagValue(offset + x, pattern)];
    }
    function getZigzagValue(x, pattern) {
        const { low, high, period } = pattern;
        const scaledX = getRemainderAbs(x / period);
        const y = scaledX > 0.5 ? 1 - 2 * (scaledX - 0.5) : 2 * scaledX;
        return low + (high - low) * y;
    }
}
function getRemainderAbs(value) {
    const remainder = value % 1;
    return remainder < 0 ? remainder + 1 : remainder;
}
function swapArrayItems(items, leftIndex, rightIndex) {
    const results = [...items];
    const temp = results[leftIndex];
    results[leftIndex] = results[rightIndex];
    results[rightIndex] = temp;
    return results;
}

class MiniBoxPlot extends MiniChartWithAxes {
    constructor(container, fills, strokes, themeTemplateParameters, isCustomTheme) {
        super(container, 'boxPlotTooltip');
        const padding = this.padding;
        const size = this.size;
        const data = [11, 11.5, 10.5];
        const maxRatio = 1.2;
        const q3Ratio = 1.1;
        const q1Ratio = 0.9;
        const minRatio = 0.8;
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.domain = [
            data.reduce((a, b) => Math.min(a, b), Infinity) * minRatio,
            data.reduce((a, b) => Math.max(a, b), 0) * maxRatio,
        ];
        yScale.range = [size - 1.5 * padding, padding];
        const xScale = new integrated_charts_scene_exports.BandScale();
        xScale.domain = data.map((_, index) => index);
        xScale.range = [padding, size - padding];
        xScale.paddingInner = 0.4;
        xScale.paddingOuter = 0.2;
        const bandwidth = Math.round(xScale.bandwidth);
        const halfBandWidth = Math.round(xScale.bandwidth / 2);
        this.boxPlotGroups = data.map((datum, i) => {
            let [minValue, q1Value, q3Value, maxValue] = [
                datum * minRatio,
                datum * q1Ratio,
                datum * q3Ratio,
                datum * maxRatio,
            ];
            const top = Math.round(yScale.convert(q3Value));
            const left = Math.round(xScale.convert(i));
            const right = Math.round(left + bandwidth);
            const bottom = Math.round(yScale.convert(q1Value));
            const min = Math.round(yScale.convert(minValue));
            const mid = Math.round(yScale.convert(datum));
            const max = Math.round(yScale.convert(maxValue));
            const whiskerX = left + halfBandWidth;
            const boxPlotGroup = new integrated_charts_scene_exports.Group();
            const box = new integrated_charts_scene_exports.Rect();
            const median = new integrated_charts_scene_exports.Line();
            const topWhisker = new integrated_charts_scene_exports.Line();
            const bottomWhisker = new integrated_charts_scene_exports.Line();
            const topCap = new integrated_charts_scene_exports.Line();
            const bottomCap = new integrated_charts_scene_exports.Line();
            box.x = left;
            box.y = top;
            box.width = bandwidth;
            box.height = bottom - top;
            box.strokeWidth = 1;
            box.strokeOpacity = 0.75;
            box.crisp = true;
            this.setLineProperties(median, left, right, mid, mid);
            this.setLineProperties(topWhisker, whiskerX, whiskerX, max, top);
            this.setLineProperties(bottomWhisker, whiskerX, whiskerX, min, bottom);
            this.setLineProperties(topCap, left, right, max, max);
            this.setLineProperties(bottomCap, left, right, min, min);
            boxPlotGroup.append([box, median, topWhisker, bottomWhisker, topCap, bottomCap]);
            return boxPlotGroup;
        });
        this.updateColors(fills, strokes, themeTemplateParameters, isCustomTheme);
        this.root.append(this.boxPlotGroups);
    }
    updateColors(fills, strokes, themeTemplateParameters, isCustomTheme) {
        var _a;
        const themeBackgroundColor = themeTemplateParameters === null || themeTemplateParameters === void 0 ? void 0 : themeTemplateParameters.properties.get(integrated_charts_theme_exports.DEFAULT_BACKGROUND_COLOUR);
        const backgroundFill = (_a = (Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor)) !== null && _a !== void 0 ? _a : 'white';
        this.boxPlotGroups.forEach((group, i) => {
            var _a;
            (_a = group.children) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
                const fill = fills[i % fills.length];
                node.fill = isCustomTheme ? fill : sparklines_util_exports.Color.interpolate(fill, backgroundFill)(0.7);
                node.stroke = strokes[i % strokes.length];
            });
        });
    }
    setLineProperties(line, x1, x2, y1, y2) {
        line.x1 = x1;
        line.x2 = x2;
        line.y1 = y1;
        line.y2 = y2;
        line.strokeOpacity = 0.75;
    }
}
MiniBoxPlot.chartType = 'boxPlot';

class MiniTreemap extends MiniChart$1 {
    constructor(container, fills, strokes, themeTemplate, isCustomTheme) {
        super(container, 'treemapTooltip');
        const { size, padding } = this;
        const data = [
            [1, 1],
            [3, 2, 1],
        ];
        const treeSize = data.length;
        const treePadding = treeSize % 2 === 0 ? 0.3 : 0.2;
        const range = [padding, size - padding];
        const columns = data.length;
        const columnParts = (columns * (columns + 1)) / 2;
        const columnPadding = treePadding / (columns - 1);
        const availableRange = range[1] - range[0];
        const availableWidth = availableRange - treePadding;
        let previousX = range[0];
        this.rects = data.reduce((rects, d, columnIndex) => {
            rects !== null && rects !== void 0 ? rects : (rects = []);
            const widthRatio = (columns - columnIndex) / columnParts;
            const width = availableWidth * widthRatio;
            const rows = d.length;
            const rowParts = d.reduce((parts, ratio) => (parts += ratio), 0);
            const rowPadding = treePadding / (rows - 1 || 1);
            const availableHeight = rows > 1 ? availableRange - treePadding : availableRange;
            let previousY = range[0];
            const xRects = d.map((ratio) => {
                const rect = new integrated_charts_scene_exports.Rect();
                const height = (availableHeight * ratio) / rowParts;
                rect.x = previousX;
                rect.y = previousY;
                rect.width = width;
                rect.height = height;
                rect.strokeWidth = 0.75;
                rect.crisp = true;
                previousY += height + rowPadding;
                return rect;
            });
            previousX += width + columnPadding;
            rects.push(...xRects);
            return rects;
        }, []);
        this.updateColors(fills, strokes, themeTemplate, isCustomTheme);
        const rectGroup = new integrated_charts_scene_exports.Group();
        rectGroup.setClipRectInGroupCoordinateSpace(new integrated_charts_scene_exports.BBox(padding, padding, size - padding, size - padding));
        rectGroup.append(this.rects);
        this.root.append(rectGroup);
    }
    updateColors(fills, strokes, themeTemplate, isCustomTheme) {
        var _a;
        const { properties } = themeTemplate !== null && themeTemplate !== void 0 ? themeTemplate : {};
        const defaultBackgroundColor = properties === null || properties === void 0 ? void 0 : properties.get(integrated_charts_theme_exports.DEFAULT_BACKGROUND_COLOUR);
        const backgroundFill = (_a = (Array.isArray(defaultBackgroundColor) ? defaultBackgroundColor[0] : defaultBackgroundColor)) !== null && _a !== void 0 ? _a : 'white';
        this.rects.forEach((rect, i) => {
            rect.fill = fills[i % strokes.length];
            rect.stroke = isCustomTheme ? strokes[i % strokes.length] : backgroundFill;
        });
    }
}
MiniTreemap.chartType = 'treemap';

class MiniSunburst extends MiniChartWithPolarAxes {
    constructor(container, fills, strokes) {
        super(container, 'sunburstTooltip');
        // Hierarchical data using multidimensional array
        this.data = [
            [[], []],
            [[], []],
            [[], []],
        ];
        // Rotate the chart by the given angle (-90 degrees)
        this.angleOffset = -Math.PI / 2;
        this.innerRadiusRatio = 0;
        this.showRadiusAxisLine = false;
        this.showAngleAxisLines = false;
        const { data, size, padding, angleOffset, innerRadiusRatio } = this;
        const radius = (size - padding * 2) / 2;
        const angleRange = [angleOffset + 0, angleOffset + 2 * Math.PI];
        const angleExtent = Math.abs(angleRange[1] - angleRange[0]);
        const radiusRange = [radius * innerRadiusRatio, radius];
        const radiusExtent = Math.abs(radiusRange[1] - radiusRange[0]);
        let maxDepth = 0;
        const findMaxDepth = (data, parentDepth) => {
            data.forEach((child) => {
                const depth = parentDepth + 1;
                maxDepth = Math.max(maxDepth, depth);
                findMaxDepth(child, depth);
            });
        };
        findMaxDepth(data, 0);
        const radiusRatio = radiusExtent / maxDepth;
        const center = this.size / 2;
        const startAngle = angleRange[0];
        this.series = [];
        const createSectors = (data, depth, startAngle, availableAngle, group) => {
            const isArray = Array.isArray(data);
            if (!isArray) {
                return;
            }
            const childDepth = depth + 1;
            let previousAngle = startAngle;
            data.forEach((child, childIndex, children) => {
                let childGroup = group;
                if (!childGroup) {
                    childGroup = new integrated_charts_scene_exports.Group();
                    this.series.push(childGroup);
                }
                const innerRadius = radiusRange[0] + depth * radiusRatio;
                const outerRadius = radiusRange[0] + childDepth * radiusRatio;
                const angleRatio = 1 / children.length;
                const start = previousAngle;
                const end = start + availableAngle * angleRatio;
                const sector = new integrated_charts_scene_exports.Sector();
                sector.centerX = center;
                sector.centerY = center;
                sector.innerRadius = innerRadius;
                sector.outerRadius = outerRadius;
                sector.startAngle = start;
                sector.endAngle = end;
                sector.stroke = undefined;
                sector.strokeWidth = 0;
                sector.inset = 0.75;
                previousAngle = end;
                childGroup.append(sector);
                createSectors(child, childDepth, start, Math.abs(end - start), childGroup);
            });
        };
        createSectors(data, 0, startAngle, angleExtent);
        this.root.append(this.series);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.series.forEach((group, i) => {
            var _a;
            (_a = group.children) === null || _a === void 0 ? void 0 : _a.forEach((sector) => {
                sector.fill = fills[i % fills.length];
                sector.stroke = strokes[i % strokes.length];
            });
        });
    }
}
MiniSunburst.chartType = 'sunburst';

class MiniHeatmap extends MiniChart$1 {
    constructor(container, fills, strokes, themeTemplate, isCustomTheme) {
        var _a, _b;
        super(container, 'heatmapTooltip');
        const { size, padding } = this;
        const heatmapSize = 3;
        const data = Array.from({ length: heatmapSize }, (_, __) => Array.from({ length: heatmapSize }, (_, yIndex) => yIndex));
        const domain = data.map((_, index) => index);
        const xScale = new integrated_charts_scene_exports.BandScale();
        xScale.domain = domain;
        xScale.range = [padding, size - padding];
        xScale.paddingInner = 0.01;
        xScale.paddingOuter = 0.1;
        const yScale = new integrated_charts_scene_exports.BandScale();
        yScale.domain = domain;
        yScale.range = [padding, size - padding];
        yScale.paddingInner = 0.01;
        yScale.paddingOuter = 0.1;
        const width = (_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0;
        const height = (_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0;
        this.rects = data.reduce((rects, d, index) => {
            rects !== null && rects !== void 0 ? rects : (rects = []);
            const xRects = d.map((_, yIndex) => {
                const rect = new integrated_charts_scene_exports.Rect();
                rect.x = xScale.convert(index);
                rect.y = yScale.convert(yIndex);
                rect.width = width;
                rect.height = height;
                rect.strokeWidth = 0;
                rect.crisp = true;
                return rect;
            });
            rects.push(...xRects);
            return rects;
        }, []);
        this.updateColors(fills, strokes, themeTemplate, isCustomTheme);
        const rectGroup = new integrated_charts_scene_exports.Group();
        rectGroup.setClipRectInGroupCoordinateSpace(new integrated_charts_scene_exports.BBox(padding, padding, size - padding, size - padding));
        rectGroup.append(this.rects);
        this.root.append(rectGroup);
    }
    updateColors(fills, strokes, themeTemplate, isCustomTheme) {
        var _a;
        const { properties } = themeTemplate !== null && themeTemplate !== void 0 ? themeTemplate : {};
        const defaultColorRange = properties === null || properties === void 0 ? void 0 : properties.get(integrated_charts_theme_exports.DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);
        const defaultBackgroundColor = properties === null || properties === void 0 ? void 0 : properties.get(integrated_charts_theme_exports.DEFAULT_BACKGROUND_COLOUR);
        const backgroundFill = (_a = (Array.isArray(defaultBackgroundColor) ? defaultBackgroundColor[0] : defaultBackgroundColor)) !== null && _a !== void 0 ? _a : 'white';
        const colorRange = isCustomTheme ? [fills[0], fills[1]] : defaultColorRange;
        const stroke = isCustomTheme ? strokes[0] : backgroundFill;
        this.rects.forEach((rect, i) => {
            rect.fill = sparklines_util_exports.Color.interpolate(colorRange[0], colorRange[1])(i * 0.2);
            rect.stroke = stroke;
        });
    }
}
MiniHeatmap.chartType = 'heatmap';

class MiniWaterfall extends MiniChartWithAxes {
    constructor(container, fills, strokes, themeTemplate, isCustomTheme) {
        super(container, 'waterfallTooltip');
        this.data = [4, 3, -3, 6, -3];
        this.bars = this.createWaterfall(this.root, this.data, this.size, this.padding, 'vertical').bars;
        this.updateColors(fills, strokes, themeTemplate, isCustomTheme);
    }
    updateColors(fills, strokes, themeTemplate, isCustomTheme) {
        var _a, _b;
        const { data } = this;
        const { properties } = themeTemplate !== null && themeTemplate !== void 0 ? themeTemplate : {};
        const palettePositive = {
            fill: fills[0],
            stroke: strokes[0],
        };
        const paletteNegative = {
            fill: fills[1],
            stroke: strokes[1],
        };
        const positive = isCustomTheme ? palettePositive : (_a = properties === null || properties === void 0 ? void 0 : properties.get(integrated_charts_theme_exports.DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS)) !== null && _a !== void 0 ? _a : palettePositive;
        const negative = isCustomTheme ? paletteNegative : (_b = properties === null || properties === void 0 ? void 0 : properties.get(integrated_charts_theme_exports.DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS)) !== null && _b !== void 0 ? _b : paletteNegative;
        this.bars.forEach((bar, i) => {
            const isPositive = data[i] >= 0;
            bar.fill = isPositive ? positive.fill : negative.fill;
            bar.stroke = isPositive ? positive.stroke : negative.stroke;
        });
    }
    createWaterfall(root, data, size, padding, direction) {
        const scalePadding = 2 * padding;
        const { processedData, min, max } = accumulateData(data.map((d) => [d]));
        const flatData = processedData.reduce((flat, d) => flat.concat(d), []);
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.domain = [Math.min(min, 0), max];
        yScale.range = [size - scalePadding, scalePadding];
        const xScale = new integrated_charts_scene_exports.BandScale();
        xScale.domain = data.map((_, index) => index);
        xScale.range = [padding, size - padding];
        xScale.paddingInner = 0.2;
        xScale.paddingOuter = 0.3;
        const width = xScale.bandwidth;
        const connectorLine = new integrated_charts_scene_exports.Path();
        connectorLine.stroke = '#575757';
        connectorLine.strokeWidth = 0;
        const pixelAlignmentOffset = (Math.floor(connectorLine.strokeWidth) % 2) / 2;
        const connectorPath = connectorLine.path;
        connectorPath.clear();
        const barAlongX = direction === 'horizontal';
        const bars = flatData.map((datum, i) => {
            const previousDatum = i > 0 ? flatData[i - 1] : 0;
            const rawValue = data[i];
            const isPositive = rawValue > 0;
            const currY = Math.round(yScale.convert(datum));
            const trailY = Math.round(yScale.convert(previousDatum));
            const y = (isPositive ? currY : trailY) - pixelAlignmentOffset;
            const bottomY = (isPositive ? trailY : currY) + pixelAlignmentOffset;
            const height = Math.abs(bottomY - y);
            const x = xScale.convert(i);
            const rect = new integrated_charts_scene_exports.Rect();
            rect.x = barAlongX ? y : x;
            rect.y = barAlongX ? x : y;
            rect.width = barAlongX ? height : width;
            rect.height = barAlongX ? width : height;
            rect.strokeWidth = 0;
            rect.crisp = true;
            const moveTo = currY + pixelAlignmentOffset;
            const lineTo = trailY + pixelAlignmentOffset;
            if (i > 0) {
                const lineToX = barAlongX ? lineTo : rect.x;
                const lineToY = barAlongX ? rect.y : lineTo;
                connectorPath.lineTo(lineToX, lineToY);
            }
            const moveToX = barAlongX ? moveTo : rect.x;
            const moveToY = barAlongX ? rect.y : moveTo;
            connectorPath.moveTo(moveToX, moveToY);
            return rect;
        });
        root.append([connectorLine, ...bars]);
        return { bars };
    }
}
MiniWaterfall.chartType = 'waterfall';

class MiniColumnLineCombo extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, "columnLineComboTooltip");
        this.columnData = [3, 4];
        this.lineData = [
            [5, 4, 6, 5, 4]
        ];
        const { root, columnData, lineData, size, padding } = this;
        this.columns = createColumnRects({
            stacked: false,
            root,
            data: columnData,
            size,
            padding,
            xScaleDomain: [0, 1],
            yScaleDomain: [0, 4],
            xScalePadding: 0.5
        });
        root.append(this.columns);
        this.lines = createLinePaths(root, lineData, size, padding);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.columns.forEach((bar, i) => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        });
        this.lines.forEach((line, i) => {
            line.stroke = fills[i + 2];
        });
    }
}
MiniColumnLineCombo.chartType = 'columnLineCombo';

class MiniAreaColumnCombo extends MiniChartWithAxes {
    constructor(container, fills, strokes) {
        super(container, "areaColumnComboTooltip");
        this.columnData = [3, 4.5];
        this.areaData = [
            [5, 4, 6, 5, 4],
        ];
        const { root, columnData, areaData, size, padding } = this;
        this.columns = createColumnRects({
            stacked: false,
            root,
            data: columnData,
            size,
            padding,
            xScaleDomain: [0, 1],
            yScaleDomain: [0, 6],
            xScalePadding: 0.5,
        });
        // scale for area series
        const xScale = new integrated_charts_scene_exports.BandScale();
        xScale.range = [padding, size - padding];
        xScale.domain = [0, 1, 2, 3, 4];
        xScale.paddingInner = 1;
        xScale.paddingOuter = 0;
        const yScale = new integrated_charts_scene_exports.LinearScale();
        yScale.range = [size - padding, padding];
        yScale.domain = [0, 6];
        const pathData = [];
        const yZero = yScale.convert(0);
        const firstX = xScale.convert(0);
        areaData.forEach((series, i) => {
            const points = pathData[i] || (pathData[i] = []);
            series.forEach((data, j) => {
                const yDatum = data;
                const xDatum = j;
                const x = xScale.convert(xDatum);
                const y = yScale.convert(yDatum);
                points[j] = { x, y };
            });
            const lastX = xScale.convert(series.length - 1);
            pathData[i].push({
                x: lastX,
                y: yZero
            }, {
                x: firstX,
                y: yZero
            });
        });
        this.areas = pathData.map((points) => {
            const area = new integrated_charts_scene_exports.Path();
            area.strokeWidth = 0;
            area.fillOpacity = 0.8;
            const path = area.path;
            points.forEach((point, i) => path[i > 0 ? 'lineTo' : 'moveTo'](point.x, point.y));
            return area;
        });
        root.append(this.areas);
        root.append([].concat.apply([], this.columns));
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.areas.forEach((area, i) => {
            area.fill = fills[i];
            area.stroke = strokes[i];
        });
        this.columns.forEach((bar, i) => {
            bar.fill = fills[i + 1];
            bar.stroke = strokes[i + 1];
        });
    }
}
MiniAreaColumnCombo.chartType = 'areaColumnCombo';

class MiniCustomCombo extends MiniChart$1 {
    constructor(container, fills, strokes) {
        super(container, 'customComboTooltip');
        this.columnData = [3, 4];
        this.lineData = [[5, 4, 6, 5, 4]];
        const { root, columnData, lineData, size, padding } = this;
        this.columns = createColumnRects({
            stacked: false,
            root,
            data: columnData,
            size,
            padding,
            xScaleDomain: [0, 1],
            yScaleDomain: [0, 4],
            xScalePadding: 0.5,
        });
        root.append(this.columns);
        this.lines = createLinePaths(root, lineData, size, padding);
        const axisStroke = 'grey';
        const axisOvershoot = 3;
        const leftAxis = new integrated_charts_scene_exports.Line();
        leftAxis.x1 = padding;
        leftAxis.y1 = padding;
        leftAxis.x2 = padding;
        leftAxis.y2 = size - padding + axisOvershoot;
        leftAxis.stroke = axisStroke;
        const bottomAxis = new integrated_charts_scene_exports.Line();
        bottomAxis.x1 = padding - axisOvershoot + 1;
        bottomAxis.y1 = size - padding;
        bottomAxis.x2 = size - padding + 1;
        bottomAxis.y2 = size - padding;
        bottomAxis.stroke = axisStroke;
        const penIcon = new integrated_charts_scene_exports.Path();
        this.buildPenIconPath(penIcon);
        penIcon.fill = 'whitesmoke';
        penIcon.stroke = 'darkslategrey';
        penIcon.strokeWidth = 1;
        root.append([bottomAxis, leftAxis, penIcon]);
        this.updateColors(fills, strokes);
    }
    updateColors(fills, strokes) {
        this.columns.forEach((bar, i) => {
            bar.fill = fills[i];
            bar.stroke = strokes[i];
        });
        this.lines.forEach((line, i) => {
            line.stroke = fills[i + 2];
        });
    }
    buildPenIconPath(penIcon) {
        const { path } = penIcon;
        path.moveTo(25.76, 43.46);
        path.lineTo(31.27, 48.53);
        path.moveTo(49.86, 22);
        path.lineTo(49.86, 22);
        path.cubicCurveTo(49.01994659053345, 21.317514933510974, 47.89593834348529, 21.09645997825817, 46.86, 21.41);
        path.lineTo(46.86, 21.41);
        path.cubicCurveTo(45.55460035985361, 21.77260167850787, 44.38777081121966, 22.517979360321792, 43.51, 23.55);
        path.lineTo(25.51, 43.8);
        path.lineTo(25.43, 43.89);
        path.lineTo(23.01, 51.89);
        path.lineTo(22.83, 52.46);
        path.lineTo(31.02, 48.86);
        path.lineTo(49.02, 28.52);
        path.lineTo(49.02, 28.52);
        path.cubicCurveTo(49.940716461596224, 27.521914221246085, 50.54302631059587, 26.2720342455763, 50.75, 24.93);
        path.lineTo(50.75, 24.93);
        path.cubicCurveTo(50.95363374988308, 23.866379846512814, 50.62080640232334, 22.77066734274871, 49.86, 22.0);
        path.closePath();
        path.moveTo(41.76, 25.5);
        path.lineTo(47.34, 30.5);
        path.moveTo(40.74, 26.65);
        path.lineTo(46.25, 31.71);
    }
}
MiniCustomCombo.chartType = 'customCombo';

var __decorate$H = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const miniChartMapping = {
    columnGroup: {
        column: { range: true, pivot: true, enterprise: false, icon: MiniColumn },
        stackedColumn: { range: true, pivot: true, enterprise: false, icon: MiniStackedColumn },
        normalizedColumn: { range: true, pivot: true, enterprise: false, icon: MiniNormalizedColumn },
    },
    barGroup: {
        bar: { range: true, pivot: true, enterprise: false, icon: MiniBar },
        stackedBar: { range: true, pivot: true, enterprise: false, icon: MiniStackedBar },
        normalizedBar: { range: true, pivot: true, enterprise: false, icon: MiniNormalizedBar },
    },
    pieGroup: {
        pie: { range: true, pivot: true, enterprise: false, icon: MiniPie },
        donut: { range: true, pivot: true, enterprise: false, icon: MiniDonut },
        doughnut: { range: true, pivot: true, enterprise: false, icon: MiniDonut },
    },
    lineGroup: { line: { range: true, pivot: true, enterprise: false, icon: MiniLine } },
    scatterGroup: {
        scatter: { range: true, pivot: true, enterprise: false, icon: MiniScatter },
        bubble: { range: true, pivot: true, enterprise: false, icon: MiniBubble },
    },
    areaGroup: {
        area: { range: true, pivot: true, enterprise: false, icon: MiniArea },
        stackedArea: { range: true, pivot: true, enterprise: false, icon: MiniStackedArea },
        normalizedArea: { range: true, pivot: true, enterprise: false, icon: MiniNormalizedArea },
    },
    polarGroup: {
        radarLine: { range: true, pivot: false, enterprise: true, icon: MiniRadarLine },
        radarArea: { range: true, pivot: false, enterprise: true, icon: MiniRadarArea },
        nightingale: { range: true, pivot: false, enterprise: true, icon: MiniNightingale },
        radialColumn: { range: true, pivot: false, enterprise: true, icon: MiniRadialColumn },
        radialBar: { range: true, pivot: false, enterprise: true, icon: MiniRadialBar },
    },
    statisticalGroup: {
        boxPlot: { range: true, pivot: false, enterprise: true, icon: MiniBoxPlot },
        histogram: { range: true, pivot: false, enterprise: false, icon: MiniHistogram },
        rangeBar: { range: true, pivot: false, enterprise: true, icon: MiniRangeBar },
        rangeArea: { range: true, pivot: false, enterprise: true, icon: MiniRangeArea },
    },
    hierarchicalGroup: {
        treemap: { range: true, pivot: true, enterprise: true, icon: MiniTreemap },
        sunburst: { range: true, pivot: true, enterprise: true, icon: MiniSunburst },
    },
    specializedGroup: {
        heatmap: { range: true, pivot: false, enterprise: true, icon: MiniHeatmap },
        waterfall: { range: true, pivot: false, enterprise: true, icon: MiniWaterfall },
    },
    combinationGroup: {
        columnLineCombo: { range: true, pivot: true, enterprise: false, icon: MiniColumnLineCombo },
        areaColumnCombo: { range: true, pivot: true, enterprise: false, icon: MiniAreaColumnCombo },
        customCombo: { range: true, pivot: true, enterprise: false, icon: MiniCustomCombo },
    },
};
class MiniChartsContainer extends Component {
    constructor(chartController, fills, strokes, themeTemplateParameters, isCustomTheme, chartGroups = DEFAULT_CHART_GROUPS) {
        super(MiniChartsContainer.TEMPLATE);
        this.wrappers = {};
        this.chartController = chartController;
        this.fills = fills;
        this.strokes = strokes;
        this.themeTemplateParameters = themeTemplateParameters;
        this.isCustomTheme = isCustomTheme;
        this.chartGroups = Object.assign({}, chartGroups);
    }
    init() {
        const eGui = this.getGui();
        const isEnterprise = this.chartController.isEnterprise();
        const isPivotChart = this.chartController.isPivotChart();
        const isRangeChart = !isPivotChart;
        // Determine the set of chart types that are specified by the chartGroupsDef config, filtering out any entries
        // that are invalid for the current chart configuration (pivot/range) and license type
        const displayedMenuGroups = Object.keys(this.chartGroups).map((group) => {
            var _a;
            const menuGroup = group in miniChartMapping
                ? miniChartMapping[group]
                : undefined;
            if (!menuGroup) {
                // User has specified an invalid chart group in the chartGroupsDef config
                _.warnOnce(`invalid chartGroupsDef config '${group}'`);
                return null;
            }
            // Determine the valid chart types within this group, based on the chartGroupsDef config
            const chartGroupValues = (_a = this.chartGroups[group]) !== null && _a !== void 0 ? _a : [];
            const menuItems = chartGroupValues.map((chartType) => {
                const menuItem = chartType in menuGroup
                    ? menuGroup[chartType]
                    : undefined;
                if (!menuItem) {
                    // User has specified an invalid chart type in the chartGroupsDef config
                    _.warnOnce(`invalid chartGroupsDef config '${group}.${chartType}'`);
                    return null;
                }
                if (!isEnterprise && menuItem.enterprise) {
                    return null; // skip enterprise charts if community
                }
                // Only show the chart if it is valid for the current chart configuration (pivot/range)
                if (isRangeChart && menuItem.range)
                    return menuItem;
                if (isPivotChart && menuItem.pivot)
                    return menuItem;
                return null;
            })
                .filter((menuItem) => menuItem != null);
            if (menuItems.length === 0)
                return null; // don't render empty chart groups
            return {
                label: this.chartTranslationService.translate(group),
                items: menuItems
            };
        })
            .filter((menuGroup) => menuGroup != null);
        // Render the filtered menu items
        for (const { label, items } of displayedMenuGroups) {
            const groupComponent = this.createBean(new AgGroupComponent({
                title: label,
                suppressEnabledCheckbox: true,
                enabled: true,
                suppressOpenCloseIcons: true,
                cssIdentifier: 'charts-settings',
                direction: 'horizontal',
            }));
            for (const menuItem of items) {
                const MiniClass = menuItem.icon;
                const miniWrapper = document.createElement('div');
                miniWrapper.classList.add('ag-chart-mini-thumbnail');
                const miniClassChartType = MiniClass.chartType;
                this.addManagedListener(miniWrapper, 'click', () => {
                    this.chartController.setChartType(miniClassChartType);
                    this.updateSelectedMiniChart();
                });
                this.wrappers[miniClassChartType] = miniWrapper;
                this.createBean(new MiniClass(miniWrapper, this.fills, this.strokes, this.themeTemplateParameters, this.isCustomTheme));
                groupComponent.addItem(miniWrapper);
            }
            eGui.appendChild(groupComponent.getGui());
        }
        // hide MiniCustomCombo if no custom combo exists
        if (!this.chartController.customComboExists() && this.chartGroups.combinationGroup) {
            this.chartGroups.combinationGroup = this.chartGroups.combinationGroup.filter(chartType => chartType !== 'customCombo');
        }
        this.updateSelectedMiniChart();
    }
    updateSelectedMiniChart() {
        const selectedChartType = this.chartController.getChartType();
        for (const miniChartType in this.wrappers) {
            const miniChart = this.wrappers[miniChartType];
            const selected = miniChartType === selectedChartType;
            miniChart.classList.toggle('ag-selected', selected);
        }
    }
}
MiniChartsContainer.TEMPLATE = `<div class="ag-chart-settings-mini-wrapper"></div>`;
__decorate$H([
    Autowired('chartTranslationService')
], MiniChartsContainer.prototype, "chartTranslationService", void 0);
__decorate$H([
    PostConstruct
], MiniChartsContainer.prototype, "init", null);

var __decorate$I = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ChartSettingsPanel extends Component {
    constructor(chartController) {
        super(ChartSettingsPanel.TEMPLATE);
        this.miniChartsContainers = [];
        this.cardItems = [];
        this.activePaletteIndex = 0;
        this.palettes = [];
        this.themes = [];
        this.chartController = chartController;
    }
    postConstruct() {
        this.resetPalettes();
        this.ePrevBtn.insertAdjacentElement('afterbegin', _.createIconNoSpan('previous', this.gridOptionsService));
        this.eNextBtn.insertAdjacentElement('afterbegin', _.createIconNoSpan('next', this.gridOptionsService));
        this.addManagedListener(this.ePrevBtn, 'click', () => this.setActivePalette(this.getPrev(), 'left'));
        this.addManagedListener(this.eNextBtn, 'click', () => this.setActivePalette(this.getNext(), 'right'));
        // change the selected chart when a combo chart is modified via the data panel, i.e. the custom combo should be selected
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_TYPE_CHANGED, () => this.resetPalettes(true));
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_API_UPDATE, () => this.resetPalettes(true));
        this.scrollSelectedIntoView();
    }
    scrollSelectedIntoView() {
        // the panel is not immediately visible due to the slide animation, so we add a
        // setTimeout to wait until the panel animation is over and is able to scroll
        setTimeout(() => {
            const isMiniChartsContainerVisible = (miniChartsContainers) => {
                return !miniChartsContainers.getGui().classList.contains('ag-hidden');
            };
            const currentMiniChartContainer = this.miniChartsContainers.find(isMiniChartsContainerVisible);
            const currentChart = currentMiniChartContainer.getGui().querySelector('.ag-selected');
            if (currentChart) {
                const parent = currentChart.offsetParent;
                if (parent) {
                    this.eMiniChartsContainer.scrollTo(0, parent.offsetTop);
                }
            }
        }, 250);
    }
    resetPalettes(forceReset) {
        var _a, _b;
        const palettes = this.chartController.getPalettes();
        const themeTemplateParameters = this.chartController.getThemeTemplateParameters();
        const chartGroups = (_b = (_a = this.gridOptionsService.get('chartToolPanelsDef')) === null || _a === void 0 ? void 0 : _a.settingsPanel) === null || _b === void 0 ? void 0 : _b.chartGroupsDef;
        if ((_.shallowCompare(palettes, this.palettes) && !forceReset) || this.isAnimating) {
            return;
        }
        this.palettes = palettes;
        this.themes = this.chartController.getThemeNames();
        this.activePaletteIndex = this.themes.findIndex(name => name === this.chartController.getChartThemeName());
        this.cardItems = [];
        _.clearElement(this.eCardSelector);
        this.destroyMiniCharts();
        const { themes } = this;
        this.palettes.forEach((palette, index) => {
            const isActivePalette = this.activePaletteIndex === index;
            const { fills, strokes } = palette;
            const themeName = themes[index];
            const isCustomTheme = !isStockTheme(themeName);
            const miniChartsContainer = this.createBean(new MiniChartsContainer(this.chartController, fills, strokes, themeTemplateParameters[index], isCustomTheme, chartGroups));
            this.miniChartsContainers.push(miniChartsContainer);
            this.eMiniChartsContainer.appendChild(miniChartsContainer.getGui());
            this.addCardLink(index);
            if (isActivePalette) {
                miniChartsContainer.updateSelectedMiniChart();
            }
            else {
                miniChartsContainer.setDisplayed(false);
            }
        });
        _.setDisplayed(this.eNavBar, this.palettes.length > 1);
        _.radioCssClass(this.cardItems[this.activePaletteIndex], 'ag-selected', 'ag-not-selected');
    }
    addCardLink(index) {
        const link = document.createElement('div');
        link.classList.add('ag-chart-settings-card-item');
        this.addManagedListener(link, 'click', () => {
            this.setActivePalette(index, index < this.activePaletteIndex ? 'left' : 'right');
        });
        this.eCardSelector.appendChild(link);
        this.cardItems.push(link);
    }
    getPrev() {
        let prev = this.activePaletteIndex - 1;
        if (prev < 0) {
            prev = this.palettes.length - 1;
        }
        return prev;
    }
    getNext() {
        let next = this.activePaletteIndex + 1;
        if (next >= this.palettes.length) {
            next = 0;
        }
        return next;
    }
    setActivePalette(index, animationDirection) {
        if (this.isAnimating || this.activePaletteIndex === index) {
            return;
        }
        _.radioCssClass(this.cardItems[index], 'ag-selected', 'ag-not-selected');
        const currentPalette = this.miniChartsContainers[this.activePaletteIndex];
        const currentGui = currentPalette.getGui();
        const futurePalette = this.miniChartsContainers[index];
        const nextGui = futurePalette.getGui();
        currentPalette.updateSelectedMiniChart();
        futurePalette.updateSelectedMiniChart();
        const multiplier = animationDirection === 'left' ? -1 : 1;
        const final = nextGui.style.left = `${(_.getAbsoluteWidth(this.getGui()) * multiplier)}px`;
        this.activePaletteIndex = index;
        this.isAnimating = true;
        const animatingClass = 'ag-animating';
        futurePalette.setDisplayed(true);
        currentPalette.addCssClass(animatingClass);
        futurePalette.addCssClass(animatingClass);
        this.chartController.setChartThemeName(this.themes[index]);
        window.setTimeout(() => {
            currentGui.style.left = `${-parseFloat(final)}px`;
            nextGui.style.left = '0px';
        }, 0);
        window.setTimeout(() => {
            this.isAnimating = false;
            currentPalette.removeCssClass(animatingClass);
            futurePalette.removeCssClass(animatingClass);
            currentPalette.setDisplayed(false);
        }, 300);
    }
    destroyMiniCharts() {
        _.clearElement(this.eMiniChartsContainer);
        this.miniChartsContainers = this.destroyBeans(this.miniChartsContainers);
    }
    destroy() {
        this.destroyMiniCharts();
        super.destroy();
    }
}
ChartSettingsPanel.TEMPLATE = `<div class="ag-chart-settings-wrapper">
            <div ref="eMiniChartsContainer" class="ag-chart-settings-mini-charts-container ag-scrollable-container"></div>
            <div ref="eNavBar" class="ag-chart-settings-nav-bar">
                <div ref="ePrevBtn" class="ag-chart-settings-prev">
                    <button type="button" class="ag-button ag-chart-settings-prev-button"></button>
                </div>
                <div ref="eCardSelector" class="ag-chart-settings-card-selector"></div>
                <div ref="eNextBtn" class="ag-chart-settings-next">
                    <button type="button" class="ag-button ag-chart-settings-next-button"></button>
                </div>
            </div>
        </div>`;
__decorate$I([
    Autowired('resizeObserverService')
], ChartSettingsPanel.prototype, "resizeObserverService", void 0);
__decorate$I([
    RefSelector('eMiniChartsContainer')
], ChartSettingsPanel.prototype, "eMiniChartsContainer", void 0);
__decorate$I([
    RefSelector('eNavBar')
], ChartSettingsPanel.prototype, "eNavBar", void 0);
__decorate$I([
    RefSelector('eCardSelector')
], ChartSettingsPanel.prototype, "eCardSelector", void 0);
__decorate$I([
    RefSelector('ePrevBtn')
], ChartSettingsPanel.prototype, "ePrevBtn", void 0);
__decorate$I([
    RefSelector('eNextBtn')
], ChartSettingsPanel.prototype, "eNextBtn", void 0);
__decorate$I([
    PostConstruct
], ChartSettingsPanel.prototype, "postConstruct", null);

var __decorate$J = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class TabbedChartMenu extends Component {
    constructor(params) {
        super();
        this.tabs = [];
        const { controller, panels, chartOptionsService } = params;
        this.chartController = controller;
        this.chartOptionsService = chartOptionsService;
        this.panels = panels;
    }
    init() {
        this.panels.forEach(panel => {
            const panelType = panel.replace('chart', '').toLowerCase();
            const { comp, tab } = this.createTab(panel, panelType, this.getPanelClass(panelType));
            this.tabs.push(tab);
            this.addDestroyFunc(() => this.destroyBean(comp));
        });
        this.tabbedLayout = new TabbedLayout({
            items: this.tabs,
            cssClass: 'ag-chart-tabbed-menu',
            keepScrollPosition: true
        });
        this.getContext().createBean(this.tabbedLayout);
    }
    createTab(name, title, TabPanelClass) {
        const eWrapperDiv = document.createElement('div');
        eWrapperDiv.classList.add('ag-chart-tab', `ag-chart-${title}`);
        const comp = new TabPanelClass(this.chartController, this.chartOptionsService);
        this.getContext().createBean(comp);
        eWrapperDiv.appendChild(comp.getGui());
        const titleEl = document.createElement('div');
        const translatedTitle = this.chartTranslationService.translate(title);
        titleEl.innerText = translatedTitle;
        return {
            comp,
            tab: {
                title: titleEl,
                titleLabel: translatedTitle,
                bodyPromise: AgPromise.resolve(eWrapperDiv),
                getScrollableContainer: () => {
                    const scrollableContainer = eWrapperDiv.querySelector('.ag-scrollable-container');
                    return (scrollableContainer || eWrapperDiv);
                },
                name
            }
        };
    }
    showTab(tab) {
        const tabItem = this.tabs[tab];
        this.tabbedLayout.showItem(tabItem);
    }
    getGui() {
        return this.tabbedLayout && this.tabbedLayout.getGui();
    }
    destroy() {
        if (this.parentComponent && this.parentComponent.isAlive()) {
            this.destroyBean(this.parentComponent);
        }
        super.destroy();
    }
    getPanelClass(panelType) {
        switch (panelType) {
            case TabbedChartMenu.TAB_DATA:
                return ChartDataPanel;
            case TabbedChartMenu.TAB_FORMAT:
                return FormatPanel;
            default:
                return ChartSettingsPanel;
        }
    }
}
TabbedChartMenu.TAB_DATA = 'data';
TabbedChartMenu.TAB_FORMAT = 'format';
__decorate$J([
    Autowired('chartTranslationService')
], TabbedChartMenu.prototype, "chartTranslationService", void 0);
__decorate$J([
    PostConstruct
], TabbedChartMenu.prototype, "init", null);

var __decorate$K = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ChartMenu extends Component {
    constructor(eChartContainer, eMenuPanelContainer, chartController, chartOptionsService) {
        super(ChartMenu.TEMPLATE);
        this.eChartContainer = eChartContainer;
        this.eMenuPanelContainer = eMenuPanelContainer;
        this.chartController = chartController;
        this.chartOptionsService = chartOptionsService;
        this.buttons = {
            chartSettings: ['menu', () => this.showMenu(this.defaultPanel)],
            chartData: ['menu', () => this.showMenu("chartData")],
            chartFormat: ['menu', () => this.showMenu("chartFormat")],
            chartLink: ['linked', e => this.toggleDetached(e)],
            chartUnlink: ['unlinked', e => this.toggleDetached(e)],
            chartDownload: ['save', () => this.saveChart()]
        };
        this.panels = [];
        this.buttonListenersDestroyFuncs = [];
        this.menuVisible = false;
    }
    postConstruct() {
        this.createButtons();
        this.addManagedListener(this.eventService, Events.EVENT_CHART_CREATED, (e) => {
            var _a;
            if (e.chartId === this.chartController.getChartId()) {
                const showDefaultToolPanel = Boolean((_a = this.gridOptionsService.get('chartToolPanelsDef')) === null || _a === void 0 ? void 0 : _a.defaultToolPanel);
                if (showDefaultToolPanel) {
                    this.showMenu(this.defaultPanel, false);
                }
            }
        });
        this.refreshMenuClasses();
        if (!this.gridOptionsService.get('suppressChartToolPanelsButton') && this.panels.length > 0) {
            this.getGui().classList.add('ag-chart-tool-panel-button-enable');
            this.addManagedListener(this.eHideButton, 'click', this.toggleMenu.bind(this));
        }
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_API_UPDATE, this.createButtons.bind(this));
    }
    isVisible() {
        return this.menuVisible;
    }
    getExtraPaddingDirections() {
        const topItems = ['chartLink', 'chartUnlink', 'chartDownload'];
        const rightItems = ['chartSettings', 'chartData', 'chartFormat'];
        const result = [];
        if (topItems.some(v => this.chartToolbarOptions.includes(v))) {
            result.push('top');
        }
        if (rightItems.some(v => this.chartToolbarOptions.includes(v))) {
            result.push(this.gridOptionsService.get('enableRtl') ? 'left' : 'right');
        }
        return result;
    }
    getToolbarOptions() {
        var _a, _b, _c;
        const useChartToolPanelCustomisation = Boolean(this.gridOptionsService.get('chartToolPanelsDef'));
        if (useChartToolPanelCustomisation) {
            const defaultChartToolbarOptions = [
                this.chartController.isChartLinked() ? 'chartLink' : 'chartUnlink',
                'chartDownload'
            ];
            const toolbarItemsFunc = this.gridOptionsService.getCallback('getChartToolbarItems');
            const params = {
                defaultItems: defaultChartToolbarOptions
            };
            let chartToolbarOptions = toolbarItemsFunc
                ? toolbarItemsFunc(params).filter(option => {
                    if (!CHART_TOOLBAR_ALLOW_LIST.includes(option)) {
                        const msg = CHART_TOOL_PANEL_ALLOW_LIST.includes(option)
                            ? `AG Grid: '${option}' is a Chart Tool Panel option and will be ignored since 'chartToolPanelsDef' is used. Please use 'chartToolPanelsDef.panels' grid option instead`
                            : `AG Grid: '${option}' is not a valid Chart Toolbar Option`;
                        console.warn(msg);
                        return false;
                    }
                    return true;
                })
                : defaultChartToolbarOptions;
            const panelsOverride = (_b = (_a = this.gridOptionsService.get('chartToolPanelsDef')) === null || _a === void 0 ? void 0 : _a.panels) === null || _b === void 0 ? void 0 : _b.map(panel => {
                const menuOption = CHART_TOOL_PANEL_MENU_OPTIONS[panel];
                if (!menuOption) {
                    console.warn(`AG Grid - invalid panel in chartToolPanelsDef.panels: '${panel}'`);
                }
                return menuOption;
            }).filter(panel => Boolean(panel));
            this.panels = panelsOverride
                ? panelsOverride
                : Object.values(CHART_TOOL_PANEL_MENU_OPTIONS);
            // pivot charts use the column tool panel instead of the data panel
            if (this.chartController.isPivotChart()) {
                this.panels = this.panels.filter(panel => panel !== 'chartData');
            }
            const defaultToolPanel = (_c = this.gridOptionsService.get('chartToolPanelsDef')) === null || _c === void 0 ? void 0 : _c.defaultToolPanel;
            this.defaultPanel = (defaultToolPanel && CHART_TOOL_PANEL_MENU_OPTIONS[defaultToolPanel]) || this.panels[0];
            return this.panels.length > 0
                // Only one panel is required to display menu icon in toolbar
                ? [this.panels[0], ...chartToolbarOptions]
                : chartToolbarOptions;
        }
        else { // To be deprecated in future. Toolbar options will be different to chart tool panels.
            let tabOptions = [
                'chartSettings',
                'chartData',
                'chartFormat',
                this.chartController.isChartLinked() ? 'chartLink' : 'chartUnlink',
                'chartDownload'
            ];
            const toolbarItemsFunc = this.gridOptionsService.getCallback('getChartToolbarItems');
            if (toolbarItemsFunc) {
                const isLegacyToolbar = this.gridOptionsService.get('suppressChartToolPanelsButton');
                const params = {
                    defaultItems: isLegacyToolbar ? tabOptions : CHART_TOOLBAR_ALLOW_LIST
                };
                tabOptions = toolbarItemsFunc(params).filter(option => {
                    if (!this.buttons[option]) {
                        console.warn(`AG Grid: '${option}' is not a valid Chart Toolbar Option`);
                        return false;
                    }
                    // If not legacy, remove chart tool panel options here,
                    // and add them all in one go below
                    else if (!isLegacyToolbar && CHART_TOOL_PANEL_ALLOW_LIST.includes(option)) {
                        const msg = `AG Grid: '${option}' is a Chart Tool Panel option and will be ignored. Please use 'chartToolPanelsDef.panels' grid option instead`;
                        console.warn(msg);
                        return false;
                    }
                    return true;
                });
                if (!isLegacyToolbar) {
                    // Add all the chart tool panels, as `chartToolPanelsDef.panels`
                    // should be used for configuration
                    tabOptions = tabOptions.concat(CHART_TOOL_PANEL_ALLOW_LIST);
                }
            }
            // pivot charts use the column tool panel instead of the data panel
            if (this.chartController.isPivotChart()) {
                tabOptions = tabOptions.filter(option => option !== 'chartData');
            }
            const ignoreOptions = ['chartUnlink', 'chartLink', 'chartDownload'];
            this.panels = tabOptions.filter(option => ignoreOptions.indexOf(option) === -1);
            this.defaultPanel = this.panels[0];
            return tabOptions.filter(value => ignoreOptions.indexOf(value) !== -1 ||
                (this.panels.length && value === this.panels[0]));
        }
    }
    toggleDetached(e) {
        const target = e.target;
        const active = target.classList.contains('ag-icon-linked');
        target.classList.toggle('ag-icon-linked', !active);
        target.classList.toggle('ag-icon-unlinked', active);
        const tooltipKey = active ? 'chartUnlinkToolbarTooltip' : 'chartLinkToolbarTooltip';
        const tooltipTitle = this.chartTranslationService.translate(tooltipKey);
        if (tooltipTitle) {
            target.title = tooltipTitle;
        }
        this.chartController.detachChartRange();
    }
    createButtons() {
        this.buttonListenersDestroyFuncs.forEach(func => func());
        this.buttonListenersDestroyFuncs = [];
        this.chartToolbarOptions = this.getToolbarOptions();
        const menuEl = this.eMenu;
        _.clearElement(menuEl);
        this.chartToolbarOptions.forEach(button => {
            const buttonConfig = this.buttons[button];
            const [iconName, callback] = buttonConfig;
            const buttonEl = _.createIconNoSpan(iconName, this.gridOptionsService, undefined, true);
            buttonEl.classList.add('ag-chart-menu-icon');
            const tooltipTitle = this.chartTranslationService.translate(button + 'ToolbarTooltip');
            if (tooltipTitle && buttonEl instanceof HTMLElement) {
                buttonEl.title = tooltipTitle;
            }
            this.buttonListenersDestroyFuncs.push(this.addManagedListener(buttonEl, 'click', callback));
            menuEl.appendChild(buttonEl);
        });
    }
    saveChart() {
        const event = { type: ChartMenu.EVENT_DOWNLOAD_CHART };
        this.dispatchEvent(event);
    }
    createMenuPanel(defaultTab) {
        const width = this.environment.chartMenuPanelWidth();
        const menuPanel = this.menuPanel = this.createBean(new AgPanel({
            minWidth: width,
            width,
            height: '100%',
            closable: true,
            hideTitleBar: true,
            cssIdentifier: 'chart-menu'
        }));
        menuPanel.setParentComponent(this);
        this.eMenuPanelContainer.appendChild(menuPanel.getGui());
        this.tabbedMenu = this.createBean(new TabbedChartMenu({
            controller: this.chartController,
            type: this.chartController.getChartType(),
            panels: this.panels,
            chartOptionsService: this.chartOptionsService
        }));
        this.addManagedListener(menuPanel, Component.EVENT_DESTROYED, () => this.destroyBean(this.tabbedMenu));
        return new AgPromise((res) => {
            window.setTimeout(() => {
                menuPanel.setBodyComponent(this.tabbedMenu);
                this.tabbedMenu.showTab(defaultTab);
                res(menuPanel);
                this.addManagedListener(this.eChartContainer, 'click', (event) => {
                    if (this.getGui().contains(event.target)) {
                        return;
                    }
                    if (this.menuVisible) {
                        this.hideMenu();
                    }
                });
            }, 100);
        });
    }
    showContainer() {
        if (!this.menuPanel) {
            return;
        }
        this.menuVisible = true;
        this.showParent(this.menuPanel.getWidth());
        this.refreshMenuClasses();
    }
    toggleMenu() {
        this.menuVisible ? this.hideMenu() : this.showMenu();
    }
    showMenu(
    /**
     * Menu panel to show. If empty, shows the existing menu, or creates the default menu if menu panel has not been created
     */
    panel, 
    /**
     * Whether to animate the menu opening
     */
    animate = true) {
        if (!animate) {
            this.eMenuPanelContainer.classList.add('ag-no-transition');
        }
        if (this.menuPanel && !panel) {
            this.showContainer();
        }
        else {
            const menuPanel = panel || this.defaultPanel;
            let tab = this.panels.indexOf(menuPanel);
            if (tab < 0) {
                console.warn(`AG Grid: '${panel}' is not a valid Chart Tool Panel name`);
                tab = this.panels.indexOf(this.defaultPanel);
            }
            if (this.menuPanel) {
                this.tabbedMenu.showTab(tab);
                this.showContainer();
            }
            else {
                this.createMenuPanel(tab).then(this.showContainer.bind(this));
            }
        }
        if (!animate) {
            // Wait for menu to render
            setTimeout(() => {
                if (!this.isAlive()) {
                    return;
                }
                this.eMenuPanelContainer.classList.remove('ag-no-transition');
            }, 500);
        }
    }
    hideMenu() {
        this.hideParent();
        window.setTimeout(() => {
            this.menuVisible = false;
            this.refreshMenuClasses();
        }, 500);
    }
    refreshMenuClasses() {
        this.eChartContainer.classList.toggle('ag-chart-menu-visible', this.menuVisible);
        this.eChartContainer.classList.toggle('ag-chart-menu-hidden', !this.menuVisible);
        if (!this.gridOptionsService.get('suppressChartToolPanelsButton')) {
            this.eHideButtonIcon.classList.toggle('ag-icon-contracted', this.menuVisible);
            this.eHideButtonIcon.classList.toggle('ag-icon-expanded', !this.menuVisible);
        }
    }
    showParent(width) {
        this.eMenuPanelContainer.style.minWidth = `${width}px`;
    }
    hideParent() {
        this.eMenuPanelContainer.style.minWidth = '0';
    }
    destroy() {
        super.destroy();
        if (this.menuPanel && this.menuPanel.isAlive()) {
            this.destroyBean(this.menuPanel);
        }
        if (this.tabbedMenu && this.tabbedMenu.isAlive()) {
            this.destroyBean(this.tabbedMenu);
        }
    }
}
ChartMenu.EVENT_DOWNLOAD_CHART = "downloadChart";
ChartMenu.TEMPLATE = `<div>
        <div class="ag-chart-menu" ref="eMenu"></div>
        <button class="ag-button ag-chart-menu-close" ref="eHideButton">
            <span class="ag-icon ag-icon-contracted" ref="eHideButtonIcon"></span>
        </button>
    </div>`;
__decorate$K([
    Autowired('chartTranslationService')
], ChartMenu.prototype, "chartTranslationService", void 0);
__decorate$K([
    RefSelector("eMenu")
], ChartMenu.prototype, "eMenu", void 0);
__decorate$K([
    RefSelector("eHideButton")
], ChartMenu.prototype, "eHideButton", void 0);
__decorate$K([
    RefSelector("eHideButtonIcon")
], ChartMenu.prototype, "eHideButtonIcon", void 0);
__decorate$K([
    PostConstruct
], ChartMenu.prototype, "postConstruct", null);

var __decorate$L = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class TitleEdit extends Component {
    constructor(chartMenu) {
        super(TitleEdit.TEMPLATE);
        this.chartMenu = chartMenu;
        this.destroyableChartListeners = [];
        this.editing = false;
    }
    init() {
        this.addManagedListener(this.getGui(), 'keydown', (e) => {
            if (this.editing && e.key === 'Enter' && !e.shiftKey) {
                this.handleEndEditing();
                e.preventDefault();
            }
        });
        this.addManagedListener(this.getGui(), 'input', () => {
            if (this.editing) {
                this.updateHeight();
            }
        });
        this.addManagedListener(this.getGui(), 'blur', () => this.endEditing());
    }
    /* should be called when the containing component changes to a new chart proxy */
    refreshTitle(chartController, chartOptionsService) {
        this.chartController = chartController;
        this.chartOptionsService = chartOptionsService;
        for (const destroyFn of this.destroyableChartListeners) {
            destroyFn();
        }
        this.destroyableChartListeners = [];
        const chartProxy = this.chartController.getChartProxy();
        const chart = chartProxy.getChart();
        const canvas = chart.scene.canvas.element;
        const destroyDbleClickListener = this.addManagedListener(canvas, 'dblclick', event => {
            const { title } = chart;
            if (title && title.node.containsPoint(event.offsetX, event.offsetY)) {
                const bbox = title.node.computeBBox();
                const xy = title.node.inverseTransformPoint(bbox.x, bbox.y);
                this.startEditing(Object.assign(Object.assign({}, bbox), xy), canvas.width);
            }
        });
        let wasInTitle = false;
        const destroyMouseMoveListener = this.addManagedListener(canvas, 'mousemove', event => {
            const { title } = chart;
            const inTitle = !!(title && title.enabled && title.node.containsPoint(event.offsetX, event.offsetY));
            if (wasInTitle !== inTitle) {
                canvas.style.cursor = inTitle ? 'pointer' : '';
            }
            wasInTitle = inTitle;
        });
        this.destroyableChartListeners = [
            destroyDbleClickListener,
            destroyMouseMoveListener
        ];
    }
    startEditing(titleBBox, canvasWidth) {
        if (this.chartMenu && this.chartMenu.isVisible()) {
            // currently, we ignore requests to edit the chart title while the chart menu is showing
            // because the click to edit the chart will also close the chart menu, making the position
            // of the title change.
            return;
        }
        if (this.editing) {
            return;
        }
        this.editing = true;
        const minimumTargetInputWidth = 300;
        const inputWidth = Math.max(Math.min(titleBBox.width + 20, canvasWidth), minimumTargetInputWidth);
        const element = this.getGui();
        element.classList.add('currently-editing');
        const inputStyle = element.style;
        // match style of input to title that we're editing
        inputStyle.fontFamily = this.chartOptionsService.getChartOption('title.fontFamily');
        inputStyle.fontWeight = this.chartOptionsService.getChartOption('title.fontWeight');
        inputStyle.fontStyle = this.chartOptionsService.getChartOption('title.fontStyle');
        inputStyle.fontSize = this.chartOptionsService.getChartOption('title.fontSize') + 'px';
        inputStyle.color = this.chartOptionsService.getChartOption('title.color');
        // populate the input with the title, unless the title is the placeholder:
        const oldTitle = this.chartOptionsService.getChartOption('title.text');
        const isTitlePlaceholder = oldTitle === this.chartTranslationService.translate('titlePlaceholder');
        element.value = isTitlePlaceholder ? '' : oldTitle;
        const oldTitleLines = oldTitle.split(/\r?\n/g).length;
        inputStyle.left = Math.round(titleBBox.x + titleBBox.width / 2 - inputWidth / 2 - 1) + 'px';
        inputStyle.top = Math.round(titleBBox.y + titleBBox.height / 2 - (oldTitleLines * this.getLineHeight()) / 2 - 2) + 'px';
        inputStyle.width = Math.round(inputWidth) + 'px';
        inputStyle.lineHeight = this.getLineHeight() + 'px';
        this.updateHeight();
        element.focus();
    }
    updateHeight() {
        const element = this.getGui();
        // The element should cover the title and provide enough space for the new one.
        const oldTitleLines = this.chartOptionsService.getChartOption('title.text').split(/\r?\n/g).length;
        const currentTitleLines = element.value.split(/\r?\n/g).length;
        element.style.height = (Math.round(Math.max(oldTitleLines, currentTitleLines) * this.getLineHeight()) + 4) + 'px';
    }
    getLineHeight() {
        const fixedLineHeight = this.chartOptionsService.getChartOption('title.lineHeight');
        if (fixedLineHeight) {
            return parseInt(fixedLineHeight);
        }
        return Math.round(parseInt(this.chartOptionsService.getChartOption('title.fontSize')) * 1.2);
    }
    handleEndEditing() {
        // special handling to avoid flicker caused by delay when swapping old and new titles
        // 1 - store current title color
        const titleColor = this.chartOptionsService.getChartOption('title.color');
        // 2 - hide title by making it transparent
        const transparentColor = 'rgba(0, 0, 0, 0)';
        this.chartOptionsService.setChartOption('title.color', transparentColor);
        // 3 - trigger 'end editing' - this will update the chart with the new title
        this.chartOptionsService.awaitChartOptionUpdate(() => this.endEditing());
        // 4 - restore title color to its original value
        this.chartOptionsService.awaitChartOptionUpdate(() => {
            this.chartOptionsService.setChartOption('title.color', titleColor);
        });
    }
    endEditing() {
        if (!this.editing) {
            return;
        }
        this.editing = false;
        const value = this.getGui().value;
        if (value && value.trim() !== '') {
            this.chartOptionsService.setChartOption('title.text', value);
            this.chartOptionsService.setChartOption('title.enabled', true);
        }
        else {
            this.chartOptionsService.setChartOption('title.text', '');
            this.chartOptionsService.setChartOption('title.enabled', false);
        }
        this.getGui().classList.remove('currently-editing');
        // await chart updates so `chartTitleEdit` event consumers can read the new state correctly
        this.chartOptionsService.awaitChartOptionUpdate(() => {
            this.eventService.dispatchEvent({ type: 'chartTitleEdit' });
        });
    }
}
TitleEdit.TEMPLATE = `<textarea
             class="ag-chart-title-edit"
             style="padding:0; border:none; border-radius: 0; min-height: 0; text-align: center; resize: none;" />
        `;
__decorate$L([
    Autowired('chartTranslationService')
], TitleEdit.prototype, "chartTranslationService", void 0);
__decorate$L([
    PostConstruct
], TitleEdit.prototype, "init", null);

var __decorate$M = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ChartDatasource extends BeanStub {
    getData(params) {
        if (params.crossFiltering) {
            if (params.grouping) {
                console.warn("AG Grid: crossing filtering with row grouping is not supported.");
                return { chartData: [], columnNames: {} };
            }
            if (!this.gridOptionsService.isRowModelType('clientSide')) {
                console.warn("AG Grid: crossing filtering is only supported in the client side row model.");
                return { chartData: [], columnNames: {} };
            }
        }
        const isServerSide = this.gridOptionsService.isRowModelType('serverSide');
        if (isServerSide && params.pivoting) {
            this.updatePivotKeysForSSRM();
        }
        const result = this.extractRowsFromGridRowModel(params);
        result.chartData = this.aggregateRowsByDimension(params, result.chartData);
        return result;
    }
    extractRowsFromGridRowModel(params) {
        let extractedRowData = [];
        const columnNames = {};
        // maps used to keep track of expanded groups that need to be removed
        const groupNodeIndexes = {};
        const groupsToRemove = {};
        // only used when cross filtering
        let filteredNodes = {};
        let allRowNodes = [];
        let numRows;
        if (params.crossFiltering) {
            filteredNodes = this.getFilteredRowNodes();
            allRowNodes = this.getAllRowNodes();
            numRows = allRowNodes.length;
        }
        else {
            // make sure enough rows in range to chart. if user filters and less rows, then end row will be
            // the last displayed row, not where the range ends.
            const modelLastRow = this.gridRowModel.getRowCount() - 1;
            const rangeLastRow = params.endRow >= 0 ? Math.min(params.endRow, modelLastRow) : modelLastRow;
            numRows = rangeLastRow - params.startRow + 1;
        }
        for (let i = 0; i < numRows; i++) {
            const data = {};
            const rowNode = params.crossFiltering ? allRowNodes[i] : this.gridRowModel.getRow(i + params.startRow);
            // first get data for dimensions columns
            params.dimensionCols.forEach(col => {
                const colId = col.colId;
                const column = this.columnModel.getGridColumn(colId);
                if (column) {
                    const valueObject = this.valueService.getValue(column, rowNode);
                    // when grouping we also need to build up multi category labels for charts
                    if (params.grouping) {
                        const valueString = valueObject && valueObject.toString ? String(valueObject.toString()) : '';
                        // traverse parents to extract group label path
                        const labels = ChartDatasource.getGroupLabels(rowNode, valueString);
                        data[colId] = {
                            labels, toString: function () {
                                return this.labels.filter((l) => !!l).reverse().join(' - ');
                            }
                        };
                        // keep track of group node indexes, so they can be padded when other groups are expanded
                        if (rowNode.group) {
                            groupNodeIndexes[labels.toString()] = i;
                        }
                        // if node (group or leaf) has parents then it is expanded and should be removed
                        const groupKey = labels.slice(1, labels.length).toString();
                        if (groupKey) {
                            groupsToRemove[groupKey] = groupNodeIndexes[groupKey];
                        }
                    }
                    else {
                        // leaf nodes can be directly added to dimension columns
                        data[colId] = valueObject;
                    }
                }
                else {
                    // introduce a default category when no dimensions exist with a value based off row index (+1)
                    data[ChartDataModel.DEFAULT_CATEGORY] = i + 1;
                }
            });
            // then get data for value columns
            params.valueCols.forEach(col => {
                let columnNamesArr = [];
                // pivot keys should be added first
                const pivotKeys = col.getColDef().pivotKeys;
                if (pivotKeys) {
                    columnNamesArr = pivotKeys.slice();
                }
                // then add column header name to results
                const headerName = col.getColDef().headerName;
                if (headerName) {
                    columnNamesArr.push(headerName);
                }
                // add array of column names to results
                if (columnNamesArr.length > 0) {
                    columnNames[col.getId()] = columnNamesArr;
                }
                const colId = col.getColId();
                if (params.crossFiltering) {
                    const filteredOutColId = colId + '-filtered-out';
                    // add data value to value column
                    const value = this.valueService.getValue(col, rowNode);
                    const actualValue = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;
                    if (filteredNodes[rowNode.id]) {
                        data[colId] = actualValue;
                        data[filteredOutColId] = params.aggFunc || params.isScatter ? undefined : 0;
                    }
                    else {
                        data[colId] = params.aggFunc || params.isScatter ? undefined : 0;
                        data[filteredOutColId] = actualValue;
                    }
                }
                else {
                    // add data value to value column
                    let value = this.valueService.getValue(col, rowNode);
                    // aggregated value
                    if (value && value.hasOwnProperty('toString')) {
                        value = parseFloat(value.toString());
                    }
                    data[colId] = value != null && typeof value.toNumber === 'function' ? value.toNumber() : value;
                }
            });
            // row data from footer nodes should not be included in charts
            if (rowNode.footer) {
                // 'stamping' data as footer to avoid impacting previously calculated `groupIndexesToRemove` and will
                // be removed from the results along with any expanded group nodes
                data.footer = true;
            }
            // add data to results
            extractedRowData.push(data);
        }
        if (params.grouping) {
            const groupIndexesToRemove = _.values(groupsToRemove);
            const filterFunc = (data, index) => !data.footer && !_.includes(groupIndexesToRemove, index);
            extractedRowData = extractedRowData.filter(filterFunc);
        }
        return { chartData: extractedRowData, columnNames };
    }
    aggregateRowsByDimension(params, dataFromGrid) {
        const dimensionCols = params.dimensionCols;
        if (!params.aggFunc || dimensionCols.length === 0) {
            return dataFromGrid;
        }
        const lastCol = _.last(dimensionCols);
        const lastColId = lastCol && lastCol.colId;
        const map = {};
        const dataAggregated = [];
        dataFromGrid.forEach(data => {
            let currentMap = map;
            dimensionCols.forEach(col => {
                const colId = col.colId;
                const key = data[colId];
                if (colId === lastColId) {
                    let groupItem = currentMap[key];
                    if (!groupItem) {
                        groupItem = { __children: [] };
                        dimensionCols.forEach(dimCol => {
                            const dimColId = dimCol.colId;
                            groupItem[dimColId] = data[dimColId];
                        });
                        currentMap[key] = groupItem;
                        dataAggregated.push(groupItem);
                    }
                    groupItem.__children.push(data);
                }
                else {
                    // map of maps
                    if (!currentMap[key]) {
                        currentMap[key] = {};
                    }
                    currentMap = currentMap[key];
                }
            });
        });
        if (ModuleRegistry.__assertRegistered(ModuleNames.RowGroupingModule, 'Charting Aggregation', this.context.getGridId())) {
            dataAggregated.forEach(groupItem => params.valueCols.forEach(col => {
                if (params.crossFiltering) {
                    params.valueCols.forEach(valueCol => {
                        const colId = valueCol.getColId();
                        // filtered data
                        const dataToAgg = groupItem.__children
                            .filter((child) => typeof child[colId] !== 'undefined')
                            .map((child) => child[colId]);
                        let aggResult = this.aggregationStage.aggregateValues(dataToAgg, params.aggFunc);
                        groupItem[valueCol.getId()] = aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult;
                        // filtered out data
                        const filteredOutColId = `${colId}-filtered-out`;
                        const dataToAggFiltered = groupItem.__children
                            .filter((child) => typeof child[filteredOutColId] !== 'undefined')
                            .map((child) => child[filteredOutColId]);
                        let aggResultFiltered = this.aggregationStage.aggregateValues(dataToAggFiltered, params.aggFunc);
                        groupItem[filteredOutColId] = aggResultFiltered && typeof aggResultFiltered.value !== 'undefined' ? aggResultFiltered.value : aggResultFiltered;
                    });
                }
                else {
                    const dataToAgg = groupItem.__children.map((child) => child[col.getId()]);
                    let aggResult = 0;
                    if (ModuleRegistry.__assertRegistered(ModuleNames.RowGroupingModule, 'Charting Aggregation', this.context.getGridId())) {
                        aggResult = this.aggregationStage.aggregateValues(dataToAgg, params.aggFunc);
                    }
                    groupItem[col.getId()] = aggResult && typeof aggResult.value !== 'undefined' ? aggResult.value : aggResult;
                }
            }));
        }
        return dataAggregated;
    }
    updatePivotKeysForSSRM() {
        const secondaryColumns = this.columnModel.getSecondaryColumns();
        if (!secondaryColumns) {
            return;
        }
        // we don't know what the application will use for the pivot key separator (i.e. '_' or '|' ) as the
        // secondary columns are provided to grid by the application via api.setSecondaryColumns()
        const pivotKeySeparator = this.extractPivotKeySeparator(secondaryColumns);
        // `pivotKeys` is not used by the SSRM for pivoting, so it is safe to reuse this colDef property. This way
        // the same logic can be used for CSRM and SSRM to extract legend names in extractRowsFromGridRowModel()
        secondaryColumns.forEach(col => {
            if (pivotKeySeparator === '') {
                col.getColDef().pivotKeys = [];
            }
            else {
                const keys = col.getColId().split(pivotKeySeparator);
                col.getColDef().pivotKeys = keys.slice(0, keys.length - 1);
            }
        });
    }
    extractPivotKeySeparator(secondaryColumns) {
        if (secondaryColumns.length === 0) {
            return '';
        }
        const extractSeparator = (columnGroup, childId) => {
            const groupId = columnGroup.getGroupId();
            if (!columnGroup.getParent()) {
                // removing groupId ('2000') from childId ('2000|Swimming') yields '|Swimming' so first char is separator
                return childId.split(groupId)[1][0];
            }
            return extractSeparator(columnGroup.getParent(), groupId);
        };
        const firstSecondaryCol = secondaryColumns[0];
        if (firstSecondaryCol.getParent() == null) {
            return '';
        }
        return extractSeparator(firstSecondaryCol.getParent(), firstSecondaryCol.getColId());
    }
    static getGroupLabels(rowNode, initialLabel) {
        const labels = [initialLabel];
        while (rowNode && rowNode.level !== 0) {
            rowNode = rowNode.parent;
            if (rowNode) {
                labels.push(rowNode.key);
            }
        }
        return labels;
    }
    getFilteredRowNodes() {
        const filteredNodes = {};
        this.gridRowModel.forEachNodeAfterFilterAndSort((rowNode) => {
            filteredNodes[rowNode.id] = rowNode;
        });
        return filteredNodes;
    }
    getAllRowNodes() {
        let allRowNodes = [];
        this.gridRowModel.forEachNode((rowNode) => {
            allRowNodes.push(rowNode);
        });
        return this.sortRowNodes(allRowNodes);
    }
    sortRowNodes(rowNodes) {
        const sortOptions = this.sortController.getSortOptions();
        const noSort = !sortOptions || sortOptions.length == 0;
        if (noSort)
            return rowNodes;
        return this.rowNodeSorter.doFullSort(rowNodes, sortOptions);
    }
}
__decorate$M([
    Autowired('rowModel')
], ChartDatasource.prototype, "gridRowModel", void 0);
__decorate$M([
    Autowired('valueService')
], ChartDatasource.prototype, "valueService", void 0);
__decorate$M([
    Autowired('columnModel')
], ChartDatasource.prototype, "columnModel", void 0);
__decorate$M([
    Autowired('rowNodeSorter')
], ChartDatasource.prototype, "rowNodeSorter", void 0);
__decorate$M([
    Autowired('sortController')
], ChartDatasource.prototype, "sortController", void 0);
__decorate$M([
    Optional('aggregationStage')
], ChartDatasource.prototype, "aggregationStage", void 0);

var __decorate$N = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ChartColumnService = class ChartColumnService extends BeanStub {
    getColumn(colId) {
        return this.columnModel.getPrimaryColumn(colId);
    }
    getAllDisplayedColumns() {
        return this.columnModel.getAllDisplayedColumns();
    }
    getColDisplayName(col) {
        return this.columnModel.getDisplayNameForColumn(col, 'chart');
    }
    getRowGroupColumns() {
        return this.columnModel.getRowGroupColumns();
    }
    getGroupDisplayColumns() {
        return this.columnModel.getGroupDisplayColumns();
    }
    isPivotMode() {
        return this.columnModel.isPivotMode();
    }
    isPivotActive() {
        return this.columnModel.isPivotActive();
    }
    getChartColumns() {
        const displayedCols = this.columnModel.getAllDisplayedColumns();
        const dimensionCols = new Set();
        const valueCols = new Set();
        displayedCols.forEach(col => {
            const colDef = col.getColDef();
            const chartDataType = colDef.chartDataType;
            if (chartDataType) {
                // chart data type was specified explicitly
                switch (chartDataType) {
                    case 'category':
                    case 'time':
                        dimensionCols.add(col);
                        return;
                    case 'series':
                        valueCols.add(col);
                        return;
                    case 'excluded':
                        return;
                    default:
                        console.warn(`AG Grid: unexpected chartDataType value '${chartDataType}' supplied, instead use 'category', 'series' or 'excluded'`);
                        break;
                }
            }
            if (colDef.colId === 'ag-Grid-AutoColumn') {
                dimensionCols.add(col);
                return;
            }
            if (!col.isPrimary()) {
                valueCols.add(col);
                return;
            }
            // if 'chartDataType' is not provided then infer type based data contained in first row
            (this.isNumberCol(col) ? valueCols : dimensionCols).add(col);
        });
        return { dimensionCols, valueCols };
    }
    isNumberCol(col) {
        if (col.getColId() === 'ag-Grid-AutoColumn') {
            return false;
        }
        const row = this.rowRenderer.getRowNode({ rowIndex: 0, rowPinned: null });
        if (!row) {
            return false;
        }
        let cellValue = this.valueService.getValue(col, row);
        if (cellValue == null) {
            cellValue = this.extractLeafData(row, col);
        }
        if (cellValue != null && typeof cellValue.toNumber === 'function') {
            cellValue = cellValue.toNumber();
        }
        return typeof cellValue === 'number';
    }
    extractLeafData(row, col) {
        if (!row.allLeafChildren) {
            return null;
        }
        for (let i = 0; i < row.allLeafChildren.length; i++) {
            const childRow = row.allLeafChildren[i];
            const value = this.valueService.getValue(col, childRow);
            if (value != null) {
                return value;
            }
        }
        return null;
    }
};
__decorate$N([
    Autowired('columnModel')
], ChartColumnService.prototype, "columnModel", void 0);
__decorate$N([
    Autowired('valueService')
], ChartColumnService.prototype, "valueService", void 0);
__decorate$N([
    Autowired('rowRenderer')
], ChartColumnService.prototype, "rowRenderer", void 0);
ChartColumnService = __decorate$N([
    Bean("chartColumnService")
], ChartColumnService);

var __decorate$O = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ComboChartModel extends BeanStub {
    constructor(chartDataModel) {
        var _a;
        super();
        // this control flag is used to only log warning for the initial user config
        this.suppressComboChartWarnings = false;
        this.chartDataModel = chartDataModel;
        this.seriesChartTypes = (_a = chartDataModel.params.seriesChartTypes) !== null && _a !== void 0 ? _a : [];
    }
    init() {
        this.initComboCharts();
    }
    update(seriesChartTypes) {
        this.seriesChartTypes = seriesChartTypes !== null && seriesChartTypes !== void 0 ? seriesChartTypes : this.seriesChartTypes;
        this.initComboCharts();
        this.updateSeriesChartTypes();
    }
    initComboCharts() {
        const seriesChartTypesExist = this.seriesChartTypes && this.seriesChartTypes.length > 0;
        const customCombo = this.chartDataModel.chartType === 'customCombo' || seriesChartTypesExist;
        if (customCombo) {
            // it is not necessary to supply a chart type for combo charts when `seriesChartTypes` is supplied
            this.chartDataModel.chartType = 'customCombo';
            // cache supplied `seriesChartTypes` to allow switching between different chart types in the settings panel
            this.savedCustomSeriesChartTypes = this.seriesChartTypes || [];
        }
    }
    updateSeriesChartTypes() {
        if (!this.chartDataModel.isComboChart()) {
            return;
        }
        // ensure primary only chart types are not placed on secondary axis
        this.seriesChartTypes = this.seriesChartTypes.map(seriesChartType => {
            const primaryOnly = ['groupedColumn', 'stackedColumn', 'stackedArea'].includes(seriesChartType.chartType);
            seriesChartType.secondaryAxis = primaryOnly ? false : seriesChartType.secondaryAxis;
            return seriesChartType;
        });
        // note that when seriesChartTypes are supplied the chart type is also changed to 'customCombo'
        if (this.chartDataModel.chartType === 'customCombo') {
            this.updateSeriesChartTypesForCustomCombo();
            return;
        }
        this.updateChartSeriesTypesForBuiltInCombos();
    }
    updateSeriesChartTypesForCustomCombo() {
        const seriesChartTypesSupplied = this.seriesChartTypes && this.seriesChartTypes.length > 0;
        if (!seriesChartTypesSupplied && !this.suppressComboChartWarnings) {
            console.warn(`AG Grid: 'seriesChartTypes' are required when the 'customCombo' chart type is specified.`);
        }
        // ensure correct chartTypes are supplied
        this.seriesChartTypes = this.seriesChartTypes.map(s => {
            if (!ComboChartModel.SUPPORTED_COMBO_CHART_TYPES.includes(s.chartType)) {
                console.warn(`AG Grid: invalid chartType '${s.chartType}' supplied in 'seriesChartTypes', converting to 'line' instead.`);
                s.chartType = 'line';
            }
            return s;
        });
        const getSeriesChartType = (valueCol) => {
            if (!this.savedCustomSeriesChartTypes || this.savedCustomSeriesChartTypes.length === 0) {
                this.savedCustomSeriesChartTypes = this.seriesChartTypes;
            }
            const providedSeriesChartType = this.savedCustomSeriesChartTypes.find(s => s.colId === valueCol.colId);
            if (!providedSeriesChartType) {
                if (valueCol.selected && !this.suppressComboChartWarnings) {
                    console.warn(`AG Grid: no 'seriesChartType' found for colId = '${valueCol.colId}', defaulting to 'line'.`);
                }
                return {
                    colId: valueCol.colId,
                    chartType: 'line',
                    secondaryAxis: false
                };
            }
            return providedSeriesChartType;
        };
        const updatedSeriesChartTypes = this.chartDataModel.valueColState.map(getSeriesChartType);
        this.seriesChartTypes = updatedSeriesChartTypes;
        // also cache custom `seriesChartTypes` to allow for switching between different chart types
        this.savedCustomSeriesChartTypes = updatedSeriesChartTypes;
        // turn off warnings as first combo chart attempt has completed
        this.suppressComboChartWarnings = true;
    }
    updateChartSeriesTypesForBuiltInCombos() {
        const { chartType, valueColState } = this.chartDataModel;
        let primaryChartType = chartType === 'columnLineCombo' ? 'groupedColumn' : 'stackedArea';
        let secondaryChartType = chartType === 'columnLineCombo' ? 'line' : 'groupedColumn';
        const selectedCols = valueColState.filter(cs => cs.selected);
        const lineIndex = Math.ceil(selectedCols.length / 2);
        this.seriesChartTypes = selectedCols.map((valueCol, i) => {
            const seriesType = (i >= lineIndex) ? secondaryChartType : primaryChartType;
            return { colId: valueCol.colId, chartType: seriesType, secondaryAxis: false };
        });
    }
}
ComboChartModel.SUPPORTED_COMBO_CHART_TYPES = ['line', 'groupedColumn', 'stackedColumn', 'area', 'stackedArea'];
__decorate$O([
    PostConstruct
], ComboChartModel.prototype, "init", null);

var __decorate$P = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ChartDataModel extends BeanStub {
    constructor(params) {
        super();
        this.unlinked = false;
        this.chartData = [];
        this.valueColState = [];
        this.dimensionColState = [];
        this.columnNames = {};
        this.crossFiltering = false;
        this.grouping = false;
        this.params = params;
        this.chartId = params.chartId;
        this.chartType = params.chartType;
        this.pivotChart = params.pivotChart;
        this.chartThemeName = params.chartThemeName;
        this.aggFunc = params.aggFunc;
        this.referenceCellRange = params.cellRange;
        this.suppliedCellRange = params.cellRange;
        this.suppressChartRanges = params.suppressChartRanges;
        this.unlinked = !!params.unlinkChart;
        this.crossFiltering = !!params.crossFiltering;
    }
    init() {
        this.datasource = this.createManagedBean(new ChartDatasource());
        this.chartColumnService = this.createManagedBean(new ChartColumnService());
        this.comboChartModel = this.createManagedBean(new ComboChartModel(this));
        this.updateCellRanges();
        this.updateData();
    }
    updateModel(params) {
        const { cellRange, chartType, pivotChart, chartThemeName, aggFunc, suppressChartRanges, unlinkChart, crossFiltering, seriesChartTypes } = params;
        if (cellRange !== this.suppliedCellRange) {
            this.dimensionCellRange = undefined;
            this.valueCellRange = undefined;
        }
        this.chartType = chartType;
        this.pivotChart = pivotChart;
        this.chartThemeName = chartThemeName;
        this.aggFunc = aggFunc;
        this.referenceCellRange = cellRange;
        this.suppliedCellRange = cellRange;
        this.suppressChartRanges = suppressChartRanges;
        this.unlinked = !!unlinkChart;
        this.crossFiltering = !!crossFiltering;
        this.updateSelectedDimensions(cellRange === null || cellRange === void 0 ? void 0 : cellRange.columns);
        this.updateCellRanges();
        const shouldUpdateComboModel = this.isComboChart() || seriesChartTypes;
        if (shouldUpdateComboModel) {
            this.comboChartModel.update(seriesChartTypes);
        }
        if (!this.unlinked) {
            this.updateData();
        }
    }
    updateCellRanges(updatedColState) {
        if (this.valueCellRange) {
            this.referenceCellRange = this.valueCellRange;
        }
        const { dimensionCols, valueCols } = this.chartColumnService.getChartColumns();
        const allColsFromRanges = this.getAllColumnsFromRanges();
        if (updatedColState) {
            this.updateColumnState(updatedColState);
        }
        this.setDimensionCellRange(dimensionCols, allColsFromRanges, updatedColState);
        this.setValueCellRange(valueCols, allColsFromRanges, updatedColState);
        if (!updatedColState) {
            this.resetColumnState();
            // dimension / category cell range could be out of sync after resetting column state when row grouping
            this.syncDimensionCellRange();
        }
        this.comboChartModel.updateSeriesChartTypes();
    }
    updateData() {
        const { startRow, endRow } = this.getRowIndexes();
        if (this.pivotChart) {
            this.resetColumnState();
        }
        this.grouping = this.isGrouping();
        const params = {
            aggFunc: this.aggFunc,
            dimensionCols: this.getSelectedDimensions(),
            grouping: this.grouping,
            pivoting: this.isPivotActive(),
            crossFiltering: this.crossFiltering,
            valueCols: this.getSelectedValueCols(),
            startRow,
            endRow,
            isScatter: _.includes(['scatter', 'bubble'], this.chartType)
        };
        const { chartData, columnNames } = this.datasource.getData(params);
        this.chartData = chartData;
        this.columnNames = columnNames;
    }
    isGrouping() {
        const usingTreeData = this.gridOptionsService.get('treeData');
        const groupedCols = usingTreeData ? null : this.chartColumnService.getRowGroupColumns();
        const isGroupActive = usingTreeData || (groupedCols && groupedCols.length > 0);
        // charts only group when the selected category is a group column
        const colIds = this.getSelectedDimensions().map(({ colId }) => colId);
        const displayedGroupCols = this.chartColumnService.getGroupDisplayColumns();
        const groupDimensionSelected = displayedGroupCols.map(col => col.getColId()).some(id => colIds.includes(id));
        return !!isGroupActive && groupDimensionSelected;
    }
    getSelectedValueCols() {
        return this.valueColState.filter(cs => cs.selected).map(cs => cs.column);
    }
    getSelectedDimensions() {
        return this.dimensionColState.filter(cs => cs.selected);
    }
    getColDisplayName(col) {
        return this.chartColumnService.getColDisplayName(col);
    }
    isPivotMode() {
        return this.chartColumnService.isPivotMode();
    }
    getChartDataType(colId) {
        const column = this.chartColumnService.getColumn(colId);
        return column ? column.getColDef().chartDataType : undefined;
    }
    isPivotActive() {
        return this.chartColumnService.isPivotActive();
    }
    createCellRange(type, ...columns) {
        return {
            id: this.chartId,
            startRow: this.referenceCellRange.startRow,
            endRow: this.referenceCellRange.endRow,
            columns,
            startColumn: type === CellRangeType.DIMENSION ? columns[0] : this.referenceCellRange.startColumn,
            type
        };
    }
    getAllColumnsFromRanges() {
        if (this.pivotChart) {
            return _.convertToSet(this.chartColumnService.getAllDisplayedColumns());
        }
        const columns = this.dimensionCellRange || this.valueCellRange ? [] : this.referenceCellRange.columns;
        if (this.dimensionCellRange) {
            columns.push(...this.dimensionCellRange.columns);
        }
        if (this.valueCellRange) {
            columns.push(...this.valueCellRange.columns);
        }
        return _.convertToSet(columns);
    }
    getRowIndexes() {
        let startRow = 0, endRow = 0;
        const { rangeService, valueCellRange, dimensionCellRange } = this;
        // Not all chart types require a value series (e.g. hierarchical charts),
        // so fall back to using the dimension cell range for inferring row indices
        const cellRange = valueCellRange || dimensionCellRange;
        if (rangeService && cellRange) {
            startRow = rangeService.getRangeStartRow(cellRange).rowIndex;
            // when the last row the cell range is a pinned 'bottom' row, the `endRow` index is set to -1 which results
            // in the ChartDatasource processing all non pinned rows from the `startRow` index.
            const endRowPosition = rangeService.getRangeEndRow(cellRange);
            endRow = endRowPosition.rowPinned === 'bottom' ? -1 : endRowPosition.rowIndex;
        }
        return { startRow, endRow };
    }
    resetColumnState() {
        const { dimensionCols, valueCols } = this.chartColumnService.getChartColumns();
        const allCols = this.getAllColumnsFromRanges();
        const isInitialising = this.valueColState.length < 1;
        this.dimensionColState = [];
        this.valueColState = [];
        const supportsMultipleDimensions = isHierarchical(this.chartType);
        let hasSelectedDimension = false;
        let order = 1;
        const aggFuncDimension = this.suppliedCellRange.columns[0]; //TODO
        dimensionCols.forEach(column => {
            const isAutoGroupCol = column.getColId() === 'ag-Grid-AutoColumn';
            let selected = false;
            if (this.crossFiltering && this.aggFunc) {
                if (aggFuncDimension.getColId() === column.getColId()) {
                    selected = true;
                }
            }
            else {
                selected = isAutoGroupCol ? true : (!hasSelectedDimension || supportsMultipleDimensions) && allCols.has(column);
            }
            this.dimensionColState.push({
                column,
                colId: column.getColId(),
                displayName: this.getColDisplayName(column),
                selected,
                order: order++
            });
            if (selected) {
                hasSelectedDimension = true;
            }
        });
        const defaultCategory = {
            colId: ChartDataModel.DEFAULT_CATEGORY,
            displayName: this.chartTranslationService.translate('defaultCategory'),
            selected: !hasSelectedDimension,
            order: 0
        };
        this.dimensionColState.unshift(defaultCategory);
        const valueColumnsFromReferenceRange = this.referenceCellRange.columns.filter(c => valueCols.has(c));
        valueCols.forEach(column => {
            // first time the value cell range is set, preserve the column order from the supplied range
            if (isInitialising && _.includes(this.referenceCellRange.columns, column)) {
                column = valueColumnsFromReferenceRange.shift();
            }
            this.valueColState.push({
                column,
                colId: column.getColId(),
                displayName: this.getColDisplayName(column),
                selected: allCols.has(column),
                order: order++
            });
        });
    }
    updateColumnState(updatedCol) {
        const idsMatch = (cs) => cs.colId === updatedCol.colId;
        const { dimensionColState, valueColState } = this;
        // Determine whether the specified column is a dimension or value column
        const matchedDimensionColState = dimensionColState.find(idsMatch);
        const matchedValueColState = valueColState.find(idsMatch);
        if (matchedDimensionColState) {
            // For non-hierarchical chart types, only one dimension can be selected
            const supportsMultipleDimensions = isHierarchical(this.chartType);
            if (!supportsMultipleDimensions) {
                // Determine which column should end up selected, if any
                const selectedColumnState = updatedCol.selected
                    ? matchedDimensionColState
                    : dimensionColState
                        .filter((cs) => cs !== matchedDimensionColState)
                        .find(({ selected }) => selected);
                // Update the selection state of all dimension columns
                dimensionColState.forEach(cs => cs.selected = (cs === selectedColumnState));
            }
            else {
                // Update the selection state of the specified dimension column
                matchedDimensionColState.selected = updatedCol.selected;
            }
        }
        else if (matchedValueColState) {
            // Update the selection state of the specified value column
            matchedValueColState.selected = updatedCol.selected;
        }
        const allColumns = [...dimensionColState, ...valueColState];
        const orderedColIds = [];
        // calculate new order
        allColumns.forEach((col, i) => {
            if (i === updatedCol.order) {
                orderedColIds.push(updatedCol.colId);
            }
            if (col.colId !== updatedCol.colId) {
                orderedColIds.push(col.colId);
            }
        });
        // update col state with new order
        allColumns.forEach(col => {
            const order = orderedColIds.indexOf(col.colId);
            col.order = order >= 0 ? orderedColIds.indexOf(col.colId) : allColumns.length - 1;
        });
        this.reorderColState();
    }
    reorderColState() {
        const ascColStateOrder = (a, b) => a.order - b.order;
        this.dimensionColState.sort(ascColStateOrder);
        this.valueColState.sort(ascColStateOrder);
    }
    setDimensionCellRange(dimensionCols, colsInRange, updatedColState) {
        this.dimensionCellRange = undefined;
        if (!updatedColState && !this.dimensionColState.length) {
            const supportsMultipleDimensions = isHierarchical(this.chartType);
            const selectedCols = new Array();
            // use first dimension column in range by default, or all dimension columns for hierarchical charts
            dimensionCols.forEach(col => {
                if ((selectedCols.length > 0 && !supportsMultipleDimensions) || !colsInRange.has(col)) {
                    return;
                }
                selectedCols.push(col);
            });
            if (selectedCols.length > 0) {
                this.dimensionCellRange = this.createCellRange(CellRangeType.DIMENSION, ...selectedCols);
            }
            return;
        }
        let selectedDimensionColStates = updatedColState ? [updatedColState] : [];
        if (this.crossFiltering && this.aggFunc) {
            const aggFuncDimension = this.suppliedCellRange.columns[0]; //TODO
            selectedDimensionColStates = this.dimensionColState.filter(cs => cs.colId === aggFuncDimension.getColId());
        }
        else if (selectedDimensionColStates.length === 0 || selectedDimensionColStates.some(({ column }) => !column || !dimensionCols.has(column))) {
            selectedDimensionColStates = this.dimensionColState.filter(cs => cs.selected);
        }
        const isDefaultCategory = selectedDimensionColStates.length === 1
            ? selectedDimensionColStates[0].colId === ChartDataModel.DEFAULT_CATEGORY
            : false;
        const selectedColumns = selectedDimensionColStates.map(({ column }) => column)
            .filter((value) => value != null);
        if (selectedColumns.length > 0 && !isDefaultCategory) {
            this.dimensionCellRange = this.createCellRange(CellRangeType.DIMENSION, ...selectedColumns);
        }
    }
    setValueCellRange(valueCols, colsInRange, updatedColState) {
        this.valueCellRange = undefined;
        const selectedValueCols = [];
        valueCols.forEach(col => {
            if (updatedColState && updatedColState.colId === col.getColId()) {
                if (updatedColState.selected) {
                    selectedValueCols.push(updatedColState.column);
                }
            }
            else if (colsInRange.has(col)) {
                selectedValueCols.push(col);
            }
        });
        if (selectedValueCols.length > 0) {
            let orderedColIds = [];
            if (this.valueColState.length > 0) {
                orderedColIds = this.valueColState.map(c => c.colId);
            }
            else {
                colsInRange.forEach(c => orderedColIds.push(c.getColId()));
            }
            selectedValueCols.sort((a, b) => orderedColIds.indexOf(a.getColId()) - orderedColIds.indexOf(b.getColId()));
            this.valueCellRange = this.createCellRange(CellRangeType.VALUE, ...selectedValueCols);
        }
    }
    updateSelectedDimensions(columns) {
        const colIdSet = new Set(columns.map((column) => column.getColId()));
        // For non-hierarchical chart types, only one dimension can be selected
        const supportsMultipleDimensions = isHierarchical(this.chartType);
        if (!supportsMultipleDimensions) {
            // Determine which column should end up selected, if any
            // if no dimension found in supplied columns use the default category (always index = 0)
            const foundColState = this.dimensionColState.find((colState) => colIdSet.has(colState.colId)) || this.dimensionColState[0];
            const selectedColumnId = foundColState.colId;
            // Update the selection state of all dimension columns
            this.dimensionColState = this.dimensionColState.map((colState) => (Object.assign(Object.assign({}, colState), { selected: colState.colId === selectedColumnId })));
        }
        else {
            // Update the selection state of all dimension columns, selecting only the provided columns from the chart model
            const foundColStates = this.dimensionColState.filter((colState) => colIdSet.has(colState.colId));
            const selectedColumnIds = new Set(foundColStates.map((colState) => colState.colId));
            this.dimensionColState = this.dimensionColState.map((colState) => (Object.assign(Object.assign({}, colState), { selected: selectedColumnIds.has(colState.colId) })));
        }
    }
    syncDimensionCellRange() {
        const selectedDimensions = this.getSelectedDimensions();
        if (selectedDimensions.length === 0)
            return;
        const selectedCols = selectedDimensions.map(({ column }) => column)
            .filter((value) => value != null);
        if (selectedCols.length > 0) {
            this.dimensionCellRange = this.createCellRange(CellRangeType.DIMENSION, ...selectedCols);
        }
    }
    isComboChart() {
        return ['columnLineCombo', 'areaColumnCombo', 'customCombo'].includes(this.chartType);
    }
}
ChartDataModel.DEFAULT_CATEGORY = 'AG-GRID-DEFAULT-CATEGORY';
__decorate$P([
    Autowired('rangeService')
], ChartDataModel.prototype, "rangeService", void 0);
__decorate$P([
    Autowired('chartTranslationService')
], ChartDataModel.prototype, "chartTranslationService", void 0);
__decorate$P([
    PostConstruct
], ChartDataModel.prototype, "init", null);

function deproxy(chartOrProxy) {
    if (chartOrProxy.chart != null) {
        return chartOrProxy.chart;
    }
    return chartOrProxy;
}

class ChartProxy {
    constructor(chartProxyParams) {
        this.chartProxyParams = chartProxyParams;
        this.clearThemeOverrides = false;
        this.chart = chartProxyParams.chartInstance;
        this.chartType = chartProxyParams.chartType;
        this.crossFiltering = chartProxyParams.crossFiltering;
        this.crossFilterCallback = chartProxyParams.crossFilterCallback;
        this.standaloneChartType = getSeriesType(this.chartType);
        if (this.chart == null) {
            this.chart = AgCharts.create(this.getCommonChartOptions());
        }
        else {
            // On chart change, reset formatting panel changes.
            this.clearThemeOverrides = true;
        }
    }
    getChart() {
        return deproxy(this.chart);
    }
    getChartRef() {
        return this.chart;
    }
    downloadChart(dimensions, fileName, fileFormat) {
        const { chart } = this;
        const rawChart = deproxy(chart);
        const imageFileName = fileName || (rawChart.title ? rawChart.title.text : 'chart');
        const { width, height } = dimensions || {};
        AgCharts.download(chart, { width, height, fileName: imageFileName, fileFormat });
    }
    getChartImageDataURL(type) {
        return this.getChart().scene.getDataURL(type);
    }
    getChartOptions() {
        return this.chart.getOptions();
    }
    getChartThemeOverrides() {
        var _a;
        const chartOptionsTheme = this.getChartOptions().theme;
        return (_a = chartOptionsTheme.overrides) !== null && _a !== void 0 ? _a : {};
    }
    getChartPalette() {
        return integrated_charts_theme_exports.getChartTheme(this.getChartOptions().theme).palette;
    }
    setPaired(paired) {
        // Special handling to make scatter charts operate in paired mode by default, where 
        // columns alternate between being X and Y (and size for bubble). In standard mode,
        // the first column is used for X and every other column is treated as Y
        // (or alternates between Y and size for bubble)
        const seriesType = getSeriesType(this.chartProxyParams.chartType);
        AgCharts.updateDelta(this.chart, { theme: { overrides: { [seriesType]: { paired } } } });
    }
    isPaired() {
        const seriesType = getSeriesType(this.chartProxyParams.chartType);
        return get(this.getChartThemeOverrides(), `${seriesType}.paired`, true);
    }
    lookupCustomChartTheme(themeName) {
        return lookupCustomChartTheme(this.chartProxyParams, themeName);
    }
    transformData(data, categoryKey, categoryAxis) {
        if (categoryAxis) {
            // replace the values for the selected category with a complex object to allow for duplicated categories
            return data.map((d, index) => {
                const value = d[categoryKey];
                const valueString = value && value.toString ? value.toString() : '';
                const datum = Object.assign({}, d);
                datum[categoryKey] = { id: index, value, toString: () => valueString };
                return datum;
            });
        }
        return data;
    }
    getCommonChartOptions(updatedOverrides) {
        var _a, _b;
        // Only apply active overrides if chart is initialised.
        const existingOptions = this.clearThemeOverrides ? {} : (_b = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.getOptions()) !== null && _b !== void 0 ? _b : {};
        const formattingPanelOverrides = this.chart != null ? this.getActiveFormattingPanelOverrides() : undefined;
        this.clearThemeOverrides = false;
        // Create a base theme and apply the various layers of overrides.
        const baseTheme = createAgChartTheme(this.chartProxyParams, this);
        const chartThemeDefaults = this.getChartThemeDefaults();
        const theme = applyThemeOverrides(baseTheme, [
            chartThemeDefaults,
            updatedOverrides !== null && updatedOverrides !== void 0 ? updatedOverrides : formattingPanelOverrides,
        ]);
        return Object.assign(Object.assign({}, existingOptions), { theme, container: this.chartProxyParams.parentElement, mode: 'integrated' });
    }
    /**
     * Retrieve default theme overrides for the current chart type
     */
    getChartThemeDefaults() {
        // Override this method to provide chart type specific theme overrides
        return undefined;
    }
    getActiveFormattingPanelOverrides() {
        var _a, _b;
        if (this.clearThemeOverrides) {
            return {};
        }
        const inUseTheme = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.getOptions().theme;
        return (_b = inUseTheme === null || inUseTheme === void 0 ? void 0 : inUseTheme.overrides) !== null && _b !== void 0 ? _b : {};
    }
    destroy({ keepChartInstance = false } = {}) {
        if (keepChartInstance) {
            // Reset Charts animation state, so that future updates to this re-used chart instance
            // behave as-if the chart is brand new. When switching chartTypes, this means we hide
            // the fact we are reusing the chart instance; the user sees a new chart which behaves
            // as-if it is a completely new and distinct chart instance.
            this.chart.resetAnimations();
            return this.chart;
        }
        this.destroyChart();
    }
    destroyChart() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = undefined;
        }
    }
}

class CartesianChartProxy extends ChartProxy {
    constructor(params) {
        super(params);
        this.crossFilteringAllPoints = new Set();
        this.crossFilteringSelectedPoints = [];
    }
    update(params) {
        const axes = this.getAxes(params);
        const options = Object.assign(Object.assign({}, this.getCommonChartOptions(params.updatedOverrides)), { data: this.getData(params, axes), axes, series: this.getSeries(params) });
        AgCharts.update(this.getChartRef(), options);
    }
    getData(params, axes) {
        const supportsCrossFiltering = ['area', 'line'].includes(this.standaloneChartType);
        const xAxisIsCategory = axes.some(axes => (axes === null || axes === void 0 ? void 0 : axes.type) === 'category');
        return this.crossFiltering && supportsCrossFiltering ?
            this.getCrossFilterData(params) :
            this.getDataTransformedData(params, xAxisIsCategory);
    }
    getDataTransformedData(params, isCategoryAxis) {
        const [category] = params.categories;
        return this.transformData(params.data, category.id, isCategoryAxis);
    }
    getXAxisType(params) {
        if (params.grouping) {
            return 'grouped-category';
        }
        else if (CartesianChartProxy.isTimeAxis(params)) {
            return 'time';
        }
        return 'category';
    }
    static isTimeAxis(params) {
        const [category] = params.categories;
        if (category && category.chartDataType) {
            return category.chartDataType === 'time';
        }
        const testDatum = params.data[0];
        return (testDatum && testDatum[category.id]) instanceof Date;
    }
    crossFilteringReset() {
        this.crossFilteringSelectedPoints = [];
        this.crossFilteringAllPoints.clear();
    }
    crossFilteringPointSelected(point) {
        return this.crossFilteringSelectedPoints.length == 0 || this.crossFilteringSelectedPoints.includes(point);
    }
    crossFilteringDeselectedPoints() {
        return this.crossFilteringSelectedPoints.length > 0 &&
            this.crossFilteringAllPoints.size !== this.crossFilteringSelectedPoints.length;
    }
    extractLineAreaCrossFilterSeries(series, params) {
        const [category] = params.categories;
        const getYKey = (yKey) => {
            if (this.standaloneChartType === 'area') {
                const lastSelectedChartId = params.getCrossFilteringContext().lastSelectedChartId;
                return (lastSelectedChartId === params.chartId) ? yKey + '-total' : yKey;
            }
            return yKey + '-total';
        };
        return series.map(s => {
            s.yKey = getYKey(s.yKey);
            s.listeners = {
                nodeClick: (e) => {
                    const value = e.datum[s.xKey];
                    const multiSelection = e.event.metaKey || e.event.ctrlKey;
                    this.crossFilteringAddSelectedPoint(multiSelection, value);
                    this.crossFilterCallback(e);
                }
            };
            s.marker = {
                formatter: (p) => {
                    const value = p.datum[category.id];
                    return {
                        fill: p.highlighted ? 'yellow' : p.fill,
                        size: p.highlighted ? 14 : this.crossFilteringPointSelected(value) ? 8 : 0,
                    };
                }
            };
            if (this.standaloneChartType === 'area') {
                s.fillOpacity = this.crossFilteringDeselectedPoints() ? 0.3 : 1;
            }
            if (this.standaloneChartType === 'line') {
                s.strokeOpacity = this.crossFilteringDeselectedPoints() ? 0.3 : 1;
            }
            return s;
        });
    }
    getCrossFilterData(params) {
        this.crossFilteringAllPoints.clear();
        const [category] = params.categories;
        const colId = params.fields[0].colId;
        const filteredOutColId = `${colId}-filtered-out`;
        const lastSelectedChartId = params.getCrossFilteringContext().lastSelectedChartId;
        return params.data.map(d => {
            const value = d[category.id];
            this.crossFilteringAllPoints.add(value);
            const pointSelected = this.crossFilteringPointSelected(value);
            if (this.standaloneChartType === 'area' && lastSelectedChartId === params.chartId) {
                d[`${colId}-total`] = pointSelected ? d[colId] : d[colId] + d[filteredOutColId];
            }
            if (this.standaloneChartType === 'line') {
                d[`${colId}-total`] = pointSelected ? d[colId] : d[colId] + d[filteredOutColId];
            }
            return d;
        });
    }
    crossFilteringAddSelectedPoint(multiSelection, value) {
        multiSelection ? this.crossFilteringSelectedPoints.push(value) : this.crossFilteringSelectedPoints = [value];
    }
}

function hexToRGBA(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return alpha ? `rgba(${r}, ${g}, ${b}, ${alpha})` : `rgba(${r}, ${g}, ${b})`;
}
function changeOpacity(fills, alpha) {
    return fills.map(fill => {
        const c = sparklines_util_exports.Color.fromString(fill);
        return new sparklines_util_exports.Color(c.r, c.g, c.b, alpha).toHexString();
    });
}

class BarChartProxy extends CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        const axes = [
            {
                type: this.getXAxisType(params),
                position: isHorizontal(this.chartType) ? 'left' : 'bottom',
            },
            {
                type: 'number',
                position: isHorizontal(this.chartType) ? 'bottom' : 'left',
            },
        ];
        // Add a default label formatter to show '%' for normalized charts if none is provided
        if (this.isNormalised()) {
            const numberAxis = axes[1];
            numberAxis.label = Object.assign(Object.assign({}, numberAxis.label), { formatter: (params) => Math.round(params.value) + '%' });
        }
        return axes;
    }
    getSeries(params) {
        const [category] = params.categories;
        const series = params.fields.map(f => ({
            type: this.standaloneChartType,
            direction: isHorizontal(this.chartType) ? 'horizontal' : 'vertical',
            stacked: this.crossFiltering || isStacked(this.chartType),
            normalizedTo: this.isNormalised() ? 100 : undefined,
            xKey: category.id,
            xName: category.name,
            yKey: f.colId,
            yName: f.displayName
        }));
        return this.crossFiltering ? this.extractCrossFilterSeries(series) : series;
    }
    extractCrossFilterSeries(series) {
        const palette = this.getChartPalette();
        const updatePrimarySeries = (seriesOptions, index) => {
            return Object.assign(Object.assign({}, seriesOptions), { highlightStyle: { item: { fill: undefined } }, fill: palette === null || palette === void 0 ? void 0 : palette.fills[index], stroke: palette === null || palette === void 0 ? void 0 : palette.strokes[index], listeners: {
                    nodeClick: this.crossFilterCallback
                } });
        };
        const updateFilteredOutSeries = (seriesOptions) => {
            const yKey = seriesOptions.yKey + '-filtered-out';
            return Object.assign(Object.assign({}, deepMerge$1({}, seriesOptions)), { yKey, fill: hexToRGBA(seriesOptions.fill, '0.3'), stroke: hexToRGBA(seriesOptions.stroke, '0.3'), showInLegend: false });
        };
        const allSeries = [];
        for (let i = 0; i < series.length; i++) {
            // update primary series
            const primarySeries = updatePrimarySeries(series[i], i);
            allSeries.push(primarySeries);
            // add 'filtered-out' series
            allSeries.push(updateFilteredOutSeries(primarySeries));
        }
        return allSeries;
    }
    isNormalised() {
        const normalisedCharts = ['normalizedColumn', 'normalizedBar'];
        return !this.crossFiltering && _.includes(normalisedCharts, this.chartType);
    }
}

class AreaChartProxy extends CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        const axes = [
            {
                type: this.getXAxisType(params),
                position: 'bottom',
            },
            {
                type: 'number',
                position: 'left',
            },
        ];
        // Add a default label formatter to show '%' for normalized charts if none is provided
        if (this.isNormalised()) {
            const numberAxis = axes[1];
            numberAxis.label = Object.assign(Object.assign({}, numberAxis.label), { formatter: (params) => Math.round(params.value) + '%' });
        }
        return axes;
    }
    getSeries(params) {
        const [category] = params.categories;
        const series = params.fields.map(f => ({
            type: this.standaloneChartType,
            xKey: category.id,
            xName: category.name,
            yKey: f.colId,
            yName: f.displayName,
            normalizedTo: this.chartType === 'normalizedArea' ? 100 : undefined,
            stacked: ['normalizedArea', 'stackedArea'].includes(this.chartType)
        }));
        return this.crossFiltering ? this.extractLineAreaCrossFilterSeries(series, params) : series;
    }
    isNormalised() {
        return !this.crossFiltering && this.chartType === 'normalizedArea';
    }
}

class LineChartProxy extends CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        return [
            {
                type: this.getXAxisType(params),
                position: 'bottom'
            },
            {
                type: 'number',
                position: 'left'
            },
        ];
    }
    getSeries(params) {
        const [category] = params.categories;
        const series = params.fields.map(f => ({
            type: this.standaloneChartType,
            xKey: category.id,
            xName: category.name,
            yKey: f.colId,
            yName: f.displayName
        }));
        return this.crossFiltering ? this.extractLineAreaCrossFilterSeries(series, params) : series;
    }
}

class PolarChartProxy extends ChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(_) {
        const radialBar = this.standaloneChartType === 'radial-bar';
        return [
            { type: radialBar ? 'angle-number' : 'angle-category' },
            { type: radialBar ? 'radius-category' : 'radius-number' },
        ];
    }
    getSeries(params) {
        const { fields } = params;
        const [category] = params.categories;
        const radialBar = this.standaloneChartType === 'radial-bar';
        return fields.map(f => {
            var _a, _b;
            return ({
                type: this.standaloneChartType,
                angleKey: radialBar ? f.colId : category.id,
                angleName: radialBar ? ((_a = f.displayName) !== null && _a !== void 0 ? _a : undefined) : category.name,
                radiusKey: radialBar ? category.id : f.colId,
                radiusName: radialBar ? category.name : ((_b = f.displayName) !== null && _b !== void 0 ? _b : undefined),
            });
        });
    }
    update(params) {
        const axes = this.getAxes(params);
        const options = Object.assign(Object.assign({}, this.getCommonChartOptions(params.updatedOverrides)), { data: this.getData(params, axes), axes, series: this.getSeries(params) });
        AgCharts.update(this.getChartRef(), options);
    }
    getData(params, axes) {
        const isCategoryAxis = axes.some((axis) => axis.type === 'angle-category' || axis.type === 'radius-category');
        return this.getDataTransformedData(params, isCategoryAxis);
    }
    getDataTransformedData(params, isCategoryAxis) {
        const [category] = params.categories;
        return this.transformData(params.data, category.id, isCategoryAxis);
    }
    crossFilteringReset() {
        // cross filtering is not currently supported in polar charts
    }
}

class PieChartProxy extends ChartProxy {
    constructor(params) {
        super(params);
    }
    update(params) {
        const { data } = params;
        const [category] = params.categories;
        const options = Object.assign(Object.assign({}, this.getCommonChartOptions(params.updatedOverrides)), { data: this.crossFiltering ? this.getCrossFilterData(params) : this.transformData(data, category.id), series: this.getSeries(params) });
        AgCharts.update(this.getChartRef(), options);
    }
    getSeries(params) {
        const [category] = params.categories;
        const numFields = params.fields.length;
        const offset = {
            currentOffset: 0,
            offsetAmount: numFields > 1 ? 20 : 40
        };
        const series = this.getFields(params).map((f) => {
            var _a;
            // options shared by 'pie' and 'donut' charts
            const options = {
                type: this.standaloneChartType,
                angleKey: f.colId,
                angleName: f.displayName,
                sectorLabelKey: f.colId,
                calloutLabelName: category.name,
                calloutLabelKey: category.id,
            };
            if (this.chartType === 'donut' || this.chartType === 'doughnut') {
                const { outerRadiusOffset, innerRadiusOffset } = PieChartProxy.calculateOffsets(offset);
                const title = f.displayName ? {
                    title: { text: f.displayName, showInLegend: numFields > 1 },
                } : undefined;
                // augment shared options with 'donut' specific options
                return Object.assign(Object.assign(Object.assign(Object.assign({}, options), { type: 'donut', outerRadiusOffset,
                    innerRadiusOffset }), title), { calloutLine: {
                        colors: (_a = this.getChartPalette()) === null || _a === void 0 ? void 0 : _a.strokes,
                    } });
            }
            return options;
        });
        return this.crossFiltering ? this.extractCrossFilterSeries(series) : series;
    }
    getCrossFilterData(params) {
        const colId = params.fields[0].colId;
        const filteredOutColId = `${colId}-filtered-out`;
        return params.data.map(d => {
            const total = d[colId] + d[filteredOutColId];
            d[`${colId}-total`] = total;
            d[filteredOutColId] = 1; // normalise to 1
            d[colId] = d[colId] / total; // fraction of 1
            return d;
        });
    }
    extractCrossFilterSeries(series) {
        const palette = this.getChartPalette();
        const primaryOptions = (seriesOptions) => {
            return Object.assign(Object.assign({}, seriesOptions), { legendItemKey: seriesOptions.calloutLabelKey, calloutLabel: { enabled: false }, highlightStyle: { item: { fill: undefined } }, radiusKey: seriesOptions.angleKey, angleKey: seriesOptions.angleKey + '-total', radiusMin: 0, radiusMax: 1, listeners: {
                    nodeClick: this.crossFilterCallback,
                } });
        };
        const filteredOutOptions = (seriesOptions, angleKey) => {
            var _a, _b;
            return Object.assign(Object.assign({}, deepMerge$1({}, primaryOpts)), { radiusKey: angleKey + '-filtered-out', fills: changeOpacity((_a = seriesOptions.fills) !== null && _a !== void 0 ? _a : palette.fills, 0.3), strokes: changeOpacity((_b = seriesOptions.strokes) !== null && _b !== void 0 ? _b : palette.strokes, 0.3), showInLegend: false });
        };
        // currently, only single 'donut' cross-filter series are supported
        const primarySeries = series[0];
        // update primary series
        const angleKey = primarySeries.angleKey;
        const primaryOpts = primaryOptions(primarySeries);
        return [
            filteredOutOptions(primarySeries, angleKey),
            primaryOpts,
        ];
    }
    static calculateOffsets(offset) {
        const outerRadiusOffset = offset.currentOffset;
        offset.currentOffset -= offset.offsetAmount;
        const innerRadiusOffset = offset.currentOffset;
        offset.currentOffset -= offset.offsetAmount;
        return { outerRadiusOffset, innerRadiusOffset };
    }
    getFields(params) {
        // pie charts only support a single series, donut charts support multiple series
        return this.chartType === 'pie' ? params.fields.slice(0, 1) : params.fields;
    }
    crossFilteringReset() {
        // not required in pie charts
    }
}

class ScatterChartProxy extends CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(_params) {
        return [
            {
                type: 'number',
                position: 'bottom',
            },
            {
                type: 'number',
                position: 'left',
            },
        ];
    }
    getSeries(params) {
        const [category] = params.categories;
        const paired = this.isPaired();
        const seriesDefinitions = this.getSeriesDefinitions(params.fields, paired);
        const labelFieldDefinition = category.id === ChartDataModel.DEFAULT_CATEGORY ? undefined : category;
        const series = seriesDefinitions.map(seriesDefinition => {
            var _a, _b, _c, _d, _e;
            if (seriesDefinition === null || seriesDefinition === void 0 ? void 0 : seriesDefinition.sizeField) {
                const opts = {
                    type: 'bubble',
                    xKey: seriesDefinition.xField.colId,
                    xName: (_a = seriesDefinition.xField.displayName) !== null && _a !== void 0 ? _a : undefined,
                    yKey: seriesDefinition.yField.colId,
                    yName: (_b = seriesDefinition.yField.displayName) !== null && _b !== void 0 ? _b : undefined,
                    title: `${seriesDefinition.yField.displayName} vs ${seriesDefinition.xField.displayName}`,
                    sizeKey: seriesDefinition.sizeField.colId,
                    sizeName: (_c = seriesDefinition.sizeField.displayName) !== null && _c !== void 0 ? _c : '',
                    labelKey: labelFieldDefinition ? labelFieldDefinition.id : seriesDefinition.yField.colId,
                    labelName: labelFieldDefinition ? labelFieldDefinition.name : undefined,
                };
                return opts;
            }
            const opts = {
                type: 'scatter',
                xKey: seriesDefinition.xField.colId,
                xName: (_d = seriesDefinition.xField.displayName) !== null && _d !== void 0 ? _d : undefined,
                yKey: seriesDefinition.yField.colId,
                yName: (_e = seriesDefinition.yField.displayName) !== null && _e !== void 0 ? _e : undefined,
                title: `${seriesDefinition.yField.displayName} vs ${seriesDefinition.xField.displayName}`,
                labelKey: labelFieldDefinition ? labelFieldDefinition.id : seriesDefinition.yField.colId,
                labelName: labelFieldDefinition ? labelFieldDefinition.name : undefined,
            };
            return opts;
        });
        return this.crossFiltering ? this.extractCrossFilterSeries(series, params) : series;
    }
    extractCrossFilterSeries(series, params) {
        const { data } = params;
        const palette = this.getChartPalette();
        const filteredOutKey = (key) => `${key}-filtered-out`;
        const calcMarkerDomain = (data, sizeKey) => {
            var _a;
            const markerDomain = [Infinity, -Infinity];
            if (sizeKey != null) {
                for (const datum of data) {
                    const value = (_a = datum[sizeKey]) !== null && _a !== void 0 ? _a : datum[filteredOutKey(sizeKey)];
                    if (value < markerDomain[0]) {
                        markerDomain[0] = value;
                    }
                    if (value > markerDomain[1]) {
                        markerDomain[1] = value;
                    }
                }
            }
            if (markerDomain[0] <= markerDomain[1]) {
                return markerDomain;
            }
            return undefined;
        };
        const updatePrimarySeries = (series, idx) => {
            const fill = palette === null || palette === void 0 ? void 0 : palette.fills[idx];
            const stroke = palette === null || palette === void 0 ? void 0 : palette.strokes[idx];
            let markerDomain = undefined;
            if (series.type === 'bubble') {
                const { sizeKey } = series;
                markerDomain = calcMarkerDomain(data, sizeKey);
            }
            const marker = Object.assign(Object.assign({}, series.marker), { fill,
                stroke, domain: markerDomain });
            return Object.assign(Object.assign({}, series), { marker, highlightStyle: { item: { fill: 'yellow' } }, listeners: Object.assign(Object.assign({}, series.listeners), { nodeClick: this.crossFilterCallback }) });
        };
        const updateFilteredOutSeries = (series) => {
            let { yKey, xKey } = series;
            let alteredSizeKey = {};
            if (series.type === 'bubble') {
                alteredSizeKey = { sizeKey: filteredOutKey(series.sizeKey) };
            }
            return Object.assign(Object.assign(Object.assign({}, series), alteredSizeKey), { yKey: filteredOutKey(yKey), xKey: filteredOutKey(xKey), marker: Object.assign(Object.assign({}, series.marker), { fillOpacity: 0.3, strokeOpacity: 0.3 }), showInLegend: false, listeners: Object.assign(Object.assign({}, series.listeners), { nodeClick: (e) => {
                        const value = e.datum[filteredOutKey(xKey)];
                        // Need to remove the `-filtered-out` suffixes from the event so that
                        // upstream processing maps the event correctly onto grid column ids.
                        const filterableEvent = Object.assign(Object.assign({}, e), { xKey, datum: Object.assign(Object.assign({}, e.datum), { [xKey]: value }) });
                        this.crossFilterCallback(filterableEvent);
                    } }) });
        };
        const updatedSeries = series.map(updatePrimarySeries);
        return [
            ...updatedSeries,
            ...updatedSeries.map(updateFilteredOutSeries),
        ];
    }
    getSeriesDefinitions(fields, paired) {
        if (fields.length < 2) {
            return [];
        }
        const isBubbleChart = this.chartType === 'bubble';
        if (paired) {
            if (isBubbleChart) {
                return fields.map((currentXField, i) => i % 3 === 0 ? ({
                    xField: currentXField,
                    yField: fields[i + 1],
                    sizeField: fields[i + 2],
                }) : null).filter(x => x && x.yField && x.sizeField);
            }
            return fields.map((currentXField, i) => i % 2 === 0 ? ({
                xField: currentXField,
                yField: fields[i + 1],
            }) : null).filter(x => x && x.yField);
        }
        const xField = fields[0];
        if (isBubbleChart) {
            return fields
                .map((yField, i) => i % 2 === 1 ? ({
                xField,
                yField,
                sizeField: fields[i + 1],
            }) : null)
                .filter(x => x && x.sizeField);
        }
        return fields.filter((value, i) => i > 0).map(yField => ({ xField, yField }));
    }
}

class StatisticalChartProxy extends CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        return [
            {
                type: this.getXAxisType(params),
                position: isHorizontal(this.chartType) ? 'left' : 'bottom',
            },
            {
                type: 'number',
                position: isHorizontal(this.chartType) ? 'bottom' : 'left',
            },
        ];
    }
    computeSeriesStatistics(params, computeStatsFn) {
        const { data, fields } = params;
        const [category] = params.categories;
        const categoryKey = category.id || ChartDataModel.DEFAULT_CATEGORY;
        const groupedData = this.groupDataByCategory(categoryKey, data);
        return Array.from(groupedData).map(([categoryValue, categoryData]) => {
            const categoryResult = { [category.id]: categoryValue };
            fields.forEach((field, seriesIndex) => {
                // `null` & `NaN` values are omitted from calculations
                const seriesValues = categoryData
                    .map(datum => datum[field.colId])
                    .filter(value => typeof value === 'number' && !isNaN(value));
                Object.entries(computeStatsFn(seriesValues)).forEach(([statKey, value]) => {
                    const propertyKey = `${statKey}:${seriesIndex}`;
                    // when no data exists, stat properties are added to results with `null` values!
                    categoryResult[propertyKey] = seriesValues.length > 0 ? value : null;
                });
            });
            return categoryResult;
        });
    }
    groupDataByCategory(categoryKey, data) {
        const getCategory = (datum) => {
            if (categoryKey === ChartDataModel.DEFAULT_CATEGORY) {
                return 1;
            }
            const categoryValue = datum[categoryKey];
            if (categoryValue === null || categoryValue === undefined) {
                return ''; // use a blank category for `null` or `undefined` values
            }
            return categoryValue instanceof Date ? categoryValue.getTime() : categoryValue;
        };
        return data.reduce((acc, datum) => {
            let category = getCategory(datum);
            const existingCategoryData = acc.get(category);
            if (existingCategoryData) {
                existingCategoryData.push(datum);
            }
            else {
                acc.set(category, [datum]);
            }
            return acc;
        }, new Map());
    }
}

class RangeChartProxy extends StatisticalChartProxy {
    constructor(params) {
        super(params);
    }
    getSeries(params) {
        const [category] = params.categories;
        return params.fields.map((field, seriesIndex) => {
            var _a;
            return ({
                type: this.standaloneChartType,
                // xKey/xName refer to category buckets
                xKey: category.id,
                xName: category.name,
                // yName is used to label the series
                yName: (_a = field.displayName) !== null && _a !== void 0 ? _a : undefined,
                // custom field labels shown in the tooltip
                yLowName: 'Min',
                yHighName: 'Max',
                // generated 'synthetic fields' from getData()
                yLowKey: `min:${seriesIndex}`,
                yHighKey: `max:${seriesIndex}`,
            });
        });
    }
    getData(params) {
        return this.computeSeriesStatistics(params, (seriesValues) => {
            return {
                min: Math.min(...seriesValues),
                max: Math.max(...seriesValues),
            };
        });
    }
}

class HistogramChartProxy extends CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getSeries(params) {
        const firstField = params.fields[0]; // multiple series are not supported!
        return [
            {
                type: this.standaloneChartType,
                xKey: firstField.colId,
                xName: firstField.displayName,
                yName: this.chartProxyParams.translate("histogramFrequency"),
                areaPlot: false, // only constant width is supported via integrated charts
            }
        ];
    }
    getAxes(_params) {
        return [
            {
                type: 'number',
                position: 'bottom',
            },
            {
                type: 'number',
                position: 'left',
            },
        ];
    }
}

class BoxPlotChartProxy extends StatisticalChartProxy {
    constructor(params) {
        super(params);
    }
    getSeries(params) {
        const [category] = params.categories;
        return params.fields.map((field, seriesIndex) => {
            var _a;
            return ({
                type: this.standaloneChartType,
                direction: isHorizontal(this.chartType) ? 'horizontal' : 'vertical',
                // xKey/xName refer to category buckets
                xKey: category.id,
                xName: category.name,
                // yName is used to label the series
                yName: (_a = field.displayName) !== null && _a !== void 0 ? _a : undefined,
                // custom field labels shown in the tooltip
                minName: 'Min',
                q1Name: 'Q1',
                medianName: 'Median',
                q3Name: 'Q3',
                maxName: 'Max',
                // generated 'synthetic fields' from getData()
                minKey: `min:${seriesIndex}`,
                q1Key: `q1:${seriesIndex}`,
                medianKey: `median:${seriesIndex}`,
                q3Key: `q3:${seriesIndex}`,
                maxKey: `max:${seriesIndex}`,
            });
        });
    }
    getData(params) {
        return this.computeSeriesStatistics(params, (seriesValues) => {
            const sortedValues = seriesValues.sort((a, b) => a - b);
            return {
                min: sortedValues[0],
                q1: this.quantile(sortedValues, 0.25),
                median: this.quantile(sortedValues, 0.5),
                q3: this.quantile(sortedValues, 0.75),
                max: sortedValues[sortedValues.length - 1],
            };
        });
    }
    quantile(sortedValues, q) {
        const position = (sortedValues.length - 1) * q;
        const indexBelow = Math.floor(position);
        const aboveValue = position - indexBelow;
        if (sortedValues[indexBelow + 1] !== undefined) {
            return sortedValues[indexBelow] + aboveValue * (sortedValues[indexBelow + 1] - sortedValues[indexBelow]);
        }
        return sortedValues[indexBelow];
    }
}

const CATEGORY_LABEL_KEY = 'AG-GRID-DEFAULT-LABEL-KEY';
function createCategoryHierarchy(data, categoryKeys) {
    const hierarchy = buildNestedHierarchy(data, getItemDepth, getItemCategoryLabel);
    return formatCategoryHierarchy(hierarchy);
    function getItemDepth(item) {
        return categoryKeys.length;
    }
    function getItemCategoryLabel(item, categoryIndex) {
        const categoryKey = categoryKeys[categoryIndex];
        const categoryValue = item[categoryKey];
        return getCategoryLabel(categoryValue);
    }
    function getCategoryLabel(value) {
        if (value == null)
            return null;
        return String(value);
    }
}
function createAutoGroupHierarchy(data, getItemLabels) {
    const hierarchy = buildNestedHierarchy(data, getItemDepth, getItemGroupLabel);
    return formatCategoryHierarchy(hierarchy);
    function getItemDepth(item) {
        var _a, _b;
        return (_b = (_a = getItemLabels(item)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    function getItemGroupLabel(item, groupIndex) {
        const labels = getItemLabels(item);
        if (!labels)
            return null;
        // Autogroup label values are ordered from the leaf outwards
        const labelIndex = labels.length - 1 - groupIndex;
        return labels[labelIndex];
    }
}
/* Utility functions for building and formatting nested category hierarchies */
/** Convert an abstract nested hierarchy structure into an ag-charts-compatible 'category-grouped' data structure */
function formatCategoryHierarchy(hierarchy) {
    const { depth, leaves, children } = hierarchy;
    // If there are no remaining levels of nesting, return a flat list of leaves with no category labels
    if (depth === 0)
        return leaves.map((item) => (Object.assign({ [CATEGORY_LABEL_KEY]: null }, item)));
    const results = new Array();
    // Push all branches and leaves into the result set, grouping results by the input tree hierarchy path
    for (const [key, childHierarchy] of children.entries()) {
        if (childHierarchy.depth === 0) {
            // If this the deepest parent level, return a flat list of child leaves with their respective category keys
            results.push(...childHierarchy.leaves.map((item) => (Object.assign({ [CATEGORY_LABEL_KEY]: key }, item))));
        }
        else {
            // Otherwise nest the grouped data recursively (ignoring any leaves defined at the current parent level)
            results.push({ [CATEGORY_LABEL_KEY]: key, children: formatCategoryHierarchy(childHierarchy) });
        }
    }
    return results;
}
/** Build an arbitrarily deeply nested hierarchy from a flat list of input items */
function buildNestedHierarchy(data, getItemDepth, getItemGroupKey) {
    const hierarchy = { depth: 0, leaves: [], children: new Map() };
    return data.reduce((hierarchy, item) => {
        const itemDepth = getItemDepth(item);
        const currentDepth = 0;
        return createNestedItemHierarchy(item, itemDepth, getItemGroupKey, currentDepth, hierarchy);
    }, hierarchy);
    function createNestedItemHierarchy(item, itemDepth, getItemGroupKey, currentDepth, hierarchy) {
        if (currentDepth === itemDepth) {
            hierarchy.leaves.push(item);
            return hierarchy;
        }
        else {
            const key = getItemGroupKey(item, currentDepth);
            const existingChildHierarchy = hierarchy.children.get(key);
            const childHierarchy = createNestedItemHierarchy(item, itemDepth, getItemGroupKey, currentDepth + 1, existingChildHierarchy || { depth: 0, leaves: [], children: new Map() });
            hierarchy.children.set(key, childHierarchy);
            hierarchy.depth = Math.max(1 + childHierarchy.depth, hierarchy.depth);
            return hierarchy;
        }
    }
}

class HierarchicalChartProxy extends ChartProxy {
    constructor(chartProxyParams) {
        super(chartProxyParams);
        this.chartProxyParams = chartProxyParams;
    }
    update(params) {
        const options = Object.assign(Object.assign({}, this.getCommonChartOptions(params.updatedOverrides)), { series: this.getSeries(params, CATEGORY_LABEL_KEY), data: this.getData(params) });
        AgCharts.update(this.getChartRef(), options);
    }
    getData(params) {
        const { categories, data, grouping: isGrouped } = params;
        if (isGrouped) {
            return createAutoGroupHierarchy(data, getRowAutoGroupLabels);
        }
        else {
            const categoryKeys = categories.map(({ id }) => id);
            return createCategoryHierarchy(data, categoryKeys);
        }
    }
}
function getRowAutoGroupLabels(item) {
    var _a, _b;
    return (_b = (_a = item[GROUP_AUTO_COLUMN_ID]) === null || _a === void 0 ? void 0 : _a.labels) !== null && _b !== void 0 ? _b : null;
}

class TreemapChartProxy extends HierarchicalChartProxy {
    constructor(params) {
        super(params);
    }
    getSeries(params, labelKey) {
        var _a, _b;
        const { fields } = params;
        // Treemap charts support up to two input series, corresponding to size and color respectively
        const [sizeField, colorField] = fields;
        // Combine the size and color series into a single composite series
        return [
            {
                type: this.standaloneChartType,
                // The label key is generated internally by the hierarchy processing and is not user-configurable
                labelKey,
                // Size and color fields are inferred from the range data
                sizeKey: sizeField === null || sizeField === void 0 ? void 0 : sizeField.colId,
                sizeName: (_a = sizeField === null || sizeField === void 0 ? void 0 : sizeField.displayName) !== null && _a !== void 0 ? _a : undefined,
                colorKey: colorField === null || colorField === void 0 ? void 0 : colorField.colId,
                colorName: (_b = colorField === null || colorField === void 0 ? void 0 : colorField.displayName) !== null && _b !== void 0 ? _b : undefined,
            },
        ];
    }
    getChartThemeDefaults() {
        return {
            treemap: {
                gradientLegend: {
                    gradient: {
                        preferredLength: 200,
                    },
                },
            },
        };
    }
    transformData(data, categoryKey, categoryAxis) {
        // Ignore the base implementation as it assumes only a single category axis
        // (this method is never actually invoked)
        return data;
    }
    crossFilteringReset() {
        // cross filtering is not currently supported in treemap charts
    }
}

class SunburstChartProxy extends HierarchicalChartProxy {
    constructor(params) {
        super(params);
    }
    getSeries(params, labelKey) {
        var _a, _b;
        const { fields } = params;
        // Sunburst charts support up to two input series, corresponding to size and color respectively
        const [sizeField, colorField] = fields;
        // Combine the size and color series into a single composite series
        return [
            {
                type: this.standaloneChartType,
                // The label key is generated internally by the hierarchy processing and is not user-configurable
                labelKey,
                // Size and color fields are inferred from the range data
                sizeKey: sizeField === null || sizeField === void 0 ? void 0 : sizeField.colId,
                sizeName: (_a = sizeField === null || sizeField === void 0 ? void 0 : sizeField.displayName) !== null && _a !== void 0 ? _a : undefined,
                colorKey: colorField === null || colorField === void 0 ? void 0 : colorField.colId,
                colorName: (_b = colorField === null || colorField === void 0 ? void 0 : colorField.displayName) !== null && _b !== void 0 ? _b : undefined,
            },
        ];
    }
    getChartThemeDefaults() {
        return {
            sunburst: {
                gradientLegend: {
                    gradient: {
                        preferredLength: 200,
                    },
                },
            },
        };
    }
    transformData(data, categoryKey, categoryAxis) {
        // Ignore the base implementation as it assumes only a single category axis
        // (this method is never actually invoked)
        return data;
    }
    crossFilteringReset() {
        // cross filtering is not currently supported in sunburst charts
    }
}

function flatMap(items, iteratee) {
    return items.reduce((acc, item, index, array) => acc.concat(iteratee(item, index, array)), new Array());
}

const HEATMAP_CATEGORY_KEY = 'AG-GRID-DEFAULT-HEATMAP-CATEGORY-KEY';
const HEATMAP_SERIES_KEY = 'AG-GRID-DEFAULT-HEATMAP-SERIES-KEY';
const HEATMAP_VALUE_KEY = 'AG-GRID-DEFAULT-HEATMAP-VALUE-KEY';
class HeatmapChartProxy extends ChartProxy {
    constructor(params) {
        super(params);
    }
    update(params) {
        const xSeriesKey = HEATMAP_SERIES_KEY;
        const xValueKey = HEATMAP_VALUE_KEY;
        const yKey = HEATMAP_CATEGORY_KEY;
        const options = Object.assign(Object.assign({}, this.getCommonChartOptions(params.updatedOverrides)), { series: this.getSeries(params, xSeriesKey, xValueKey, yKey), data: this.getData(params, xSeriesKey, xValueKey, yKey) });
        AgCharts.update(this.getChartRef(), options);
    }
    getSeries(params, xSeriesKey, xValueKey, yKey) {
        const [category] = params.categories;
        return [
            {
                type: this.standaloneChartType,
                // The axis keys reference synthetic fields based on the category values and series column names
                yKey,
                xKey: xSeriesKey,
                // The color key references a synthetic field based on the series column value for a specific cell
                colorKey: xValueKey,
                yName: category.name,
                // We don't know how to label the 'x' series, as it is a synthetic series created from the set of all input columns
                // In future releases we may want to consider inferring the series label from column groupings etc
                xName: undefined,
                colorName: undefined,
            },
        ];
    }
    getData(params, xSeriesKey, xValueKey, yKey) {
        const [category] = params.categories;
        // Heatmap chart expects a flat array of data, with each row representing a single cell in the heatmap
        // This means we need to explode the list of input rows into their individual cells
        return flatMap(params.data, (datum, index) => {
            // We need to create a unique y value object for each row to prevent unintended category grouping
            // when there are multiple rows with the same category value
            const value = datum[category.id];
            const valueString = value == null ? '' : String(value);
            const yValue = { id: index, value, toString: () => valueString };
            // Return a flat list of output data items corresponding to each cell,
            // appending the synthetic series and category fields to the cell data
            return params.fields.map(({ colId, displayName }) => (Object.assign(Object.assign({}, datum), { [xSeriesKey]: displayName, [xValueKey]: datum[colId], [yKey]: yValue })));
        });
    }
    getChartThemeDefaults() {
        return {
            heatmap: {
                gradientLegend: {
                    gradient: {
                        preferredLength: 200,
                    },
                },
                series: {
                    tooltip: {
                        renderer: renderHeatmapTooltip,
                    },
                },
            },
        };
    }
    transformData(data, categoryKey, categoryAxis) {
        // Ignore the base implementation as it assumes only a single category axis
        // (this method is never actually invoked)
        return data;
    }
    crossFilteringReset() {
        // cross filtering is not currently supported in heatmap charts
    }
}
function renderHeatmapTooltip(params) {
    const { xKey, yKey, colorKey, yName, seriesId, datum } = params;
    const item = datum[seriesId];
    const table = [
        { label: yName, value: item[yKey] },
        { label: item[xKey], value: colorKey && item[colorKey] },
    ];
    const html = table
        .map(({ label, value }) => `<b>${sanitizeHtml$2(String(label))}:</b> ${sanitizeHtml$2(String(value))}`)
        .join('<br>');
    return {
        title: '',
        content: html,
    };
}
function sanitizeHtml$2(input) {
    const ESCAPED_CHARS = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
    };
    const characterClass = `[${Object.keys(ESCAPED_CHARS).join('')}]`;
    const pattern = new RegExp(characterClass, 'g');
    return input.replace(pattern, (char) => ESCAPED_CHARS[char]);
}

class WaterfallChartProxy extends CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        return [
            {
                type: this.getXAxisType(params),
                position: isHorizontal(this.chartType) ? 'left' : 'bottom',
            },
            {
                type: 'number',
                position: isHorizontal(this.chartType) ? 'bottom' : 'left',
            },
        ];
    }
    getSeries(params) {
        var _a;
        const [category] = params.categories;
        const [firstField] = params.fields;
        const firstSeries = {
            type: this.standaloneChartType,
            direction: isHorizontal(this.chartType) ? 'horizontal' : 'vertical',
            xKey: category.id,
            xName: category.name,
            yKey: firstField.colId,
            yName: (_a = firstField.displayName) !== null && _a !== void 0 ? _a : undefined
        };
        return [firstSeries]; // waterfall only supports a single series!
    }
}

class ChartOptionsService extends BeanStub {
    constructor(chartController) {
        super();
        this.chartController = chartController;
    }
    getChartOption(expression) {
        return get(this.getChart(), expression, undefined);
    }
    setChartOption(expression, value, isSilent) {
        const chartSeriesTypes = this.chartController.getChartSeriesTypes();
        if (this.chartController.isComboChart()) {
            chartSeriesTypes.push('common');
        }
        let chartOptions = {};
        // we need to update chart options on each series type for combo charts
        chartSeriesTypes.forEach(seriesType => {
            chartOptions = deepMerge$1(chartOptions, this.createChartOptions({
                seriesType,
                expression,
                value
            }));
        });
        if (!isSilent) {
            this.updateChart(chartOptions);
            this.raiseChartOptionsChangedEvent();
        }
    }
    awaitChartOptionUpdate(func) {
        const chart = this.chartController.getChartProxy().getChart();
        chart.waitForUpdate().then(() => func())
            .catch((e) => console.error(`AG Grid - chart update failed`, e));
    }
    getAxisProperty(expression) {
        var _a;
        return get((_a = this.getChart().axes) === null || _a === void 0 ? void 0 : _a[0], expression, undefined);
    }
    setAxisProperty(expression, value) {
        this.setAxisProperties([{ expression, value }]);
    }
    setAxisProperties(properties) {
        const chart = this.getChart();
        const chartOptions = flatMap(properties, ({ expression, value }) => {
            var _a;
            // Only apply the property to axes that declare the property on their prototype chain
            const relevantAxes = (_a = chart.axes) === null || _a === void 0 ? void 0 : _a.filter((axis) => {
                const parts = expression.split('.');
                let current = axis;
                for (const part of parts) {
                    if (!(part in current)) {
                        return false;
                    }
                    current = current[part];
                }
                return true;
            });
            if (!relevantAxes)
                return [];
            return relevantAxes.map((axis) => this.getUpdateAxisOptions(axis, expression, value));
        })
            // Combine all property updates into a single merged object
            .reduce((chartOptions, axisOptions) => deepMerge$1(chartOptions, axisOptions), {});
        if (Object.keys(chartOptions).length > 0) {
            this.updateChart(chartOptions);
            this.raiseChartOptionsChangedEvent();
        }
    }
    getLabelRotation(axisType) {
        const axis = this.getAxis(axisType);
        return get(axis, 'label.rotation', undefined);
    }
    setLabelRotation(axisType, value) {
        const chartAxis = this.getAxis(axisType);
        if (chartAxis) {
            const chartOptions = this.getUpdateAxisOptions(chartAxis, 'label.rotation', value);
            this.updateChart(chartOptions);
            this.raiseChartOptionsChangedEvent();
        }
    }
    getSeriesOption(expression, seriesType, calculated) {
        // N.B. 'calculated' here refers to the fact that the property exists on the internal series object itself,
        // rather than the properties object. This is due to us needing to reach inside the chart itself to retrieve
        // the value, and will likely be cleaned up in a future release
        const series = this.getChart().series.find((s) => ChartOptionsService.isMatchingSeries(seriesType, s));
        return get(calculated ? series : series === null || series === void 0 ? void 0 : series.properties.toJson(), expression, undefined);
    }
    setSeriesOption(expression, value, seriesType) {
        const chartOptions = this.createChartOptions({
            seriesType,
            expression: `series.${expression}`,
            value
        });
        this.updateChart(chartOptions);
        this.raiseChartOptionsChangedEvent();
    }
    getPairedMode() {
        return this.chartController.getChartProxy().isPaired();
    }
    setPairedMode(paired) {
        this.chartController.getChartProxy().setPaired(paired);
    }
    getAxis(axisType) {
        const chart = this.getChart();
        if (!chart.axes || chart.axes.length < 1) {
            return undefined;
        }
        if (axisType === 'xAxis') {
            return (chart.axes && chart.axes[0].direction === 'x') ? chart.axes[0] : chart.axes[1];
        }
        return (chart.axes && chart.axes[1].direction === 'y') ? chart.axes[1] : chart.axes[0];
    }
    getUpdateAxisOptions(chartAxis, expression, value) {
        const chartSeriesTypes = this.chartController.getChartSeriesTypes();
        if (this.chartController.isComboChart()) {
            chartSeriesTypes.push('common');
        }
        const validAxisTypes = ['number', 'category', 'time', 'grouped-category', 'angle-category', 'angle-number', 'radius-category', 'radius-number'];
        if (!validAxisTypes.includes(chartAxis.type)) {
            return {};
        }
        return chartSeriesTypes
            .map((seriesType) => this.createChartOptions({
            seriesType,
            expression: `axes.${chartAxis.type}.${expression}`,
            value,
        }))
            .reduce((combinedOptions, options) => deepMerge$1(combinedOptions, options));
    }
    getChartType() {
        return this.chartController.getChartType();
    }
    getChart() {
        return this.chartController.getChartProxy().getChart();
    }
    updateChart(chartOptions) {
        const chartRef = this.chartController.getChartProxy().getChartRef();
        chartRef.skipAnimations();
        AgCharts.updateDelta(chartRef, chartOptions);
    }
    createChartOptions({ seriesType, expression, value }) {
        const overrides = {};
        const chartOptions = {
            theme: {
                overrides
            }
        };
        set(overrides, `${seriesType}.${expression}`, value);
        return chartOptions;
    }
    raiseChartOptionsChangedEvent() {
        const chartModel = this.chartController.getChartModel();
        const event = {
            type: Events.EVENT_CHART_OPTIONS_CHANGED,
            chartId: chartModel.chartId,
            chartType: chartModel.chartType,
            chartThemeName: this.chartController.getChartThemeName(),
            chartOptions: chartModel.chartOptions
        };
        this.eventService.dispatchEvent(event);
    }
    static isMatchingSeries(seriesType, series) {
        return VALID_SERIES_TYPES.includes(seriesType) && series.type === seriesType;
    }
    destroy() {
        super.destroy();
    }
}

class ComboChartProxy extends CartesianChartProxy {
    constructor(params) {
        super(params);
    }
    getAxes(params) {
        const fields = params ? params.fields : [];
        const fieldsMap = new Map(fields.map(f => [f.colId, f]));
        const { primaryYKeys, secondaryYKeys } = this.getYKeys(fields, params.seriesChartTypes);
        const axes = [
            {
                type: this.getXAxisType(params),
                position: 'bottom',
            },
        ];
        if (primaryYKeys.length > 0) {
            axes.push({
                type: 'number',
                keys: primaryYKeys,
                position: 'left',
            });
        }
        if (secondaryYKeys.length > 0) {
            secondaryYKeys.forEach((secondaryYKey) => {
                const field = fieldsMap.get(secondaryYKey);
                const secondaryAxisIsVisible = field && field.colId === secondaryYKey;
                if (!secondaryAxisIsVisible) {
                    return;
                }
                const secondaryAxisOptions = {
                    type: 'number',
                    keys: [secondaryYKey],
                    position: 'right',
                };
                axes.push(secondaryAxisOptions);
            });
        }
        return axes;
    }
    getSeries(params) {
        const { fields, seriesChartTypes } = params;
        const [category] = params.categories;
        return fields.map(field => {
            const seriesChartType = seriesChartTypes.find(s => s.colId === field.colId);
            if (seriesChartType) {
                const chartType = seriesChartType.chartType;
                const grouped = ['groupedColumn', 'groupedBar'].includes(chartType);
                const groupedOpts = grouped ? { grouped: true } : {};
                return Object.assign({ type: getSeriesType(chartType), xKey: category.id, yKey: field.colId, yName: field.displayName, stacked: ['stackedArea', 'stackedColumn'].includes(chartType) }, groupedOpts);
            }
        });
    }
    getYKeys(fields, seriesChartTypes) {
        const primaryYKeys = [];
        const secondaryYKeys = [];
        fields.forEach(field => {
            const colId = field.colId;
            const seriesChartType = seriesChartTypes.find(s => s.colId === colId);
            if (seriesChartType) {
                seriesChartType.secondaryAxis ? secondaryYKeys.push(colId) : primaryYKeys.push(colId);
            }
        });
        return { primaryYKeys, secondaryYKeys };
    }
}

var __decorate$Q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class GridChartComp extends Component {
    constructor(params) {
        super(GridChartComp.TEMPLATE);
        this.params = params;
    }
    init() {
        const modelParams = {
            chartId: this.params.chartId,
            pivotChart: this.params.pivotChart,
            chartType: getCanonicalChartType(this.params.chartType),
            chartThemeName: this.getThemeName(),
            aggFunc: this.params.aggFunc,
            cellRange: this.params.cellRange,
            suppressChartRanges: this.params.suppressChartRanges,
            unlinkChart: this.params.unlinkChart,
            crossFiltering: this.params.crossFiltering,
            seriesChartTypes: this.params.seriesChartTypes,
        };
        const isRtl = this.gridOptionsService.get('enableRtl');
        this.addCssClass(isRtl ? 'ag-rtl' : 'ag-ltr');
        // only the chart controller interacts with the chart model
        const model = this.createBean(new ChartDataModel(modelParams));
        this.chartController = this.createManagedBean(new ChartController(model));
        this.validateCustomThemes();
        // create chart before dialog to ensure dialog is correct size
        this.createChart();
        if (this.params.insideDialog) {
            this.addDialog();
        }
        this.addMenu();
        this.addTitleEditComp();
        this.addManagedListener(this.getGui(), 'focusin', this.setActiveChartCellRange.bind(this));
        this.addManagedListener(this.chartController, ChartController.EVENT_CHART_MODEL_UPDATE, this.update.bind(this));
        this.addManagedPropertyListeners(['chartThemeOverrides', 'chartThemes'], this.reactivePropertyUpdate.bind(this));
        if (this.chartMenu) {
            // chart menu may not exist, i.e. cross filtering
            this.addManagedListener(this.chartMenu, ChartMenu.EVENT_DOWNLOAD_CHART, () => this.downloadChart());
        }
        this.update();
        this.raiseChartCreatedEvent();
    }
    createChart() {
        // if chart already exists, destroy it and remove it from DOM
        let chartInstance = undefined;
        if (this.chartProxy) {
            chartInstance = this.chartProxy.destroy({ keepChartInstance: true });
        }
        const crossFilterCallback = (event, reset) => {
            const ctx = this.params.crossFilteringContext;
            ctx.lastSelectedChartId = reset ? '' : this.chartController.getChartId();
            if (reset) {
                this.params.crossFilteringResetCallback();
            }
            this.crossFilterService.filter(event, reset);
        };
        const chartType = this.chartController.getChartType();
        const chartProxyParams = {
            chartType,
            chartInstance,
            getChartThemeName: this.getChartThemeName.bind(this),
            getChartThemes: this.getChartThemes.bind(this),
            customChartThemes: this.gridOptionsService.get('customChartThemes'),
            getGridOptionsChartThemeOverrides: () => this.getGridOptionsChartThemeOverrides(),
            getExtraPaddingDirections: () => { var _a, _b; return (_b = (_a = this.chartMenu) === null || _a === void 0 ? void 0 : _a.getExtraPaddingDirections()) !== null && _b !== void 0 ? _b : []; },
            apiChartThemeOverrides: this.params.chartThemeOverrides,
            crossFiltering: this.params.crossFiltering,
            crossFilterCallback,
            parentElement: this.eChart,
            grouping: this.chartController.isGrouping(),
            chartThemeToRestore: this.params.chartThemeName,
            chartOptionsToRestore: this.params.chartOptionsToRestore,
            chartPaletteToRestore: this.params.chartPaletteToRestore,
            seriesChartTypes: this.chartController.getSeriesChartTypes(),
            translate: (toTranslate, defaultText) => this.chartTranslationService.translate(toTranslate, defaultText),
        };
        // ensure 'restoring' options are not reused when switching chart types
        this.params.chartOptionsToRestore = undefined;
        // set local state used to detect when chart changes
        this.chartType = chartType;
        this.chartProxy = GridChartComp.createChartProxy(chartProxyParams);
        if (!this.chartProxy) {
            console.warn('AG Grid: invalid chart type supplied: ', chartProxyParams.chartType);
            return;
        }
        const canvas = this.eChart.querySelector('canvas');
        if (canvas) {
            canvas.classList.add('ag-charts-canvas');
        }
        this.chartController.setChartProxy(this.chartProxy);
        this.chartOptionsService = this.createBean(new ChartOptionsService(this.chartController));
        this.titleEdit && this.titleEdit.refreshTitle(this.chartController, this.chartOptionsService);
    }
    getChartThemeName() {
        return this.chartController.getChartThemeName();
    }
    getChartThemes() {
        return this.chartController.getThemeNames();
    }
    getGridOptionsChartThemeOverrides() {
        return this.gridOptionsService.get('chartThemeOverrides');
    }
    static createChartProxy(chartProxyParams) {
        switch (chartProxyParams.chartType) {
            case 'column':
            case 'bar':
            case 'groupedColumn':
            case 'stackedColumn':
            case 'normalizedColumn':
            case 'groupedBar':
            case 'stackedBar':
            case 'normalizedBar':
                return new BarChartProxy(chartProxyParams);
            case 'pie':
            case 'donut':
            case 'doughnut':
                return new PieChartProxy(chartProxyParams);
            case 'area':
            case 'stackedArea':
            case 'normalizedArea':
                return new AreaChartProxy(chartProxyParams);
            case 'line':
                return new LineChartProxy(chartProxyParams);
            case 'scatter':
            case 'bubble':
                return new ScatterChartProxy(chartProxyParams);
            case 'histogram':
                return new HistogramChartProxy(chartProxyParams);
            case 'radarLine':
            case 'radarArea':
            case 'nightingale':
            case 'radialColumn':
            case 'radialBar':
                return new PolarChartProxy(chartProxyParams);
            case 'rangeBar':
                return new RangeChartProxy(chartProxyParams);
            case 'rangeArea':
                return new RangeChartProxy(chartProxyParams);
            case 'boxPlot':
                return new BoxPlotChartProxy(chartProxyParams);
            case 'treemap':
                return new TreemapChartProxy(chartProxyParams);
            case 'sunburst':
                return new SunburstChartProxy(chartProxyParams);
            case 'heatmap':
                return new HeatmapChartProxy(chartProxyParams);
            case 'waterfall':
                return new WaterfallChartProxy(chartProxyParams);
            case 'columnLineCombo':
            case 'areaColumnCombo':
            case 'customCombo':
                return new ComboChartProxy(chartProxyParams);
            default:
                throw `AG Grid: Unable to create chart as an invalid chartType = '${chartProxyParams.chartType}' was supplied.`;
        }
    }
    addDialog() {
        const title = this.chartTranslationService.translate(this.params.pivotChart ? 'pivotChartTitle' : 'rangeChartTitle');
        const { width, height } = this.getBestDialogSize();
        this.chartDialog = new AgDialog({
            resizable: true,
            movable: true,
            maximizable: true,
            title,
            width,
            height,
            component: this,
            centered: true,
            closable: true
        });
        this.getContext().createBean(this.chartDialog);
        this.chartDialog.addEventListener(AgDialog.EVENT_DESTROYED, () => this.destroy());
    }
    getBestDialogSize() {
        const popupParent = this.popupService.getPopupParent();
        const maxWidth = _.getAbsoluteWidth(popupParent) * 0.75;
        const maxHeight = _.getAbsoluteHeight(popupParent) * 0.75;
        const ratio = 0.553;
        const chart = this.chartProxy.getChart();
        let width = this.params.insideDialog ? 850 : chart.width;
        let height = this.params.insideDialog ? 470 : chart.height;
        if (width > maxWidth || height > maxHeight) {
            width = Math.min(width, maxWidth);
            height = Math.round(width * ratio);
            if (height > maxHeight) {
                height = maxHeight;
                width = Math.min(width, Math.round(height / ratio));
            }
        }
        return { width, height };
    }
    addMenu() {
        if (!this.params.crossFiltering) {
            this.chartMenu = this.createBean(new ChartMenu(this.eChartContainer, this.eMenuContainer, this.chartController, this.chartOptionsService));
            this.eChartContainer.appendChild(this.chartMenu.getGui());
        }
    }
    addTitleEditComp() {
        this.titleEdit = this.createBean(new TitleEdit(this.chartMenu));
        this.eTitleEditContainer.appendChild(this.titleEdit.getGui());
        if (this.chartProxy) {
            this.titleEdit.refreshTitle(this.chartController, this.chartOptionsService);
        }
    }
    update(params) {
        // update chart model for api.updateChart()
        if (params === null || params === void 0 ? void 0 : params.chartId) {
            const validUpdate = this.chartController.update(params);
            if (!validUpdate) {
                return; // warning already logged!
            }
        }
        const chartTypeChanged = this.chartTypeChanged(params);
        // recreate chart if chart type has changed
        if (chartTypeChanged)
            this.createChart();
        // update chart options if chart type hasn't changed or if overrides are supplied
        this.updateChart(params === null || params === void 0 ? void 0 : params.chartThemeOverrides);
        if (params === null || params === void 0 ? void 0 : params.chartId) {
            this.chartProxy.getChart().waitForUpdate().then(() => {
                this.chartController.raiseChartApiUpdateEvent();
            });
        }
    }
    updateChart(updatedOverrides) {
        const { chartProxy } = this;
        const selectedCols = this.chartController.getSelectedValueColState();
        const fields = selectedCols.map(c => ({ colId: c.colId, displayName: c.displayName }));
        const data = this.chartController.getChartData();
        const chartEmpty = this.handleEmptyChart(data, fields);
        if (chartEmpty) {
            return;
        }
        let chartUpdateParams = this.chartController.getChartUpdateParams(updatedOverrides);
        chartProxy.update(chartUpdateParams);
        this.chartProxy.getChart().waitForUpdate().then(() => {
            this.chartController.raiseChartUpdatedEvent();
        });
        this.titleEdit.refreshTitle(this.chartController, this.chartOptionsService);
    }
    chartTypeChanged(updateParams) {
        const [currentType, updatedChartType] = [this.chartController.getChartType(), updateParams === null || updateParams === void 0 ? void 0 : updateParams.chartType];
        return this.chartType !== currentType || (!!updatedChartType && this.chartType !== getCanonicalChartType(updatedChartType));
    }
    getChartModel() {
        return this.chartController.getChartModel();
    }
    getChartImageDataURL(fileFormat) {
        return this.chartProxy.getChartImageDataURL(fileFormat);
    }
    handleEmptyChart(data, fields) {
        const pivotModeDisabled = this.chartController.isPivotChart() && !this.chartController.isPivotMode();
        // Determine the minimum number of fields based on the chart type
        const chartType = this.chartController.getChartType();
        let minFieldsRequired = 1;
        if (this.chartController.isActiveXYChart()) {
            minFieldsRequired = chartType === 'bubble' ? 3 : 2;
        }
        else if (isHierarchical(chartType)) {
            minFieldsRequired = 0;
        }
        const isEmptyChart = fields.length < minFieldsRequired || data.length === 0;
        if (this.eChart) {
            const isEmpty = pivotModeDisabled || isEmptyChart;
            _.setDisplayed(this.eChart, !isEmpty);
            _.setDisplayed(this.eEmpty, isEmpty);
        }
        if (pivotModeDisabled) {
            this.eEmpty.innerText = this.chartTranslationService.translate('pivotChartRequiresPivotMode');
            return true;
        }
        if (isEmptyChart) {
            this.eEmpty.innerText = this.chartTranslationService.translate('noDataToChart');
            return true;
        }
        return false;
    }
    downloadChart(dimensions, fileName, fileFormat) {
        this.chartProxy.downloadChart(dimensions, fileName, fileFormat);
    }
    openChartToolPanel(panel) {
        const menuPanel = panel ? CHART_TOOL_PANEL_MENU_OPTIONS[panel] : panel;
        this.chartMenu.showMenu(menuPanel);
    }
    closeChartToolPanel() {
        this.chartMenu.hideMenu();
    }
    getChartId() {
        return this.chartController.getChartId();
    }
    getUnderlyingChart() {
        return this.chartProxy.getChartRef();
    }
    crossFilteringReset() {
        this.chartProxy.crossFilteringReset();
    }
    setActiveChartCellRange(focusEvent) {
        if (this.getGui().contains(focusEvent.relatedTarget)) {
            return;
        }
        this.chartController.setChartRange(true);
        this.gridApi.focusService.clearFocusedCell();
    }
    getThemeName() {
        const availableChartThemes = this.gridOptionsService.get('chartThemes') || DEFAULT_THEMES;
        if (availableChartThemes.length === 0) {
            throw new Error('Cannot create chart: no chart themes available.');
        }
        const { chartThemeName } = this.params;
        return _.includes(availableChartThemes, chartThemeName) ? chartThemeName : availableChartThemes[0];
    }
    getAllKeysInObjects(objects) {
        const allValues = {};
        objects.filter(obj => obj != null).forEach(obj => {
            Object.keys(obj).forEach(key => allValues[key] = null);
        });
        return Object.keys(allValues);
    }
    validateCustomThemes() {
        const suppliedThemes = this.getChartThemes();
        const customChartThemes = this.gridOptionsService.get('customChartThemes');
        if (customChartThemes) {
            this.getAllKeysInObjects([customChartThemes]).forEach(customThemeName => {
                if (!_.includes(suppliedThemes, customThemeName)) {
                    console.warn("AG Grid: a custom chart theme with the name '" + customThemeName + "' has been " +
                        "supplied but not added to the 'chartThemes' list");
                }
            });
        }
    }
    reactivePropertyUpdate() {
        // switch to the first theme if the current theme is unavailable
        this.chartController.setChartThemeName(this.getThemeName(), true);
        const chartId = this.getChartId();
        const modelType = this.chartController.isCrossFilterChart()
            ? 'crossFilter'
            : this.getChartModel().modelType;
        // standalone requires that `undefined` / `null` values are supplied as `{}`
        const chartThemeOverrides = this.gridOptionsService.get('chartThemeOverrides') || {};
        this.update({
            type: `${modelType}ChartUpdate`,
            chartId,
            chartThemeOverrides
        });
    }
    raiseChartCreatedEvent() {
        const event = {
            type: Events.EVENT_CHART_CREATED,
            chartId: this.chartController.getChartId()
        };
        this.chartProxy.getChart().waitForUpdate().then(() => {
            this.eventService.dispatchEvent(event);
        });
    }
    raiseChartDestroyedEvent() {
        const event = {
            type: Events.EVENT_CHART_DESTROYED,
            chartId: this.chartController.getChartId(),
        };
        this.eventService.dispatchEvent(event);
    }
    destroy() {
        var _a;
        super.destroy();
        if (this.chartProxy) {
            this.chartProxy.destroy();
        }
        this.destroyBean(this.chartMenu);
        this.destroyBean(this.titleEdit);
        // don't want to invoke destroy() on the Dialog (prevents destroy loop)
        if (this.chartDialog && this.chartDialog.isAlive()) {
            this.destroyBean(this.chartDialog);
        }
        (_a = this.onDestroyColorSchemeChangeListener) === null || _a === void 0 ? void 0 : _a.call(this);
        // if the user is providing containers for the charts, we need to clean up, otherwise the old chart
        // data will still be visible although the chart is no longer bound to the grid
        const eGui = this.getGui();
        _.clearElement(eGui);
        // remove from parent, so if user provided container, we detach from the provided dom element
        _.removeFromParent(eGui);
        this.raiseChartDestroyedEvent();
    }
}
GridChartComp.TEMPLATE = `<div class="ag-chart" tabindex="-1">
            <div ref="eChartContainer" tabindex="-1" class="ag-chart-components-wrapper">
                <div ref="eChart" class="ag-chart-canvas-wrapper"></div>
                <div ref="eEmpty" class="ag-chart-empty-text ag-unselectable"></div>
            </div>
            <div ref="eTitleEditContainer"></div>
            <div ref="eMenuContainer" class="ag-chart-docked-container" style="min-width: 0px;"></div>
        </div>`;
__decorate$Q([
    RefSelector('eChart')
], GridChartComp.prototype, "eChart", void 0);
__decorate$Q([
    RefSelector('eChartContainer')
], GridChartComp.prototype, "eChartContainer", void 0);
__decorate$Q([
    RefSelector('eMenuContainer')
], GridChartComp.prototype, "eMenuContainer", void 0);
__decorate$Q([
    RefSelector('eEmpty')
], GridChartComp.prototype, "eEmpty", void 0);
__decorate$Q([
    RefSelector('eTitleEditContainer')
], GridChartComp.prototype, "eTitleEditContainer", void 0);
__decorate$Q([
    Autowired('chartCrossFilterService')
], GridChartComp.prototype, "crossFilterService", void 0);
__decorate$Q([
    Autowired('chartTranslationService')
], GridChartComp.prototype, "chartTranslationService", void 0);
__decorate$Q([
    Autowired('gridApi')
], GridChartComp.prototype, "gridApi", void 0);
__decorate$Q([
    Autowired('popupService')
], GridChartComp.prototype, "popupService", void 0);
__decorate$Q([
    PostConstruct
], GridChartComp.prototype, "init", null);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$3 = '31.1.1';

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function upgradeChartModel(model) {
    const originalVersion = model.version;
    if (model.version == null) {
        // Try to guess the version so we can apply the right subset of migrations.
        model.version = heuristicVersionDetection(model);
    }
    model = migrateIfBefore('23.0.0', model, migrateV23);
    model = migrateIfBefore('24.0.0', model, migrateV24);
    model = migrateIfBefore('25.1.0', model, migrateV25_1);
    model = migrateIfBefore('26.0.0', model, migrateV26);
    model = migrateIfBefore('26.1.0', model, migrateV26_1);
    // Switch from iChartOptions to iAgChartOptions....
    model = migrateIfBefore('26.2.0', model, migrateV26_2);
    model = migrateIfBefore('28.0.0', model, migrateV28);
    model = migrateIfBefore('28.2.0', model, migrateV28_2);
    model = migrateIfBefore('29.0.0', model, migrateV29);
    model = migrateIfBefore('29.1.0', model, migrateV29_1);
    model = migrateIfBefore('29.2.0', model, migrateV29_2);
    model = migrateIfBefore('30.0.0', model, migrateV30);
    model = migrateIfBefore('31.0.0', model, migrateV31);
    model = cleanup(model);
    // Bump version to latest.
    model = migrateIfBefore(VERSION$3, model, (m) => m);
    return model;
}
function migrateV23(model) {
    // https://github.com/ag-grid/ag-grid/commit/76c6744ff2b732d298d1ade73c122188854b5bac
    model = jsonRename('chartOptions.legend.item.marker.type', 'shape', model);
    model = jsonRename('chartOptions.seriesDefaults.marker.type', 'shape', model);
    // https://github.com/ag-grid/ag-grid/commit/7bdf2cfd666acda758a818733a9f9cb35ac1d7a7
    model = jsonRename('chartOptions.legend.padding', 'spacing', model);
    return model;
}
function migrateV24(model) {
    var _a;
    // https://github.com/ag-grid/ag-grid/commit/f4e854e3dc459400fa00e6da2873cb8e9cfff6fe#
    model = jsonDelete('chartOptions.seriesDefaults.marker.minSize', model);
    const _b = model, { chartType, chartPalette } = _b, // Migrate.
    _c = _b.chartOptions, // Migrate.
    { xAxis, yAxis } = _c, chartOptions = __rest(_c, ["xAxis", "yAxis"]), chartModel = __rest(_b, ["chartType", "chartPalette", "chartOptions"]);
    const axesTypes = getLegacyAxisType(chartType);
    const axes = axesTypes === null || axesTypes === void 0 ? void 0 : axesTypes.map((type, i) => (Object.assign({ type }, (i === 0 ? xAxis : yAxis))));
    // Precise legacy palette fills/strokes can be found here for future reference:
    // https://github.com/ag-grid/ag-grid/blob/b22.1.0/grid-enterprise-modules/charts/src/charts/chart/palettes.ts
    const LEGACY_PALETTES = {
        borneo: 'ag-default',
        material: 'ag-material',
        bright: 'ag-vivid',
    };
    return Object.assign({ chartType, chartThemeName: (_a = LEGACY_PALETTES[chartPalette]) !== null && _a !== void 0 ? _a : 'ag-default', chartOptions: Object.assign(Object.assign({}, chartOptions), { axes,
            xAxis,
            yAxis }) }, chartModel);
}
function migrateV25_1(model) {
    // https://github.com/ag-grid/ag-grid/commit/61943f9fecbfb5ac1b9a1fd93788f9fdd8687181
    model = jsonRename('chartOptions.seriesDefaults.label.minRequiredAngle', 'minAngle', model);
    return model;
}
function migrateV26(model) {
    // https://github.com/ag-grid/ag-grid/commit/df2445d88e64cb4e831d6163104a0fa60ccde3b5
    const highlightOptUpdate = (_a) => {
        var { dimOpacity } = _a, opts = __rest(_a, ["dimOpacity"]);
        return (Object.assign(Object.assign({}, opts), (dimOpacity != null ? { series: { dimOpacity } } : {})));
    };
    model = jsonMutate('chartOptions.seriesDefaults.highlightStyle', model, highlightOptUpdate);
    // https://github.com/ag-grid/ag-grid/commit/f4e854e3dc459400fa00e6da2873cb8e9cfff6fe#
    model = jsonDelete('chart', model);
    model = jsonDelete('chartOptions.seriesDefaults.tooltipClass', model);
    model = jsonDelete('chartOptions.seriesDefaults.tooltipTracking', model);
    // Cleanup label.rotation === 0, which was treated as 'use the default' on reload prior to 26.
    model = jsonDeleteDefault('chartOptions.axes[].label.rotation', 0, model);
    model = jsonDeleteDefault('chartOptions.axes[].label.rotation', 335, model);
    return model;
}
function migrateV26_1(model) {
    // https://github.com/ag-grid/ag-grid/commit/df2445d88e64cb4e831d6163104a0fa60ccde3b5
    const highlightOptUpdate = (_a) => {
        var { item, series } = _a, opts = __rest(_a, ["item", "series"]);
        return (Object.assign({ item: Object.assign(Object.assign({}, opts), item) }, (series ? { series } : {})));
    };
    model = jsonMutate('chartOptions.seriesDefaults.highlightStyle', model, highlightOptUpdate);
    model = jsonMutate('chartOptions.series[].highlightStyle', model, highlightOptUpdate);
    return model;
}
function migrateV26_2(model) {
    // https://github.com/ag-grid/ag-grid/commit/8b2e223cb1a687cb6c1d70b9f75f52fa29d00341
    model = jsonMove('chartOptions.seriesDefaults.fill.opacity', 'chartOptions.seriesDefaults.fillOpacity', model);
    model = jsonMove('chartOptions.seriesDefaults.stroke.opacity', 'chartOptions.seriesDefaults.strokeOpacity', model);
    model = jsonMove('chartOptions.seriesDefaults.stroke.width', 'chartOptions.seriesDefaults.strokeWidth', model);
    model = jsonDelete('chartOptions.seriesDefaults.fill', model);
    model = jsonDelete('chartOptions.seriesDefaults.stroke', model);
    model = jsonDelete('chartOptions.seriesDefaults.callout.colors', model);
    model = jsonDelete('chartOptions.xAxis', model);
    model = jsonDelete('chartOptions.yAxis', model);
    const _a = model, { chartType: providedChartType } = _a, _b = _a.chartOptions, { axes, series, seriesDefaults } = _b, otherChartOptions = __rest(_b, ["axes", "series", "seriesDefaults"]), otherModelProps = __rest(_a, ["chartType", "chartOptions"]);
    // At 26.2.0 combination charts weren't supported, so we can safely assume a single series type.
    // We can't rely on the `series.type` field as it was incorrect (in v25.0.0 line chart has an
    // `area` series).
    // Note that in v31.1.0, the canonical name for the 'doughnut' chart type changed to 'donut'.
    const chartType = getCanonicalChartType(providedChartType);
    const seriesType = getSeriesType(chartType);
    const seriesTypes = [seriesType];
    const chartTypeMixin = {};
    if (!isPieChartSeries(seriesType)) {
        const minimalAxis = { top: {}, bottom: {}, left: {}, right: {} };
        const updatedAxes = axes
            .map((_a) => {
            var { type } = _a, axisProps = __rest(_a, ["type"]);
            return ({
                [type]: Object.assign(Object.assign({}, minimalAxis), axisProps),
            });
        })
            .reduce(merge, {});
        ALL_AXIS_TYPES.filter((v) => updatedAxes[v] == null).forEach((v) => {
            updatedAxes[v] = Object.assign({}, minimalAxis);
        });
        chartTypeMixin.axes = updatedAxes;
    }
    const updatedChartOptions = seriesTypes
        .map((t) => ({
        [t]: Object.assign(Object.assign(Object.assign({}, chartTypeMixin), { series: seriesDefaults }), otherChartOptions),
    }))
        .reduce(merge, {});
    model = Object.assign(Object.assign({}, otherModelProps), { chartType, chartOptions: updatedChartOptions });
    return model;
}
function migrateV28(model) {
    model = jsonDelete('chartOptions.*.title.padding', model);
    model = jsonDelete('chartOptions.*.subtitle.padding', model);
    model = jsonDelete('chartOptions.*.axes.*.title.padding', model);
    model = jsonBackfill('chartOptions.*.axes.*.title.enabled', false, model);
    return model;
}
function migrateV28_2(model) {
    model = jsonRename('chartOptions.pie.series.callout', 'calloutLine', model);
    model = jsonRename('chartOptions.pie.series.label', 'calloutLabel', model);
    model = jsonRename('chartOptions.pie.series.labelKey', 'sectorLabelKey', model);
    model = jsonRename('chartOptions.pie.series.labelName', 'sectorLabelName', model);
    model = jsonRename('chartOptions.donut.series.callout', 'calloutLine', model);
    model = jsonRename('chartOptions.donut.series.label', 'calloutLabel', model);
    model = jsonRename('chartOptions.donut.series.labelKey', 'sectorLabelKey', model);
    model = jsonRename('chartOptions.donut.series.labelName', 'sectorLabelName', model);
    // series.yKeys => yKey ?
    // series.yNames => yName ?
    return model;
}
function migrateV29(model) {
    model = jsonMoveIfMissing('chartOptions.scatter.series.fill', 'chartOptions.scatter.series.marker.fill', model);
    model = jsonMoveIfMissing('chartOptions.scatter.series.fillOpacity', 'chartOptions.scatter.series.marker.fillOpacity', model);
    model = jsonMoveIfMissing('chartOptions.scatter.series.stroke', 'chartOptions.scatter.series.marker.stroke', model);
    model = jsonMoveIfMissing('chartOptions.scatter.series.strokeOpacity', 'chartOptions.scatter.series.marker.strokeOpacity', model);
    model = jsonMoveIfMissing('chartOptions.scatter.series.strokeWidth', 'chartOptions.scatter.series.marker.strokeWidth', model);
    model = jsonMove('chartOptions.scatter.series.paired', 'chartOptions.scatter.paired', model);
    return model;
}
function migrateV29_1(model) {
    model = jsonDelete('chartOptions.axes[].tick.count', model);
    return model;
}
function migrateV29_2(model) {
    // https://github.com/ag-grid/ag-grid/commit/ce11956492e42e845932edb4e05d7b0b21db5c61
    const tooltipOptUpdate = (_a) => {
        var _b, _c, _d, _e;
        var { tracking } = _a, opts = __rest(_a, ["tracking"]);
        const output = Object.assign({}, opts);
        if (tracking === false) {
            (_b = output.position) !== null && _b !== void 0 ? _b : (output.position = { type: 'pointer' });
            (_c = output.range) !== null && _c !== void 0 ? _c : (output.range = 'nearest');
        }
        else if (tracking === true) {
            (_d = output.position) !== null && _d !== void 0 ? _d : (output.position = { type: 'node' });
            (_e = output.range) !== null && _e !== void 0 ? _e : (output.range = 'nearest');
        }
        return output;
    };
    model = jsonMutate('chartOptions.*.tooltip', model, tooltipOptUpdate);
    return model;
}
function migrateV30(model) {
    // Repeated from migrateV28_2() as they were applied retrospectively for the v30 release.
    model = jsonRename('chartOptions.pie.series.labelKey', 'sectorLabelKey', model);
    model = jsonRename('chartOptions.pie.series.labelName', 'sectorLabelName', model);
    // Late-applied migrations for deprecations in the 29.x.y range.
    model = migrateV29_1(model);
    model = migrateV29_2(model);
    // Actual v30 changes.
    model = jsonDelete('chartOptions.*.series.flipXY', model);
    model = jsonAdd('chartOptions.common.legend.enabled', true, model);
    model = jsonBackfill('chartOptions.common.legend.position', 'right', model);
    return model;
}
function migrateV31(model) {
    const V30_LEGACY_PALETTES = {
        'ag-pastel': 'ag-sheets',
        'ag-solar': 'ag-polychroma'
    };
    const updatedModel = jsonRename('chartOptions.column', 'bar', model);
    const chartThemeName = V30_LEGACY_PALETTES[updatedModel.chartThemeName] || updatedModel.chartThemeName;
    return Object.assign(Object.assign({}, updatedModel), { chartThemeName });
}
function cleanup(model) {
    // Remove fixed width/height - this has never been supported via UI configuration.
    model = jsonDelete('chartOptions.*.width', model);
    model = jsonDelete('chartOptions.*.height', model);
    model = jsonBackfill('chartOptions.*.axes.category.label.autoRotate', true, model);
    return model;
}
function heuristicVersionDetection(model) {
    var _a, _b;
    const modelAny = model;
    if (model.version != null) {
        return model.version;
    }
    const hasKey = (obj, ...keys) => {
        return Object.keys(obj || {}).some((k) => keys.includes(k));
    };
    const chartOptions = modelAny.chartOptions;
    const seriesOptions = hasKey(chartOptions, 'seriesDefaults')
        ? chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.seriesDefaults
        : chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions[Object.keys(chartOptions)[0]];
    const hints = {
        '27.0.0': hasKey(modelAny, 'seriesChartTypes'),
        '26.2.0': !hasKey(chartOptions, 'seriesDefaults'),
        '26.1.0': hasKey(seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.highlightStyle, 'item'),
        '26.0.0': hasKey(seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.highlightStyle, 'series'),
        // '26.0.0': modelAny.chart === undefined,
        '25.1.0': hasKey(seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.label, 'minAngle'),
        '25.0.0': hasKey(modelAny, 'modelType', 'aggFunc', 'unlinkChart', 'suppressChartRanges') ||
            hasKey(seriesOptions, 'lineDash', 'lineDashOffset'),
        '24.0.0': hasKey(modelAny, 'chartThemeName', 'chart') || hasKey(chartOptions, 'series'),
        '23.2.0': hasKey(chartOptions, 'navigator'),
        '23.0.0': hasKey((_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.legend) === null || _a === void 0 ? void 0 : _a.item) === null || _b === void 0 ? void 0 : _b.marker, 'shape'),
        '22.1.0': hasKey(modelAny, 'chartPalette', 'chartType'),
    };
    // Default to 27.1.0, the last version before we added `version`.
    const defaultVersion = '27.1.0';
    const matchingHints = Object.entries(hints).filter(([_, match]) => match);
    const [heuristicVersion = defaultVersion] = matchingHints[0];
    return heuristicVersion;
}
function migrateIfBefore(maxVersion, model, migration) {
    if (versionNumber(maxVersion) > versionNumber(model.version)) {
        const result = migration(model);
        result.version = maxVersion;
        return result;
    }
    return model;
}
function versionParts(version) {
    const split = typeof version === 'string' ? version.split('.').map((v) => Number(v)) : [];
    if (split.length !== 3 || split.some((v) => isNaN(v))) {
        throw new Error('AG Grid - Illegal version string: ' + version);
    }
    return {
        major: split[0],
        minor: split[1],
        patch: split[2],
    };
}
function versionNumber(version) {
    const { major, minor, patch } = versionParts(version);
    // Return a number of the form MMmmPP.
    return major * 10000 + minor * 100 + patch;
}
function jsonDeleteDefault(path, defaultValue, json) {
    return jsonMutateProperty(path, true, json, (parent, prop) => {
        if (parent[prop] === defaultValue) {
            delete parent[prop];
        }
    });
}
function jsonBackfill(path, defaultValue, json) {
    return jsonMutateProperty(path, false, json, (parent, prop) => {
        if (parent[prop] == null) {
            parent[prop] = defaultValue;
        }
    });
}
function jsonAdd(path, value, json) {
    var _a;
    if (typeof path === 'string') {
        path = path.split('.');
    }
    const nextPath = path[0];
    if (path.length > 1) {
        json[nextPath] = jsonAdd(path.slice(1), value, (_a = json[nextPath]) !== null && _a !== void 0 ? _a : {});
    }
    const hasProperty = Object.keys(json).includes(nextPath);
    if (!hasProperty) {
        json[nextPath] = value;
    }
    return json;
}
function jsonMove(from, to, json) {
    let valueToMove = undefined;
    let valueFound = false;
    json = jsonMutateProperty(from, true, json, (parent, prop) => {
        valueFound = true;
        valueToMove = parent[prop];
        delete parent[prop];
    });
    if (!valueFound) {
        return json;
    }
    return jsonMutateProperty(to, false, json, (parent, prop) => {
        parent[prop] = valueToMove;
    });
}
function jsonMoveIfMissing(from, to, json) {
    let valueToMove = undefined;
    let valueFound = false;
    json = jsonMutateProperty(from, true, json, (parent, prop) => {
        valueFound = true;
        valueToMove = parent[prop];
        delete parent[prop];
    });
    if (!valueFound) {
        return json;
    }
    return jsonMutateProperty(to, false, json, (parent, prop) => {
        if (parent[prop] === undefined) {
            parent[prop] = valueToMove;
        }
    });
}
function jsonRename(path, renameTo, json) {
    return jsonMutateProperty(path, true, json, (parent, prop) => {
        parent[renameTo] = parent[prop];
        delete parent[prop];
    });
}
function jsonDelete(path, json) {
    return jsonMutateProperty(path, true, json, (parent, prop) => delete parent[prop]);
}
function jsonMutateProperty(path, skipMissing, json, mutator) {
    const pathElements = path instanceof Array ? path : path.split('.');
    const parentPathElements = pathElements.slice(0, pathElements.length - 1);
    const targetName = pathElements[pathElements.length - 1];
    return jsonMutate(parentPathElements, json, (parent) => {
        const hasProperty = Object.keys(parent).includes(targetName);
        if (skipMissing && !hasProperty) {
            return parent;
        }
        const result = Object.assign({}, parent);
        mutator(result, targetName);
        return result;
    });
}
function jsonMutate(path, json, mutator) {
    const pathElements = path instanceof Array ? path : path.split('.');
    // Clone to avoid mutating original input.
    json = Object.assign({}, json);
    if (pathElements.length === 0) {
        return mutator(json);
    }
    else if (pathElements[0].startsWith('{')) {
        const pathOptions = pathElements[0].substring(1, pathElements[0].lastIndexOf('}')).split(',');
        for (const pathOption of pathOptions) {
            if (json[pathOption] != null) {
                json[pathOption] = jsonMutate(pathElements.slice(1), json[pathOption], mutator);
            }
        }
    }
    else if (pathElements[0].endsWith('[]')) {
        const arrayName = pathElements[0].substring(0, path[0].indexOf('['));
        if (json[arrayName] instanceof Array) {
            json[arrayName] = json[arrayName].map((v) => jsonMutate(pathElements.slice(1), v, mutator));
        }
    }
    else if (pathElements[0] === '*') {
        for (const jsonProp in json) {
            json[jsonProp] = jsonMutate(pathElements.slice(1), json[jsonProp], mutator);
        }
    }
    else if (json[pathElements[0]] != null) {
        json[pathElements[0]] = jsonMutate(pathElements.slice(1), json[pathElements[0]], mutator);
    }
    return json;
}
const merge = (r, n) => (Object.assign(Object.assign({}, r), n));

var __decorate$R = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ChartService = class ChartService extends BeanStub {
    constructor() {
        super(...arguments);
        // we destroy all charts bound to this grid when grid is destroyed. activeCharts contains all charts, including
        // those in developer provided containers.
        this.activeCharts = new Set();
        this.activeChartComps = new Set();
        // this shared (singleton) context is used by cross filtering in line and area charts
        this.crossFilteringContext = {
            lastSelectedChartId: '',
        };
        this.isEnterprise = () => module_support_exports.enterpriseModule.isEnterprise;
    }
    updateChart(params) {
        const chartType = params.chartType;
        if (chartType && isEnterpriseChartType(chartType) && !this.isEnterprise()) {
            ModuleRegistry.__warnEnterpriseChartDisabled(chartType);
            return;
        }
        if (this.activeChartComps.size === 0) {
            console.warn(`AG Grid - No active charts to update.`);
            return;
        }
        const chartComp = [...this.activeChartComps].find(chartComp => chartComp.getChartId() === params.chartId);
        if (!chartComp) {
            console.warn(`AG Grid - Unable to update chart. No active chart found with ID: ${params.chartId}.`);
            return;
        }
        chartComp.update(params);
    }
    getChartModels() {
        const models = [];
        const versionedModel = (c) => {
            return Object.assign(Object.assign({}, c), { version: VERSION$3 });
        };
        this.activeChartComps.forEach(c => models.push(versionedModel(c.getChartModel())));
        return models;
    }
    getChartRef(chartId) {
        let chartRef;
        this.activeCharts.forEach(cr => {
            if (cr.chartId === chartId) {
                chartRef = cr;
            }
        });
        return chartRef;
    }
    getChartComp(chartId) {
        let chartComp;
        this.activeChartComps.forEach(comp => {
            if (comp.getChartId() === chartId) {
                chartComp = comp;
            }
        });
        return chartComp;
    }
    getChartImageDataURL(params) {
        let url;
        this.activeChartComps.forEach(c => {
            if (c.getChartId() === params.chartId) {
                url = c.getChartImageDataURL(params.fileFormat);
            }
        });
        return url;
    }
    downloadChart(params) {
        const chartComp = Array.from(this.activeChartComps).find(c => c.getChartId() === params.chartId);
        chartComp === null || chartComp === void 0 ? void 0 : chartComp.downloadChart(params.dimensions, params.fileName, params.fileFormat);
    }
    openChartToolPanel(params) {
        const chartComp = Array.from(this.activeChartComps).find(c => c.getChartId() === params.chartId);
        chartComp === null || chartComp === void 0 ? void 0 : chartComp.openChartToolPanel(params.panel);
    }
    closeChartToolPanel(chartId) {
        const chartComp = Array.from(this.activeChartComps).find(c => c.getChartId() === chartId);
        chartComp === null || chartComp === void 0 ? void 0 : chartComp.closeChartToolPanel();
    }
    createChartFromCurrentRange(chartType = 'groupedColumn') {
        const selectedRange = this.getSelectedRange();
        return this.createChart(selectedRange, chartType);
    }
    restoreChart(model, chartContainer) {
        if (!model) {
            console.warn("AG Grid - unable to restore chart as no chart model is provided");
            return;
        }
        if (model.version !== VERSION$3) {
            model = upgradeChartModel(model);
        }
        const params = {
            cellRange: model.cellRange,
            chartType: model.chartType,
            chartThemeName: model.chartThemeName,
            chartContainer: chartContainer,
            suppressChartRanges: model.suppressChartRanges,
            aggFunc: model.aggFunc,
            unlinkChart: model.unlinkChart,
            seriesChartTypes: model.seriesChartTypes
        };
        const getCellRange = (cellRangeParams) => {
            return this.rangeService
                ? this.rangeService.createCellRangeFromCellRangeParams(cellRangeParams)
                : undefined;
        };
        if (model.modelType === 'pivot') {
            // if required enter pivot mode
            this.gridOptionsService.updateGridOptions({ options: { pivotMode: true }, source: 'pivotChart' });
            // pivot chart range contains all visible column without a row range to include all rows
            const columns = this.columnModel.getAllDisplayedColumns().map(col => col.getColId());
            const chartAllRangeParams = {
                rowStartIndex: null,
                rowStartPinned: undefined,
                rowEndIndex: null,
                rowEndPinned: undefined,
                columns
            };
            const cellRange = getCellRange(chartAllRangeParams);
            if (!cellRange) {
                console.warn("AG Grid - unable to create chart as there are no columns in the grid.");
                return;
            }
            return this.createChart(cellRange, params.chartType, params.chartThemeName, true, true, params.chartContainer, undefined, undefined, params.unlinkChart, false, model.chartOptions);
        }
        const cellRange = getCellRange(params.cellRange);
        if (!cellRange) {
            console.warn("AG Grid - unable to create chart as no range is selected");
            return;
        }
        return this.createChart(cellRange, params.chartType, params.chartThemeName, false, params.suppressChartRanges, params.chartContainer, params.aggFunc, undefined, params.unlinkChart, false, model.chartOptions, model.chartPalette, params.seriesChartTypes);
    }
    createRangeChart(params) {
        var _a;
        const cellRange = (_a = this.rangeService) === null || _a === void 0 ? void 0 : _a.createCellRangeFromCellRangeParams(params.cellRange);
        if (!cellRange) {
            console.warn("AG Grid - unable to create chart as no range is selected");
            return;
        }
        return this.createChart(cellRange, params.chartType, params.chartThemeName, false, params.suppressChartRanges, params.chartContainer, params.aggFunc, params.chartThemeOverrides, params.unlinkChart, undefined, undefined, undefined, params.seriesChartTypes);
    }
    createPivotChart(params) {
        // if required enter pivot mode
        this.gridOptionsService.updateGridOptions({ options: { pivotMode: true }, source: 'pivotChart' });
        // pivot chart range contains all visible column without a row range to include all rows
        const chartAllRangeParams = {
            rowStartIndex: null,
            rowStartPinned: undefined,
            rowEndIndex: null,
            rowEndPinned: undefined,
            columns: this.columnModel.getAllDisplayedColumns().map(col => col.getColId())
        };
        const cellRange = this.rangeService
            ? this.rangeService.createCellRangeFromCellRangeParams(chartAllRangeParams)
            : undefined;
        if (!cellRange) {
            console.warn("AG Grid - unable to create chart as there are no columns in the grid.");
            return;
        }
        return this.createChart(cellRange, params.chartType, params.chartThemeName, true, true, params.chartContainer, undefined, params.chartThemeOverrides, params.unlinkChart);
    }
    createCrossFilterChart(params) {
        var _a;
        const cellRange = (_a = this.rangeService) === null || _a === void 0 ? void 0 : _a.createCellRangeFromCellRangeParams(params.cellRange);
        if (!cellRange) {
            console.warn("AG Grid - unable to create chart as no range is selected");
            return;
        }
        const crossFiltering = true;
        const suppressChartRangesSupplied = typeof params.suppressChartRanges !== 'undefined' && params.suppressChartRanges !== null;
        const suppressChartRanges = suppressChartRangesSupplied ? params.suppressChartRanges : true;
        return this.createChart(cellRange, params.chartType, params.chartThemeName, false, suppressChartRanges, params.chartContainer, params.aggFunc, params.chartThemeOverrides, params.unlinkChart, crossFiltering);
    }
    createChart(cellRange, chartType, chartThemeName, pivotChart = false, suppressChartRanges = false, container, aggFunc, chartThemeOverrides, unlinkChart = false, crossFiltering = false, chartOptionsToRestore, chartPaletteToRestore, seriesChartTypes) {
        if (isEnterpriseChartType(chartType) && !this.isEnterprise()) {
            ModuleRegistry.__warnEnterpriseChartDisabled(chartType);
            return undefined;
        }
        const createChartContainerFunc = this.gridOptionsService.getCallback('createChartContainer');
        const params = {
            chartId: this.generateId(),
            pivotChart,
            cellRange,
            chartType: getCanonicalChartType(chartType),
            chartThemeName,
            insideDialog: !(container || createChartContainerFunc),
            suppressChartRanges,
            aggFunc,
            chartThemeOverrides,
            unlinkChart,
            crossFiltering,
            crossFilteringContext: this.crossFilteringContext,
            chartOptionsToRestore,
            chartPaletteToRestore,
            seriesChartTypes,
            crossFilteringResetCallback: () => this.activeChartComps.forEach(c => c.crossFilteringReset()),
        };
        const chartComp = new GridChartComp(params);
        this.context.createBean(chartComp);
        const chartRef = this.createChartRef(chartComp);
        if (container) {
            // if container exists, means developer initiated chart create via API, so place in provided container
            container.appendChild(chartComp.getGui());
            // if the chart container was placed outside an element that
            // has the grid's theme, we manually add the current theme to
            // make sure all styles for the chartMenu are rendered correctly
            const theme = this.environment.getTheme();
            if (theme.el && !theme.el.contains(container)) {
                container.classList.add(theme.theme);
            }
        }
        else if (createChartContainerFunc) {
            // otherwise, user created chart via grid UI, check if developer provides containers (e.g. if the application
            // is using its own dialogs rather than the grid provided dialogs)
            createChartContainerFunc(chartRef);
        }
        else {
            // add listener to remove from active charts list when charts are destroyed, e.g. closing chart dialog
            chartComp.addEventListener(GridChartComp.EVENT_DESTROYED, () => {
                this.activeChartComps.delete(chartComp);
                this.activeCharts.delete(chartRef);
            });
        }
        return chartRef;
    }
    createChartRef(chartComp) {
        const chartRef = {
            destroyChart: () => {
                if (this.activeCharts.has(chartRef)) {
                    this.context.destroyBean(chartComp);
                    this.activeChartComps.delete(chartComp);
                    this.activeCharts.delete(chartRef);
                }
            },
            chartElement: chartComp.getGui(),
            chart: chartComp.getUnderlyingChart(),
            chartId: chartComp.getChartModel().chartId
        };
        this.activeCharts.add(chartRef);
        this.activeChartComps.add(chartComp);
        return chartRef;
    }
    getSelectedRange() {
        const ranges = this.rangeService.getCellRanges();
        return ranges.length > 0 ? ranges[0] : {};
    }
    generateId() {
        return `id-${Math.random().toString(36).substring(2, 18)}`;
    }
    destroyAllActiveCharts() {
        this.activeCharts.forEach(chart => chart.destroyChart());
    }
};
ChartService.CHARTS_VERSION = VERSION$2;
__decorate$R([
    Optional('rangeService')
], ChartService.prototype, "rangeService", void 0);
__decorate$R([
    Autowired('columnModel')
], ChartService.prototype, "columnModel", void 0);
__decorate$R([
    PreDestroy
], ChartService.prototype, "destroyAllActiveCharts", null);
ChartService = __decorate$R([
    Bean('chartService')
], ChartService);

var __decorate$S = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ChartTranslationService_1;
let ChartTranslationService = ChartTranslationService_1 = class ChartTranslationService extends BeanStub {
    translate(toTranslate, defaultText) {
        const translate = this.localeService.getLocaleTextFunc();
        const defaultTranslation = ChartTranslationService_1.DEFAULT_TRANSLATIONS[toTranslate] || defaultText;
        return translate(toTranslate, defaultTranslation);
    }
};
ChartTranslationService.DEFAULT_TRANSLATIONS = {
    pivotChartTitle: 'Pivot Chart',
    rangeChartTitle: 'Range Chart',
    settings: 'Settings',
    data: 'Data',
    format: 'Format',
    categories: 'Categories',
    defaultCategory: '(None)',
    series: 'Series',
    xyValues: 'X Y Values',
    paired: 'Paired Mode',
    axis: 'Axis',
    radiusAxis: 'Radius Axis',
    navigator: 'Navigator',
    color: 'Color',
    thickness: 'Thickness',
    preferredLength: 'Preferred Length',
    xType: 'X Type',
    automatic: 'Automatic',
    category: 'Category',
    number: 'Number',
    time: 'Time',
    autoRotate: 'Auto Rotate',
    xRotation: 'X Rotation',
    yRotation: 'Y Rotation',
    labelRotation: 'Rotation',
    circle: 'Circle',
    orientation: 'Orientation',
    polygon: 'Polygon',
    fixed: 'Fixed',
    parallel: 'Parallel',
    perpendicular: 'Perpendicular',
    radiusAxisPosition: 'Position',
    ticks: 'Ticks',
    width: 'Width',
    height: 'Height',
    length: 'Length',
    padding: 'Padding',
    spacing: 'Spacing',
    chart: 'Chart',
    title: 'Title',
    titlePlaceholder: 'Chart title - double click to edit',
    background: 'Background',
    font: 'Font',
    top: 'Top',
    right: 'Right',
    bottom: 'Bottom',
    left: 'Left',
    labels: 'Labels',
    calloutLabels: 'Callout Labels',
    sectorLabels: 'Sector Labels',
    positionRatio: 'Position Ratio',
    size: 'Size',
    shape: 'Shape',
    minSize: 'Minimum Size',
    maxSize: 'Maximum Size',
    legend: 'Legend',
    position: 'Position',
    markerSize: 'Marker Size',
    markerStroke: 'Marker Stroke',
    markerPadding: 'Marker Padding',
    itemSpacing: 'Item Spacing',
    itemPaddingX: 'Item Padding X',
    itemPaddingY: 'Item Padding Y',
    layoutHorizontalSpacing: 'Horizontal Spacing',
    layoutVerticalSpacing: 'Vertical Spacing',
    strokeWidth: 'Stroke Width',
    offset: 'Offset',
    offsets: 'Offsets',
    tooltips: 'Tooltips',
    callout: 'Callout',
    markers: 'Markers',
    shadow: 'Shadow',
    blur: 'Blur',
    xOffset: 'X Offset',
    yOffset: 'Y Offset',
    lineWidth: 'Line Width',
    lineDash: 'Line Dash',
    lineDashOffset: 'Dash Offset',
    normal: 'Normal',
    bold: 'Bold',
    italic: 'Italic',
    boldItalic: 'Bold Italic',
    predefined: 'Predefined',
    fillOpacity: 'Fill Opacity',
    strokeColor: 'Line Color',
    strokeOpacity: 'Line Opacity',
    histogramBinCount: 'Bin count',
    connectorLine: 'Connector Line',
    seriesItems: 'Series Items',
    seriesItemType: 'Item Type',
    seriesItemPositive: 'Positive',
    seriesItemNegative: 'Negative',
    seriesItemLabels: 'Item Labels',
    columnGroup: 'Column',
    barGroup: 'Bar',
    pieGroup: 'Pie',
    lineGroup: 'Line',
    scatterGroup: 'X Y (Scatter)',
    areaGroup: 'Area',
    polarGroup: 'Polar',
    statisticalGroup: 'Statistical',
    hierarchicalGroup: 'Hierarchical',
    specializedGroup: 'Specialized',
    combinationGroup: 'Combination',
    groupedColumnTooltip: 'Grouped',
    stackedColumnTooltip: 'Stacked',
    normalizedColumnTooltip: '100% Stacked',
    groupedBarTooltip: 'Grouped',
    stackedBarTooltip: 'Stacked',
    normalizedBarTooltip: '100% Stacked',
    pieTooltip: 'Pie',
    donutTooltip: 'Donut',
    lineTooltip: 'Line',
    groupedAreaTooltip: 'Area',
    stackedAreaTooltip: 'Stacked',
    normalizedAreaTooltip: '100% Stacked',
    scatterTooltip: 'Scatter',
    bubbleTooltip: 'Bubble',
    histogramTooltip: 'Histogram',
    radialColumnTooltip: 'Radial Column',
    radialBarTooltip: 'Radial Bar',
    radarLineTooltip: 'Radar Line',
    radarAreaTooltip: 'Radar Area',
    nightingaleTooltip: 'Nightingale',
    rangeBarTooltip: 'Range Bar',
    rangeAreaTooltip: 'Range Area',
    boxPlotTooltip: 'Box Plot',
    treemapTooltip: 'Treemap',
    sunburstTooltip: 'Sunburst',
    heatmapTooltip: 'Heatmap',
    waterfallTooltip: 'Waterfall',
    columnLineComboTooltip: 'Column & Line',
    areaColumnComboTooltip: 'Area & Column',
    customComboTooltip: 'Custom Combination',
    innerRadius: 'Inner Radius',
    startAngle: 'Start Angle',
    endAngle: 'End Angle',
    reverseDirection: 'Reverse Direction',
    groupPadding: 'Group Padding',
    seriesPadding: 'Series Padding',
    group: 'Group',
    tile: 'Tile',
    whisker: 'Whisker',
    cap: 'Cap',
    capLengthRatio: 'Length Ratio',
    labelPlacement: 'Placement',
    inside: 'Inside',
    outside: 'Outside',
    noDataToChart: 'No data available to be charted.',
    pivotChartRequiresPivotMode: 'Pivot Chart requires Pivot Mode enabled.',
    chartSettingsToolbarTooltip: 'Menu',
    chartLinkToolbarTooltip: 'Linked to Grid',
    chartUnlinkToolbarTooltip: 'Unlinked from Grid',
    chartDownloadToolbarTooltip: 'Download Chart',
    histogramFrequency: "Frequency",
    seriesChartType: 'Series Chart Type',
    seriesType: 'Series Type',
    secondaryAxis: 'Secondary Axis',
};
ChartTranslationService = ChartTranslationService_1 = __decorate$S([
    Bean("chartTranslationService")
], ChartTranslationService);

var __decorate$T = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ChartCrossFilterService_1;
let ChartCrossFilterService = ChartCrossFilterService_1 = class ChartCrossFilterService extends BeanStub {
    filter(event, reset = false) {
        const filterModel = this.gridApi.getFilterModel();
        // filters should be reset when user clicks on canvas background
        if (reset) {
            this.resetFilters(filterModel);
            return;
        }
        let colId = ChartCrossFilterService_1.extractFilterColId(event);
        if (this.isValidColumnFilter(colId)) {
            // update filters based on current chart selections
            this.updateFilters(filterModel, event, colId);
        }
        else {
            console.warn("AG Grid: cross filtering requires a 'agSetColumnFilter' or 'agMultiColumnFilter' " +
                "to be defined on the column with id: '" + colId + "'");
        }
    }
    resetFilters(filterModel) {
        const filtersExist = Object.keys(filterModel).length > 0;
        if (filtersExist) {
            // only reset filters / charts when necessary to prevent undesirable flickering effect
            this.gridApi.setFilterModel(null);
            this.gridApi.onFilterChanged();
        }
    }
    updateFilters(filterModel, event, colId) {
        let dataKey = ChartCrossFilterService_1.extractFilterColId(event);
        let rawValue = event.datum[dataKey];
        if (rawValue === undefined) {
            return;
        }
        let selectedValue = rawValue.toString();
        if (event.event.metaKey || event.event.ctrlKey) {
            const existingGridValues = this.getCurrentGridValuesForCategory(colId);
            const valueAlreadyExists = _.includes(existingGridValues, selectedValue);
            let updatedValues;
            if (valueAlreadyExists) {
                updatedValues = existingGridValues.filter((v) => v !== selectedValue);
            }
            else {
                updatedValues = existingGridValues;
                updatedValues.push(selectedValue);
            }
            filterModel[colId] = this.getUpdatedFilterModel(colId, updatedValues);
        }
        else {
            const updatedValues = [selectedValue];
            filterModel = { [colId]: this.getUpdatedFilterModel(colId, updatedValues) };
        }
        this.gridApi.setFilterModel(filterModel);
    }
    getUpdatedFilterModel(colId, updatedValues) {
        let columnFilterType = this.getColumnFilterType(colId);
        if (columnFilterType === 'agMultiColumnFilter') {
            return { filterType: 'multi', filterModels: [null, { filterType: 'set', values: updatedValues }] };
        }
        return { filterType: 'set', values: updatedValues };
    }
    getCurrentGridValuesForCategory(colId) {
        let filteredValues = [];
        const column = this.getColumnById(colId);
        this.gridApi.forEachNodeAfterFilter((rowNode) => {
            if (column && !rowNode.group) {
                const value = this.valueService.getValue(column, rowNode) + '';
                if (!filteredValues.includes(value)) {
                    filteredValues.push(value);
                }
            }
        });
        return filteredValues;
    }
    static extractFilterColId(event) {
        return event.xKey || event.calloutLabelKey;
    }
    isValidColumnFilter(colId) {
        if (colId.indexOf('-filtered-out')) {
            colId = colId.replace('-filtered-out', '');
        }
        let filterType = this.getColumnFilterType(colId);
        if (typeof filterType === 'boolean') {
            return filterType;
        }
        return _.includes(['agSetColumnFilter', 'agMultiColumnFilter'], filterType);
    }
    getColumnFilterType(colId) {
        let gridColumn = this.getColumnById(colId);
        if (gridColumn) {
            const colDef = gridColumn.getColDef();
            return colDef.filter;
        }
    }
    getColumnById(colId) {
        return this.columnModel.getGridColumn(colId);
    }
};
__decorate$T([
    Autowired('gridApi')
], ChartCrossFilterService.prototype, "gridApi", void 0);
__decorate$T([
    Autowired('columnModel')
], ChartCrossFilterService.prototype, "columnModel", void 0);
__decorate$T([
    Autowired('valueService')
], ChartCrossFilterService.prototype, "valueService", void 0);
ChartCrossFilterService = ChartCrossFilterService_1 = __decorate$T([
    Bean("chartCrossFilterService")
], ChartCrossFilterService);

var __decorate$U = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RangeService = class RangeService extends BeanStub {
    constructor() {
        super(...arguments);
        this.cellRanges = [];
        this.bodyScrollListener = this.onBodyScroll.bind(this);
        this.dragging = false;
        this.intersectionRange = false; // When dragging ends, the current range will be used to intersect all other ranges
    }
    init() {
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.onColumnsChanged());
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, this.onColumnsChanged.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onColumnsChanged.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => this.removeAllCellRanges());
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.removeAllCellRanges());
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, () => this.removeAllCellRanges());
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_GROUP_OPENED, this.refreshLastRangeStart.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, this.refreshLastRangeStart.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, this.refreshLastRangeStart.bind(this));
        this.ctrlsService.whenReady(() => {
            const gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();
            this.autoScrollService = new AutoScrollService({
                scrollContainer: gridBodyCtrl.getBodyViewportElement(),
                scrollAxis: 'xy',
                getVerticalPosition: () => gridBodyCtrl.getScrollFeature().getVScrollPosition().top,
                setVerticalPosition: (position) => gridBodyCtrl.getScrollFeature().setVerticalScrollPosition(position),
                getHorizontalPosition: () => gridBodyCtrl.getScrollFeature().getHScrollPosition().left,
                setHorizontalPosition: (position) => gridBodyCtrl.getScrollFeature().setHorizontalScrollPosition(position),
                shouldSkipVerticalScroll: () => !this.gridOptionsService.isDomLayout('normal'),
                shouldSkipHorizontalScroll: () => !gridBodyCtrl.getScrollFeature().isHorizontalScrollShowing()
            });
        });
    }
    // Called for both columns loaded & column visibility events
    onColumnsChanged() {
        // first move start column in last cell range (i.e. series chart range)
        this.refreshLastRangeStart();
        const allColumns = this.columnModel.getAllDisplayedColumns();
        // check that the columns in each range still exist and are visible
        this.cellRanges.forEach(cellRange => {
            const beforeCols = cellRange.columns;
            // remove hidden or removed cols from cell range
            cellRange.columns = cellRange.columns.filter(col => col.isVisible() && allColumns.indexOf(col) !== -1);
            const colsInRangeChanged = !_.areEqual(beforeCols, cellRange.columns);
            if (colsInRangeChanged) {
                // notify users and other parts of grid (i.e. status panel) that range has changed
                this.dispatchChangedEvent(false, true, cellRange.id);
            }
        });
        // Remove empty cell ranges
        const countBefore = this.cellRanges.length;
        this.cellRanges = this.cellRanges.filter((range) => range.columns.length > 0);
        if (countBefore > this.cellRanges.length) {
            this.dispatchChangedEvent(false, true);
        }
    }
    refreshLastRangeStart() {
        const lastRange = _.last(this.cellRanges);
        if (!lastRange) {
            return;
        }
        this.refreshRangeStart(lastRange);
    }
    isContiguousRange(cellRange) {
        const rangeColumns = cellRange.columns;
        if (!rangeColumns.length) {
            return false;
        }
        const allColumns = this.columnModel.getAllDisplayedColumns();
        const allPositions = rangeColumns.map(c => allColumns.indexOf(c)).sort((a, b) => a - b);
        return _.last(allPositions) - allPositions[0] + 1 === rangeColumns.length;
    }
    getRangeStartRow(cellRange) {
        if (cellRange.startRow && cellRange.endRow) {
            return this.rowPositionUtils.before(cellRange.startRow, cellRange.endRow) ?
                cellRange.startRow : cellRange.endRow;
        }
        const rowPinned = this.pinnedRowModel.getPinnedTopRowCount() > 0 ? 'top' : null;
        return { rowIndex: 0, rowPinned };
    }
    getRangeEndRow(cellRange) {
        if (cellRange.startRow && cellRange.endRow) {
            return this.rowPositionUtils.before(cellRange.startRow, cellRange.endRow) ?
                cellRange.endRow : cellRange.startRow;
        }
        const pinnedBottomRowCount = this.pinnedRowModel.getPinnedBottomRowCount();
        const pinnedBottom = pinnedBottomRowCount > 0;
        if (pinnedBottom) {
            return {
                rowIndex: pinnedBottomRowCount - 1,
                rowPinned: 'bottom'
            };
        }
        return {
            rowIndex: this.rowModel.getRowCount() - 1,
            rowPinned: null
        };
    }
    setRangeToCell(cell, appendRange = false) {
        if (!this.gridOptionsService.get('enableRangeSelection')) {
            return;
        }
        const columns = this.calculateColumnsBetween(cell.column, cell.column);
        if (!columns) {
            return;
        }
        const suppressMultiRangeSelections = this.gridOptionsService.get('suppressMultiRangeSelection');
        // if not appending, then clear previous range selections
        if (suppressMultiRangeSelections || !appendRange || _.missing(this.cellRanges)) {
            this.removeAllCellRanges(true);
        }
        const rowForCell = {
            rowIndex: cell.rowIndex,
            rowPinned: cell.rowPinned
        };
        const cellRange = {
            startRow: rowForCell,
            endRow: rowForCell,
            columns,
            startColumn: cell.column
        };
        this.cellRanges.push(cellRange);
        this.setNewestRangeStartCell(cell);
        this.onDragStop();
        this.dispatchChangedEvent(true, true);
    }
    extendLatestRangeToCell(cellPosition) {
        if (this.isEmpty() || !this.newestRangeStartCell) {
            return;
        }
        const cellRange = _.last(this.cellRanges);
        this.updateRangeEnd(cellRange, cellPosition);
    }
    updateRangeEnd(cellRange, cellPosition, silent = false) {
        const endColumn = cellPosition.column;
        const colsToAdd = this.calculateColumnsBetween(cellRange.startColumn, endColumn);
        if (!colsToAdd || this.isLastCellOfRange(cellRange, cellPosition)) {
            return;
        }
        cellRange.columns = colsToAdd;
        cellRange.endRow = { rowIndex: cellPosition.rowIndex, rowPinned: cellPosition.rowPinned };
        if (!silent) {
            this.dispatchChangedEvent(true, true, cellRange.id);
        }
    }
    refreshRangeStart(cellRange) {
        const { startColumn, columns } = cellRange;
        const moveColInCellRange = (colToMove, moveToFront) => {
            const otherCols = cellRange.columns.filter(col => col !== colToMove);
            if (colToMove) {
                cellRange.startColumn = colToMove;
                cellRange.columns = moveToFront ? [colToMove, ...otherCols] : [...otherCols, colToMove];
            }
            else {
                cellRange.columns = otherCols;
            }
        };
        const { left, right } = this.getRangeEdgeColumns(cellRange);
        const shouldMoveLeftCol = startColumn === columns[0] && startColumn !== left;
        if (shouldMoveLeftCol) {
            moveColInCellRange(left, true);
            return;
        }
        const shouldMoveRightCol = startColumn === _.last(columns) && startColumn === right;
        if (shouldMoveRightCol) {
            moveColInCellRange(right, false);
            return;
        }
    }
    getRangeEdgeColumns(cellRange) {
        const allColumns = this.columnModel.getAllDisplayedColumns();
        const allIndices = cellRange.columns
            .map(c => allColumns.indexOf(c))
            .filter(i => i > -1)
            .sort((a, b) => a - b);
        return {
            left: allColumns[allIndices[0]],
            right: allColumns[_.last(allIndices)]
        };
    }
    // returns true if successful, false if not successful
    extendLatestRangeInDirection(event) {
        if (this.isEmpty() || !this.newestRangeStartCell) {
            return;
        }
        const key = event.key;
        const ctrlKey = event.ctrlKey || event.metaKey;
        const lastRange = _.last(this.cellRanges);
        const startCell = this.newestRangeStartCell;
        const firstCol = lastRange.columns[0];
        const lastCol = _.last(lastRange.columns);
        // find the cell that is at the furthest away corner from the starting cell
        const endCellIndex = lastRange.endRow.rowIndex;
        const endCellFloating = lastRange.endRow.rowPinned;
        const endCellColumn = startCell.column === firstCol ? lastCol : firstCol;
        const endCell = { column: endCellColumn, rowIndex: endCellIndex, rowPinned: endCellFloating };
        const newEndCell = this.cellNavigationService.getNextCellToFocus(key, endCell, ctrlKey);
        // if user is at end of grid, so no cell to extend to, we return false
        if (!newEndCell) {
            return;
        }
        this.setCellRange({
            rowStartIndex: startCell.rowIndex,
            rowStartPinned: startCell.rowPinned,
            rowEndIndex: newEndCell.rowIndex,
            rowEndPinned: newEndCell.rowPinned,
            columnStart: startCell.column,
            columnEnd: newEndCell.column
        });
        return newEndCell;
    }
    setCellRange(params) {
        if (!this.gridOptionsService.get('enableRangeSelection')) {
            return;
        }
        this.removeAllCellRanges(true);
        this.addCellRange(params);
    }
    setCellRanges(cellRanges) {
        if (_.shallowCompare(this.cellRanges, cellRanges)) {
            return;
        }
        this.removeAllCellRanges(true);
        cellRanges.forEach(newRange => {
            if (newRange.columns && newRange.startRow) {
                this.setNewestRangeStartCell({
                    rowIndex: newRange.startRow.rowIndex,
                    rowPinned: newRange.startRow.rowPinned,
                    column: newRange.columns[0]
                });
            }
            this.cellRanges.push(newRange);
        });
        this.dispatchChangedEvent(false, true);
    }
    setNewestRangeStartCell(position) {
        this.newestRangeStartCell = position;
    }
    clearCellRangeCellValues(params) {
        let { cellRanges } = params;
        const { cellEventSource = 'rangeService', dispatchWrapperEvents, wrapperEventSource = 'deleteKey' } = params;
        if (dispatchWrapperEvents) {
            const startEvent = {
                type: Events.EVENT_RANGE_DELETE_START,
                source: wrapperEventSource
            };
            this.eventService.dispatchEvent(startEvent);
        }
        if (!cellRanges) {
            cellRanges = this.cellRanges;
        }
        cellRanges.forEach(cellRange => {
            this.forEachRowInRange(cellRange, rowPosition => {
                const rowNode = this.rowPositionUtils.getRowNode(rowPosition);
                if (!rowNode) {
                    return;
                }
                for (let i = 0; i < cellRange.columns.length; i++) {
                    const column = this.columnModel.getGridColumn(cellRange.columns[i]);
                    if (!column || !column.isCellEditable(rowNode)) {
                        continue;
                    }
                    rowNode.setDataValue(column, null, cellEventSource);
                }
            });
        });
        if (dispatchWrapperEvents) {
            const endEvent = {
                type: Events.EVENT_RANGE_DELETE_END,
                source: wrapperEventSource
            };
            this.eventService.dispatchEvent(endEvent);
        }
    }
    createCellRangeFromCellRangeParams(params) {
        let columns;
        let startsOnTheRight = false;
        if (params.columns) {
            columns = params.columns.map(c => this.columnModel.getColumnWithValidation(c)).filter(c => c);
        }
        else {
            const columnStart = this.columnModel.getColumnWithValidation(params.columnStart);
            const columnEnd = this.columnModel.getColumnWithValidation(params.columnEnd);
            if (!columnStart || !columnEnd) {
                return;
            }
            columns = this.calculateColumnsBetween(columnStart, columnEnd);
            if (columns && columns.length) {
                startsOnTheRight = columns[0] !== columnStart;
            }
        }
        if (!columns) {
            return;
        }
        const startRow = params.rowStartIndex != null ? {
            rowIndex: params.rowStartIndex,
            rowPinned: params.rowStartPinned || null
        } : undefined;
        const endRow = params.rowEndIndex != null ? {
            rowIndex: params.rowEndIndex,
            rowPinned: params.rowEndPinned || null
        } : undefined;
        return {
            startRow,
            endRow,
            columns,
            startColumn: startsOnTheRight ? _.last(columns) : columns[0]
        };
    }
    addCellRange(params) {
        if (!this.gridOptionsService.get('enableRangeSelection')) {
            return;
        }
        const newRange = this.createCellRangeFromCellRangeParams(params);
        if (newRange) {
            if (newRange.startRow) {
                this.setNewestRangeStartCell({
                    rowIndex: newRange.startRow.rowIndex,
                    rowPinned: newRange.startRow.rowPinned,
                    column: newRange.startColumn
                });
            }
            this.cellRanges.push(newRange);
            this.dispatchChangedEvent(false, true, newRange.id);
        }
    }
    getCellRanges() {
        return this.cellRanges;
    }
    isEmpty() {
        return this.cellRanges.length === 0;
    }
    isMoreThanOneCell() {
        const len = this.cellRanges.length;
        if (len === 0) {
            return false;
        }
        if (len > 1) {
            return true; // Assumes a cell range must contain at least one cell
        }
        // only one range, return true if range has more than one
        const range = this.cellRanges[0];
        const startRow = this.getRangeStartRow(range);
        const endRow = this.getRangeEndRow(range);
        return startRow.rowPinned !== endRow.rowPinned ||
            startRow.rowIndex !== endRow.rowIndex ||
            range.columns.length !== 1;
    }
    areAllRangesAbleToMerge() {
        const rowToColumnMap = new Map();
        const len = this.cellRanges.length;
        if (len <= 1)
            return true;
        this.cellRanges.forEach(range => {
            this.forEachRowInRange(range, row => {
                const rowName = `${row.rowPinned || 'normal'}_${row.rowIndex}`;
                const columns = rowToColumnMap.get(rowName);
                const currentRangeColIds = range.columns.map(col => col.getId());
                if (columns) {
                    const filteredColumns = currentRangeColIds.filter(col => columns.indexOf(col) === -1);
                    columns.push(...filteredColumns);
                }
                else {
                    rowToColumnMap.set(rowName, currentRangeColIds);
                }
            });
        });
        let columnsString;
        for (const val of rowToColumnMap.values()) {
            const currentValString = val.sort().join();
            if (columnsString === undefined) {
                columnsString = currentValString;
                continue;
            }
            if (columnsString !== currentValString) {
                return false;
            }
        }
        return true;
    }
    forEachRowInRange(cellRange, callback) {
        const topRow = this.getRangeStartRow(cellRange);
        const bottomRow = this.getRangeEndRow(cellRange);
        let currentRow = topRow;
        while (currentRow) {
            callback(currentRow);
            if (this.rowPositionUtils.sameRow(currentRow, bottomRow)) {
                break;
            }
            currentRow = this.cellNavigationService.getRowBelow(currentRow);
        }
    }
    removeAllCellRanges(silent) {
        if (this.isEmpty()) {
            return;
        }
        this.onDragStop();
        this.cellRanges.length = 0;
        if (!silent) {
            this.dispatchChangedEvent(false, true);
        }
    }
    // as the user is dragging outside of the panel, the div starts to scroll, which in turn
    // means we are selection more (or less) cells, but the mouse isn't moving, so we recalculate
    // the selection my mimicking a new mouse event
    onBodyScroll() {
        if (this.dragging && this.lastMouseEvent) {
            this.onDragging(this.lastMouseEvent);
        }
    }
    isCellInAnyRange(cell) {
        return this.getCellRangeCount(cell) > 0;
    }
    isCellInSpecificRange(cell, range) {
        const columnInRange = range.columns !== null && _.includes(range.columns, cell.column);
        const rowInRange = this.isRowInRange(cell.rowIndex, cell.rowPinned, range);
        return columnInRange && rowInRange;
    }
    isLastCellOfRange(cellRange, cell) {
        const { startRow, endRow } = cellRange;
        const lastRow = this.rowPositionUtils.before(startRow, endRow) ? endRow : startRow;
        const isLastRow = cell.rowIndex === lastRow.rowIndex && cell.rowPinned === lastRow.rowPinned;
        const rangeFirstIndexColumn = cellRange.columns[0];
        const rangeLastIndexColumn = _.last(cellRange.columns);
        const lastRangeColumn = cellRange.startColumn === rangeFirstIndexColumn ? rangeLastIndexColumn : rangeFirstIndexColumn;
        const isLastColumn = cell.column === lastRangeColumn;
        return isLastColumn && isLastRow;
    }
    isBottomRightCell(cellRange, cell) {
        const allColumns = this.columnModel.getAllDisplayedColumns();
        const allPositions = cellRange.columns.map(c => allColumns.indexOf(c)).sort((a, b) => a - b);
        const { startRow, endRow } = cellRange;
        const lastRow = this.rowPositionUtils.before(startRow, endRow) ? endRow : startRow;
        const isRightColumn = allColumns.indexOf(cell.column) === _.last(allPositions);
        const isLastRow = cell.rowIndex === lastRow.rowIndex && _.makeNull(cell.rowPinned) === _.makeNull(lastRow.rowPinned);
        return isRightColumn && isLastRow;
    }
    // returns the number of ranges this cell is in
    getCellRangeCount(cell) {
        if (this.isEmpty()) {
            return 0;
        }
        return this.cellRanges.filter(cellRange => this.isCellInSpecificRange(cell, cellRange)).length;
    }
    isRowInRange(rowIndex, floating, cellRange) {
        const firstRow = this.getRangeStartRow(cellRange);
        const lastRow = this.getRangeEndRow(cellRange);
        const thisRow = { rowIndex, rowPinned: floating || null };
        // compare rowPinned with == instead of === because it can be `null` or `undefined`
        const equalsFirstRow = thisRow.rowIndex === firstRow.rowIndex && thisRow.rowPinned == firstRow.rowPinned;
        const equalsLastRow = thisRow.rowIndex === lastRow.rowIndex && thisRow.rowPinned == lastRow.rowPinned;
        if (equalsFirstRow || equalsLastRow) {
            return true;
        }
        const afterFirstRow = !this.rowPositionUtils.before(thisRow, firstRow);
        const beforeLastRow = this.rowPositionUtils.before(thisRow, lastRow);
        return afterFirstRow && beforeLastRow;
    }
    getDraggingRange() {
        return this.draggingRange;
    }
    onDragStart(mouseEvent) {
        if (!this.gridOptionsService.get('enableRangeSelection')) {
            return;
        }
        const { ctrlKey, metaKey, shiftKey } = mouseEvent;
        // ctrlKey for windows, metaKey for Apple
        const isMultiKey = ctrlKey || metaKey;
        const allowMulti = !this.gridOptionsService.get('suppressMultiRangeSelection');
        const isMultiSelect = allowMulti ? isMultiKey : false;
        const extendRange = shiftKey && _.existsAndNotEmpty(this.cellRanges);
        if (!isMultiSelect && (!extendRange || _.exists(_.last(this.cellRanges).type))) {
            this.removeAllCellRanges(true);
        }
        // The browser changes the Event target of cached events when working with the ShadowDOM
        // so we need to retrieve the initial DragStartTarget.
        const startTarget = this.dragService.getStartTarget();
        if (startTarget) {
            this.updateValuesOnMove(startTarget);
        }
        if (!this.lastCellHovered) {
            return;
        }
        this.dragging = true;
        this.lastMouseEvent = mouseEvent;
        this.intersectionRange = isMultiSelect && this.getCellRangeCount(this.lastCellHovered) > 1;
        if (!extendRange) {
            this.setNewestRangeStartCell(this.lastCellHovered);
        }
        // if we didn't clear the ranges, then dragging means the user clicked, and when the
        // user clicks it means a range of one cell was created. we need to extend this range
        // rather than creating another range. otherwise we end up with two distinct ranges
        // from a drag operation (one from click, and one from drag).
        if (this.cellRanges.length > 0) {
            this.draggingRange = _.last(this.cellRanges);
        }
        else {
            const mouseRowPosition = {
                rowIndex: this.lastCellHovered.rowIndex,
                rowPinned: this.lastCellHovered.rowPinned
            };
            this.draggingRange = {
                startRow: mouseRowPosition,
                endRow: mouseRowPosition,
                columns: [this.lastCellHovered.column],
                startColumn: this.newestRangeStartCell.column
            };
            this.cellRanges.push(this.draggingRange);
        }
        this.ctrlsService.getGridBodyCtrl().addScrollEventListener(this.bodyScrollListener);
        this.dispatchChangedEvent(true, false, this.draggingRange.id);
    }
    intersectLastRange(fromMouseClick) {
        // when ranges are created due to a mouse click without drag (happens in cellMouseListener)
        // this method will be called with `fromMouseClick=true`.
        if (fromMouseClick && this.dragging) {
            return;
        }
        if (this.gridOptionsService.get('suppressMultiRangeSelection')) {
            return;
        }
        if (this.isEmpty()) {
            return;
        }
        const lastRange = _.last(this.cellRanges);
        const intersectionStartRow = this.getRangeStartRow(lastRange);
        const intersectionEndRow = this.getRangeEndRow(lastRange);
        const newRanges = [];
        this.cellRanges.slice(0, -1).forEach((range) => {
            const startRow = this.getRangeStartRow(range);
            const endRow = this.getRangeEndRow(range);
            const cols = range.columns;
            const intersectCols = cols.filter((col) => lastRange.columns.indexOf(col) === -1);
            if (intersectCols.length === cols.length) {
                // No overlapping columns, retain previous range
                newRanges.push(range);
                return;
            }
            if (this.rowPositionUtils.before(intersectionEndRow, startRow) || this.rowPositionUtils.before(endRow, intersectionStartRow)) {
                // No overlapping rows, retain previous range
                newRanges.push(range);
                return;
            }
            const rangeCountBefore = newRanges.length;
            // Top
            if (this.rowPositionUtils.before(startRow, intersectionStartRow)) {
                const top = {
                    columns: [...cols],
                    startColumn: lastRange.startColumn,
                    startRow: Object.assign({}, startRow),
                    endRow: this.cellNavigationService.getRowAbove(intersectionStartRow),
                };
                newRanges.push(top);
            }
            // Left & Right (not contiguous with columns)
            if (intersectCols.length > 0) {
                const middle = {
                    columns: intersectCols,
                    startColumn: _.includes(intersectCols, lastRange.startColumn) ? lastRange.startColumn : intersectCols[0],
                    startRow: this.rowPositionUtils.rowMax([Object.assign({}, intersectionStartRow), Object.assign({}, startRow)]),
                    endRow: this.rowPositionUtils.rowMin([Object.assign({}, intersectionEndRow), Object.assign({}, endRow)]),
                };
                newRanges.push(middle);
            }
            // Bottom
            if (this.rowPositionUtils.before(intersectionEndRow, endRow)) {
                newRanges.push({
                    columns: [...cols],
                    startColumn: lastRange.startColumn,
                    startRow: this.cellNavigationService.getRowBelow(intersectionEndRow),
                    endRow: Object.assign({}, endRow),
                });
            }
            if ((newRanges.length - rangeCountBefore) === 1) {
                // Only one range result from the intersection.
                // Copy the source range's id, since essentially we just reduced it's size
                newRanges[newRanges.length - 1].id = range.id;
            }
        });
        this.cellRanges = newRanges;
        // when this is called because of a clickEvent and the ranges were changed
        // we need to force a dragEnd event to update the UI.
        if (fromMouseClick) {
            this.dispatchChangedEvent(false, true);
        }
    }
    updateValuesOnMove(eventTarget) {
        const cellCtrl = _.getCtrlForEventTarget(this.gridOptionsService, eventTarget, CellCtrl.DOM_DATA_KEY_CELL_CTRL);
        const cell = cellCtrl === null || cellCtrl === void 0 ? void 0 : cellCtrl.getCellPosition();
        this.cellHasChanged = false;
        if (!cell || (this.lastCellHovered && this.cellPositionUtils.equals(cell, this.lastCellHovered))) {
            return;
        }
        if (this.lastCellHovered) {
            this.cellHasChanged = true;
        }
        this.lastCellHovered = cell;
    }
    onDragging(mouseEvent) {
        if (!this.dragging || !mouseEvent) {
            return;
        }
        this.updateValuesOnMove(mouseEvent.target);
        this.lastMouseEvent = mouseEvent;
        const cellPosition = this.lastCellHovered;
        const isMouseAndStartInPinned = (position) => cellPosition && cellPosition.rowPinned === position && this.newestRangeStartCell.rowPinned === position;
        const skipVerticalScroll = isMouseAndStartInPinned('top') || isMouseAndStartInPinned('bottom');
        this.autoScrollService.check(mouseEvent, skipVerticalScroll);
        if (!this.cellHasChanged) {
            return;
        }
        const columns = this.calculateColumnsBetween(this.newestRangeStartCell.column, cellPosition.column);
        if (!columns) {
            return;
        }
        this.draggingRange.endRow = {
            rowIndex: cellPosition.rowIndex,
            rowPinned: cellPosition.rowPinned
        };
        this.draggingRange.columns = columns;
        this.dispatchChangedEvent(false, false, this.draggingRange.id);
    }
    onDragStop() {
        if (!this.dragging) {
            return;
        }
        const { id } = this.draggingRange;
        this.autoScrollService.ensureCleared();
        this.ctrlsService.getGridBodyCtrl().removeScrollEventListener(this.bodyScrollListener);
        this.lastMouseEvent = null;
        this.dragging = false;
        this.draggingRange = undefined;
        this.lastCellHovered = undefined;
        if (this.intersectionRange) {
            this.intersectionRange = false;
            this.intersectLastRange();
        }
        this.dispatchChangedEvent(false, true, id);
    }
    dispatchChangedEvent(started, finished, id) {
        const event = {
            type: Events.EVENT_RANGE_SELECTION_CHANGED,
            started,
            finished,
            id,
        };
        this.eventService.dispatchEvent(event);
    }
    calculateColumnsBetween(columnFrom, columnTo) {
        const allColumns = this.columnModel.getAllDisplayedColumns();
        const isSameColumn = columnFrom === columnTo;
        const fromIndex = allColumns.indexOf(columnFrom);
        if (fromIndex < 0) {
            console.warn(`AG Grid: column ${columnFrom.getId()} is not visible`);
            return;
        }
        const toIndex = isSameColumn ? fromIndex : allColumns.indexOf(columnTo);
        if (toIndex < 0) {
            console.warn(`AG Grid: column ${columnTo.getId()} is not visible`);
            return;
        }
        if (isSameColumn) {
            return [columnFrom];
        }
        const firstIndex = Math.min(fromIndex, toIndex);
        const lastIndex = firstIndex === fromIndex ? toIndex : fromIndex;
        const columns = [];
        for (let i = firstIndex; i <= lastIndex; i++) {
            columns.push(allColumns[i]);
        }
        return columns;
    }
};
__decorate$U([
    Autowired('rowModel')
], RangeService.prototype, "rowModel", void 0);
__decorate$U([
    Autowired('dragService')
], RangeService.prototype, "dragService", void 0);
__decorate$U([
    Autowired('columnModel')
], RangeService.prototype, "columnModel", void 0);
__decorate$U([
    Autowired('cellNavigationService')
], RangeService.prototype, "cellNavigationService", void 0);
__decorate$U([
    Autowired("pinnedRowModel")
], RangeService.prototype, "pinnedRowModel", void 0);
__decorate$U([
    Autowired('rowPositionUtils')
], RangeService.prototype, "rowPositionUtils", void 0);
__decorate$U([
    Autowired('cellPositionUtils')
], RangeService.prototype, "cellPositionUtils", void 0);
__decorate$U([
    Autowired('ctrlsService')
], RangeService.prototype, "ctrlsService", void 0);
__decorate$U([
    PostConstruct
], RangeService.prototype, "init", null);
RangeService = __decorate$U([
    Bean('rangeService')
], RangeService);

var __decorate$V = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AbstractSelectionHandle extends Component {
    constructor() {
        super(...arguments);
        this.changedCalculatedValues = false;
        this.dragging = false;
        this.shouldDestroyOnEndDragging = false;
    }
    init() {
        this.dragService.addDragSource({
            dragStartPixels: 0,
            eElement: this.getGui(),
            onDragStart: this.onDragStart.bind(this),
            onDragging: (e) => {
                this.dragging = true;
                this.rangeService.autoScrollService.check(e);
                if (this.changedCalculatedValues) {
                    this.onDrag(e);
                    this.changedCalculatedValues = false;
                }
            },
            onDragStop: (e) => {
                this.dragging = false;
                this.onDragEnd(e);
                this.clearValues();
                this.rangeService.autoScrollService.ensureCleared();
                // TODO: this causes a bug where if there are multiple grids in the same page, all of them will
                // be affected by a drag on any. Move it to the root element.
                document.body.classList.remove(this.getDraggingCssClass());
                if (this.shouldDestroyOnEndDragging) {
                    this.destroy();
                }
            }
        });
        this.addManagedListener(this.getGui(), 'mousedown', this.preventRangeExtension.bind(this));
    }
    isDragging() {
        return this.dragging;
    }
    getCellCtrl() {
        return this.cellCtrl;
    }
    setCellCtrl(cellComp) {
        this.cellCtrl = cellComp;
    }
    getCellRange() {
        return this.cellRange;
    }
    setCellRange(range) {
        this.cellRange = range;
    }
    getRangeStartRow() {
        return this.rangeStartRow;
    }
    setRangeStartRow(row) {
        this.rangeStartRow = row;
    }
    getRangeEndRow() {
        return this.rangeEndRow;
    }
    setRangeEndRow(row) {
        this.rangeEndRow = row;
    }
    getLastCellHovered() {
        return this.lastCellHovered;
    }
    preventRangeExtension(e) {
        e.stopPropagation();
    }
    onDragStart(e) {
        this.cellHoverListener = this.addManagedListener(this.ctrlsService.getGridCtrl().getGui(), 'mousemove', this.updateValuesOnMove.bind(this));
        document.body.classList.add(this.getDraggingCssClass());
    }
    getDraggingCssClass() {
        return `ag-dragging-${this.type === SelectionHandleType.FILL ? 'fill' : 'range'}-handle`;
    }
    updateValuesOnMove(e) {
        const cell = this.mouseEventService.getCellPositionForEvent(e);
        if (!cell || (this.lastCellHovered && this.cellPositionUtils.equals(cell, this.lastCellHovered))) {
            return;
        }
        this.lastCellHovered = cell;
        this.changedCalculatedValues = true;
    }
    getType() {
        return this.type;
    }
    refresh(cellCtrl) {
        const oldCellComp = this.getCellCtrl();
        const eGui = this.getGui();
        const cellRange = _.last(this.rangeService.getCellRanges());
        const start = cellRange.startRow;
        const end = cellRange.endRow;
        if (start && end) {
            const isBefore = this.rowPositionUtils.before(end, start);
            if (isBefore) {
                this.setRangeStartRow(end);
                this.setRangeEndRow(start);
            }
            else {
                this.setRangeStartRow(start);
                this.setRangeEndRow(end);
            }
        }
        if (oldCellComp !== cellCtrl || !_.isVisible(eGui)) {
            this.setCellCtrl(cellCtrl);
            const eParentOfValue = cellCtrl.getComp().getParentOfValue();
            if (eParentOfValue) {
                eParentOfValue.appendChild(eGui);
            }
        }
        this.setCellRange(cellRange);
    }
    clearValues() {
        this.lastCellHovered = undefined;
        this.removeListeners();
    }
    removeListeners() {
        if (this.cellHoverListener) {
            this.cellHoverListener();
            this.cellHoverListener = undefined;
        }
    }
    destroy() {
        if (!this.shouldDestroyOnEndDragging && this.isDragging()) {
            _.setDisplayed(this.getGui(), false);
            this.shouldDestroyOnEndDragging = true;
            return;
        }
        this.shouldDestroyOnEndDragging = false;
        super.destroy();
        this.removeListeners();
        const eGui = this.getGui();
        if (eGui.parentElement) {
            eGui.parentElement.removeChild(eGui);
        }
    }
}
__decorate$V([
    Autowired("rowRenderer")
], AbstractSelectionHandle.prototype, "rowRenderer", void 0);
__decorate$V([
    Autowired("dragService")
], AbstractSelectionHandle.prototype, "dragService", void 0);
__decorate$V([
    Autowired("rangeService")
], AbstractSelectionHandle.prototype, "rangeService", void 0);
__decorate$V([
    Autowired("mouseEventService")
], AbstractSelectionHandle.prototype, "mouseEventService", void 0);
__decorate$V([
    Autowired("columnModel")
], AbstractSelectionHandle.prototype, "columnModel", void 0);
__decorate$V([
    Autowired("cellNavigationService")
], AbstractSelectionHandle.prototype, "cellNavigationService", void 0);
__decorate$V([
    Autowired("navigationService")
], AbstractSelectionHandle.prototype, "navigationService", void 0);
__decorate$V([
    Autowired('rowPositionUtils')
], AbstractSelectionHandle.prototype, "rowPositionUtils", void 0);
__decorate$V([
    Autowired('cellPositionUtils')
], AbstractSelectionHandle.prototype, "cellPositionUtils", void 0);
__decorate$V([
    Autowired('ctrlsService')
], AbstractSelectionHandle.prototype, "ctrlsService", void 0);
__decorate$V([
    PostConstruct
], AbstractSelectionHandle.prototype, "init", null);

function findLineByLeastSquares(values) {
    const len = values.length;
    let maxDecimals = 0;
    if (len <= 1) {
        return values;
    }
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        const splitExponent = value.toString().split('e-');
        if (splitExponent.length > 1) {
            maxDecimals = Math.max(maxDecimals, parseInt(splitExponent[1], 10));
            continue;
        }
        if (Math.floor(value) === value) {
            continue;
        }
        maxDecimals = Math.max(maxDecimals, value.toString().split('.')[1].length);
    }
    let sum_x = 0;
    let sum_y = 0;
    let sum_xy = 0;
    let sum_xx = 0;
    let y = 0;
    for (let x = 0; x < len; x++) {
        y = values[x];
        sum_x += x;
        sum_y += y;
        sum_xx += x * x;
        sum_xy += x * y;
    }
    const m = (len * sum_xy - sum_x * sum_y) / (len * sum_xx - sum_x * sum_x);
    const b = (sum_y / len) - (m * sum_x) / len;
    const result = [];
    for (let x = 0; x <= len; x++) {
        result.push(parseFloat((x * m + b).toFixed(maxDecimals)));
    }
    return result;
}

var __decorate$W = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class FillHandle extends AbstractSelectionHandle {
    constructor() {
        super(FillHandle.TEMPLATE);
        this.markedCells = [];
        this.cellValues = [];
        this.isUp = false;
        this.isLeft = false;
        this.isReduce = false;
        this.type = SelectionHandleType.FILL;
    }
    updateValuesOnMove(e) {
        super.updateValuesOnMove(e);
        if (!this.initialXY) {
            this.initialXY = this.mouseEventService.getNormalisedPosition(e);
        }
        const { x, y } = this.initialXY;
        const { x: newX, y: newY } = this.mouseEventService.getNormalisedPosition(e);
        const diffX = Math.abs(x - newX);
        const diffY = Math.abs(y - newY);
        const allowedDirection = this.getFillHandleDirection();
        let direction;
        if (allowedDirection === 'xy') {
            direction = diffX > diffY ? 'x' : 'y';
        }
        else {
            direction = allowedDirection;
        }
        if (direction !== this.dragAxis) {
            this.dragAxis = direction;
            this.changedCalculatedValues = true;
        }
    }
    onDrag(e) {
        if (!this.initialPosition) {
            const cellCtrl = this.getCellCtrl();
            if (!cellCtrl) {
                return;
            }
            this.initialPosition = cellCtrl.getCellPosition();
        }
        const lastCellHovered = this.getLastCellHovered();
        if (lastCellHovered) {
            this.markPathFrom(this.initialPosition, lastCellHovered);
        }
    }
    onDragEnd(e) {
        this.initialXY = null;
        if (!this.markedCells.length) {
            return;
        }
        const isX = this.dragAxis === 'x';
        const initialRange = this.getCellRange();
        const colLen = initialRange.columns.length;
        const rangeStartRow = this.getRangeStartRow();
        const rangeEndRow = this.getRangeEndRow();
        let finalRange;
        if (!this.isUp && !this.isLeft) {
            finalRange = this.rangeService.createCellRangeFromCellRangeParams({
                rowStartIndex: rangeStartRow.rowIndex,
                rowStartPinned: rangeStartRow.rowPinned,
                columnStart: initialRange.columns[0],
                rowEndIndex: isX ? rangeEndRow.rowIndex : this.lastCellMarked.rowIndex,
                rowEndPinned: isX ? rangeEndRow.rowPinned : this.lastCellMarked.rowPinned,
                columnEnd: isX ? this.lastCellMarked.column : initialRange.columns[colLen - 1]
            });
        }
        else {
            const startRow = isX ? rangeStartRow : this.lastCellMarked;
            finalRange = this.rangeService.createCellRangeFromCellRangeParams({
                rowStartIndex: startRow.rowIndex,
                rowStartPinned: startRow.rowPinned,
                columnStart: isX ? this.lastCellMarked.column : initialRange.columns[0],
                rowEndIndex: rangeEndRow.rowIndex,
                rowEndPinned: rangeEndRow.rowPinned,
                columnEnd: initialRange.columns[colLen - 1]
            });
        }
        if (finalRange) {
            // raising fill events for undo / redo
            this.raiseFillStartEvent();
            this.handleValueChanged(initialRange, finalRange, e);
            this.rangeService.setCellRanges([finalRange]);
            this.raiseFillEndEvent(initialRange, finalRange);
        }
    }
    getFillHandleDirection() {
        const direction = this.gridOptionsService.get('fillHandleDirection');
        if (!direction) {
            return 'xy';
        }
        if (direction !== 'x' && direction !== 'y' && direction !== 'xy') {
            _.warnOnce(`valid values for fillHandleDirection are 'x', 'y' and 'xy'. Default to 'xy'.`);
            return 'xy';
        }
        return direction;
    }
    raiseFillStartEvent() {
        const fillStartEvent = {
            type: Events.EVENT_FILL_START
        };
        this.eventService.dispatchEvent(fillStartEvent);
    }
    raiseFillEndEvent(initialRange, finalRange) {
        const fillEndEvent = {
            type: Events.EVENT_FILL_END,
            initialRange: initialRange,
            finalRange: finalRange
        };
        this.eventService.dispatchEvent(fillEndEvent);
    }
    handleValueChanged(initialRange, finalRange, e) {
        const initialRangeEndRow = this.rangeService.getRangeEndRow(initialRange);
        const initialRangeStartRow = this.rangeService.getRangeStartRow(initialRange);
        const finalRangeEndRow = this.rangeService.getRangeEndRow(finalRange);
        const finalRangeStartRow = this.rangeService.getRangeStartRow(finalRange);
        const isVertical = this.dragAxis === 'y';
        // if the range is being reduced in size, all we need to do is
        // clear the cells that are no longer part of the range
        if (this.isReduce && !this.gridOptionsService.get('suppressClearOnFillReduction')) {
            const columns = isVertical
                ? initialRange.columns
                : initialRange.columns.filter(col => finalRange.columns.indexOf(col) < 0);
            const startRow = isVertical ? this.cellNavigationService.getRowBelow(finalRangeEndRow) : finalRangeStartRow;
            if (startRow) {
                this.clearCellsInRange(startRow, initialRangeEndRow, columns);
            }
            return;
        }
        const values = [];
        const initialValues = [];
        const initialNonAggregatedValues = [];
        const initialFormattedValues = [];
        let withinInitialRange = true;
        let idx = 0;
        const resetValues = () => {
            values.length = 0;
            initialValues.length = 0;
            initialNonAggregatedValues.length = 0;
            initialFormattedValues.length = 0;
            idx = 0;
        };
        const iterateAcrossCells = (column, columns) => {
            let currentRow = this.isUp ? initialRangeEndRow : initialRangeStartRow;
            let finished = false;
            if (isVertical) {
                withinInitialRange = true;
                resetValues();
            }
            while (!finished && currentRow) {
                const rowNode = this.rowPositionUtils.getRowNode(currentRow);
                if (!rowNode) {
                    break;
                }
                if (isVertical && column) {
                    fillValues(values, column, rowNode, () => {
                        return !this.rowPositionUtils.sameRow(currentRow, this.isUp ? initialRangeStartRow : initialRangeEndRow);
                    });
                }
                else if (columns) {
                    withinInitialRange = true;
                    resetValues();
                    columns.forEach(col => fillValues(values, col, rowNode, () => col !== (this.isLeft ? initialRange.columns[0] : _.last(initialRange.columns))));
                }
                finished = this.rowPositionUtils.sameRow(currentRow, this.isUp ? finalRangeStartRow : finalRangeEndRow);
                currentRow = this.isUp
                    ? this.cellNavigationService.getRowAbove(currentRow)
                    : this.cellNavigationService.getRowBelow(currentRow);
            }
        };
        const fillValues = (currentValues, col, rowNode, updateInitialSet) => {
            var _a, _b;
            let currentValue;
            let skipValue = false;
            if (withinInitialRange) {
                currentValue = this.valueService.getValue(col, rowNode);
                initialValues.push(currentValue);
                initialNonAggregatedValues.push(this.valueService.getValue(col, rowNode, undefined, true));
                initialFormattedValues.push(this.valueFormatterService.formatValue(col, rowNode, currentValue));
                withinInitialRange = updateInitialSet();
            }
            else {
                const { value, fromUserFunction, sourceCol, sourceRowNode } = this.processValues({
                    event: e,
                    values: currentValues,
                    initialValues,
                    initialNonAggregatedValues,
                    initialFormattedValues,
                    col,
                    rowNode,
                    idx: idx++
                });
                currentValue = value;
                if (col.isCellEditable(rowNode)) {
                    const cellValue = this.valueService.getValue(col, rowNode);
                    if (!fromUserFunction) {
                        if (sourceCol && ((_a = sourceCol.getColDef()) === null || _a === void 0 ? void 0 : _a.useValueFormatterForExport) !== false) {
                            currentValue = (_b = this.valueFormatterService.formatValue(sourceCol, sourceRowNode, currentValue)) !== null && _b !== void 0 ? _b : currentValue;
                        }
                        if (col.getColDef().useValueParserForImport !== false) {
                            currentValue = this.valueParserService.parseValue(col, rowNode, 
                            // if no sourceCol, then currentValue is a number
                            sourceCol ? currentValue : _.toStringOrNull(currentValue), cellValue);
                        }
                    }
                    if (!fromUserFunction || cellValue !== currentValue) {
                        rowNode.setDataValue(col, currentValue, 'rangeService');
                    }
                    else {
                        skipValue = true;
                    }
                }
            }
            if (!skipValue) {
                currentValues.push({
                    value: currentValue,
                    column: col,
                    rowNode
                });
            }
        };
        if (isVertical) {
            initialRange.columns.forEach(col => {
                iterateAcrossCells(col);
            });
        }
        else {
            const columns = this.isLeft ? [...finalRange.columns].reverse() : finalRange.columns;
            iterateAcrossCells(undefined, columns);
        }
    }
    clearCellsInRange(startRow, endRow, columns) {
        const cellRange = {
            startRow,
            endRow,
            columns,
            startColumn: columns[0]
        };
        this.rangeService.clearCellRangeCellValues({ cellRanges: [cellRange] });
    }
    processValues(params) {
        const { event, values, initialValues, initialNonAggregatedValues, initialFormattedValues, col, rowNode, idx } = params;
        const userFillOperation = this.gridOptionsService.getCallback('fillOperation');
        const isVertical = this.dragAxis === 'y';
        let direction;
        if (isVertical) {
            direction = this.isUp ? 'up' : 'down';
        }
        else {
            direction = this.isLeft ? 'left' : 'right';
        }
        if (userFillOperation) {
            const params = {
                event,
                values: values.map(({ value }) => value),
                initialValues,
                initialNonAggregatedValues,
                initialFormattedValues,
                currentIndex: idx,
                currentCellValue: this.valueService.getValue(col, rowNode),
                direction,
                column: col,
                rowNode: rowNode
            };
            const userResult = userFillOperation(params);
            if (userResult !== false) {
                return { value: userResult, fromUserFunction: true };
            }
        }
        const allNumbers = !values.some(({ value }) => {
            const asFloat = parseFloat(value);
            return isNaN(asFloat) || asFloat.toString() !== value.toString();
        });
        // values should be copied in order if the alt key is pressed
        // or if the values contain strings and numbers
        // However, if we only have one initial value selected, and that
        // value is a number and we are also pressing alt, then we should
        // increment or decrement the value by 1 based on direction.
        if (event.altKey || !allNumbers) {
            if (allNumbers && initialValues.length === 1) {
                const multiplier = (this.isUp || this.isLeft) ? -1 : 1;
                return { value: parseFloat(_.last(values).value) + 1 * multiplier, fromUserFunction: false };
            }
            const { value, column: sourceCol, rowNode: sourceRowNode } = values[idx % values.length];
            return { value, fromUserFunction: false, sourceCol, sourceRowNode };
        }
        return { value: _.last(findLineByLeastSquares(values.map(({ value }) => Number(value)))), fromUserFunction: false };
    }
    clearValues() {
        this.clearMarkedPath();
        this.clearCellValues();
        this.lastCellMarked = undefined;
        super.clearValues();
    }
    clearMarkedPath() {
        this.markedCells.forEach(cell => {
            if (!cell.isAlive()) {
                return;
            }
            const comp = cell.getComp();
            comp.addOrRemoveCssClass('ag-selection-fill-top', false);
            comp.addOrRemoveCssClass('ag-selection-fill-right', false);
            comp.addOrRemoveCssClass('ag-selection-fill-bottom', false);
            comp.addOrRemoveCssClass('ag-selection-fill-left', false);
        });
        this.markedCells.length = 0;
        this.isUp = false;
        this.isLeft = false;
        this.isReduce = false;
    }
    clearCellValues() {
        this.cellValues.length = 0;
    }
    markPathFrom(initialPosition, currentPosition) {
        this.clearMarkedPath();
        this.clearCellValues();
        if (this.dragAxis === 'y') {
            if (this.rowPositionUtils.sameRow(currentPosition, initialPosition)) {
                return;
            }
            const isBefore = this.rowPositionUtils.before(currentPosition, initialPosition);
            const rangeStartRow = this.getRangeStartRow();
            const rangeEndRow = this.getRangeEndRow();
            if (isBefore && ((currentPosition.rowPinned == rangeStartRow.rowPinned &&
                currentPosition.rowIndex >= rangeStartRow.rowIndex) ||
                (rangeStartRow.rowPinned != rangeEndRow.rowPinned &&
                    currentPosition.rowPinned == rangeEndRow.rowPinned &&
                    currentPosition.rowIndex <= rangeEndRow.rowIndex))) {
                this.reduceVertical(initialPosition, currentPosition);
                this.isReduce = true;
            }
            else {
                this.extendVertical(initialPosition, currentPosition, isBefore);
                this.isReduce = false;
            }
        }
        else {
            const initialColumn = initialPosition.column;
            const currentColumn = currentPosition.column;
            if (initialColumn === currentColumn) {
                return;
            }
            const displayedColumns = this.columnModel.getAllDisplayedColumns();
            const initialIndex = displayedColumns.indexOf(initialColumn);
            const currentIndex = displayedColumns.indexOf(currentColumn);
            if (currentIndex <= initialIndex && currentIndex >= displayedColumns.indexOf(this.getCellRange().columns[0])) {
                this.reduceHorizontal(initialPosition, currentPosition);
                this.isReduce = true;
            }
            else {
                this.extendHorizontal(initialPosition, currentPosition, currentIndex < initialIndex);
                this.isReduce = false;
            }
        }
        this.lastCellMarked = currentPosition;
    }
    extendVertical(initialPosition, endPosition, isMovingUp) {
        const { navigationService, rangeService } = this;
        let row = initialPosition;
        do {
            const cellRange = this.getCellRange();
            const colLen = cellRange.columns.length;
            for (let i = 0; i < colLen; i++) {
                const column = cellRange.columns[i];
                const rowPos = { rowIndex: row.rowIndex, rowPinned: row.rowPinned };
                const cellPos = Object.assign(Object.assign({}, rowPos), { column });
                const cellInRange = rangeService.isCellInSpecificRange(cellPos, cellRange);
                const isInitialRow = this.rowPositionUtils.sameRow(row, initialPosition);
                if (isMovingUp) {
                    this.isUp = true;
                }
                if (!isInitialRow) {
                    const cell = navigationService.getCellByPosition(cellPos);
                    if (cell) {
                        this.markedCells.push(cell);
                        const cellCtrl = cell.getComp();
                        if (!cellInRange) {
                            cellCtrl.addOrRemoveCssClass('ag-selection-fill-left', i === 0);
                            cellCtrl.addOrRemoveCssClass('ag-selection-fill-right', i === colLen - 1);
                        }
                        cellCtrl.addOrRemoveCssClass(isMovingUp ? 'ag-selection-fill-top' : 'ag-selection-fill-bottom', this.rowPositionUtils.sameRow(row, endPosition));
                    }
                }
            }
            if (this.rowPositionUtils.sameRow(row, endPosition)) {
                break;
            }
        } while (
        // tslint:disable-next-line
        row = isMovingUp
            ? this.cellNavigationService.getRowAbove(row)
            : this.cellNavigationService.getRowBelow(row));
    }
    reduceVertical(initialPosition, endPosition) {
        let row = initialPosition;
        do {
            const cellRange = this.getCellRange();
            const colLen = cellRange.columns.length;
            const isLastRow = this.rowPositionUtils.sameRow(row, endPosition);
            for (let i = 0; i < colLen; i++) {
                const rowPos = { rowIndex: row.rowIndex, rowPinned: row.rowPinned };
                const celPos = Object.assign(Object.assign({}, rowPos), { column: cellRange.columns[i] });
                const cell = this.navigationService.getCellByPosition(celPos);
                if (cell) {
                    this.markedCells.push(cell);
                    const cellComp = cell.getComp();
                    cellComp.addOrRemoveCssClass('ag-selection-fill-bottom', this.rowPositionUtils.sameRow(row, endPosition));
                }
            }
            if (isLastRow) {
                break;
            }
            // tslint:disable-next-line
        } while (row = this.cellNavigationService.getRowAbove(row));
    }
    extendHorizontal(initialPosition, endPosition, isMovingLeft) {
        const allCols = this.columnModel.getAllDisplayedColumns();
        const startCol = allCols.indexOf(isMovingLeft ? endPosition.column : initialPosition.column);
        const endCol = allCols.indexOf(isMovingLeft ? this.getCellRange().columns[0] : endPosition.column);
        const offset = isMovingLeft ? 0 : 1;
        const colsToMark = allCols.slice(startCol + offset, endCol + offset);
        const rangeStartRow = this.getRangeStartRow();
        const rangeEndRow = this.getRangeEndRow();
        colsToMark.forEach(column => {
            let row = rangeStartRow;
            let isLastRow = false;
            do {
                isLastRow = this.rowPositionUtils.sameRow(row, rangeEndRow);
                const cell = this.navigationService.getCellByPosition({
                    rowIndex: row.rowIndex,
                    rowPinned: row.rowPinned,
                    column: column
                });
                if (cell) {
                    this.markedCells.push(cell);
                    const cellComp = cell.getComp();
                    cellComp.addOrRemoveCssClass('ag-selection-fill-top', this.rowPositionUtils.sameRow(row, rangeStartRow));
                    cellComp.addOrRemoveCssClass('ag-selection-fill-bottom', this.rowPositionUtils.sameRow(row, rangeEndRow));
                    if (isMovingLeft) {
                        this.isLeft = true;
                        cellComp.addOrRemoveCssClass('ag-selection-fill-left', column === colsToMark[0]);
                    }
                    else {
                        cellComp.addOrRemoveCssClass('ag-selection-fill-right', column === _.last(colsToMark));
                    }
                }
                row = this.cellNavigationService.getRowBelow(row);
            } while (!isLastRow);
        });
    }
    reduceHorizontal(initialPosition, endPosition) {
        const allCols = this.columnModel.getAllDisplayedColumns();
        const startCol = allCols.indexOf(endPosition.column);
        const endCol = allCols.indexOf(initialPosition.column);
        const colsToMark = allCols.slice(startCol, endCol);
        const rangeStartRow = this.getRangeStartRow();
        const rangeEndRow = this.getRangeEndRow();
        colsToMark.forEach(column => {
            let row = rangeStartRow;
            let isLastRow = false;
            do {
                isLastRow = this.rowPositionUtils.sameRow(row, rangeEndRow);
                const cell = this.navigationService.getCellByPosition({
                    rowIndex: row.rowIndex,
                    rowPinned: row.rowPinned,
                    column: column
                });
                if (cell) {
                    this.markedCells.push(cell);
                    const cellComp = cell.getComp();
                    cellComp.addOrRemoveCssClass('ag-selection-fill-right', column === colsToMark[0]);
                }
                row = this.cellNavigationService.getRowBelow(row);
            } while (!isLastRow);
        });
    }
    refresh(cellCtrl) {
        const cellRange = this.rangeService.getCellRanges()[0];
        const isColumnRange = !cellRange.startRow || !cellRange.endRow;
        if (isColumnRange) {
            this.destroy();
            return;
        }
        super.refresh(cellCtrl);
    }
}
FillHandle.TEMPLATE = `<div class="ag-fill-handle"></div>`;
__decorate$W([
    Autowired('valueService')
], FillHandle.prototype, "valueService", void 0);
__decorate$W([
    Autowired('valueParserService')
], FillHandle.prototype, "valueParserService", void 0);
__decorate$W([
    Autowired('valueFormatterService')
], FillHandle.prototype, "valueFormatterService", void 0);

class RangeHandle$1 extends AbstractSelectionHandle {
    constructor() {
        super(RangeHandle$1.TEMPLATE);
        this.type = SelectionHandleType.RANGE;
        this.rangeFixed = false;
    }
    onDrag(e) {
        const lastCellHovered = this.getLastCellHovered();
        if (!lastCellHovered) {
            return;
        }
        const cellRanges = this.rangeService.getCellRanges();
        const lastRange = _.last(cellRanges);
        if (!this.rangeFixed) {
            this.fixRangeStartEnd(lastRange);
            this.rangeFixed = true;
        }
        this.endPosition = {
            rowIndex: lastCellHovered.rowIndex,
            rowPinned: lastCellHovered.rowPinned,
            column: lastCellHovered.column
        };
        // check if the cell ranges are for a chart
        if (cellRanges.length === 2 && cellRanges[0].type === CellRangeType.DIMENSION && lastRange.type === CellRangeType.VALUE) {
            const rowChanged = !this.rowPositionUtils.sameRow(this.endPosition, this.rangeService.getRangeEndRow(lastRange));
            if (rowChanged) {
                // ensure the dimension range is kept in sync with the value range (which has the handle)
                this.rangeService.updateRangeEnd(cellRanges[0], Object.assign(Object.assign({}, this.endPosition), { column: cellRanges[0].columns[0] }), true);
            }
        }
        this.rangeService.extendLatestRangeToCell(this.endPosition);
    }
    onDragEnd(e) {
        const cellRange = _.last(this.rangeService.getCellRanges());
        this.fixRangeStartEnd(cellRange);
        this.rangeFixed = false;
    }
    fixRangeStartEnd(cellRange) {
        const startRow = this.rangeService.getRangeStartRow(cellRange);
        const endRow = this.rangeService.getRangeEndRow(cellRange);
        const column = cellRange.columns[0];
        cellRange.startRow = startRow;
        cellRange.endRow = endRow;
        cellRange.startColumn = column;
    }
}
RangeHandle$1.TEMPLATE = `<div class="ag-range-handle"></div>`;

var __decorate$X = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SelectionHandleFactory = class SelectionHandleFactory extends BeanStub {
    createSelectionHandle(type) {
        return this.createBean(type === SelectionHandleType.RANGE ? new RangeHandle$1() : new FillHandle());
    }
};
SelectionHandleFactory = __decorate$X([
    Bean('selectionHandleFactory')
], SelectionHandleFactory);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$4 = '31.1.1';

const RangeSelectionModule = {
    version: VERSION$4,
    moduleName: ModuleNames.RangeSelectionModule,
    beans: [RangeService, SelectionHandleFactory],
    agStackComponents: [
        { componentName: 'AgFillHandle', componentClass: FillHandle },
        { componentName: 'AgRangeHandle', componentClass: RangeHandle$1 }
    ],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

const VERSION_CHECKING_FIRST_GRID_MAJOR_VERSION = 28;
const VERSION_CHECKING_FIRST_CHARTS_MAJOR_VERSION = 6;
function isValidVersion(version) {
    return version && version.match(/\d+\.\d+\.\d+/);
}
function isValidMajorVersion({ gridMajorVersion, chartsMajorVersion }) {
    const gridMajor = parseInt(gridMajorVersion, 10);
    const chartsMajor = parseInt(chartsMajorVersion, 10);
    const gridMajorDifference = gridMajor - VERSION_CHECKING_FIRST_GRID_MAJOR_VERSION;
    const chartsMajorDifference = chartsMajor - VERSION_CHECKING_FIRST_CHARTS_MAJOR_VERSION;
    const isFirstOrAfterVersion = gridMajorDifference >= 0;
    return gridMajorDifference === chartsMajorDifference && isFirstOrAfterVersion;
}
function gridChartVersion(gridVersion) {
    if (!gridVersion || !isValidVersion(gridVersion)) {
        return undefined;
    }
    const [gridMajor, gridMinor] = gridVersion.split('.') || [];
    const gridMajorMinor = `${gridMajor}.${gridMinor}.x`;
    const gridMajorNumber = parseInt(gridMajor, 10);
    const chartsMajor = (gridMajorNumber - VERSION_CHECKING_FIRST_GRID_MAJOR_VERSION) + VERSION_CHECKING_FIRST_CHARTS_MAJOR_VERSION;
    if (chartsMajor < 0) {
        return undefined;
    }
    const chartsMinor = gridMinor;
    const chartsMajorMinor = `${chartsMajor}.${chartsMinor}.x`;
    return {
        gridMajorMinor,
        chartsMajorMinor
    };
}
function validGridChartsVersionErrorMessage({ type, gridVersion, chartsVersion }) {
    const invalidMessage = 'AG Grid: AG Grid version is incompatible. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.';
    if (!gridVersion) {
        return invalidMessage;
    }
    const version = gridChartVersion(gridVersion);
    if (!version) {
        return invalidMessage;
    }
    const { gridMajorMinor, chartsMajorMinor } = version;
    if (type === 'incompatible') {
        return `AG Grid version ${gridVersion} and AG Charts version ${chartsVersion} is not supported. AG Grid version ${gridMajorMinor} should be used with AG Chart ${chartsMajorMinor}. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.`;
    }
    else if (type === 'invalidCharts') {
        return `AG Grid version ${gridMajorMinor} should be used with AG Chart ${chartsMajorMinor}. Please see https://www.ag-grid.com/javascript-data-grid/modules/ for more information.`;
    }
    return invalidMessage;
}
function validGridChartsVersion({ gridVersion, chartsVersion }) {
    if (!isValidVersion(chartsVersion)) {
        return {
            isValid: false,
            message: validGridChartsVersionErrorMessage({ type: 'invalidCharts', gridVersion, chartsVersion })
        };
    }
    if (!isValidVersion(gridVersion)) {
        return {
            isValid: false,
            message: validGridChartsVersionErrorMessage({ type: 'invalidGrid', gridVersion, chartsVersion })
        };
    }
    const [gridMajor, gridMinor] = gridVersion.split('.') || [];
    const [chartsMajor, chartsMinor] = chartsVersion.split('.') || [];
    const isValidMajor = isValidMajorVersion({
        gridMajorVersion: gridMajor,
        chartsMajorVersion: chartsMajor
    });
    if (isValidMajor && gridMinor === chartsMinor) {
        return {
            isValid: true
        };
    }
    else if (!isValidMajor || gridMinor !== chartsMinor) {
        return {
            isValid: false,
            message: validGridChartsVersionErrorMessage({ type: 'incompatible', gridVersion, chartsVersion })
        };
    }
    return {
        isValid: false,
        message: validGridChartsVersionErrorMessage({ type: 'invalid', gridVersion, chartsVersion })
    };
}

const GridChartsModule = {
    version: VERSION$3,
    validate: () => {
        return validGridChartsVersion({
            gridVersion: VERSION$3,
            chartsVersion: ChartService.CHARTS_VERSION
        });
    },
    moduleName: ModuleNames.GridChartsModule,
    beans: [
        ChartService, ChartTranslationService, ChartCrossFilterService
    ],
    agStackComponents: [
        { componentName: 'AgColorPicker', componentClass: AgColorPicker },
        { componentName: 'AgAngleSelect', componentClass: AgAngleSelect },
    ],
    dependantModules: [
        RangeSelectionModule,
        EnterpriseCoreModule
    ]
};

/**
 * Internal Use Only: Used to ensure this file is treated as a module until we can use moduleDetection flag in Ts v4.7
 */
const __FORCE_MODULE_DETECTION_AG_GRID_CORE_EXT = 0;

const agCharts = {
    time: time_exports,
    AgChart
};

AgCharts.setGridContext(true);
GridLicenseManager.setChartsLicenseManager(AgCharts);

class BaseCreator {
    setBeans(beans) {
        this.beans = beans;
    }
    getFileName(fileName) {
        const extension = this.getDefaultFileExtension();
        if (fileName == null || !fileName.length) {
            fileName = this.getDefaultFileName();
        }
        return fileName.indexOf('.') === -1 ? `${fileName}.${extension}` : fileName;
    }
    getData(params) {
        const serializingSession = this.createSerializingSession(params);
        return this.beans.gridSerializer.serialize(serializingSession, params);
    }
    getDefaultFileName() {
        return `export.${this.getDefaultFileExtension()}`;
    }
}

class BaseGridSerializingSession {
    constructor(config) {
        this.groupColumns = [];
        const { columnModel, valueService, gridOptionsService, valueFormatterService, valueParserService, processCellCallback, processHeaderCallback, processGroupHeaderCallback, processRowGroupCallback, } = config;
        this.columnModel = columnModel;
        this.valueService = valueService;
        this.gridOptionsService = gridOptionsService;
        this.valueFormatterService = valueFormatterService;
        this.valueParserService = valueParserService;
        this.processCellCallback = processCellCallback;
        this.processHeaderCallback = processHeaderCallback;
        this.processGroupHeaderCallback = processGroupHeaderCallback;
        this.processRowGroupCallback = processRowGroupCallback;
    }
    prepare(columnsToExport) {
        this.groupColumns = columnsToExport.filter(col => !!col.getColDef().showRowGroup);
    }
    extractHeaderValue(column) {
        const value = this.getHeaderName(this.processHeaderCallback, column);
        return value != null ? value : '';
    }
    extractRowCellValue(column, index, accumulatedRowIndex, type, node) {
        // we render the group summary text e.g. "-> Parent -> Child"...
        const hideOpenParents = this.gridOptionsService.get('groupHideOpenParents');
        const value = ((!hideOpenParents || node.footer) && this.shouldRenderGroupSummaryCell(node, column, index))
            ? this.createValueForGroupNode(column, node)
            : this.valueService.getValue(column, node);
        const processedValue = this.processCell({
            accumulatedRowIndex,
            rowNode: node,
            column,
            value,
            processCellCallback: this.processCellCallback,
            type
        });
        return processedValue;
    }
    shouldRenderGroupSummaryCell(node, column, currentColumnIndex) {
        var _a;
        const isGroupNode = node && node.group;
        // only on group rows
        if (!isGroupNode) {
            return false;
        }
        const currentColumnGroupIndex = this.groupColumns.indexOf(column);
        if (currentColumnGroupIndex !== -1) {
            if (((_a = node.groupData) === null || _a === void 0 ? void 0 : _a[column.getId()]) != null) {
                return true;
            }
            if (this.gridOptionsService.isRowModelType('serverSide') && node.group) {
                return true;
            }
            // if this is a top level footer, always render`Total` in the left-most cell
            if (node.footer && node.level === -1) {
                const colDef = column.getColDef();
                const isFullWidth = colDef == null || colDef.showRowGroup === true;
                return isFullWidth || colDef.showRowGroup === this.columnModel.getRowGroupColumns()[0].getId();
            }
        }
        const isGroupUseEntireRow = this.gridOptionsService.isGroupUseEntireRow(this.columnModel.isPivotMode());
        return currentColumnIndex === 0 && isGroupUseEntireRow;
    }
    getHeaderName(callback, column) {
        if (callback) {
            return callback(this.gridOptionsService.addGridCommonParams({ column }));
        }
        return this.columnModel.getDisplayNameForColumn(column, 'csv', true);
    }
    createValueForGroupNode(column, node) {
        if (this.processRowGroupCallback) {
            return this.processRowGroupCallback(this.gridOptionsService.addGridCommonParams({ column, node }));
        }
        const isTreeData = this.gridOptionsService.get('treeData');
        const isSuppressGroupMaintainValueType = this.gridOptionsService.get('suppressGroupMaintainValueType');
        // if not tree data and not suppressGroupMaintainValueType then we get the value from the group data
        const getValueFromNode = (node) => {
            var _a, _b;
            if (isTreeData || isSuppressGroupMaintainValueType) {
                return node.key;
            }
            const value = (_a = node.groupData) === null || _a === void 0 ? void 0 : _a[column.getId()];
            if (!value || !node.rowGroupColumn || node.rowGroupColumn.getColDef().useValueFormatterForExport === false) {
                return value;
            }
            return (_b = this.valueFormatterService.formatValue(node.rowGroupColumn, node, value)) !== null && _b !== void 0 ? _b : value;
        };
        const isFooter = node.footer;
        const keys = [getValueFromNode(node)];
        if (!this.gridOptionsService.isGroupMultiAutoColumn()) {
            while (node.parent) {
                node = node.parent;
                keys.push(getValueFromNode(node));
            }
        }
        const groupValue = keys.reverse().join(' -> ');
        return isFooter ? `Total ${groupValue}` : groupValue;
    }
    processCell(params) {
        var _a;
        const { accumulatedRowIndex, rowNode, column, value, processCellCallback, type } = params;
        if (processCellCallback) {
            return {
                value: (_a = processCellCallback(this.gridOptionsService.addGridCommonParams({
                    accumulatedRowIndex,
                    column: column,
                    node: rowNode,
                    value: value,
                    type: type,
                    parseValue: (valueToParse) => this.valueParserService.parseValue(column, rowNode, valueToParse, this.valueService.getValue(column, rowNode)),
                    formatValue: (valueToFormat) => { var _a; return (_a = this.valueFormatterService.formatValue(column, rowNode, valueToFormat)) !== null && _a !== void 0 ? _a : valueToFormat; }
                }))) !== null && _a !== void 0 ? _a : ''
            };
        }
        if (column.getColDef().useValueFormatterForExport !== false) {
            return {
                value: value !== null && value !== void 0 ? value : '',
                valueFormatted: this.valueFormatterService.formatValue(column, rowNode, value),
            };
        }
        return { value: value !== null && value !== void 0 ? value : '' };
    }
}

class Downloader {
    static download(fileName, content) {
        const win = document.defaultView || window;
        if (!win) {
            console.warn('AG Grid: There is no `window` associated with the current `document`');
            return;
        }
        const element = document.createElement('a');
        // @ts-ignore
        const url = win.URL.createObjectURL(content);
        element.setAttribute('href', url);
        element.setAttribute('download', fileName);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.dispatchEvent(new MouseEvent('click', {
            bubbles: false,
            cancelable: true,
            view: win
        }));
        document.body.removeChild(element);
        win.setTimeout(() => {
            // @ts-ignore
            win.URL.revokeObjectURL(url);
        }, 0);
    }
}

const LINE_SEPARATOR = '\r\n';
class CsvSerializingSession extends BaseGridSerializingSession {
    constructor(config) {
        super(config);
        this.isFirstLine = true;
        this.result = '';
        const { suppressQuotes, columnSeparator } = config;
        this.suppressQuotes = suppressQuotes;
        this.columnSeparator = columnSeparator;
    }
    addCustomContent(content) {
        if (!content) {
            return;
        }
        if (typeof content === 'string') {
            if (!/^\s*\n/.test(content)) {
                this.beginNewLine();
            }
            // replace whatever newlines are supplied with the style we're using
            content = content.replace(/\r?\n/g, LINE_SEPARATOR);
            this.result += content;
        }
        else {
            content.forEach(row => {
                this.beginNewLine();
                row.forEach((cell, index) => {
                    if (index !== 0) {
                        this.result += this.columnSeparator;
                    }
                    this.result += this.putInQuotes(cell.data.value || '');
                    if (cell.mergeAcross) {
                        this.appendEmptyCells(cell.mergeAcross);
                    }
                });
            });
        }
    }
    onNewHeaderGroupingRow() {
        this.beginNewLine();
        return {
            onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
        };
    }
    onNewHeaderGroupingRowColumn(columnGroup, header, index, span) {
        if (index != 0) {
            this.result += this.columnSeparator;
        }
        this.result += this.putInQuotes(header);
        this.appendEmptyCells(span);
    }
    appendEmptyCells(count) {
        for (let i = 1; i <= count; i++) {
            this.result += this.columnSeparator + this.putInQuotes("");
        }
    }
    onNewHeaderRow() {
        this.beginNewLine();
        return {
            onColumn: this.onNewHeaderRowColumn.bind(this)
        };
    }
    onNewHeaderRowColumn(column, index) {
        if (index != 0) {
            this.result += this.columnSeparator;
        }
        this.result += this.putInQuotes(this.extractHeaderValue(column));
    }
    onNewBodyRow() {
        this.beginNewLine();
        return {
            onColumn: this.onNewBodyRowColumn.bind(this)
        };
    }
    onNewBodyRowColumn(column, index, node) {
        var _a;
        if (index != 0) {
            this.result += this.columnSeparator;
        }
        const rowCellValue = this.extractRowCellValue(column, index, index, 'csv', node);
        this.result += this.putInQuotes((_a = rowCellValue.valueFormatted) !== null && _a !== void 0 ? _a : rowCellValue.value);
    }
    putInQuotes(value) {
        if (this.suppressQuotes) {
            return value;
        }
        if (value === null || value === undefined) {
            return '""';
        }
        let stringValue;
        if (typeof value === 'string') {
            stringValue = value;
        }
        else if (typeof value.toString === 'function') {
            stringValue = value.toString();
        }
        else {
            console.warn('AG Grid: unknown value type during csv conversion');
            stringValue = '';
        }
        // replace each " with "" (ie two sets of double quotes is how to do double quotes in csv)
        const valueEscaped = stringValue.replace(/"/g, "\"\"");
        return '"' + valueEscaped + '"';
    }
    parse() {
        return this.result;
    }
    beginNewLine() {
        if (!this.isFirstLine) {
            this.result += LINE_SEPARATOR;
        }
        this.isFirstLine = false;
    }
}

var __decorate$Y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let CsvCreator = class CsvCreator extends BaseCreator {
    postConstruct() {
        this.setBeans({
            gridSerializer: this.gridSerializer,
            gridOptionsService: this.gridOptionsService
        });
    }
    getMergedParams(params) {
        const baseParams = this.gridOptionsService.get('defaultCsvExportParams');
        return Object.assign({}, baseParams, params);
    }
    export(userParams) {
        if (this.isExportSuppressed()) {
            console.warn(`AG Grid: Export cancelled. Export is not allowed as per your configuration.`);
            return;
        }
        const mergedParams = this.getMergedParams(userParams);
        const data = this.getData(mergedParams);
        const packagedFile = new Blob(["\ufeff", data], { type: 'text/plain' });
        const fileName = typeof mergedParams.fileName === 'function'
            ? mergedParams.fileName(this.gridOptionsService.getGridCommonParams())
            : mergedParams.fileName;
        Downloader.download(this.getFileName(fileName), packagedFile);
    }
    exportDataAsCsv(params) {
        this.export(params);
    }
    getDataAsCsv(params, skipDefaultParams = false) {
        const mergedParams = skipDefaultParams
            ? Object.assign({}, params)
            : this.getMergedParams(params);
        return this.getData(mergedParams);
    }
    getDefaultFileExtension() {
        return 'csv';
    }
    createSerializingSession(params) {
        const { columnModel, valueService, gridOptionsService, valueFormatterService, valueParserService } = this;
        const { processCellCallback, processHeaderCallback, processGroupHeaderCallback, processRowGroupCallback, suppressQuotes, columnSeparator } = params;
        return new CsvSerializingSession({
            columnModel: columnModel,
            valueService,
            gridOptionsService,
            valueFormatterService,
            valueParserService,
            processCellCallback: processCellCallback || undefined,
            processHeaderCallback: processHeaderCallback || undefined,
            processGroupHeaderCallback: processGroupHeaderCallback || undefined,
            processRowGroupCallback: processRowGroupCallback || undefined,
            suppressQuotes: suppressQuotes || false,
            columnSeparator: columnSeparator || ','
        });
    }
    isExportSuppressed() {
        return this.gridOptionsService.get('suppressCsvExport');
    }
};
__decorate$Y([
    Autowired('columnModel')
], CsvCreator.prototype, "columnModel", void 0);
__decorate$Y([
    Autowired('valueService')
], CsvCreator.prototype, "valueService", void 0);
__decorate$Y([
    Autowired('gridSerializer')
], CsvCreator.prototype, "gridSerializer", void 0);
__decorate$Y([
    Autowired('gridOptionsService')
], CsvCreator.prototype, "gridOptionsService", void 0);
__decorate$Y([
    Autowired('valueFormatterService')
], CsvCreator.prototype, "valueFormatterService", void 0);
__decorate$Y([
    Autowired('valueParserService')
], CsvCreator.prototype, "valueParserService", void 0);
__decorate$Y([
    PostConstruct
], CsvCreator.prototype, "postConstruct", null);
CsvCreator = __decorate$Y([
    Bean('csvCreator')
], CsvCreator);

var __decorate$Z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RowType;
(function (RowType) {
    RowType[RowType["HEADER_GROUPING"] = 0] = "HEADER_GROUPING";
    RowType[RowType["HEADER"] = 1] = "HEADER";
    RowType[RowType["BODY"] = 2] = "BODY";
})(RowType || (RowType = {}));
let GridSerializer = class GridSerializer extends BeanStub {
    serialize(gridSerializingSession, params = {}) {
        const { allColumns, columnKeys, skipRowGroups } = params;
        const columnsToExport = this.getColumnsToExport(allColumns, skipRowGroups, columnKeys);
        const serializeChain = _.compose(
        // first pass, put in the header names of the cols
        this.prepareSession(columnsToExport), this.prependContent(params), this.exportColumnGroups(params, columnsToExport), this.exportHeaders(params, columnsToExport), this.processPinnedTopRows(params, columnsToExport), this.processRows(params, columnsToExport), this.processPinnedBottomRows(params, columnsToExport), this.appendContent(params));
        return serializeChain(gridSerializingSession).parse();
    }
    processRow(gridSerializingSession, params, columnsToExport, node) {
        const rowSkipper = params.shouldRowBeSkipped || (() => false);
        const skipSingleChildrenGroup = this.gridOptionsService.get('groupRemoveSingleChildren');
        const skipLowestSingleChildrenGroup = this.gridOptionsService.get('groupRemoveLowestSingleChildren');
        // if onlySelected, we ignore groupHideOpenParents as the user has explicitly selected the rows they wish to export.
        // similarly, if specific rowNodes are provided we do the same. (the clipboard service uses rowNodes to define which rows to export)
        const isClipboardExport = params.rowPositions != null;
        const isExplicitExportSelection = isClipboardExport || !!params.onlySelected;
        const hideOpenParents = this.gridOptionsService.get('groupHideOpenParents') && !isExplicitExportSelection;
        const isLeafNode = this.columnModel.isPivotMode() ? node.leafGroup : !node.group;
        const isFooter = !!node.footer;
        const skipRowGroups = params.skipRowGroups;
        const shouldSkipLowestGroup = skipLowestSingleChildrenGroup && node.leafGroup;
        const shouldSkipCurrentGroup = node.allChildrenCount === 1 && (skipSingleChildrenGroup || shouldSkipLowestGroup);
        if ((!isLeafNode && !isFooter && (params.skipRowGroups || shouldSkipCurrentGroup || hideOpenParents)) ||
            (params.onlySelected && !node.isSelected()) ||
            (params.skipPinnedTop && node.rowPinned === 'top') ||
            (params.skipPinnedBottom && node.rowPinned === 'bottom')) {
            return;
        }
        // if we are in pivotMode, then the grid will show the root node only
        // if it's not a leaf group
        const nodeIsRootNode = node.level === -1;
        if (nodeIsRootNode && !isLeafNode && !isFooter) {
            return;
        }
        const shouldRowBeSkipped = rowSkipper(this.gridOptionsService.addGridCommonParams({ node }));
        if (shouldRowBeSkipped) {
            return;
        }
        const rowAccumulator = gridSerializingSession.onNewBodyRow(node);
        columnsToExport.forEach((column, index) => {
            rowAccumulator.onColumn(column, index, node);
        });
        if (params.getCustomContentBelowRow) {
            const content = params.getCustomContentBelowRow(this.gridOptionsService.addGridCommonParams({ node }));
            if (content) {
                gridSerializingSession.addCustomContent(content);
            }
        }
    }
    appendContent(params) {
        return (gridSerializingSession) => {
            const appendContent = params.appendContent;
            if (appendContent) {
                gridSerializingSession.addCustomContent(appendContent);
            }
            return gridSerializingSession;
        };
    }
    prependContent(params) {
        return (gridSerializingSession) => {
            const prependContent = params.prependContent;
            if (prependContent) {
                gridSerializingSession.addCustomContent(prependContent);
            }
            return gridSerializingSession;
        };
    }
    prepareSession(columnsToExport) {
        return (gridSerializingSession) => {
            gridSerializingSession.prepare(columnsToExport);
            return gridSerializingSession;
        };
    }
    exportColumnGroups(params, columnsToExport) {
        return (gridSerializingSession) => {
            if (!params.skipColumnGroupHeaders) {
                const groupInstanceIdCreator = new GroupInstanceIdCreator();
                const displayedGroups = this.displayedGroupCreator.createDisplayedGroups(columnsToExport, groupInstanceIdCreator, null);
                this.recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, params.processGroupHeaderCallback);
            }
            return gridSerializingSession;
        };
    }
    exportHeaders(params, columnsToExport) {
        return (gridSerializingSession) => {
            if (!params.skipColumnHeaders) {
                const gridRowIterator = gridSerializingSession.onNewHeaderRow();
                columnsToExport.forEach((column, index) => {
                    gridRowIterator.onColumn(column, index, undefined);
                });
            }
            return gridSerializingSession;
        };
    }
    processPinnedTopRows(params, columnsToExport) {
        return (gridSerializingSession) => {
            const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
            if (params.rowPositions) {
                params.rowPositions
                    // only pinnedTop rows, other models are processed by `processRows` and `processPinnedBottomsRows`
                    .filter(position => position.rowPinned === 'top')
                    .sort((a, b) => a.rowIndex - b.rowIndex)
                    .map(position => this.pinnedRowModel.getPinnedTopRow(position.rowIndex))
                    .forEach(processRow);
            }
            else {
                this.pinnedRowModel.forEachPinnedTopRow(processRow);
            }
            return gridSerializingSession;
        };
    }
    processRows(params, columnsToExport) {
        return (gridSerializingSession) => {
            // when in pivot mode, we always render cols on screen, never 'all columns'
            const rowModel = this.rowModel;
            const rowModelType = rowModel.getType();
            const usingCsrm = rowModelType === 'clientSide';
            const usingSsrm = rowModelType === 'serverSide';
            const onlySelectedNonStandardModel = !usingCsrm && params.onlySelected;
            const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
            const { exportedRows = 'filteredAndSorted', } = params;
            if (params.rowPositions) {
                params.rowPositions
                    // pinnedRows are processed by `processPinnedTopRows` and `processPinnedBottomsRows`
                    .filter(position => position.rowPinned == null)
                    .sort((a, b) => a.rowIndex - b.rowIndex)
                    .map(position => rowModel.getRow(position.rowIndex))
                    .forEach(processRow);
            }
            else if (this.columnModel.isPivotMode()) {
                if (usingCsrm) {
                    rowModel.forEachPivotNode(processRow, true);
                }
                else if (usingSsrm) {
                    rowModel.forEachNodeAfterFilterAndSort(processRow, true);
                }
                else {
                    // must be enterprise, so we can just loop through all the nodes
                    rowModel.forEachNode(processRow);
                }
            }
            else {
                // onlySelectedAllPages: user doing pagination and wants selected items from
                // other pages, so cannot use the standard row model as it won't have rows from
                // other pages.
                // onlySelectedNonStandardModel: if user wants selected in non standard row model
                // (eg viewport) then again RowModel cannot be used, so need to use selected instead.
                if (params.onlySelectedAllPages || onlySelectedNonStandardModel) {
                    const selectedNodes = this.selectionService.getSelectedNodes();
                    this.replicateSortedOrder(selectedNodes);
                    // serialize each node
                    selectedNodes.forEach(processRow);
                }
                else {
                    // here is everything else - including standard row model and selected. we don't use
                    // the selection model even when just using selected, so that the result is the order
                    // of the rows appearing on the screen.
                    if (exportedRows === 'all') {
                        rowModel.forEachNode(processRow);
                    }
                    else if (usingCsrm) {
                        rowModel.forEachNodeAfterFilterAndSort(processRow, true);
                    }
                    else if (usingSsrm) {
                        rowModel.forEachNodeAfterFilterAndSort(processRow, true);
                    }
                    else {
                        rowModel.forEachNode(processRow);
                    }
                }
            }
            return gridSerializingSession;
        };
    }
    replicateSortedOrder(rows) {
        const sortOptions = this.sortController.getSortOptions();
        const compareNodes = (rowA, rowB) => {
            var _a, _b, _c, _d;
            if (rowA.rowIndex != null && rowB.rowIndex != null) {
                // if the rows have rowIndexes, this is the easiest way to compare,
                // as they're already ordered
                return rowA.rowIndex - rowB.rowIndex;
            }
            // if the level is the same, compare these nodes, or their parents
            if (rowA.level === rowB.level) {
                if (((_a = rowA.parent) === null || _a === void 0 ? void 0 : _a.id) === ((_b = rowB.parent) === null || _b === void 0 ? void 0 : _b.id)) {
                    return this.rowNodeSorter.compareRowNodes(sortOptions, {
                        rowNode: rowA,
                        currentPos: (_c = rowA.rowIndex) !== null && _c !== void 0 ? _c : -1,
                    }, {
                        rowNode: rowB,
                        currentPos: (_d = rowB.rowIndex) !== null && _d !== void 0 ? _d : -1,
                    });
                }
                // level is same, but parent isn't, compare parents
                return compareNodes(rowA.parent, rowB.parent);
            }
            // if level is different, match levels
            if (rowA.level > rowB.level) {
                return compareNodes(rowA.parent, rowB);
            }
            return compareNodes(rowA, rowB.parent);
        };
        // sort the nodes either by existing row index or compare them
        rows.sort(compareNodes);
    }
    processPinnedBottomRows(params, columnsToExport) {
        return (gridSerializingSession) => {
            const processRow = this.processRow.bind(this, gridSerializingSession, params, columnsToExport);
            if (params.rowPositions) {
                params.rowPositions
                    // only pinnedBottom rows, other models are processed by `processRows` and `processPinnedTopRows`
                    .filter(position => position.rowPinned === 'bottom')
                    .sort((a, b) => a.rowIndex - b.rowIndex)
                    .map(position => this.pinnedRowModel.getPinnedBottomRow(position.rowIndex))
                    .forEach(processRow);
            }
            else {
                this.pinnedRowModel.forEachPinnedBottomRow(processRow);
            }
            return gridSerializingSession;
        };
    }
    getColumnsToExport(allColumns = false, skipRowGroups = false, columnKeys) {
        const isPivotMode = this.columnModel.isPivotMode();
        if (columnKeys && columnKeys.length) {
            return this.columnModel.getGridColumns(columnKeys);
        }
        const isTreeData = this.gridOptionsService.get('treeData');
        let columnsToExport = [];
        if (allColumns && !isPivotMode) {
            columnsToExport = this.columnModel.getAllGridColumns();
        }
        else {
            columnsToExport = this.columnModel.getAllDisplayedColumns();
        }
        if (skipRowGroups && !isTreeData) {
            columnsToExport = columnsToExport.filter(column => column.getColId() !== GROUP_AUTO_COLUMN_ID);
        }
        return columnsToExport;
    }
    recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession, processGroupHeaderCallback) {
        const directChildrenHeaderGroups = [];
        displayedGroups.forEach((columnGroupChild) => {
            const columnGroup = columnGroupChild;
            if (!columnGroup.getChildren) {
                return;
            }
            columnGroup.getChildren().forEach(it => directChildrenHeaderGroups.push(it));
        });
        if (displayedGroups.length > 0 && displayedGroups[0] instanceof ColumnGroup) {
            this.doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback);
        }
        if (directChildrenHeaderGroups && directChildrenHeaderGroups.length > 0) {
            this.recursivelyAddHeaderGroups(directChildrenHeaderGroups, gridSerializingSession, processGroupHeaderCallback);
        }
    }
    doAddHeaderHeader(gridSerializingSession, displayedGroups, processGroupHeaderCallback) {
        const gridRowIterator = gridSerializingSession.onNewHeaderGroupingRow();
        let columnIndex = 0;
        displayedGroups.forEach((columnGroupChild) => {
            const columnGroup = columnGroupChild;
            let name;
            if (processGroupHeaderCallback) {
                name = processGroupHeaderCallback(this.gridOptionsService.addGridCommonParams({
                    columnGroup: columnGroup
                }));
            }
            else {
                name = this.columnModel.getDisplayNameForColumnGroup(columnGroup, 'header');
            }
            const collapsibleGroupRanges = columnGroup.getLeafColumns().reduce((collapsibleGroups, currentColumn, currentIdx, arr) => {
                let lastGroup = _.last(collapsibleGroups);
                const groupShow = currentColumn.getColumnGroupShow() === 'open';
                if (!groupShow) {
                    if (lastGroup && lastGroup[1] == null) {
                        lastGroup[1] = currentIdx - 1;
                    }
                }
                else if (!lastGroup || lastGroup[1] != null) {
                    lastGroup = [currentIdx];
                    collapsibleGroups.push(lastGroup);
                }
                if (currentIdx === arr.length - 1 && lastGroup && lastGroup[1] == null) {
                    lastGroup[1] = currentIdx;
                }
                return collapsibleGroups;
            }, []);
            gridRowIterator.onColumn(columnGroup, name || '', columnIndex++, columnGroup.getLeafColumns().length - 1, collapsibleGroupRanges);
        });
    }
};
__decorate$Z([
    Autowired('displayedGroupCreator')
], GridSerializer.prototype, "displayedGroupCreator", void 0);
__decorate$Z([
    Autowired('columnModel')
], GridSerializer.prototype, "columnModel", void 0);
__decorate$Z([
    Autowired('rowModel')
], GridSerializer.prototype, "rowModel", void 0);
__decorate$Z([
    Autowired('pinnedRowModel')
], GridSerializer.prototype, "pinnedRowModel", void 0);
__decorate$Z([
    Autowired('selectionService')
], GridSerializer.prototype, "selectionService", void 0);
__decorate$Z([
    Autowired('rowNodeSorter')
], GridSerializer.prototype, "rowNodeSorter", void 0);
__decorate$Z([
    Autowired('sortController')
], GridSerializer.prototype, "sortController", void 0);
GridSerializer = __decorate$Z([
    Bean("gridSerializer")
], GridSerializer);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$5 = '31.1.1';

const CsvExportModule = {
    version: VERSION$5,
    moduleName: ModuleNames.CsvExportModule,
    beans: [CsvCreator, GridSerializer]
};

const LINE_SEPARATOR$1 = '\r\n';
class XmlFactory {
    static createHeader(headerElement = {}) {
        const headerStart = '<?';
        const headerEnd = '?>';
        const keys = ['version'];
        if (!headerElement.version) {
            headerElement.version = "1.0";
        }
        if (headerElement.encoding) {
            keys.push('encoding');
        }
        if (headerElement.standalone) {
            keys.push('standalone');
        }
        const att = keys.map((key) => `${key}="${headerElement[key]}"`).join(' ');
        return `${headerStart}xml ${att} ${headerEnd}`;
    }
    static createXml(xmlElement, booleanTransformer) {
        let props = '';
        if (xmlElement.properties) {
            if (xmlElement.properties.prefixedAttributes) {
                xmlElement.properties.prefixedAttributes.forEach((prefixedSet) => {
                    Object.keys(prefixedSet.map).forEach((key) => {
                        props += this.returnAttributeIfPopulated(prefixedSet.prefix + key, prefixedSet.map[key], booleanTransformer);
                    });
                });
            }
            if (xmlElement.properties.rawMap) {
                Object.keys(xmlElement.properties.rawMap).forEach((key) => {
                    props += this.returnAttributeIfPopulated(key, xmlElement.properties.rawMap[key], booleanTransformer);
                });
            }
        }
        let result = '<' + xmlElement.name + props;
        if (!xmlElement.children && xmlElement.textNode == null) {
            return result + '/>' + LINE_SEPARATOR$1;
        }
        if (xmlElement.textNode != null) {
            return result + '>' + xmlElement.textNode + '</' + xmlElement.name + '>' + LINE_SEPARATOR$1;
        }
        result += '>' + LINE_SEPARATOR$1;
        if (xmlElement.children) {
            xmlElement.children.forEach((it) => {
                result += this.createXml(it, booleanTransformer);
            });
        }
        return result + '</' + xmlElement.name + '>' + LINE_SEPARATOR$1;
    }
    static returnAttributeIfPopulated(key, value, booleanTransformer) {
        if (!value && value !== '' && value !== 0) {
            return '';
        }
        let xmlValue = value;
        if ((typeof (value) === 'boolean')) {
            if (booleanTransformer) {
                xmlValue = booleanTransformer(value);
            }
        }
        return ` ${key}="${xmlValue}"`;
    }
}

const convertTime = (date) => {
    let time = date.getHours();
    time <<= 6;
    time = time | date.getMinutes();
    time <<= 5;
    time = time | date.getSeconds() / 2;
    return time;
};
const convertDate = (date) => {
    let dt = date.getFullYear() - 1980;
    dt <<= 4;
    dt = dt | (date.getMonth() + 1);
    dt <<= 5;
    dt = dt | date.getDate();
    return dt;
};
function convertDecToHex(number, bytes) {
    let hex = '';
    for (let i = 0; i < bytes; i++) {
        hex += String.fromCharCode(number & 0xff);
        number >>>= 8;
    }
    return hex;
}

const getCrcFromCrc32TableAndByteArray = (content) => {
    if (!content.length) {
        return 0;
    }
    let crc = 0 ^ (-1);
    let j = 0;
    let k = 0;
    let l = 0;
    for (let i = 0; i < content.length; i++) {
        j = content[i];
        k = (crc ^ j) & 0xFF;
        l = crcTable[k];
        crc = (crc >>> 8) ^ l;
    }
    return crc ^ (-1);
};
const getCrcFromCrc32Table = (content) => {
    if (!content.length) {
        return 0;
    }
    if (typeof content === 'string') {
        return getCrcFromCrc32TableAndByteArray(new TextEncoder().encode(content));
    }
    return getCrcFromCrc32TableAndByteArray(content);
};
// Table for crc calculation from:
// https://referencesource.microsoft.com/#System/sys/System/IO/compression/Crc32Helper.cs,3b31978c7d7f7246,references
const crcTable = new Uint32Array([
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
]);

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const compressBlob = (data) => __awaiter(void 0, void 0, void 0, function* () {
    // Callback to extract the compressed data
    let chunksSize = 0;
    const chunks = [];
    const writeCompressedData = new WritableStream({
        write: (chunk) => {
            chunks.push(chunk);
            chunksSize += chunk.length;
        }
    });
    // Create readable stream from blob
    const readable = new ReadableStream({
        start: (controller) => {
            const reader = new FileReader();
            reader.onload = e => {
                var _a;
                if ((_a = e.target) === null || _a === void 0 ? void 0 : _a.result) {
                    controller.enqueue(e.target.result);
                }
                controller.close();
            };
            reader.readAsArrayBuffer(data);
        }
    });
    // Perform the compression using the browser's native CompressionStream API
    // Ref https://developer.mozilla.org/en-US/docs/Web/API/CompressionStream for details
    const compressStream = new window.CompressionStream('deflate-raw');
    yield readable.pipeThrough(compressStream).pipeTo(writeCompressedData);
    // Return the compressed data
    return {
        size: chunksSize,
        content: new Blob(chunks),
    };
});
const deflateLocalFile = (rawContent) => __awaiter(void 0, void 0, void 0, function* () {
    const contentAsBlob = new Blob([rawContent]);
    const { size: compressedSize, content: compressedContent } = yield compressBlob(contentAsBlob);
    const compressedContentAsUint8Array = new Uint8Array(yield compressedContent.arrayBuffer());
    return {
        size: compressedSize,
        content: compressedContentAsUint8Array,
    };
});

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { utf8_encode } = _;
const getDeflatedHeaderAndContent = (currentFile, offset) => __awaiter$1(void 0, void 0, void 0, function* () {
    const { content } = currentFile;
    const { size, content: rawContent } = !content
        ? ({ size: 0, content: Uint8Array.from([]) })
        : getDecodedContent(content);
    let deflatedContent = undefined;
    let deflatedSize = undefined;
    let deflationPerformed = false;
    const shouldDeflate = currentFile.type === 'file' && rawContent && size > 0;
    if (shouldDeflate) {
        const result = yield deflateLocalFile(rawContent);
        deflatedContent = result.content;
        deflatedSize = result.size;
        deflationPerformed = true;
    }
    const headers = getHeaders(currentFile, deflationPerformed, offset, size, rawContent, deflatedSize);
    return Object.assign(Object.assign({}, headers), { content: deflatedContent || rawContent, isCompressed: deflationPerformed });
});
const getHeaderAndContent = (currentFile, offset) => {
    const { content } = currentFile;
    const { content: rawContent } = !content
        ? ({ content: Uint8Array.from([]) })
        : getDecodedContent(content);
    const headers = getHeaders(currentFile, false, offset, rawContent.length, rawContent, undefined);
    return Object.assign(Object.assign({}, headers), { content: rawContent, isCompressed: false });
};
const getHeaders = (currentFile, isCompressed, offset, rawSize, rawContent, deflatedSize) => {
    const { content, path, created: creationDate, } = currentFile;
    const time = convertTime(creationDate);
    const dt = convertDate(creationDate);
    const crcFlag = getCrcFromCrc32Table(rawContent);
    const zipSize = deflatedSize !== undefined ? deflatedSize : rawSize;
    const utfPath = utf8_encode(path);
    const isUTF8 = utfPath !== path;
    let extraFields = '';
    if (isUTF8) {
        const uExtraFieldPath = convertDecToHex(1, 1) + convertDecToHex(getCrcFromCrc32Table(utfPath), 4) + utfPath;
        extraFields = "\x75\x70" + convertDecToHex(uExtraFieldPath.length, 2) + uExtraFieldPath;
    }
    const commonHeader = '\x14\x00' + // version needed to extract
        (isUTF8 ? '\x00\x08' : '\x00\x00') + // Language encoding flag (EFS) (12th bit turned on)
        convertDecToHex(isCompressed ? 8 : 0, 2) + // As per ECMA-376 Part 2 specs
        convertDecToHex(time, 2) + // last modified time
        convertDecToHex(dt, 2) + // last modified date
        convertDecToHex(zipSize ? crcFlag : 0, 4) +
        convertDecToHex(deflatedSize !== null && deflatedSize !== void 0 ? deflatedSize : rawSize, 4) + // compressed size
        convertDecToHex(rawSize, 4) + // uncompressed size
        convertDecToHex(utfPath.length, 2) + // file name length
        convertDecToHex(extraFields.length, 2); // extra field length
    const localFileHeader = 'PK\x03\x04' + commonHeader + utfPath + extraFields;
    const centralDirectoryHeader = 'PK\x01\x02' + // central header
        '\x14\x00' +
        commonHeader + // file header
        '\x00\x00' +
        '\x00\x00' +
        '\x00\x00' +
        (content ? '\x00\x00\x00\x00' : '\x10\x00\x00\x00') + // external file attributes
        convertDecToHex(offset, 4) + // relative offset of local header
        utfPath + // file name
        extraFields; // extra field
    return {
        localFileHeader: Uint8Array.from(localFileHeader, c => c.charCodeAt(0)),
        centralDirectoryHeader: Uint8Array.from(centralDirectoryHeader, c => c.charCodeAt(0)),
    };
};
const buildCentralDirectoryEnd = (tLen, cLen, lLen) => {
    const str = 'PK\x05\x06' + // central folder end
        '\x00\x00' +
        '\x00\x00' +
        convertDecToHex(tLen, 2) + // total number of entries in the central folder
        convertDecToHex(tLen, 2) + // total number of entries in the central folder
        convertDecToHex(cLen, 4) + // size of the central folder
        convertDecToHex(lLen, 4) + // central folder start offset
        '\x00\x00';
    return Uint8Array.from(str, c => c.charCodeAt(0));
};
const convertStringToByteArray = (str) => {
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
};
const getDecodedContent = (content) => {
    let contentToUse;
    // base64 content is passed as string
    if (typeof content === 'string') {
        const base64String = atob(content.split(';base64,')[1]);
        contentToUse = convertStringToByteArray(base64String);
    }
    else {
        contentToUse = content;
    }
    return {
        size: contentToUse.length,
        content: contentToUse,
    };
};

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ZipContainer {
    static addFolders(paths) {
        paths.forEach(this.addFolder.bind(this));
    }
    static addFolder(path) {
        this.folders.push({
            path,
            created: new Date(),
            isBase64: false,
            type: 'folder'
        });
    }
    static addFile(path, content, isBase64 = false) {
        this.files.push({
            path,
            created: new Date(),
            content: isBase64 ? content : new TextEncoder().encode(content),
            isBase64,
            type: 'file'
        });
    }
    static getZipFile(mimeType = 'application/zip') {
        return __awaiter$2(this, void 0, void 0, function* () {
            const textOutput = yield this.buildCompressedFileStream();
            this.clearStream();
            return new Blob([textOutput], { type: mimeType });
        });
    }
    static getUncompressedZipFile(mimeType = 'application/zip') {
        const textOutput = this.buildFileStream();
        this.clearStream();
        return new Blob([textOutput], { type: mimeType });
    }
    static clearStream() {
        this.folders = [];
        this.files = [];
    }
    static packageFiles(files) {
        let fileData = new Uint8Array(0);
        let folderData = new Uint8Array(0);
        let filesContentAndHeaderLength = 0;
        let folderHeadersLength = 0;
        for (const currentFile of files) {
            const { localFileHeader, centralDirectoryHeader, content, } = currentFile;
            // Append fileHeader to fData
            const dataWithHeader = new Uint8Array(fileData.length + localFileHeader.length);
            dataWithHeader.set(fileData);
            dataWithHeader.set(localFileHeader, fileData.length);
            fileData = dataWithHeader;
            // Append content to fData
            const dataWithContent = new Uint8Array(fileData.length + content.length);
            dataWithContent.set(fileData);
            dataWithContent.set(content, fileData.length);
            fileData = dataWithContent;
            // Append folder header to foData
            const folderDataWithFolderHeader = new Uint8Array(folderData.length + centralDirectoryHeader.length);
            folderDataWithFolderHeader.set(folderData);
            folderDataWithFolderHeader.set(centralDirectoryHeader, folderData.length);
            folderData = folderDataWithFolderHeader;
            filesContentAndHeaderLength += localFileHeader.length + content.length;
            folderHeadersLength += centralDirectoryHeader.length;
        }
        const folderEnd = buildCentralDirectoryEnd(files.length, folderHeadersLength, filesContentAndHeaderLength);
        // Append folder data and file data
        const result = new Uint8Array(fileData.length + folderData.length + folderEnd.length);
        result.set(fileData);
        result.set(folderData, fileData.length);
        result.set(folderEnd, fileData.length + folderData.length);
        return result;
    }
    static buildCompressedFileStream() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const totalFiles = [...this.folders, ...this.files];
            const readyFiles = [];
            let lL = 0;
            for (const currentFile of totalFiles) {
                const output = yield getDeflatedHeaderAndContent(currentFile, lL);
                const { localFileHeader, content } = output;
                readyFiles.push(output);
                lL += localFileHeader.length + content.length;
            }
            return this.packageFiles(readyFiles);
        });
    }
    static buildFileStream() {
        const totalFiles = [...this.folders, ...this.files];
        const readyFiles = [];
        let lL = 0;
        for (const currentFile of totalFiles) {
            const readyFile = getHeaderAndContent(currentFile, lL);
            const { localFileHeader, content } = readyFile;
            readyFiles.push(readyFile);
            lL += localFileHeader.length + content.length;
        }
        return this.packageFiles(readyFiles);
    }
}
ZipContainer.folders = [];
ZipContainer.files = [];

var __decorate$_ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ClipboardService_1;
// Matches value in changeDetectionService
const SOURCE_PASTE = 'paste';
const EXPORT_TYPE_DRAG_COPY = 'dragCopy';
const EXPORT_TYPE_CLIPBOARD = 'clipboard';
var CellClearType;
(function (CellClearType) {
    CellClearType[CellClearType["CellRange"] = 0] = "CellRange";
    CellClearType[CellClearType["SelectedRows"] = 1] = "SelectedRows";
    CellClearType[CellClearType["FocusedCell"] = 2] = "FocusedCell";
})(CellClearType || (CellClearType = {}));
const apiError = (method) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${method}()). ` +
    'The reason why it could not be used has been logged in the previous line. ' +
    'For this reason the grid has defaulted to using a workaround which doesn\'t perform as well. ' +
    'Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid ' +
    'property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.';
let ClipboardService = ClipboardService_1 = class ClipboardService extends BeanStub {
    constructor() {
        super(...arguments);
        this.lastPasteOperationTime = 0;
        this.navigatorApiFailed = false;
    }
    init() {
        this.logger = this.loggerFactory.create('ClipboardService');
        if (this.rowModel.getType() === 'clientSide') {
            this.clientSideRowModel = this.rowModel;
        }
        this.ctrlsService.whenReady(p => {
            this.gridCtrl = p.gridCtrl;
        });
    }
    pasteFromClipboard() {
        this.logger.log('pasteFromClipboard');
        // Method 1 - native clipboard API, available in modern chrome browsers
        const allowNavigator = !this.gridOptionsService.get('suppressClipboardApi');
        // Some browsers (Firefox) do not allow Web Applications to read from
        // the clipboard so verify if not only the ClipboardAPI is available,
        // but also if the `readText` method is public.
        if (allowNavigator && !this.navigatorApiFailed && navigator.clipboard && navigator.clipboard.readText) {
            navigator.clipboard.readText()
                .then(this.processClipboardData.bind(this))
                .catch((e) => {
                _.doOnce(() => {
                    console.warn(e);
                    console.warn(apiError('readText'));
                }, 'clipboardApiError');
                this.navigatorApiFailed = true;
                this.pasteFromClipboardLegacy();
            });
        }
        else {
            this.pasteFromClipboardLegacy();
        }
    }
    pasteFromClipboardLegacy() {
        // Method 2 - if modern API fails, the old school hack
        let defaultPrevented = false;
        const handlePasteEvent = (e) => {
            const currentPastOperationTime = (new Date()).getTime();
            if (currentPastOperationTime - this.lastPasteOperationTime < 50) {
                defaultPrevented = true;
                e.preventDefault();
            }
            this.lastPasteOperationTime = currentPastOperationTime;
        };
        this.executeOnTempElement((textArea) => {
            textArea.addEventListener('paste', handlePasteEvent);
            textArea.focus({ preventScroll: true });
        }, (element) => {
            const data = element.value;
            if (!defaultPrevented) {
                this.processClipboardData(data);
            }
            else {
                this.refocusLastFocusedCell();
            }
            element.removeEventListener('paste', handlePasteEvent);
        });
    }
    refocusLastFocusedCell() {
        const focusedCell = this.focusService.getFocusedCell();
        if (focusedCell) {
            this.focusService.setFocusedCell({
                rowIndex: focusedCell.rowIndex,
                column: focusedCell.column,
                rowPinned: focusedCell.rowPinned,
                forceBrowserFocus: true
            });
        }
    }
    getClipboardDelimiter() {
        const delimiter = this.gridOptionsService.get('clipboardDelimiter');
        return _.exists(delimiter) ? delimiter : '\t';
    }
    processClipboardData(data) {
        if (data == null) {
            return;
        }
        let parsedData = ClipboardService_1.stringToArray(data, this.getClipboardDelimiter());
        const userFunc = this.gridOptionsService.getCallback('processDataFromClipboard');
        if (userFunc) {
            parsedData = userFunc({ data: parsedData });
        }
        if (parsedData == null) {
            return;
        }
        if (this.gridOptionsService.get('suppressLastEmptyLineOnPaste')) {
            this.removeLastLineIfBlank(parsedData);
        }
        const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {
            const rangeActive = this.rangeService && this.rangeService.isMoreThanOneCell();
            const pasteIntoRange = rangeActive && !this.hasOnlyOneValueToPaste(parsedData);
            if (pasteIntoRange) {
                this.pasteIntoActiveRange(parsedData, cellsToFlash, updatedRowNodes, changedPath);
            }
            else {
                this.pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath);
            }
        };
        this.doPasteOperation(pasteOperation);
    }
    // This will parse a delimited string into an array of arrays.
    static stringToArray(strData, delimiter = ',') {
        const data = [];
        const isNewline = (char) => char === '\r' || char === '\n';
        let insideQuotedField = false;
        if (strData === '') {
            return [['']];
        }
        // iterate over each character, keep track of current row and column (of the returned array)
        for (let row = 0, column = 0, position = 0; position < strData.length; position++) {
            const previousChar = strData[position - 1];
            const currentChar = strData[position];
            const nextChar = strData[position + 1];
            const ensureDataExists = () => {
                if (!data[row]) {
                    // create row if it doesn't exist
                    data[row] = [];
                }
                if (!data[row][column]) {
                    // create column if it doesn't exist
                    data[row][column] = '';
                }
            };
            ensureDataExists();
            if (currentChar === '"') {
                if (insideQuotedField) {
                    if (nextChar === '"') {
                        // unescape double quote
                        data[row][column] += '"';
                        position++;
                    }
                    else {
                        // exit quoted field
                        insideQuotedField = false;
                    }
                    // continue;
                }
                else if (previousChar === undefined || previousChar === delimiter || isNewline(previousChar)) {
                    // enter quoted field
                    insideQuotedField = true;
                    // continue;
                }
            }
            if (!insideQuotedField && currentChar !== '"') {
                if (currentChar === delimiter) {
                    // move to next column
                    column++;
                    ensureDataExists();
                    continue;
                }
                else if (isNewline(currentChar)) {
                    // move to next row
                    column = 0;
                    row++;
                    ensureDataExists();
                    if (currentChar === '\r' && nextChar === '\n') {
                        // skip over second newline character if it exists
                        position++;
                    }
                    continue;
                }
            }
            // add current character to current column
            data[row][column] += currentChar;
        }
        return data;
    }
    // common code to paste operations, e.g. paste to cell, paste to range, and copy range down
    doPasteOperation(pasteOperationFunc) {
        const source = 'clipboard';
        this.eventService.dispatchEvent({
            type: Events.EVENT_PASTE_START,
            source
        });
        let changedPath;
        if (this.clientSideRowModel) {
            const onlyChangedColumns = this.gridOptionsService.get('aggregateOnlyChangedColumns');
            changedPath = new ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());
        }
        const cellsToFlash = {};
        const updatedRowNodes = [];
        const focusedCell = this.focusService.getFocusedCell();
        pasteOperationFunc(cellsToFlash, updatedRowNodes, focusedCell, changedPath);
        const nodesToRefresh = [...updatedRowNodes];
        if (changedPath) {
            this.clientSideRowModel.doAggregate(changedPath);
            // add all nodes impacted by aggregation, as they need refreshed also.
            changedPath.forEachChangedNodeDepthFirst(rowNode => {
                nodesToRefresh.push(rowNode);
            });
        }
        // clipboardService has to do changeDetection itself, to prevent repeat logic in favour of batching.
        // changeDetectionService is disabled for this action.
        this.rowRenderer.refreshCells({ rowNodes: nodesToRefresh });
        this.dispatchFlashCells(cellsToFlash);
        this.fireRowChanged(updatedRowNodes);
        // if using the clipboard hack with a temp element, then the focus has been lost,
        // so need to put it back. otherwise paste operation loosed focus on cell and keyboard
        // navigation stops.
        this.refocusLastFocusedCell();
        const event = {
            type: Events.EVENT_PASTE_END,
            source
        };
        this.eventService.dispatchEvent(event);
    }
    pasteIntoActiveRange(clipboardData, cellsToFlash, updatedRowNodes, changedPath) {
        // true if clipboard data can be evenly pasted into range, otherwise false
        const abortRepeatingPasteIntoRows = this.getRangeSize() % clipboardData.length != 0;
        let indexOffset = 0;
        let dataRowIndex = 0;
        const rowCallback = (currentRow, rowNode, columns, index) => {
            const atEndOfClipboardData = index - indexOffset >= clipboardData.length;
            if (atEndOfClipboardData) {
                if (abortRepeatingPasteIntoRows) {
                    return;
                }
                // increment offset and reset data index to repeat paste of data
                indexOffset += dataRowIndex;
                dataRowIndex = 0;
            }
            const currentRowData = clipboardData[index - indexOffset];
            // otherwise we are not the first row, so copy
            updatedRowNodes.push(rowNode);
            const processCellFromClipboardFunc = this.gridOptionsService.getCallback('processCellFromClipboard');
            columns.forEach((column, idx) => {
                if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {
                    return;
                }
                // repeat data for columns we don't have data for - happens when to range is bigger than copied data range
                if (idx >= currentRowData.length) {
                    idx = idx % currentRowData.length;
                }
                const newValue = this.processCell(rowNode, column, currentRowData[idx], EXPORT_TYPE_DRAG_COPY, processCellFromClipboardFunc, true);
                rowNode.setDataValue(column, newValue, SOURCE_PASTE);
                if (changedPath) {
                    changedPath.addParentNode(rowNode.parent, [column]);
                }
                const { rowIndex, rowPinned } = currentRow;
                const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });
                cellsToFlash[cellId] = true;
            });
            dataRowIndex++;
        };
        this.iterateActiveRanges(false, rowCallback);
    }
    pasteStartingFromFocusedCell(parsedData, cellsToFlash, updatedRowNodes, focusedCell, changedPath) {
        if (!focusedCell) {
            return;
        }
        const currentRow = { rowIndex: focusedCell.rowIndex, rowPinned: focusedCell.rowPinned };
        const columnsToPasteInto = this.columnModel.getDisplayedColumnsStartingAt(focusedCell.column);
        if (this.isPasteSingleValueIntoRange(parsedData)) {
            this.pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath);
        }
        else {
            this.pasteMultipleValues(parsedData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, EXPORT_TYPE_CLIPBOARD, changedPath);
        }
    }
    // if range is active, and only one cell, then we paste this cell into all cells in the active range.
    isPasteSingleValueIntoRange(parsedData) {
        return this.hasOnlyOneValueToPaste(parsedData)
            && this.rangeService != null
            && !this.rangeService.isEmpty();
    }
    pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath) {
        const value = parsedData[0][0];
        const rowCallback = (currentRow, rowNode, columns) => {
            updatedRowNodes.push(rowNode);
            columns.forEach(column => this.updateCellValue(rowNode, column, value, cellsToFlash, EXPORT_TYPE_CLIPBOARD, changedPath));
        };
        this.iterateActiveRanges(false, rowCallback);
    }
    hasOnlyOneValueToPaste(parsedData) {
        return parsedData.length === 1 && parsedData[0].length === 1;
    }
    copyRangeDown() {
        if (!this.rangeService || this.rangeService.isEmpty()) {
            return;
        }
        const firstRowValues = [];
        const pasteOperation = (cellsToFlash, updatedRowNodes, focusedCell, changedPath) => {
            const processCellForClipboardFunc = this.gridOptionsService.getCallback('processCellForClipboard');
            const processCellFromClipboardFunc = this.gridOptionsService.getCallback('processCellFromClipboard');
            const rowCallback = (currentRow, rowNode, columns) => {
                // take reference of first row, this is the one we will be using to copy from
                if (!firstRowValues.length) {
                    // two reasons for looping through columns
                    columns.forEach(column => {
                        // get the initial values to copy down
                        const value = this.processCell(rowNode, column, this.valueService.getValue(column, rowNode), EXPORT_TYPE_DRAG_COPY, processCellForClipboardFunc, false, true);
                        firstRowValues.push(value);
                    });
                }
                else {
                    // otherwise we are not the first row, so copy
                    updatedRowNodes.push(rowNode);
                    columns.forEach((column, index) => {
                        if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) {
                            return;
                        }
                        const firstRowValue = this.processCell(rowNode, column, firstRowValues[index], EXPORT_TYPE_DRAG_COPY, processCellFromClipboardFunc, true);
                        rowNode.setDataValue(column, firstRowValue, SOURCE_PASTE);
                        if (changedPath) {
                            changedPath.addParentNode(rowNode.parent, [column]);
                        }
                        const { rowIndex, rowPinned } = currentRow;
                        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });
                        cellsToFlash[cellId] = true;
                    });
                }
            };
            this.iterateActiveRanges(true, rowCallback);
        };
        this.doPasteOperation(pasteOperation);
    }
    removeLastLineIfBlank(parsedData) {
        // remove last row if empty, excel puts empty last row in
        const lastLine = _.last(parsedData);
        const lastLineIsBlank = lastLine && lastLine.length === 1 && lastLine[0] === '';
        if (lastLineIsBlank) {
            // do not remove the last empty line when that is the only line pasted
            if (parsedData.length === 1) {
                return;
            }
            _.removeFromArray(parsedData, lastLine);
        }
    }
    fireRowChanged(rowNodes) {
        if (this.gridOptionsService.get('editType') !== 'fullRow') {
            return;
        }
        rowNodes.forEach(rowNode => {
            const event = {
                type: Events.EVENT_ROW_VALUE_CHANGED,
                node: rowNode,
                data: rowNode.data,
                rowIndex: rowNode.rowIndex,
                rowPinned: rowNode.rowPinned
            };
            this.eventService.dispatchEvent(event);
        });
    }
    pasteMultipleValues(clipboardGridData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, type, changedPath) {
        let rowPointer = currentRow;
        // if doing CSRM and NOT tree data, then it means groups are aggregates, which are read only,
        // so we should skip them when doing paste operations.
        const skipGroupRows = this.clientSideRowModel != null && !this.gridOptionsService.get('enableGroupEdit') && !this.gridOptionsService.get('treeData');
        const getNextGoodRowNode = () => {
            while (true) {
                if (!rowPointer) {
                    return null;
                }
                const res = this.rowPositionUtils.getRowNode(rowPointer);
                // move to next row down for next set of values
                rowPointer = this.cellNavigationService.getRowBelow({ rowPinned: rowPointer.rowPinned, rowIndex: rowPointer.rowIndex });
                // if no more rows, return null
                if (res == null) {
                    return null;
                }
                // skip details rows and footer rows, never paste into them as they don't hold data
                const skipRow = res.detail || res.footer || (skipGroupRows && res.group);
                // skipping row means we go into the next iteration of the while loop
                if (!skipRow) {
                    return res;
                }
            }
        };
        clipboardGridData.forEach(clipboardRowData => {
            const rowNode = getNextGoodRowNode();
            // if we have come to end of rows in grid, then skip
            if (!rowNode) {
                return;
            }
            clipboardRowData.forEach((value, index) => this.updateCellValue(rowNode, columnsToPasteInto[index], value, cellsToFlash, type, changedPath));
            updatedRowNodes.push(rowNode);
        });
    }
    updateCellValue(rowNode, column, value, cellsToFlash, type, changedPath) {
        if (!rowNode ||
            !column ||
            !column.isCellEditable(rowNode) ||
            column.isSuppressPaste(rowNode)) {
            return;
        }
        // if the cell is a group and the col is an aggregation, skip the cell.
        if (rowNode.group && column.isValueActive()) {
            return;
        }
        const processedValue = this.processCell(rowNode, column, value, type, this.gridOptionsService.getCallback('processCellFromClipboard'), true);
        rowNode.setDataValue(column, processedValue, SOURCE_PASTE);
        const { rowIndex, rowPinned } = rowNode;
        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex: rowIndex, column, rowPinned });
        cellsToFlash[cellId] = true;
        if (changedPath) {
            changedPath.addParentNode(rowNode.parent, [column]);
        }
    }
    copyToClipboard(params = {}) {
        this.copyOrCutToClipboard(params);
    }
    cutToClipboard(params = {}, source = 'api') {
        if (this.gridOptionsService.get('suppressCutToClipboard')) {
            return;
        }
        const startEvent = {
            type: Events.EVENT_CUT_START,
            source
        };
        this.eventService.dispatchEvent(startEvent);
        this.copyOrCutToClipboard(params, true);
        const endEvent = {
            type: Events.EVENT_CUT_END,
            source
        };
        this.eventService.dispatchEvent(endEvent);
    }
    copyOrCutToClipboard(params, cut) {
        let { includeHeaders, includeGroupHeaders } = params;
        this.logger.log(`copyToClipboard: includeHeaders = ${includeHeaders}`);
        // don't override 'includeHeaders' if it has been explicitly set to 'false'
        if (includeHeaders == null) {
            includeHeaders = this.gridOptionsService.get('copyHeadersToClipboard');
        }
        if (includeGroupHeaders == null) {
            includeGroupHeaders = this.gridOptionsService.get('copyGroupHeadersToClipboard');
        }
        const copyParams = { includeHeaders, includeGroupHeaders };
        const shouldCopyRows = !this.gridOptionsService.get('suppressCopyRowsToClipboard');
        let cellClearType = null;
        // Copy priority is Range > Row > Focus
        if (this.rangeService && !this.rangeService.isEmpty() && !this.shouldSkipSingleCellRange()) {
            this.copySelectedRangeToClipboard(copyParams);
            cellClearType = CellClearType.CellRange;
        }
        else if (shouldCopyRows && !this.selectionService.isEmpty()) {
            this.copySelectedRowsToClipboard(copyParams);
            cellClearType = CellClearType.SelectedRows;
        }
        else if (this.focusService.isAnyCellFocused()) {
            this.copyFocusedCellToClipboard(copyParams);
            cellClearType = CellClearType.FocusedCell;
        }
        if (cut && cellClearType !== null) {
            this.clearCellsAfterCopy(cellClearType);
        }
    }
    clearCellsAfterCopy(type) {
        this.eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START });
        if (type === CellClearType.CellRange) {
            this.rangeService.clearCellRangeCellValues({ cellEventSource: 'clipboardService' });
        }
        else if (type === CellClearType.SelectedRows) {
            this.clearSelectedRows();
        }
        else {
            const focusedCell = this.focusService.getFocusedCell();
            if (focusedCell == null) {
                return;
            }
            const rowNode = this.rowPositionUtils.getRowNode(focusedCell);
            if (rowNode) {
                this.clearCellValue(rowNode, focusedCell.column);
            }
        }
        this.eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END });
    }
    clearSelectedRows() {
        const selected = this.selectionService.getSelectedNodes();
        const columns = this.columnModel.getAllDisplayedColumns();
        for (const row of selected) {
            for (const col of columns) {
                this.clearCellValue(row, col);
            }
        }
    }
    clearCellValue(rowNode, column) {
        if (!column.isCellEditable(rowNode)) {
            return;
        }
        rowNode.setDataValue(column, null, 'clipboardService');
    }
    shouldSkipSingleCellRange() {
        return this.gridOptionsService.get('suppressCopySingleCellRanges') && !this.rangeService.isMoreThanOneCell();
    }
    iterateActiveRanges(onlyFirst, rowCallback, columnCallback) {
        if (!this.rangeService || this.rangeService.isEmpty()) {
            return;
        }
        const cellRanges = this.rangeService.getCellRanges();
        if (onlyFirst) {
            this.iterateActiveRange(cellRanges[0], rowCallback, columnCallback, true);
        }
        else {
            cellRanges.forEach((range, idx) => this.iterateActiveRange(range, rowCallback, columnCallback, idx === cellRanges.length - 1));
        }
    }
    iterateActiveRange(range, rowCallback, columnCallback, isLastRange) {
        if (!this.rangeService) {
            return;
        }
        let currentRow = this.rangeService.getRangeStartRow(range);
        const lastRow = this.rangeService.getRangeEndRow(range);
        if (columnCallback && range.columns) {
            columnCallback(range.columns);
        }
        let rangeIndex = 0;
        let isLastRow = false;
        // the currentRow could be missing if the user sets the active range manually, and sets a range
        // that is outside of the grid (eg. sets range rows 0 to 100, but grid has only 20 rows).
        while (!isLastRow && currentRow != null) {
            const rowNode = this.rowPositionUtils.getRowNode(currentRow);
            isLastRow = this.rowPositionUtils.sameRow(currentRow, lastRow);
            rowCallback(currentRow, rowNode, range.columns, rangeIndex++, isLastRow && isLastRange);
            currentRow = this.cellNavigationService.getRowBelow(currentRow);
        }
    }
    copySelectedRangeToClipboard(params = {}) {
        if (!this.rangeService || this.rangeService.isEmpty()) {
            return;
        }
        const allRangesMerge = this.rangeService.areAllRangesAbleToMerge();
        const { data, cellsToFlash } = allRangesMerge ? this.buildDataFromMergedRanges(params) : this.buildDataFromRanges(params);
        this.copyDataToClipboard(data);
        this.dispatchFlashCells(cellsToFlash);
    }
    buildDataFromMergedRanges(params) {
        const columnsSet = new Set();
        const ranges = this.rangeService.getCellRanges();
        const rowPositionsMap = new Map();
        const allRowPositions = [];
        const allCellsToFlash = {};
        ranges.forEach(range => {
            range.columns.forEach(col => columnsSet.add(col));
            const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(range);
            rowPositions.forEach(rowPosition => {
                const rowPositionAsString = `${rowPosition.rowIndex}-${rowPosition.rowPinned || 'null'}`;
                if (!rowPositionsMap.get(rowPositionAsString)) {
                    rowPositionsMap.set(rowPositionAsString, true);
                    allRowPositions.push(rowPosition);
                }
            });
            Object.assign(allCellsToFlash, cellsToFlash);
        });
        const allColumns = this.columnModel.getAllDisplayedColumns();
        const exportedColumns = Array.from(columnsSet);
        exportedColumns.sort((a, b) => {
            const posA = allColumns.indexOf(a);
            const posB = allColumns.indexOf(b);
            return posA - posB;
        });
        const data = this.buildExportParams({
            columns: exportedColumns,
            rowPositions: allRowPositions,
            includeHeaders: params.includeHeaders,
            includeGroupHeaders: params.includeGroupHeaders,
        });
        return { data, cellsToFlash: allCellsToFlash };
    }
    buildDataFromRanges(params) {
        const ranges = this.rangeService.getCellRanges();
        const data = [];
        const allCellsToFlash = {};
        ranges.forEach(range => {
            const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(range);
            Object.assign(allCellsToFlash, cellsToFlash);
            data.push(this.buildExportParams({
                columns: range.columns,
                rowPositions: rowPositions,
                includeHeaders: params.includeHeaders,
                includeGroupHeaders: params.includeGroupHeaders,
            }));
        });
        return { data: data.join('\n'), cellsToFlash: allCellsToFlash };
    }
    getRangeRowPositionsAndCellsToFlash(range) {
        const rowPositions = [];
        const cellsToFlash = {};
        const startRow = this.rangeService.getRangeStartRow(range);
        const lastRow = this.rangeService.getRangeEndRow(range);
        let node = startRow;
        while (node) {
            rowPositions.push(node);
            range.columns.forEach(column => {
                const { rowIndex, rowPinned } = node;
                const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });
                cellsToFlash[cellId] = true;
            });
            if (this.rowPositionUtils.sameRow(node, lastRow)) {
                break;
            }
            node = this.cellNavigationService.getRowBelow(node);
        }
        return { rowPositions, cellsToFlash };
    }
    getCellsToFlashFromRowNodes(rowNodes) {
        const allDisplayedColumns = this.columnModel.getAllDisplayedColumns();
        const cellsToFlash = {};
        for (let i = 0; i < rowNodes.length; i++) {
            const { rowIndex, rowPinned } = rowNodes[i];
            if (rowIndex == null) {
                continue;
            }
            for (let j = 0; j < allDisplayedColumns.length; j++) {
                const column = allDisplayedColumns[j];
                const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });
                cellsToFlash[cellId] = true;
            }
        }
        return cellsToFlash;
    }
    copyFocusedCellToClipboard(params = {}) {
        const focusedCell = this.focusService.getFocusedCell();
        if (focusedCell == null) {
            return;
        }
        const cellId = this.cellPositionUtils.createId(focusedCell);
        const currentRow = { rowPinned: focusedCell.rowPinned, rowIndex: focusedCell.rowIndex };
        const column = focusedCell.column;
        const data = this.buildExportParams({
            columns: [column],
            rowPositions: [currentRow],
            includeHeaders: params.includeHeaders,
            includeGroupHeaders: params.includeGroupHeaders
        });
        this.copyDataToClipboard(data);
        this.dispatchFlashCells({ [cellId]: true });
    }
    copySelectedRowsToClipboard(params = {}) {
        const { columnKeys, includeHeaders, includeGroupHeaders } = params;
        const data = this.buildExportParams({
            columns: columnKeys,
            includeHeaders,
            includeGroupHeaders
        });
        this.copyDataToClipboard(data);
        const rowNodes = this.selectionService.getSelectedNodes() || [];
        this.dispatchFlashCells(this.getCellsToFlashFromRowNodes(rowNodes));
    }
    buildExportParams(params) {
        const { columns, rowPositions, includeHeaders = false, includeGroupHeaders = false } = params;
        const exportParams = {
            columnKeys: columns,
            rowPositions,
            skipColumnHeaders: !includeHeaders,
            skipColumnGroupHeaders: !includeGroupHeaders,
            suppressQuotes: true,
            columnSeparator: this.getClipboardDelimiter(),
            onlySelected: !rowPositions,
            processCellCallback: this.gridOptionsService.getCallback('processCellForClipboard'),
            processRowGroupCallback: (params) => this.processRowGroupCallback(params),
            processHeaderCallback: this.gridOptionsService.getCallback('processHeaderForClipboard'),
            processGroupHeaderCallback: this.gridOptionsService.getCallback('processGroupHeaderForClipboard')
        };
        return this.csvCreator.getDataAsCsv(exportParams, true);
    }
    processRowGroupCallback(params) {
        const { node, column } = params;
        const isTreeData = this.gridOptionsService.get('treeData');
        const isSuppressGroupMaintainValueType = this.gridOptionsService.get('suppressGroupMaintainValueType');
        // if not tree data and not suppressGroupMaintainValueType then we get the value from the group data
        const getValueFromNode = () => {
            var _a, _b;
            if (isTreeData || isSuppressGroupMaintainValueType || !column) {
                return node.key;
            }
            const value = (_a = node.groupData) === null || _a === void 0 ? void 0 : _a[column.getId()];
            if (!value || !node.rowGroupColumn || node.rowGroupColumn.getColDef().useValueFormatterForExport === false) {
                return value;
            }
            return (_b = this.valueFormatterService.formatValue(node.rowGroupColumn, node, value)) !== null && _b !== void 0 ? _b : value;
        };
        let value = getValueFromNode();
        if (params.node.footer) {
            let suffix = '';
            if (value && value.length) {
                suffix = ` ${value}`;
            }
            value = `Total${suffix}`;
        }
        const processCellForClipboard = this.gridOptionsService.getCallback('processCellForClipboard');
        if (processCellForClipboard) {
            let column = node.rowGroupColumn;
            if (!column && node.footer && node.level === -1) {
                column = this.columnModel.getRowGroupColumns()[0];
            }
            return processCellForClipboard({
                value,
                node,
                column,
                type: 'clipboard',
                formatValue: (valueToFormat) => { var _a; return (_a = this.valueFormatterService.formatValue(column, node, valueToFormat)) !== null && _a !== void 0 ? _a : valueToFormat; },
                parseValue: (valueToParse) => this.valueParserService.parseValue(column, node, valueToParse, this.valueService.getValue(column, node))
            });
        }
        return value;
    }
    dispatchFlashCells(cellsToFlash) {
        window.setTimeout(() => {
            const event = {
                type: Events.EVENT_FLASH_CELLS,
                cells: cellsToFlash
            };
            this.eventService.dispatchEvent(event);
        }, 0);
    }
    processCell(rowNode, column, value, type, func, canParse, canFormat) {
        var _a;
        if (func) {
            const params = {
                column,
                node: rowNode,
                value,
                type,
                formatValue: (valueToFormat) => { var _a; return (_a = this.valueFormatterService.formatValue(column, rowNode !== null && rowNode !== void 0 ? rowNode : null, valueToFormat)) !== null && _a !== void 0 ? _a : valueToFormat; },
                parseValue: (valueToParse) => this.valueParserService.parseValue(column, rowNode !== null && rowNode !== void 0 ? rowNode : null, valueToParse, this.valueService.getValue(column, rowNode))
            };
            return func(params);
        }
        if (canParse && column.getColDef().useValueParserForImport !== false) {
            return this.valueParserService.parseValue(column, rowNode !== null && rowNode !== void 0 ? rowNode : null, value, this.valueService.getValue(column, rowNode));
        }
        else if (canFormat && column.getColDef().useValueFormatterForExport !== false) {
            return (_a = this.valueFormatterService.formatValue(column, rowNode !== null && rowNode !== void 0 ? rowNode : null, value)) !== null && _a !== void 0 ? _a : value;
        }
        return value;
    }
    copyDataToClipboard(data) {
        const userProvidedFunc = this.gridOptionsService.getCallback('sendToClipboard');
        // method 1 - user provided func
        if (userProvidedFunc) {
            userProvidedFunc({ data });
            return;
        }
        // method 2 - native clipboard API, available in modern chrome browsers
        const allowNavigator = !this.gridOptionsService.get('suppressClipboardApi');
        if (allowNavigator && navigator.clipboard) {
            navigator.clipboard.writeText(data).catch((e) => {
                _.doOnce(() => {
                    console.warn(e);
                    console.warn(apiError('writeText'));
                }, 'clipboardApiError');
                this.copyDataToClipboardLegacy(data);
            });
            return;
        }
        this.copyDataToClipboardLegacy(data);
    }
    copyDataToClipboardLegacy(data) {
        // method 3 - if all else fails, the old school hack
        this.executeOnTempElement(element => {
            const eDocument = this.gridOptionsService.getDocument();
            const focusedElementBefore = eDocument.activeElement;
            element.value = data || ' '; // has to be non-empty value or execCommand will not do anything
            element.select();
            element.focus({ preventScroll: true });
            const result = eDocument.execCommand('copy');
            if (!result) {
                console.warn('AG Grid: Browser did not allow document.execCommand(\'copy\'). Ensure ' +
                    'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise ' +
                    'the browser will prevent it for security reasons.');
            }
            if (focusedElementBefore != null && focusedElementBefore.focus != null) {
                focusedElementBefore.focus({ preventScroll: true });
            }
        });
    }
    executeOnTempElement(callbackNow, callbackAfter) {
        const eDoc = this.gridOptionsService.getDocument();
        const eTempInput = eDoc.createElement('textarea');
        eTempInput.style.width = '1px';
        eTempInput.style.height = '1px';
        // removing items from the DOM causes the document element to scroll to the
        // position where the element was positioned. Here we set scrollTop / scrollLeft
        // to prevent the document element from scrolling when we remove it from the DOM.
        eTempInput.style.top = eDoc.documentElement.scrollTop + 'px';
        eTempInput.style.left = eDoc.documentElement.scrollLeft + 'px';
        eTempInput.style.position = 'absolute';
        eTempInput.style.opacity = '0';
        const guiRoot = this.gridCtrl.getGui();
        guiRoot.appendChild(eTempInput);
        try {
            callbackNow(eTempInput);
        }
        catch (err) {
            console.warn('AG Grid: Browser does not support document.execCommand(\'copy\') for clipboard operations');
        }
        //It needs 100 otherwise OS X seemed to not always be able to paste... Go figure...
        if (callbackAfter) {
            window.setTimeout(() => {
                callbackAfter(eTempInput);
                guiRoot.removeChild(eTempInput);
            }, 100);
        }
        else {
            guiRoot.removeChild(eTempInput);
        }
    }
    getRangeSize() {
        const ranges = this.rangeService.getCellRanges();
        let startRangeIndex = 0;
        let endRangeIndex = 0;
        if (ranges.length > 0) {
            startRangeIndex = this.rangeService.getRangeStartRow(ranges[0]).rowIndex;
            endRangeIndex = this.rangeService.getRangeEndRow(ranges[0]).rowIndex;
        }
        return startRangeIndex - endRangeIndex + 1;
    }
};
__decorate$_([
    Autowired('csvCreator')
], ClipboardService.prototype, "csvCreator", void 0);
__decorate$_([
    Autowired('loggerFactory')
], ClipboardService.prototype, "loggerFactory", void 0);
__decorate$_([
    Autowired('selectionService')
], ClipboardService.prototype, "selectionService", void 0);
__decorate$_([
    Optional('rangeService')
], ClipboardService.prototype, "rangeService", void 0);
__decorate$_([
    Autowired('rowModel')
], ClipboardService.prototype, "rowModel", void 0);
__decorate$_([
    Autowired('ctrlsService')
], ClipboardService.prototype, "ctrlsService", void 0);
__decorate$_([
    Autowired('valueService')
], ClipboardService.prototype, "valueService", void 0);
__decorate$_([
    Autowired('focusService')
], ClipboardService.prototype, "focusService", void 0);
__decorate$_([
    Autowired('rowRenderer')
], ClipboardService.prototype, "rowRenderer", void 0);
__decorate$_([
    Autowired('columnModel')
], ClipboardService.prototype, "columnModel", void 0);
__decorate$_([
    Autowired('cellNavigationService')
], ClipboardService.prototype, "cellNavigationService", void 0);
__decorate$_([
    Autowired('cellPositionUtils')
], ClipboardService.prototype, "cellPositionUtils", void 0);
__decorate$_([
    Autowired('rowPositionUtils')
], ClipboardService.prototype, "rowPositionUtils", void 0);
__decorate$_([
    Autowired('valueFormatterService')
], ClipboardService.prototype, "valueFormatterService", void 0);
__decorate$_([
    Autowired('valueParserService')
], ClipboardService.prototype, "valueParserService", void 0);
__decorate$_([
    PostConstruct
], ClipboardService.prototype, "init", null);
ClipboardService = ClipboardService_1 = __decorate$_([
    Bean('clipboardService')
], ClipboardService);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$6 = '31.1.1';

const ClipboardModule = {
    version: VERSION$6,
    moduleName: ModuleNames.ClipboardModule,
    beans: [ClipboardService],
    dependantModules: [
        EnterpriseCoreModule,
        CsvExportModule
    ]
};

var __decorate$$ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ExpandState;
(function (ExpandState) {
    ExpandState[ExpandState["EXPANDED"] = 0] = "EXPANDED";
    ExpandState[ExpandState["COLLAPSED"] = 1] = "COLLAPSED";
    ExpandState[ExpandState["INDETERMINATE"] = 2] = "INDETERMINATE";
})(ExpandState || (ExpandState = {}));
class PrimaryColsHeaderPanel extends Component {
    constructor() {
        super(PrimaryColsHeaderPanel.TEMPLATE);
    }
    postConstruct() {
        this.createExpandIcons();
        this.addManagedListener(this.eExpand, 'click', this.onExpandClicked.bind(this));
        this.addManagedListener(this.eExpand, 'keydown', (e) => {
            if (e.key === KeyCode.SPACE) {
                e.preventDefault();
                this.onExpandClicked();
            }
        });
        this.addManagedListener(this.eSelect.getInputElement(), 'click', this.onSelectClicked.bind(this));
        this.addManagedPropertyListener('functionsReadOnly', () => this.onFunctionsReadOnlyPropChanged());
        this.eFilterTextField
            .setAutoComplete(false)
            .onValueChange(() => this.onFilterTextChanged());
        this.addManagedListener(this.eFilterTextField.getInputElement(), 'keydown', this.onMiniFilterKeyDown.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.showOrHideOptions.bind(this));
        const translate = this.localeService.getLocaleTextFunc();
        this.eSelect.setInputAriaLabel(translate('ariaColumnSelectAll', 'Toggle Select All Columns'));
        this.eFilterTextField.setInputAriaLabel(translate('ariaFilterColumnsInput', 'Filter Columns Input'));
        this.activateTabIndex([this.eExpand]);
    }
    onFunctionsReadOnlyPropChanged() {
        const readOnly = this.gridOptionsService.get('functionsReadOnly');
        this.eSelect.setReadOnly(readOnly);
        this.eSelect.addOrRemoveCssClass('ag-column-select-column-readonly', readOnly);
    }
    init(params) {
        this.params = params;
        const readOnly = this.gridOptionsService.get('functionsReadOnly');
        this.eSelect.setReadOnly(readOnly);
        this.eSelect.addOrRemoveCssClass('ag-column-select-column-readonly', readOnly);
        if (this.columnModel.isReady()) {
            this.showOrHideOptions();
        }
    }
    createExpandIcons() {
        this.eExpand.appendChild((this.eExpandChecked = _.createIconNoSpan('columnSelectOpen', this.gridOptionsService)));
        this.eExpand.appendChild((this.eExpandUnchecked = _.createIconNoSpan('columnSelectClosed', this.gridOptionsService)));
        this.eExpand.appendChild((this.eExpandIndeterminate = _.createIconNoSpan('columnSelectIndeterminate', this.gridOptionsService)));
        this.setExpandState(ExpandState.EXPANDED);
    }
    // we only show expand / collapse if we are showing columns
    showOrHideOptions() {
        const showFilter = !this.params.suppressColumnFilter;
        const showSelect = !this.params.suppressColumnSelectAll;
        const showExpand = !this.params.suppressColumnExpandAll;
        const groupsPresent = this.columnModel.isPrimaryColumnGroupsPresent();
        const translate = this.localeService.getLocaleTextFunc();
        this.eFilterTextField.setInputPlaceholder(translate('searchOoo', 'Search...'));
        _.setDisplayed(this.eFilterTextField.getGui(), showFilter);
        _.setDisplayed(this.eSelect.getGui(), showSelect);
        _.setDisplayed(this.eExpand, showExpand && groupsPresent);
    }
    onFilterTextChanged() {
        if (!this.onFilterTextChangedDebounced) {
            this.onFilterTextChangedDebounced = _.debounce(() => {
                const filterText = this.eFilterTextField.getValue();
                this.dispatchEvent({ type: "filterChanged", filterText: filterText });
            }, PrimaryColsHeaderPanel.DEBOUNCE_DELAY);
        }
        this.onFilterTextChangedDebounced();
    }
    onMiniFilterKeyDown(e) {
        if (e.key === KeyCode.ENTER) {
            // we need to add a delay that corresponds to the filter text debounce delay to ensure
            // the text filtering has happened, otherwise all columns will be deselected
            setTimeout(() => this.onSelectClicked(), PrimaryColsHeaderPanel.DEBOUNCE_DELAY);
        }
    }
    onSelectClicked() {
        this.dispatchEvent({ type: this.selectState ? 'unselectAll' : 'selectAll' });
    }
    onExpandClicked() {
        this.dispatchEvent({ type: this.expandState === ExpandState.EXPANDED ? 'collapseAll' : 'expandAll' });
    }
    setExpandState(state) {
        this.expandState = state;
        _.setDisplayed(this.eExpandChecked, this.expandState === ExpandState.EXPANDED);
        _.setDisplayed(this.eExpandUnchecked, this.expandState === ExpandState.COLLAPSED);
        _.setDisplayed(this.eExpandIndeterminate, this.expandState === ExpandState.INDETERMINATE);
    }
    setSelectionState(state) {
        this.selectState = state;
        this.eSelect.setValue(this.selectState);
    }
}
PrimaryColsHeaderPanel.DEBOUNCE_DELAY = 300;
PrimaryColsHeaderPanel.TEMPLATE = `<div class="ag-column-select-header" role="presentation">
            <div ref="eExpand" class="ag-column-select-header-icon"></div>
            <ag-checkbox ref="eSelect" class="ag-column-select-header-checkbox"></ag-checkbox>
            <ag-input-text-field class="ag-column-select-header-filter-wrapper" ref="eFilterTextField"></ag-input-text-field>
        </div>`;
__decorate$$([
    Autowired('columnModel')
], PrimaryColsHeaderPanel.prototype, "columnModel", void 0);
__decorate$$([
    RefSelector('eExpand')
], PrimaryColsHeaderPanel.prototype, "eExpand", void 0);
__decorate$$([
    RefSelector('eSelect')
], PrimaryColsHeaderPanel.prototype, "eSelect", void 0);
__decorate$$([
    RefSelector('eFilterTextField')
], PrimaryColsHeaderPanel.prototype, "eFilterTextField", void 0);
__decorate$$([
    PostConstruct
], PrimaryColsHeaderPanel.prototype, "postConstruct", null);

class ColumnModelItem {
    constructor(displayName, columnOrGroup, dept, group = false, expanded) {
        this.eventService = new EventService();
        this.displayName = displayName;
        this.dept = dept;
        this.group = group;
        if (group) {
            this.columnGroup = columnOrGroup;
            this.expanded = expanded;
            this.children = [];
        }
        else {
            this.column = columnOrGroup;
        }
    }
    isGroup() { return this.group; }
    getDisplayName() { return this.displayName; }
    getColumnGroup() { return this.columnGroup; }
    getColumn() { return this.column; }
    getDept() { return this.dept; }
    isExpanded() { return !!this.expanded; }
    getChildren() { return this.children; }
    isPassesFilter() { return this.passesFilter; }
    setExpanded(expanded) {
        if (expanded === this.expanded) {
            return;
        }
        this.expanded = expanded;
        this.eventService.dispatchEvent({ type: ColumnModelItem.EVENT_EXPANDED_CHANGED });
    }
    setPassesFilter(passesFilter) {
        this.passesFilter = passesFilter;
    }
    addEventListener(eventType, listener) {
        this.eventService.addEventListener(eventType, listener);
    }
    removeEventListener(eventType, listener) {
        this.eventService.removeEventListener(eventType, listener);
    }
}
ColumnModelItem.EVENT_EXPANDED_CHANGED = 'expandedChanged';

var __decorate$10 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ToolPanelContextMenu extends Component {
    constructor(column, mouseEvent, parentEl) {
        super(/* html */ `<div class="ag-menu"></div>`);
        this.column = column;
        this.mouseEvent = mouseEvent;
        this.parentEl = parentEl;
        this.displayName = null;
    }
    postConstruct() {
        this.initializeProperties(this.column);
        this.buildMenuItemMap();
        if (this.column instanceof Column) {
            this.displayName = this.columnModel.getDisplayNameForColumn(this.column, 'columnToolPanel');
        }
        else {
            this.displayName = this.columnModel.getDisplayNameForProvidedColumnGroup(null, this.column, 'columnToolPanel');
        }
        if (this.isActive()) {
            this.mouseEvent.preventDefault();
            const menuItemsMapped = this.getMappedMenuItems();
            if (menuItemsMapped.length === 0) {
                return;
            }
            this.displayContextMenu(menuItemsMapped);
        }
    }
    initializeProperties(column) {
        if (column instanceof ProvidedColumnGroup) {
            this.columns = column.getLeafColumns();
        }
        else {
            this.columns = [column];
        }
        this.allowGrouping = this.columns.some(col => col.isPrimary() && col.isAllowRowGroup());
        this.allowValues = this.columns.some(col => col.isPrimary() && col.isAllowValue());
        this.allowPivoting = this.columnModel.isPivotMode() && this.columns.some(col => col.isPrimary() && col.isAllowPivot());
    }
    buildMenuItemMap() {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        this.menuItemMap = new Map();
        this.menuItemMap.set('rowGroup', {
            allowedFunction: (col) => col.isPrimary() && col.isAllowRowGroup() && !this.columnModel.isColumnGroupingLocked(col),
            activeFunction: (col) => col.isRowGroupActive(),
            activateLabel: () => `${localeTextFunc('groupBy', 'Group by')} ${this.displayName}`,
            deactivateLabel: () => `${localeTextFunc('ungroupBy', 'Un-Group by')} ${this.displayName}`,
            activateFunction: () => {
                const groupedColumns = this.columnModel.getRowGroupColumns();
                this.columnModel.setRowGroupColumns(this.addColumnsToList(groupedColumns), "toolPanelUi");
            },
            deActivateFunction: () => {
                const groupedColumns = this.columnModel.getRowGroupColumns();
                this.columnModel.setRowGroupColumns(this.removeColumnsFromList(groupedColumns), "toolPanelUi");
            },
            addIcon: 'menuAddRowGroup',
            removeIcon: 'menuRemoveRowGroup'
        });
        this.menuItemMap.set('value', {
            allowedFunction: (col) => col.isPrimary() && col.isAllowValue(),
            activeFunction: (col) => col.isValueActive(),
            activateLabel: () => localeTextFunc('addToValues', `Add ${this.displayName} to values`, [this.displayName]),
            deactivateLabel: () => localeTextFunc('removeFromValues', `Remove ${this.displayName} from values`, [this.displayName]),
            activateFunction: () => {
                const valueColumns = this.columnModel.getValueColumns();
                this.columnModel.setValueColumns(this.addColumnsToList(valueColumns), "toolPanelUi");
            },
            deActivateFunction: () => {
                const valueColumns = this.columnModel.getValueColumns();
                this.columnModel.setValueColumns(this.removeColumnsFromList(valueColumns), "toolPanelUi");
            },
            addIcon: 'valuePanel',
            removeIcon: 'valuePanel'
        });
        this.menuItemMap.set('pivot', {
            allowedFunction: (col) => this.columnModel.isPivotMode() && col.isPrimary() && col.isAllowPivot(),
            activeFunction: (col) => col.isPivotActive(),
            activateLabel: () => localeTextFunc('addToLabels', `Add ${this.displayName} to labels`, [this.displayName]),
            deactivateLabel: () => localeTextFunc('removeFromLabels', `Remove ${this.displayName} from labels`, [this.displayName]),
            activateFunction: () => {
                const pivotColumns = this.columnModel.getPivotColumns();
                this.columnModel.setPivotColumns(this.addColumnsToList(pivotColumns), "toolPanelUi");
            },
            deActivateFunction: () => {
                const pivotColumns = this.columnModel.getPivotColumns();
                this.columnModel.setPivotColumns(this.removeColumnsFromList(pivotColumns), "toolPanelUi");
            },
            addIcon: 'pivotPanel',
            removeIcon: 'pivotPanel'
        });
    }
    addColumnsToList(columnList) {
        return [...columnList].concat(this.columns.filter(col => columnList.indexOf(col) === -1));
    }
    removeColumnsFromList(columnList) {
        return columnList.filter(col => this.columns.indexOf(col) === -1);
    }
    displayContextMenu(menuItemsMapped) {
        const eGui = this.getGui();
        const menuList = this.createBean(new AgMenuList());
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        let hideFunc = () => { };
        eGui.appendChild(menuList.getGui());
        menuList.addMenuItems(menuItemsMapped);
        menuList.addManagedListener(menuList, AgMenuItemComponent.EVENT_CLOSE_MENU, () => {
            this.parentEl.focus();
            hideFunc();
        });
        const addPopupRes = this.popupService.addPopup({
            modal: true,
            eChild: eGui,
            closeOnEsc: true,
            afterGuiAttached: () => this.focusService.focusInto(menuList.getGui()),
            ariaLabel: localeTextFunc('ariaLabelContextMenu', 'Context Menu'),
            closedCallback: (e) => {
                if (e instanceof KeyboardEvent) {
                    this.parentEl.focus();
                }
                this.destroyBean(menuList);
            }
        });
        if (addPopupRes) {
            hideFunc = addPopupRes.hideFunc;
        }
        this.popupService.positionPopupUnderMouseEvent({
            type: 'columnContextMenu',
            mouseEvent: this.mouseEvent,
            ePopup: eGui
        });
    }
    isActive() {
        return this.allowGrouping || this.allowValues || this.allowPivoting;
    }
    getMappedMenuItems() {
        const ret = [];
        for (const val of this.menuItemMap.values()) {
            const isInactive = this.columns.some(col => val.allowedFunction(col) && !val.activeFunction(col));
            const isActive = this.columns.some(col => val.allowedFunction(col) && val.activeFunction(col));
            if (isInactive) {
                ret.push({
                    name: val.activateLabel(this.displayName),
                    icon: _.createIconNoSpan(val.addIcon, this.gridOptionsService, null),
                    action: () => val.activateFunction()
                });
            }
            if (isActive) {
                ret.push({
                    name: val.deactivateLabel(this.displayName),
                    icon: _.createIconNoSpan(val.removeIcon, this.gridOptionsService, null),
                    action: () => val.deActivateFunction()
                });
            }
        }
        return ret;
    }
}
__decorate$10([
    Autowired('columnModel')
], ToolPanelContextMenu.prototype, "columnModel", void 0);
__decorate$10([
    Autowired('popupService')
], ToolPanelContextMenu.prototype, "popupService", void 0);
__decorate$10([
    Autowired('focusService')
], ToolPanelContextMenu.prototype, "focusService", void 0);
__decorate$10([
    PostConstruct
], ToolPanelContextMenu.prototype, "postConstruct", null);

var __decorate$11 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ToolPanelColumnGroupComp extends Component {
    constructor(modelItem, allowDragging, eventType, focusWrapper) {
        super();
        this.modelItem = modelItem;
        this.allowDragging = allowDragging;
        this.eventType = eventType;
        this.focusWrapper = focusWrapper;
        this.processingColumnStateChange = false;
        this.modelItem = modelItem;
        this.columnGroup = modelItem.getColumnGroup();
        this.columnDept = modelItem.getDept();
        this.displayName = modelItem.getDisplayName();
        this.allowDragging = allowDragging;
    }
    init() {
        this.setTemplate(ToolPanelColumnGroupComp.TEMPLATE);
        this.eDragHandle = _.createIconNoSpan('columnDrag', this.gridOptionsService);
        this.eDragHandle.classList.add('ag-drag-handle', 'ag-column-select-column-group-drag-handle');
        const checkboxGui = this.cbSelect.getGui();
        const checkboxInput = this.cbSelect.getInputElement();
        checkboxGui.insertAdjacentElement('afterend', this.eDragHandle);
        checkboxInput.setAttribute('tabindex', '-1');
        this.eLabel.innerHTML = this.displayName ? this.displayName : '';
        this.setupExpandContract();
        this.addCssClass('ag-column-select-indent-' + this.columnDept);
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this));
        this.addManagedListener(this.eLabel, 'click', this.onLabelClicked.bind(this));
        this.addManagedListener(this.cbSelect, Events.EVENT_FIELD_VALUE_CHANGED, this.onCheckboxChanged.bind(this));
        this.addManagedListener(this.modelItem, ColumnModelItem.EVENT_EXPANDED_CHANGED, this.onExpandChanged.bind(this));
        this.addManagedListener(this.focusWrapper, 'keydown', this.handleKeyDown.bind(this));
        this.addManagedListener(this.focusWrapper, 'contextmenu', this.onContextMenu.bind(this));
        this.setOpenClosedIcons();
        this.setupDragging();
        this.onColumnStateChanged();
        this.addVisibilityListenersToAllChildren();
        this.refreshAriaExpanded();
        this.refreshAriaLabel();
        this.setupTooltip();
        const classes = CssClassApplier.getToolPanelClassesFromColDef(this.columnGroup.getColGroupDef(), this.gridOptionsService, null, this.columnGroup);
        classes.forEach(c => this.addOrRemoveCssClass(c, true));
    }
    getColumns() {
        return this.columnGroup.getLeafColumns();
    }
    setupTooltip() {
        const colGroupDef = this.columnGroup.getColGroupDef();
        if (!colGroupDef) {
            return;
        }
        const refresh = () => {
            const newTooltipText = colGroupDef.headerTooltip;
            this.setTooltip(newTooltipText);
        };
        refresh();
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refresh);
    }
    getTooltipParams() {
        const res = super.getTooltipParams();
        res.location = 'columnToolPanelColumnGroup';
        return res;
    }
    handleKeyDown(e) {
        switch (e.key) {
            case KeyCode.LEFT:
                e.preventDefault();
                this.modelItem.setExpanded(false);
                break;
            case KeyCode.RIGHT:
                e.preventDefault();
                this.modelItem.setExpanded(true);
                break;
            case KeyCode.SPACE:
                e.preventDefault();
                if (this.isSelectable()) {
                    this.onSelectAllChanged(!this.isSelected());
                }
                break;
        }
    }
    onContextMenu(e) {
        const { columnGroup, gridOptionsService } = this;
        if (gridOptionsService.get('functionsReadOnly')) {
            return;
        }
        const contextMenu = this.createBean(new ToolPanelContextMenu(columnGroup, e, this.focusWrapper));
        this.addDestroyFunc(() => {
            if (contextMenu.isAlive()) {
                this.destroyBean(contextMenu);
            }
        });
    }
    addVisibilityListenersToAllChildren() {
        this.columnGroup.getLeafColumns().forEach(column => {
            this.addManagedListener(column, Column.EVENT_VISIBLE_CHANGED, this.onColumnStateChanged.bind(this));
            this.addManagedListener(column, Column.EVENT_VALUE_CHANGED, this.onColumnStateChanged.bind(this));
            this.addManagedListener(column, Column.EVENT_PIVOT_CHANGED, this.onColumnStateChanged.bind(this));
            this.addManagedListener(column, Column.EVENT_ROW_GROUP_CHANGED, this.onColumnStateChanged.bind(this));
        });
    }
    setupDragging() {
        if (!this.allowDragging) {
            _.setDisplayed(this.eDragHandle, false);
            return;
        }
        let hideColumnOnExit = !this.gridOptionsService.get('suppressDragLeaveHidesColumns');
        const dragSource = {
            type: DragSourceType.ToolPanel,
            eElement: this.eDragHandle,
            dragItemName: this.displayName,
            getDefaultIconName: () => hideColumnOnExit ? DragAndDropService.ICON_HIDE : DragAndDropService.ICON_NOT_ALLOWED,
            getDragItem: () => this.createDragItem(),
            onDragStarted: () => {
                hideColumnOnExit = !this.gridOptionsService.get('suppressDragLeaveHidesColumns');
                const event = {
                    type: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
                    column: this.columnGroup
                };
                this.eventService.dispatchEvent(event);
            },
            onDragStopped: () => {
                const event = {
                    type: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END
                };
                this.eventService.dispatchEvent(event);
            },
            onGridEnter: (dragItem) => {
                if (hideColumnOnExit) {
                    // when dragged into the grid, restore the state that was active pre-drag
                    this.modelItemUtils.updateColumns({
                        columns: this.columnGroup.getLeafColumns(),
                        visibleState: dragItem === null || dragItem === void 0 ? void 0 : dragItem.visibleState,
                        pivotState: dragItem === null || dragItem === void 0 ? void 0 : dragItem.pivotState,
                        eventType: this.eventType
                    });
                }
            },
            onGridExit: () => {
                if (hideColumnOnExit) {
                    // when dragged outside of the grid, mimic what happens when checkbox is disabled
                    // this handles the behaviour for pivot which is different to just hiding a column.
                    this.onChangeCommon(false);
                }
            }
        };
        this.dragAndDropService.addDragSource(dragSource, true);
        this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(dragSource));
    }
    createDragItem() {
        const columns = this.columnGroup.getLeafColumns();
        const visibleState = {};
        const pivotState = {};
        columns.forEach(col => {
            const colId = col.getId();
            visibleState[colId] = col.isVisible();
            pivotState[colId] = this.modelItemUtils.createPivotState(col);
        });
        return {
            columns,
            visibleState,
            pivotState
        };
    }
    setupExpandContract() {
        this.eGroupClosedIcon.appendChild(_.createIcon('columnSelectClosed', this.gridOptionsService, null));
        this.eGroupOpenedIcon.appendChild(_.createIcon('columnSelectOpen', this.gridOptionsService, null));
        this.addManagedListener(this.eGroupClosedIcon, 'click', this.onExpandOrContractClicked.bind(this));
        this.addManagedListener(this.eGroupOpenedIcon, 'click', this.onExpandOrContractClicked.bind(this));
        const touchListener = new TouchListener(this.eColumnGroupIcons, true);
        this.addManagedListener(touchListener, TouchListener.EVENT_TAP, this.onExpandOrContractClicked.bind(this));
        this.addDestroyFunc(touchListener.destroy.bind(touchListener));
    }
    onLabelClicked() {
        const nextState = !this.cbSelect.getValue();
        this.onChangeCommon(nextState);
    }
    onCheckboxChanged(event) {
        this.onChangeCommon(event.selected);
    }
    getVisibleLeafColumns() {
        const childColumns = [];
        const extractCols = (children) => {
            children.forEach(child => {
                if (!child.isPassesFilter()) {
                    return;
                }
                if (child.isGroup()) {
                    extractCols(child.getChildren());
                }
                else {
                    childColumns.push(child.getColumn());
                }
            });
        };
        extractCols(this.modelItem.getChildren());
        return childColumns;
    }
    onChangeCommon(nextState) {
        this.refreshAriaLabel();
        if (this.processingColumnStateChange) {
            return;
        }
        this.modelItemUtils.selectAllChildren(this.modelItem.getChildren(), nextState, this.eventType);
    }
    refreshAriaLabel() {
        const translate = this.localeService.getLocaleTextFunc();
        const columnLabel = translate('ariaColumnGroup', 'Column Group');
        const checkboxValue = this.cbSelect.getValue();
        const state = checkboxValue === undefined ?
            translate('ariaIndeterminate', 'indeterminate') :
            (checkboxValue ? translate('ariaVisible', 'visible') : translate('ariaHidden', 'hidden'));
        const visibilityLabel = translate('ariaToggleVisibility', 'Press SPACE to toggle visibility');
        _.setAriaLabel(this.focusWrapper, `${this.displayName} ${columnLabel}`);
        this.cbSelect.setInputAriaLabel(`${visibilityLabel} (${state})`);
        _.setAriaDescribedBy(this.focusWrapper, this.cbSelect.getInputElement().id);
    }
    onColumnStateChanged() {
        const selectedValue = this.workOutSelectedValue();
        const readOnlyValue = this.workOutReadOnlyValue();
        this.processingColumnStateChange = true;
        this.cbSelect.setValue(selectedValue);
        this.cbSelect.setReadOnly(readOnlyValue);
        this.addOrRemoveCssClass('ag-column-select-column-group-readonly', readOnlyValue);
        this.processingColumnStateChange = false;
    }
    workOutSelectedValue() {
        const pivotMode = this.columnModel.isPivotMode();
        const visibleLeafColumns = this.getVisibleLeafColumns();
        let checkedCount = 0;
        let uncheckedCount = 0;
        visibleLeafColumns.forEach(column => {
            if (!pivotMode && column.getColDef().lockVisible) {
                return;
            }
            if (this.isColumnChecked(column, pivotMode)) {
                checkedCount++;
            }
            else {
                uncheckedCount++;
            }
        });
        if (checkedCount > 0 && uncheckedCount > 0) {
            return undefined;
        }
        return checkedCount > 0;
    }
    workOutReadOnlyValue() {
        const pivotMode = this.columnModel.isPivotMode();
        let colsThatCanAction = 0;
        this.columnGroup.getLeafColumns().forEach(col => {
            if (pivotMode) {
                if (col.isAnyFunctionAllowed()) {
                    colsThatCanAction++;
                }
            }
            else {
                if (!col.getColDef().lockVisible) {
                    colsThatCanAction++;
                }
            }
        });
        return colsThatCanAction === 0;
    }
    isColumnChecked(column, pivotMode) {
        if (pivotMode) {
            const pivoted = column.isPivotActive();
            const grouped = column.isRowGroupActive();
            const aggregated = column.isValueActive();
            return pivoted || grouped || aggregated;
        }
        return column.isVisible();
    }
    onExpandOrContractClicked() {
        const oldState = this.modelItem.isExpanded();
        this.modelItem.setExpanded(!oldState);
    }
    onExpandChanged() {
        this.setOpenClosedIcons();
        this.refreshAriaExpanded();
    }
    setOpenClosedIcons() {
        const folderOpen = this.modelItem.isExpanded();
        _.setDisplayed(this.eGroupClosedIcon, !folderOpen);
        _.setDisplayed(this.eGroupOpenedIcon, folderOpen);
    }
    refreshAriaExpanded() {
        _.setAriaExpanded(this.focusWrapper, this.modelItem.isExpanded());
    }
    getDisplayName() {
        return this.displayName;
    }
    onSelectAllChanged(value) {
        const cbValue = this.cbSelect.getValue();
        const readOnly = this.cbSelect.isReadOnly();
        if (!readOnly && ((value && !cbValue) || (!value && cbValue))) {
            this.cbSelect.toggle();
        }
    }
    isSelected() {
        return this.cbSelect.getValue();
    }
    isSelectable() {
        return !this.cbSelect.isReadOnly();
    }
    setSelected(selected) {
        this.cbSelect.setValue(selected, true);
    }
}
ToolPanelColumnGroupComp.TEMPLATE = `<div class="ag-column-select-column-group" aria-hidden="true">
            <span class="ag-column-group-icons" ref="eColumnGroupIcons" >
                <span class="ag-column-group-closed-icon" ref="eGroupClosedIcon"></span>
                <span class="ag-column-group-opened-icon" ref="eGroupOpenedIcon"></span>
            </span>
            <ag-checkbox ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
            <span class="ag-column-select-column-label" ref="eLabel"></span>
        </div>`;
__decorate$11([
    Autowired('columnModel')
], ToolPanelColumnGroupComp.prototype, "columnModel", void 0);
__decorate$11([
    Autowired('dragAndDropService')
], ToolPanelColumnGroupComp.prototype, "dragAndDropService", void 0);
__decorate$11([
    Autowired('modelItemUtils')
], ToolPanelColumnGroupComp.prototype, "modelItemUtils", void 0);
__decorate$11([
    RefSelector('cbSelect')
], ToolPanelColumnGroupComp.prototype, "cbSelect", void 0);
__decorate$11([
    RefSelector('eLabel')
], ToolPanelColumnGroupComp.prototype, "eLabel", void 0);
__decorate$11([
    RefSelector('eGroupOpenedIcon')
], ToolPanelColumnGroupComp.prototype, "eGroupOpenedIcon", void 0);
__decorate$11([
    RefSelector('eGroupClosedIcon')
], ToolPanelColumnGroupComp.prototype, "eGroupClosedIcon", void 0);
__decorate$11([
    RefSelector('eColumnGroupIcons')
], ToolPanelColumnGroupComp.prototype, "eColumnGroupIcons", void 0);
__decorate$11([
    PostConstruct
], ToolPanelColumnGroupComp.prototype, "init", null);

var __decorate$12 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class PrimaryColsListPanelItemDragFeature extends BeanStub {
    constructor(comp, virtualList) {
        super();
        this.comp = comp;
        this.virtualList = virtualList;
    }
    postConstruct() {
        this.createManagedBean(new VirtualListDragFeature(this.comp, this.virtualList, {
            dragSourceType: DragSourceType.ToolPanel,
            listItemDragStartEvent: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
            listItemDragEndEvent: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END,
            eventSource: this.eventService,
            getCurrentDragValue: (listItemDragStartEvent) => this.getCurrentDragValue(listItemDragStartEvent),
            isMoveBlocked: (currentDragValue) => this.isMoveBlocked(currentDragValue),
            getNumRows: (comp) => comp.getDisplayedColsList().length,
            moveItem: (currentDragValue, lastHoveredListItem) => this.moveItem(currentDragValue, lastHoveredListItem)
        }));
    }
    getCurrentDragValue(listItemDragStartEvent) {
        return listItemDragStartEvent.column;
    }
    isMoveBlocked(currentDragValue) {
        const preventMoving = this.gridOptionsService.get('suppressMovableColumns');
        if (preventMoving) {
            return true;
        }
        const currentColumns = this.getCurrentColumns(currentDragValue);
        const hasNotMovable = currentColumns.find(col => {
            const colDef = col.getColDef();
            return !!colDef.suppressMovable || !!colDef.lockPosition;
        });
        return !!hasNotMovable;
    }
    moveItem(currentDragValue, lastHoveredListItem) {
        const targetIndex = this.getTargetIndex(currentDragValue, lastHoveredListItem);
        const columnsToMove = this.getCurrentColumns(currentDragValue);
        if (targetIndex != null) {
            this.columnModel.moveColumns(columnsToMove, targetIndex, 'toolPanelUi');
        }
    }
    getMoveDiff(currentDragValue, end) {
        const allColumns = this.columnModel.getAllGridColumns();
        const currentColumns = this.getCurrentColumns(currentDragValue);
        const currentColumn = currentColumns[0];
        const span = currentColumns.length;
        const currentIndex = allColumns.indexOf(currentColumn);
        if (currentIndex < end) {
            return span;
        }
        return 0;
    }
    getCurrentColumns(currentDragValue) {
        if (currentDragValue instanceof ProvidedColumnGroup) {
            return currentDragValue.getLeafColumns();
        }
        return [currentDragValue];
    }
    getTargetIndex(currentDragValue, lastHoveredListItem) {
        if (!lastHoveredListItem) {
            return null;
        }
        const columnItemComponent = lastHoveredListItem.component;
        let isBefore = lastHoveredListItem.position === 'top';
        let targetColumn;
        if (columnItemComponent instanceof ToolPanelColumnGroupComp) {
            const columns = columnItemComponent.getColumns();
            targetColumn = columns[0];
            isBefore = true;
        }
        else {
            targetColumn = columnItemComponent.getColumn();
        }
        // if the target col is in the cols to be moved, no index to move.
        const movingCols = this.getCurrentColumns(currentDragValue);
        if (movingCols.indexOf(targetColumn) !== -1) {
            return null;
        }
        const targetColumnIndex = this.columnModel.getAllGridColumns().indexOf(targetColumn);
        const adjustedTarget = isBefore ? targetColumnIndex : targetColumnIndex + 1;
        const diff = this.getMoveDiff(currentDragValue, adjustedTarget);
        return adjustedTarget - diff;
    }
}
__decorate$12([
    Autowired('columnModel')
], PrimaryColsListPanelItemDragFeature.prototype, "columnModel", void 0);
__decorate$12([
    Autowired('gridOptionsService')
], PrimaryColsListPanelItemDragFeature.prototype, "gridOptionsService", void 0);
__decorate$12([
    PostConstruct
], PrimaryColsListPanelItemDragFeature.prototype, "postConstruct", null);

var __decorate$13 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ToolPanelColumnComp extends Component {
    constructor(modelItem, allowDragging, groupsExist, focusWrapper) {
        super();
        this.allowDragging = allowDragging;
        this.groupsExist = groupsExist;
        this.focusWrapper = focusWrapper;
        this.processingColumnStateChange = false;
        this.column = modelItem.getColumn();
        this.columnDept = modelItem.getDept();
        this.displayName = modelItem.getDisplayName();
    }
    init() {
        this.setTemplate(ToolPanelColumnComp.TEMPLATE);
        this.eDragHandle = _.createIconNoSpan('columnDrag', this.gridOptionsService);
        this.eDragHandle.classList.add('ag-drag-handle', 'ag-column-select-column-drag-handle');
        const checkboxGui = this.cbSelect.getGui();
        const checkboxInput = this.cbSelect.getInputElement();
        checkboxGui.insertAdjacentElement('afterend', this.eDragHandle);
        checkboxInput.setAttribute('tabindex', '-1');
        const displayNameSanitised = _.escapeString(this.displayName);
        this.eLabel.innerHTML = displayNameSanitised;
        // if grouping, we add an extra level of indent, to cater for expand/contract icons we need to indent for
        const indent = this.columnDept;
        if (this.groupsExist) {
            this.addCssClass('ag-column-select-add-group-indent');
        }
        this.addCssClass(`ag-column-select-indent-${indent}`);
        this.setupDragging();
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onColumnStateChanged.bind(this));
        this.addManagedListener(this.column, Column.EVENT_VALUE_CHANGED, this.onColumnStateChanged.bind(this));
        this.addManagedListener(this.column, Column.EVENT_PIVOT_CHANGED, this.onColumnStateChanged.bind(this));
        this.addManagedListener(this.column, Column.EVENT_ROW_GROUP_CHANGED, this.onColumnStateChanged.bind(this));
        this.addManagedListener(this.column, Column.EVENT_VISIBLE_CHANGED, this.onColumnStateChanged.bind(this));
        this.addManagedListener(this.focusWrapper, 'keydown', this.handleKeyDown.bind(this));
        this.addManagedListener(this.focusWrapper, 'contextmenu', this.onContextMenu.bind(this));
        this.addManagedPropertyListener('functionsReadOnly', this.onColumnStateChanged.bind(this));
        this.addManagedListener(this.cbSelect, Events.EVENT_FIELD_VALUE_CHANGED, this.onCheckboxChanged.bind(this));
        this.addManagedListener(this.eLabel, 'click', this.onLabelClicked.bind(this));
        this.onColumnStateChanged();
        this.refreshAriaLabel();
        this.setupTooltip();
        const classes = CssClassApplier.getToolPanelClassesFromColDef(this.column.getColDef(), this.gridOptionsService, this.column, null);
        classes.forEach(c => this.addOrRemoveCssClass(c, true));
    }
    getColumn() {
        return this.column;
    }
    setupTooltip() {
        const refresh = () => {
            const newTooltipText = this.column.getColDef().headerTooltip;
            this.setTooltip(newTooltipText);
        };
        refresh();
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refresh);
    }
    getTooltipParams() {
        const res = super.getTooltipParams();
        res.location = 'columnToolPanelColumn';
        res.colDef = this.column.getColDef();
        return res;
    }
    onContextMenu(e) {
        const { column, gridOptionsService } = this;
        if (gridOptionsService.get('functionsReadOnly')) {
            return;
        }
        const contextMenu = this.createBean(new ToolPanelContextMenu(column, e, this.focusWrapper));
        this.addDestroyFunc(() => {
            if (contextMenu.isAlive()) {
                this.destroyBean(contextMenu);
            }
        });
    }
    handleKeyDown(e) {
        if (e.key === KeyCode.SPACE) {
            e.preventDefault();
            if (this.isSelectable()) {
                this.onSelectAllChanged(!this.isSelected());
            }
        }
    }
    onLabelClicked() {
        if (this.gridOptionsService.get('functionsReadOnly')) {
            return;
        }
        const nextState = !this.cbSelect.getValue();
        this.onChangeCommon(nextState);
    }
    onCheckboxChanged(event) {
        this.onChangeCommon(event.selected);
    }
    onChangeCommon(nextState) {
        // ignore lock visible columns
        if (this.cbSelect.isReadOnly()) {
            return;
        }
        this.refreshAriaLabel();
        // only want to action if the user clicked the checkbox, not if we are setting the checkbox because
        // of a change in the model
        if (this.processingColumnStateChange) {
            return;
        }
        this.modelItemUtils.setColumn(this.column, nextState, 'toolPanelUi');
    }
    refreshAriaLabel() {
        const translate = this.localeService.getLocaleTextFunc();
        const columnLabel = translate('ariaColumn', 'Column');
        const state = this.cbSelect.getValue() ? translate('ariaVisible', 'visible') : translate('ariaHidden', 'hidden');
        const visibilityLabel = translate('ariaToggleVisibility', 'Press SPACE to toggle visibility');
        _.setAriaLabel(this.focusWrapper, `${this.displayName} ${columnLabel}`);
        this.cbSelect.setInputAriaLabel(`${visibilityLabel} (${state})`);
        _.setAriaDescribedBy(this.focusWrapper, this.cbSelect.getInputElement().id);
    }
    setupDragging() {
        if (!this.allowDragging) {
            _.setDisplayed(this.eDragHandle, false);
            return;
        }
        let hideColumnOnExit = !this.gridOptionsService.get('suppressDragLeaveHidesColumns');
        const dragSource = {
            type: DragSourceType.ToolPanel,
            eElement: this.eDragHandle,
            dragItemName: this.displayName,
            getDefaultIconName: () => hideColumnOnExit ? DragAndDropService.ICON_HIDE : DragAndDropService.ICON_NOT_ALLOWED,
            getDragItem: () => this.createDragItem(),
            onDragStarted: () => {
                hideColumnOnExit = !this.gridOptionsService.get('suppressDragLeaveHidesColumns');
                const event = {
                    type: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_START,
                    column: this.column
                };
                this.eventService.dispatchEvent(event);
            },
            onDragStopped: () => {
                const event = {
                    type: Events.EVENT_COLUMN_PANEL_ITEM_DRAG_END
                };
                this.eventService.dispatchEvent(event);
            },
            onGridEnter: (dragItem) => {
                if (hideColumnOnExit) {
                    // when dragged into the grid, restore the state that was active pre-drag
                    this.modelItemUtils.updateColumns({
                        columns: [this.column],
                        visibleState: dragItem === null || dragItem === void 0 ? void 0 : dragItem.visibleState,
                        pivotState: dragItem === null || dragItem === void 0 ? void 0 : dragItem.pivotState,
                        eventType: 'toolPanelUi'
                    });
                }
            },
            onGridExit: () => {
                if (hideColumnOnExit) {
                    // when dragged outside of the grid, mimic what happens when checkbox is disabled
                    // this handles the behaviour for pivot which is different to just hiding a column.
                    this.onChangeCommon(false);
                }
            }
        };
        this.dragAndDropService.addDragSource(dragSource, true);
        this.addDestroyFunc(() => this.dragAndDropService.removeDragSource(dragSource));
    }
    createDragItem() {
        const colId = this.column.getColId();
        const visibleState = { [colId]: this.column.isVisible() };
        const pivotState = { [colId]: this.modelItemUtils.createPivotState(this.column) };
        return {
            columns: [this.column],
            visibleState,
            pivotState
        };
    }
    onColumnStateChanged() {
        this.processingColumnStateChange = true;
        const isPivotMode = this.columnModel.isPivotMode();
        if (isPivotMode) {
            // if reducing, checkbox means column is one of pivot, value or group
            const anyFunctionActive = this.column.isAnyFunctionActive();
            this.cbSelect.setValue(anyFunctionActive);
        }
        else {
            // if not reducing, the checkbox tells us if column is visible or not
            this.cbSelect.setValue(this.column.isVisible());
        }
        let canBeToggled = true;
        let canBeDragged = true;
        if (isPivotMode) {
            // when in pivot mode, the item should be read only if:
            //  a) gui is not allowed make any changes
            const functionsReadOnly = this.gridOptionsService.get('functionsReadOnly');
            //  b) column is not allow any functions on it
            const noFunctionsAllowed = !this.column.isAnyFunctionAllowed();
            canBeToggled = !functionsReadOnly && !noFunctionsAllowed;
            canBeDragged = canBeToggled;
        }
        else {
            const { enableRowGroup, enableValue, lockPosition, suppressMovable, lockVisible } = this.column.getColDef();
            const forceDraggable = !!enableRowGroup || !!enableValue;
            const disableDraggable = !!lockPosition || !!suppressMovable;
            canBeToggled = !lockVisible;
            canBeDragged = forceDraggable || !disableDraggable;
        }
        this.cbSelect.setReadOnly(!canBeToggled);
        this.eDragHandle.classList.toggle('ag-column-select-column-readonly', !canBeDragged);
        this.addOrRemoveCssClass('ag-column-select-column-readonly', !canBeDragged && !canBeToggled);
        const checkboxPassive = isPivotMode && this.gridOptionsService.get('functionsPassive');
        this.cbSelect.setPassive(checkboxPassive);
        this.processingColumnStateChange = false;
    }
    getDisplayName() {
        return this.displayName;
    }
    onSelectAllChanged(value) {
        if (value !== this.cbSelect.getValue()) {
            if (!this.cbSelect.isReadOnly()) {
                this.cbSelect.toggle();
            }
        }
    }
    isSelected() {
        return this.cbSelect.getValue();
    }
    isSelectable() {
        return !this.cbSelect.isReadOnly();
    }
    isExpandable() {
        return false;
    }
    setExpanded(value) {
        console.warn('AG Grid: can not expand a column item that does not represent a column group header');
    }
}
ToolPanelColumnComp.TEMPLATE = `<div class="ag-column-select-column" aria-hidden="true">
            <ag-checkbox ref="cbSelect" class="ag-column-select-checkbox"></ag-checkbox>
            <span class="ag-column-select-column-label" ref="eLabel"></span>
        </div>`;
__decorate$13([
    Autowired('columnModel')
], ToolPanelColumnComp.prototype, "columnModel", void 0);
__decorate$13([
    Autowired('dragAndDropService')
], ToolPanelColumnComp.prototype, "dragAndDropService", void 0);
__decorate$13([
    Autowired('modelItemUtils')
], ToolPanelColumnComp.prototype, "modelItemUtils", void 0);
__decorate$13([
    RefSelector('eLabel')
], ToolPanelColumnComp.prototype, "eLabel", void 0);
__decorate$13([
    RefSelector('cbSelect')
], ToolPanelColumnComp.prototype, "cbSelect", void 0);
__decorate$13([
    PostConstruct
], ToolPanelColumnComp.prototype, "init", null);

var __decorate$14 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class UIColumnModel {
    constructor(items) {
        this.items = items;
    }
    getRowCount() {
        return this.items.length;
    }
    getRow(index) {
        return this.items[index];
    }
}
const PRIMARY_COLS_LIST_PANEL_CLASS = 'ag-column-select-list';
class PrimaryColsListPanel extends Component {
    constructor() {
        super(PrimaryColsListPanel.TEMPLATE);
        this.destroyColumnItemFuncs = [];
        this.hasLoadedInitialState = false;
        this.isInitialState = false;
    }
    destroyColumnTree() {
        this.allColsTree = [];
        this.destroyColumnItemFuncs.forEach(f => f());
        this.destroyColumnItemFuncs = [];
    }
    init(params, allowDragging, eventType) {
        this.params = params;
        this.allowDragging = allowDragging;
        this.eventType = eventType;
        if (!this.params.suppressSyncLayoutWithGrid) {
            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, this.onColumnsChanged.bind(this));
        }
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnsChanged.bind(this));
        const eventsImpactingCheckedState = [
            Events.EVENT_COLUMN_PIVOT_CHANGED,
            Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,
            Events.EVENT_COLUMN_ROW_GROUP_CHANGED,
            Events.EVENT_COLUMN_VALUE_CHANGED,
            Events.EVENT_COLUMN_VISIBLE,
            Events.EVENT_NEW_COLUMNS_LOADED
        ];
        eventsImpactingCheckedState.forEach(event => {
            // update header select all checkbox with current selection state
            this.addManagedListener(this.eventService, event, this.fireSelectionChangedEvent.bind(this));
        });
        this.expandGroupsByDefault = !this.params.contractColumnSelection;
        this.virtualList = this.createManagedBean(new VirtualList({
            cssIdentifier: 'column-select',
            ariaRole: 'tree',
        }));
        this.appendChild(this.virtualList.getGui());
        const ariaEl = this.virtualList.getAriaElement();
        _.setAriaLive(ariaEl, 'assertive');
        _.setAriaAtomic(ariaEl, false);
        _.setAriaRelevant(ariaEl, 'text');
        this.virtualList.setComponentCreator((item, listItemElement) => {
            _.setAriaLevel(listItemElement, (item.getDept() + 1));
            return this.createComponentFromItem(item, listItemElement);
        });
        if (this.columnModel.isReady()) {
            this.onColumnsChanged();
        }
        if (this.params.suppressColumnMove) {
            return;
        }
        this.colsListPanelItemDragFeature = this.createManagedBean(new PrimaryColsListPanelItemDragFeature(this, this.virtualList));
    }
    createComponentFromItem(item, listItemElement) {
        if (item.isGroup()) {
            const renderedGroup = new ToolPanelColumnGroupComp(item, this.allowDragging, this.eventType, listItemElement);
            this.getContext().createBean(renderedGroup);
            return renderedGroup;
        }
        const columnComp = new ToolPanelColumnComp(item, this.allowDragging, this.groupsExist, listItemElement);
        this.getContext().createBean(columnComp);
        return columnComp;
    }
    onColumnsChanged() {
        if (!this.hasLoadedInitialState) {
            this.hasLoadedInitialState = true;
            this.isInitialState = !!this.params.initialState;
        }
        const expandedStates = this.getExpandedStates();
        const pivotModeActive = this.columnModel.isPivotMode();
        const shouldSyncColumnLayoutWithGrid = !this.params.suppressSyncLayoutWithGrid && !pivotModeActive;
        if (shouldSyncColumnLayoutWithGrid) {
            this.buildTreeFromWhatGridIsDisplaying();
        }
        else {
            this.buildTreeFromProvidedColumnDefs();
        }
        this.setExpandedStates(expandedStates);
        this.markFilteredColumns();
        this.flattenAndFilterModel();
        this.isInitialState = false;
    }
    getDisplayedColsList() {
        return this.displayedColsList;
    }
    getExpandedStates() {
        const res = {};
        if (this.isInitialState) {
            const { expandedGroupIds } = this.params.initialState;
            expandedGroupIds.forEach(id => {
                res[id] = true;
            });
            return res;
        }
        if (!this.allColsTree) {
            return {};
        }
        this.forEachItem(item => {
            if (!item.isGroup()) {
                return;
            }
            const colGroup = item.getColumnGroup();
            if (colGroup) { // group should always exist, this is defensive
                res[colGroup.getId()] = item.isExpanded();
            }
        });
        return res;
    }
    setExpandedStates(states) {
        if (!this.allColsTree) {
            return;
        }
        const { isInitialState } = this;
        this.forEachItem(item => {
            if (!item.isGroup()) {
                return;
            }
            const colGroup = item.getColumnGroup();
            if (colGroup) { // group should always exist, this is defensive
                const expanded = states[colGroup.getId()];
                const groupExistedLastTime = expanded != null;
                if (groupExistedLastTime || isInitialState) {
                    item.setExpanded(!!expanded);
                }
            }
        });
    }
    buildTreeFromWhatGridIsDisplaying() {
        this.colDefService.syncLayoutWithGrid(this.setColumnLayout.bind(this));
    }
    setColumnLayout(colDefs) {
        const columnTree = this.colDefService.createColumnTree(colDefs);
        this.buildListModel(columnTree);
        // using col defs to check if groups exist as it could be a custom layout
        this.groupsExist = colDefs.some(colDef => {
            return colDef && typeof colDef.children !== 'undefined';
        });
        this.markFilteredColumns();
        this.flattenAndFilterModel();
    }
    buildTreeFromProvidedColumnDefs() {
        // add column / group comps to tool panel
        this.buildListModel(this.columnModel.getPrimaryColumnTree());
        this.groupsExist = this.columnModel.isPrimaryColumnGroupsPresent();
    }
    buildListModel(columnTree) {
        const columnExpandedListener = this.onColumnExpanded.bind(this);
        const addListeners = (item) => {
            item.addEventListener(ColumnModelItem.EVENT_EXPANDED_CHANGED, columnExpandedListener);
            const removeFunc = item.removeEventListener.bind(item, ColumnModelItem.EVENT_EXPANDED_CHANGED, columnExpandedListener);
            this.destroyColumnItemFuncs.push(removeFunc);
        };
        const recursivelyBuild = (tree, dept, parentList) => {
            tree.forEach(child => {
                if (child instanceof ProvidedColumnGroup) {
                    createGroupItem(child, dept, parentList);
                }
                else {
                    createColumnItem(child, dept, parentList);
                }
            });
        };
        const createGroupItem = (columnGroup, dept, parentList) => {
            const columnGroupDef = columnGroup.getColGroupDef();
            const skipThisGroup = columnGroupDef && columnGroupDef.suppressColumnsToolPanel;
            if (skipThisGroup) {
                return;
            }
            if (columnGroup.isPadding()) {
                recursivelyBuild(columnGroup.getChildren(), dept, parentList);
                return;
            }
            const displayName = this.columnModel.getDisplayNameForProvidedColumnGroup(null, columnGroup, 'columnToolPanel');
            const item = new ColumnModelItem(displayName, columnGroup, dept, true, this.expandGroupsByDefault);
            parentList.push(item);
            addListeners(item);
            recursivelyBuild(columnGroup.getChildren(), dept + 1, item.getChildren());
        };
        const createColumnItem = (column, dept, parentList) => {
            const skipThisColumn = column.getColDef() && column.getColDef().suppressColumnsToolPanel;
            if (skipThisColumn) {
                return;
            }
            const displayName = this.columnModel.getDisplayNameForColumn(column, 'columnToolPanel');
            parentList.push(new ColumnModelItem(displayName, column, dept));
        };
        this.destroyColumnTree();
        recursivelyBuild(columnTree, 0, this.allColsTree);
    }
    onColumnExpanded() {
        this.flattenAndFilterModel();
    }
    flattenAndFilterModel() {
        this.displayedColsList = [];
        const recursiveFunc = (item) => {
            if (!item.isPassesFilter()) {
                return;
            }
            this.displayedColsList.push(item);
            if (item.isGroup() && item.isExpanded()) {
                item.getChildren().forEach(recursiveFunc);
            }
        };
        this.allColsTree.forEach(recursiveFunc);
        this.virtualList.setModel(new UIColumnModel(this.displayedColsList));
        const focusedRow = this.virtualList.getLastFocusedRow();
        this.virtualList.refresh();
        if (focusedRow != null) {
            this.focusRowIfAlive(focusedRow);
        }
        this.notifyListeners();
        this.refreshAriaLabel();
    }
    refreshAriaLabel() {
        const translate = this.localeService.getLocaleTextFunc();
        const columnListName = translate('ariaColumnPanelList', 'Column List');
        const localeColumns = translate('columns', 'Columns');
        const items = this.displayedColsList.length;
        _.setAriaLabel(this.virtualList.getAriaElement(), `${columnListName} ${items} ${localeColumns}`);
    }
    focusRowIfAlive(rowIndex) {
        window.setTimeout(() => {
            if (this.isAlive()) {
                this.virtualList.focusRow(rowIndex);
            }
        }, 0);
    }
    forEachItem(callback) {
        const recursiveFunc = (items) => {
            items.forEach(item => {
                callback(item);
                if (item.isGroup()) {
                    recursiveFunc(item.getChildren());
                }
            });
        };
        if (!this.allColsTree) {
            return;
        }
        recursiveFunc(this.allColsTree);
    }
    doSetExpandedAll(value) {
        this.forEachItem(item => {
            if (item.isGroup()) {
                item.setExpanded(value);
            }
        });
    }
    setGroupsExpanded(expand, groupIds) {
        if (!groupIds) {
            this.doSetExpandedAll(expand);
            return;
        }
        const expandedGroupIds = [];
        this.forEachItem(item => {
            if (!item.isGroup()) {
                return;
            }
            const groupId = item.getColumnGroup().getId();
            if (groupIds.indexOf(groupId) >= 0) {
                item.setExpanded(expand);
                expandedGroupIds.push(groupId);
            }
        });
        const unrecognisedGroupIds = groupIds.filter(groupId => !_.includes(expandedGroupIds, groupId));
        if (unrecognisedGroupIds.length > 0) {
            console.warn('AG Grid: unable to find group(s) for supplied groupIds:', unrecognisedGroupIds);
        }
    }
    getExpandState() {
        let expandedCount = 0;
        let notExpandedCount = 0;
        this.forEachItem(item => {
            if (!item.isGroup()) {
                return;
            }
            if (item.isExpanded()) {
                expandedCount++;
            }
            else {
                notExpandedCount++;
            }
        });
        if (expandedCount > 0 && notExpandedCount > 0) {
            return ExpandState.INDETERMINATE;
        }
        if (notExpandedCount > 0) {
            return ExpandState.COLLAPSED;
        }
        return ExpandState.EXPANDED;
    }
    doSetSelectedAll(selectAllChecked) {
        this.modelItemUtils.selectAllChildren(this.allColsTree, selectAllChecked, this.eventType);
    }
    getSelectionState() {
        let checkedCount = 0;
        let uncheckedCount = 0;
        const pivotMode = this.columnModel.isPivotMode();
        this.forEachItem(item => {
            if (item.isGroup()) {
                return;
            }
            if (!item.isPassesFilter()) {
                return;
            }
            const column = item.getColumn();
            const colDef = column.getColDef();
            let checked;
            if (pivotMode) {
                const noPivotModeOptionsAllowed = !column.isAllowPivot() && !column.isAllowRowGroup() && !column.isAllowValue();
                if (noPivotModeOptionsAllowed) {
                    return;
                }
                checked = column.isValueActive() || column.isPivotActive() || column.isRowGroupActive();
            }
            else {
                if (colDef.lockVisible) {
                    return;
                }
                checked = column.isVisible();
            }
            checked ? checkedCount++ : uncheckedCount++;
        });
        if (checkedCount > 0 && uncheckedCount > 0) {
            return undefined;
        }
        return !(checkedCount === 0 || uncheckedCount > 0);
    }
    setFilterText(filterText) {
        this.filterText = _.exists(filterText) ? filterText.toLowerCase() : null;
        this.markFilteredColumns();
        this.flattenAndFilterModel();
    }
    markFilteredColumns() {
        const passesFilter = (item) => {
            if (!_.exists(this.filterText)) {
                return true;
            }
            const displayName = item.getDisplayName();
            return displayName == null || displayName.toLowerCase().indexOf(this.filterText) !== -1;
        };
        const recursivelyCheckFilter = (item, parentPasses) => {
            let atLeastOneChildPassed = false;
            if (item.isGroup()) {
                const groupPasses = passesFilter(item);
                item.getChildren().forEach(child => {
                    const childPasses = recursivelyCheckFilter(child, groupPasses || parentPasses);
                    if (childPasses) {
                        atLeastOneChildPassed = childPasses;
                    }
                });
            }
            const filterPasses = (parentPasses || atLeastOneChildPassed) ? true : passesFilter(item);
            item.setPassesFilter(filterPasses);
            return filterPasses;
        };
        this.allColsTree.forEach(item => recursivelyCheckFilter(item, false));
    }
    notifyListeners() {
        this.fireGroupExpandedEvent();
        this.fireSelectionChangedEvent();
    }
    fireGroupExpandedEvent() {
        const expandState = this.getExpandState();
        this.dispatchEvent({ type: 'groupExpanded', state: expandState });
    }
    fireSelectionChangedEvent() {
        if (!this.allColsTree) {
            return;
        }
        const selectionState = this.getSelectionState();
        this.dispatchEvent({ type: 'selectionChanged', state: selectionState });
    }
    getExpandedGroups() {
        const expandedGroupIds = [];
        if (!this.allColsTree) {
            return expandedGroupIds;
        }
        this.forEachItem(item => {
            if (item.isGroup() && item.isExpanded()) {
                expandedGroupIds.push(item.getColumnGroup().getId());
            }
        });
        return expandedGroupIds;
    }
}
PrimaryColsListPanel.TEMPLATE = `<div class="${PRIMARY_COLS_LIST_PANEL_CLASS}" role="presentation"></div>`;
__decorate$14([
    Autowired('columnModel')
], PrimaryColsListPanel.prototype, "columnModel", void 0);
__decorate$14([
    Autowired('toolPanelColDefService')
], PrimaryColsListPanel.prototype, "colDefService", void 0);
__decorate$14([
    Autowired('modelItemUtils')
], PrimaryColsListPanel.prototype, "modelItemUtils", void 0);
__decorate$14([
    PreDestroy
], PrimaryColsListPanel.prototype, "destroyColumnTree", null);

var __decorate$15 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class PivotModePanel extends Component {
    createTemplate() {
        return /* html */ `<div class="ag-pivot-mode-panel">
                <ag-toggle-button ref="cbPivotMode" class="ag-pivot-mode-select"></ag-toggle-button>
            </div>`;
    }
    init() {
        this.setTemplate(this.createTemplate());
        this.cbPivotMode.setValue(this.columnModel.isPivotMode());
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        this.cbPivotMode.setLabel(localeTextFunc('pivotMode', 'Pivot Mode'));
        this.addManagedListener(this.cbPivotMode, Events.EVENT_FIELD_VALUE_CHANGED, this.onBtPivotMode.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onPivotModeChanged.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this));
    }
    onBtPivotMode() {
        const newValue = !!this.cbPivotMode.getValue();
        if (newValue !== this.columnModel.isPivotMode()) {
            this.gridOptionsService.updateGridOptions({ options: { pivotMode: newValue }, source: 'toolPanelUi' });
            const { api } = this;
            if (api) {
                api.refreshHeader();
            }
        }
    }
    onPivotModeChanged() {
        const pivotModeActive = this.columnModel.isPivotMode();
        this.cbPivotMode.setValue(pivotModeActive);
    }
}
__decorate$15([
    Autowired('columnModel')
], PivotModePanel.prototype, "columnModel", void 0);
__decorate$15([
    Autowired('gridApi')
], PivotModePanel.prototype, "api", void 0);
__decorate$15([
    RefSelector('cbPivotMode')
], PivotModePanel.prototype, "cbPivotMode", void 0);
__decorate$15([
    PreConstruct
], PivotModePanel.prototype, "init", null);

var __decorate$16 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let AggregationStage = class AggregationStage extends BeanStub {
    // it's possible to recompute the aggregate without doing the other parts
    // + api.refreshClientSideRowModel('aggregate')
    execute(params) {
        // if changed path is active, it means we came from a) change detection or b) transaction update.
        // for both of these, if no value columns are present, it means there is nothing to aggregate now
        // and there is no cleanup to be done (as value columns don't change between transactions or change
        // detections). if no value columns and no changed path, means we have to go through all nodes in
        // case we need to clean up agg data from before.
        const noValueColumns = _.missingOrEmpty(this.columnModel.getValueColumns());
        const noUserAgg = !this.gridOptionsService.getCallback('getGroupRowAgg');
        const changedPathActive = params.changedPath && params.changedPath.isActive();
        if (noValueColumns && noUserAgg && changedPathActive) {
            return;
        }
        const aggDetails = this.createAggDetails(params);
        this.recursivelyCreateAggData(aggDetails);
    }
    createAggDetails(params) {
        const pivotActive = this.columnModel.isPivotActive();
        const measureColumns = this.columnModel.getValueColumns();
        const pivotColumns = pivotActive ? this.columnModel.getPivotColumns() : [];
        const aggDetails = {
            alwaysAggregateAtRootLevel: this.gridOptionsService.get('alwaysAggregateAtRootLevel'),
            groupIncludeTotalFooter: this.gridOptionsService.get('groupIncludeTotalFooter'),
            changedPath: params.changedPath,
            valueColumns: measureColumns,
            pivotColumns: pivotColumns,
            filteredOnly: !this.isSuppressAggFilteredOnly(),
            userAggFunc: this.gridOptionsService.getCallback('getGroupRowAgg'),
        };
        return aggDetails;
    }
    isSuppressAggFilteredOnly() {
        const isGroupAggFiltering = this.gridOptionsService.getGroupAggFiltering() !== undefined;
        return isGroupAggFiltering || this.gridOptionsService.get('suppressAggFilteredOnly');
    }
    recursivelyCreateAggData(aggDetails) {
        const callback = (rowNode) => {
            const hasNoChildren = !rowNode.hasChildren();
            if (hasNoChildren) {
                // this check is needed for TreeData, in case the node is no longer a child,
                // but it was a child previously.
                if (rowNode.aggData) {
                    rowNode.setAggData(null);
                }
                // never agg data for leaf nodes
                return;
            }
            //Optionally enable the aggregation at the root Node
            const isRootNode = rowNode.level === -1;
            // if total footer is displayed, the value is in use
            if (isRootNode && !aggDetails.groupIncludeTotalFooter) {
                const notPivoting = !this.columnModel.isPivotMode();
                if (!aggDetails.alwaysAggregateAtRootLevel && notPivoting) {
                    rowNode.setAggData(null);
                    return;
                }
            }
            this.aggregateRowNode(rowNode, aggDetails);
        };
        aggDetails.changedPath.forEachChangedNodeDepthFirst(callback, true);
    }
    aggregateRowNode(rowNode, aggDetails) {
        const measureColumnsMissing = aggDetails.valueColumns.length === 0;
        const pivotColumnsMissing = aggDetails.pivotColumns.length === 0;
        let aggResult;
        if (aggDetails.userAggFunc) {
            aggResult = aggDetails.userAggFunc({ nodes: rowNode.childrenAfterFilter });
        }
        else if (measureColumnsMissing) {
            aggResult = null;
        }
        else if (pivotColumnsMissing) {
            aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, aggDetails);
        }
        else {
            aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);
        }
        rowNode.setAggData(aggResult);
        // if we are grouping, then it's possible there is a sibling footer
        // to the group, so update the data here also if there is one
        if (rowNode.sibling) {
            rowNode.sibling.setAggData(aggResult);
        }
    }
    aggregateRowNodeUsingValuesAndPivot(rowNode) {
        var _a, _b;
        const result = {};
        const secondaryColumns = (_a = this.columnModel.getSecondaryColumns()) !== null && _a !== void 0 ? _a : [];
        let canSkipTotalColumns = true;
        for (let i = 0; i < secondaryColumns.length; i++) {
            const secondaryCol = secondaryColumns[i];
            const colDef = secondaryCol.getColDef();
            if (colDef.pivotTotalColumnIds != null) {
                canSkipTotalColumns = false;
                continue;
            }
            const keys = (_b = colDef.pivotKeys) !== null && _b !== void 0 ? _b : [];
            let values;
            if (rowNode.leafGroup) {
                // lowest level group, get the values from the mapped set
                values = this.getValuesFromMappedSet(rowNode.childrenMapped, keys, colDef.pivotValueColumn);
            }
            else {
                // value columns and pivot columns, non-leaf group
                values = this.getValuesPivotNonLeaf(rowNode, colDef.colId);
            }
            // bit of a memory drain storing null/undefined, but seems to speed up performance.
            result[colDef.colId] = this.aggregateValues(values, colDef.pivotValueColumn.getAggFunc(), colDef.pivotValueColumn, rowNode, secondaryCol);
        }
        if (!canSkipTotalColumns) {
            for (let i = 0; i < secondaryColumns.length; i++) {
                const secondaryCol = secondaryColumns[i];
                const colDef = secondaryCol.getColDef();
                if (colDef.pivotTotalColumnIds == null || !colDef.pivotTotalColumnIds.length) {
                    continue;
                }
                const aggResults = colDef.pivotTotalColumnIds.map((currentColId) => result[currentColId]);
                // bit of a memory drain storing null/undefined, but seems to speed up performance.
                result[colDef.colId] = this.aggregateValues(aggResults, colDef.pivotValueColumn.getAggFunc(), colDef.pivotValueColumn, rowNode, secondaryCol);
            }
        }
        return result;
    }
    aggregateRowNodeUsingValuesOnly(rowNode, aggDetails) {
        const result = {};
        const changedValueColumns = aggDetails.changedPath.isActive() ?
            aggDetails.changedPath.getValueColumnsForNode(rowNode, aggDetails.valueColumns)
            : aggDetails.valueColumns;
        const notChangedValueColumns = aggDetails.changedPath.isActive() ?
            aggDetails.changedPath.getNotValueColumnsForNode(rowNode, aggDetails.valueColumns)
            : null;
        const values2d = this.getValuesNormal(rowNode, changedValueColumns, aggDetails.filteredOnly);
        const oldValues = rowNode.aggData;
        changedValueColumns.forEach((valueColumn, index) => {
            result[valueColumn.getId()] = this.aggregateValues(values2d[index], valueColumn.getAggFunc(), valueColumn, rowNode);
        });
        if (notChangedValueColumns && oldValues) {
            notChangedValueColumns.forEach((valueColumn) => {
                result[valueColumn.getId()] = oldValues[valueColumn.getId()];
            });
        }
        return result;
    }
    getValuesPivotNonLeaf(rowNode, colId) {
        return rowNode.childrenAfterFilter.map((childNode) => childNode.aggData[colId]);
    }
    getValuesFromMappedSet(mappedSet, keys, valueColumn) {
        let mapPointer = mappedSet;
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            mapPointer = mapPointer ? mapPointer[key] : null;
        }
        if (!mapPointer) {
            return [];
        }
        return mapPointer.map((rowNode) => this.valueService.getValue(valueColumn, rowNode));
    }
    getValuesNormal(rowNode, valueColumns, filteredOnly) {
        // create 2d array, of all values for all valueColumns
        const values = [];
        valueColumns.forEach(() => values.push([]));
        const valueColumnCount = valueColumns.length;
        const nodeList = filteredOnly ? rowNode.childrenAfterFilter : rowNode.childrenAfterGroup;
        const rowCount = nodeList.length;
        for (let i = 0; i < rowCount; i++) {
            const childNode = nodeList[i];
            for (let j = 0; j < valueColumnCount; j++) {
                const valueColumn = valueColumns[j];
                // if the row is a group, then it will only have an agg result value,
                // which means valueGetter is never used.
                const value = this.valueService.getValue(valueColumn, childNode);
                values[j].push(value);
            }
        }
        return values;
    }
    aggregateValues(values, aggFuncOrString, column, rowNode, pivotResultColumn) {
        const aggFunc = typeof aggFuncOrString === 'string' ?
            this.aggFuncService.getAggFunc(aggFuncOrString) :
            aggFuncOrString;
        if (typeof aggFunc !== 'function') {
            console.error(`AG Grid: unrecognised aggregation function ${aggFuncOrString}`);
            return null;
        }
        const aggFuncAny = aggFunc;
        const params = this.gridOptionsService.addGridCommonParams({
            values: values,
            column: column,
            colDef: column ? column.getColDef() : undefined,
            pivotResultColumn: pivotResultColumn,
            rowNode: rowNode,
            data: rowNode ? rowNode.data : undefined
        }); // the "as any" is needed to allow the deprecation warning messages
        return aggFuncAny(params);
    }
};
__decorate$16([
    Autowired('columnModel')
], AggregationStage.prototype, "columnModel", void 0);
__decorate$16([
    Autowired('valueService')
], AggregationStage.prototype, "valueService", void 0);
__decorate$16([
    Autowired('aggFuncService')
], AggregationStage.prototype, "aggFuncService", void 0);
AggregationStage = __decorate$16([
    Bean('aggregationStage')
], AggregationStage);

class BatchRemover {
    constructor() {
        this.allSets = {};
        this.allParents = [];
    }
    removeFromChildrenAfterGroup(parent, child) {
        const set = this.getSet(parent);
        set.removeFromChildrenAfterGroup[child.id] = true;
    }
    isRemoveFromAllLeafChildren(parent, child) {
        const set = this.getSet(parent);
        return !!set.removeFromAllLeafChildren[child.id];
    }
    preventRemoveFromAllLeafChildren(parent, child) {
        const set = this.getSet(parent);
        delete set.removeFromAllLeafChildren[child.id];
    }
    removeFromAllLeafChildren(parent, child) {
        const set = this.getSet(parent);
        set.removeFromAllLeafChildren[child.id] = true;
    }
    getSet(parent) {
        if (!this.allSets[parent.id]) {
            this.allSets[parent.id] = {
                removeFromAllLeafChildren: {},
                removeFromChildrenAfterGroup: {}
            };
            this.allParents.push(parent);
        }
        return this.allSets[parent.id];
    }
    getAllParents() {
        return this.allParents;
    }
    flush() {
        this.allParents.forEach(parent => {
            const nodeDetails = this.allSets[parent.id];
            parent.childrenAfterGroup = parent.childrenAfterGroup.filter(child => !nodeDetails.removeFromChildrenAfterGroup[child.id]);
            parent.allLeafChildren = parent.allLeafChildren.filter(child => !nodeDetails.removeFromAllLeafChildren[child.id]);
            parent.updateHasChildren();
            if (parent.sibling) {
                parent.sibling.childrenAfterGroup = parent.childrenAfterGroup;
                parent.sibling.allLeafChildren = parent.allLeafChildren;
            }
        });
        this.allSets = {};
        this.allParents.length = 0;
    }
}

var __decorate$17 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let GroupStage = class GroupStage extends BeanStub {
    execute(params) {
        const details = this.createGroupingDetails(params);
        if (details.transactions) {
            this.handleTransaction(details);
        }
        else {
            const afterColsChanged = params.afterColumnsChanged === true;
            this.shotgunResetEverything(details, afterColsChanged);
        }
        if (!details.usingTreeData) {
            // we don't do group sorting for tree data
            this.positionLeafsAndGroups(params.changedPath);
            this.orderGroups(details);
        }
        this.selectableService.updateSelectableAfterGrouping();
    }
    positionLeafsAndGroups(changedPath) {
        changedPath.forEachChangedNodeDepthFirst(group => {
            if (group.childrenAfterGroup) {
                const leafNodes = [];
                const groupNodes = [];
                let unbalancedNode;
                group.childrenAfterGroup.forEach(row => {
                    var _a;
                    if (!((_a = row.childrenAfterGroup) === null || _a === void 0 ? void 0 : _a.length)) {
                        leafNodes.push(row);
                    }
                    else {
                        if (row.key === '' && !unbalancedNode) {
                            unbalancedNode = row;
                        }
                        else {
                            groupNodes.push(row);
                        }
                    }
                });
                if (unbalancedNode) {
                    groupNodes.push(unbalancedNode);
                }
                group.childrenAfterGroup = [...leafNodes, ...groupNodes];
            }
        }, false);
    }
    createGroupingDetails(params) {
        var _a;
        const { rowNode, changedPath, rowNodeTransactions, rowNodeOrder } = params;
        const usingTreeData = this.gridOptionsService.get('treeData');
        const groupedCols = usingTreeData ? null : this.columnModel.getRowGroupColumns();
        const details = {
            // someone complained that the parent attribute was causing some change detection
            // to break in an angular add-on.  Taking the parent out breaks a cyclic dependency, hence this flag got introduced.
            includeParents: !this.gridOptionsService.get('suppressParentsInRowNodes'),
            expandByDefault: this.gridOptionsService.get('groupDefaultExpanded'),
            groupedCols: groupedCols,
            rootNode: rowNode,
            pivotMode: this.columnModel.isPivotMode(),
            groupedColCount: usingTreeData || !groupedCols ? 0 : groupedCols.length,
            rowNodeOrder: rowNodeOrder,
            transactions: rowNodeTransactions,
            // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway
            changedPath: changedPath,
            groupAllowUnbalanced: this.gridOptionsService.get('groupAllowUnbalanced'),
            isGroupOpenByDefault: this.gridOptionsService.getCallback('isGroupOpenByDefault'),
            initialGroupOrderComparator: this.gridOptionsService.getCallback('initialGroupOrderComparator'),
            usingTreeData: usingTreeData,
            suppressGroupMaintainValueType: this.gridOptionsService.get('suppressGroupMaintainValueType'),
            getDataPath: usingTreeData ? this.gridOptionsService.get('getDataPath') : undefined,
            keyCreators: (_a = groupedCols === null || groupedCols === void 0 ? void 0 : groupedCols.map(column => column.getColDef().keyCreator)) !== null && _a !== void 0 ? _a : []
        };
        return details;
    }
    handleTransaction(details) {
        details.transactions.forEach(tran => {
            // we don't allow batch remover for tree data as tree data uses Filler Nodes,
            // and creating/deleting filler nodes needs to be done alongside the node deleting
            // and moving. if we want to Batch Remover working with tree data then would need
            // to consider how Filler Nodes would be impacted (it's possible that it can be easily
            // modified to work, however for now I don't have the brain energy to work it all out).
            const batchRemover = !details.usingTreeData ? new BatchRemover() : undefined;
            // the order here of [add, remove, update] needs to be the same as in ClientSideNodeManager,
            // as the order is important when a record with the same id is added and removed in the same
            // transaction.
            if (_.existsAndNotEmpty(tran.remove)) {
                this.removeNodes(tran.remove, details, batchRemover);
            }
            if (_.existsAndNotEmpty(tran.update)) {
                this.moveNodesInWrongPath(tran.update, details, batchRemover);
            }
            if (_.existsAndNotEmpty(tran.add)) {
                this.insertNodes(tran.add, details, false);
            }
            // must flush here, and not allow another transaction to be applied,
            // as each transaction must finish leaving the data in a consistent state.
            if (batchRemover) {
                const parentsWithChildrenRemoved = batchRemover.getAllParents().slice();
                batchRemover.flush();
                this.removeEmptyGroups(parentsWithChildrenRemoved, details);
            }
        });
        if (details.rowNodeOrder) {
            this.sortChildren(details);
        }
    }
    // this is used when doing delta updates, eg Redux, keeps nodes in right order
    sortChildren(details) {
        details.changedPath.forEachChangedNodeDepthFirst(node => {
            if (!node.childrenAfterGroup) {
                return;
            }
            const didSort = _.sortRowNodesByOrder(node.childrenAfterGroup, details.rowNodeOrder);
            if (didSort) {
                details.changedPath.addParentNode(node);
            }
        }, false, true);
    }
    orderGroups(details) {
        const comparator = details.initialGroupOrderComparator;
        if (_.exists(comparator)) {
            recursiveSort(details.rootNode);
        }
        function recursiveSort(rowNode) {
            const doSort = _.exists(rowNode.childrenAfterGroup) &&
                // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)
                !rowNode.leafGroup;
            if (doSort) {
                rowNode.childrenAfterGroup.sort((nodeA, nodeB) => comparator({ nodeA, nodeB }));
                rowNode.childrenAfterGroup.forEach((childNode) => recursiveSort(childNode));
            }
        }
    }
    getExistingPathForNode(node, details) {
        const res = [];
        // when doing tree data, the node is part of the path,
        // but when doing grid grouping, the node is not part of the path so we start with the parent.
        let pointer = details.usingTreeData ? node : node.parent;
        while (pointer && pointer !== details.rootNode) {
            res.push({
                key: pointer.key,
                rowGroupColumn: pointer.rowGroupColumn,
                field: pointer.field
            });
            pointer = pointer.parent;
        }
        res.reverse();
        return res;
    }
    moveNodesInWrongPath(childNodes, details, batchRemover) {
        childNodes.forEach(childNode => {
            // we add node, even if parent has not changed, as the data could have
            // changed, hence aggregations will be wrong
            if (details.changedPath.isActive()) {
                details.changedPath.addParentNode(childNode.parent);
            }
            const infoToKeyMapper = (item) => item.key;
            const oldPath = this.getExistingPathForNode(childNode, details).map(infoToKeyMapper);
            const newPath = this.getGroupInfo(childNode, details).map(infoToKeyMapper);
            const nodeInCorrectPath = _.areEqual(oldPath, newPath);
            if (!nodeInCorrectPath) {
                this.moveNode(childNode, details, batchRemover);
            }
        });
    }
    moveNode(childNode, details, batchRemover) {
        this.removeNodesInStages([childNode], details, batchRemover);
        this.insertOneNode(childNode, details, true, batchRemover);
        // hack - if we didn't do this, then renaming a tree item (ie changing rowNode.key) wouldn't get
        // refreshed into the gui.
        // this is needed to kick off the event that rowComp listens to for refresh. this in turn
        // then will get each cell in the row to refresh - which is what we need as we don't know which
        // columns will be displaying the rowNode.key info.
        childNode.setData(childNode.data);
        // we add both old and new parents to changed path, as both will need to be refreshed.
        // we already added the old parent (in calling method), so just add the new parent here
        if (details.changedPath.isActive()) {
            const newParent = childNode.parent;
            details.changedPath.addParentNode(newParent);
        }
    }
    removeNodes(leafRowNodes, details, batchRemover) {
        this.removeNodesInStages(leafRowNodes, details, batchRemover);
        if (details.changedPath.isActive()) {
            leafRowNodes.forEach(rowNode => details.changedPath.addParentNode(rowNode.parent));
        }
    }
    removeNodesInStages(leafRowNodes, details, batchRemover) {
        this.removeNodesFromParents(leafRowNodes, details, batchRemover);
        if (details.usingTreeData) {
            this.postRemoveCreateFillerNodes(leafRowNodes, details);
            // When not TreeData, then removeEmptyGroups is called just before the BatchRemover is flushed.
            // However for TreeData, there is no BatchRemover, so we have to call removeEmptyGroups here.
            const nodeParents = leafRowNodes.map(n => n.parent);
            this.removeEmptyGroups(nodeParents, details);
        }
    }
    forEachParentGroup(details, group, callback) {
        let pointer = group;
        while (pointer && pointer !== details.rootNode) {
            callback(pointer);
            pointer = pointer.parent;
        }
    }
    removeNodesFromParents(nodesToRemove, details, provided) {
        // this method can be called with BatchRemover as optional. if it is missed, we created a local version
        // and flush it at the end. if one is provided, we add to the provided one and it gets flushed elsewhere.
        const batchRemoverIsLocal = provided == null;
        const batchRemoverToUse = provided ? provided : new BatchRemover();
        nodesToRemove.forEach(nodeToRemove => {
            this.removeFromParent(nodeToRemove, batchRemoverToUse);
            // remove from allLeafChildren. we clear down all parents EXCEPT the Root Node, as
            // the ClientSideNodeManager is responsible for the Root Node.
            this.forEachParentGroup(details, nodeToRemove.parent, parentNode => {
                batchRemoverToUse.removeFromAllLeafChildren(parentNode, nodeToRemove);
            });
        });
        if (batchRemoverIsLocal) {
            batchRemoverToUse.flush();
        }
    }
    postRemoveCreateFillerNodes(nodesToRemove, details) {
        nodesToRemove.forEach(nodeToRemove => {
            // if not group, and children are present, need to move children to a group.
            // otherwise if no children, we can just remove without replacing.
            const replaceWithGroup = nodeToRemove.hasChildren();
            if (replaceWithGroup) {
                const oldPath = this.getExistingPathForNode(nodeToRemove, details);
                // because we just removed the userGroup, this will always return new support group
                const newGroupNode = this.findParentForNode(nodeToRemove, oldPath, details);
                // these properties are the ones that will be incorrect in the newly created group,
                // so copy them from the old childNode
                newGroupNode.expanded = nodeToRemove.expanded;
                newGroupNode.allLeafChildren = nodeToRemove.allLeafChildren;
                newGroupNode.childrenAfterGroup = nodeToRemove.childrenAfterGroup;
                newGroupNode.childrenMapped = nodeToRemove.childrenMapped;
                newGroupNode.updateHasChildren();
                newGroupNode.childrenAfterGroup.forEach(rowNode => rowNode.parent = newGroupNode);
            }
        });
    }
    removeEmptyGroups(possibleEmptyGroups, details) {
        // we do this multiple times, as when we remove groups, that means the parent of just removed
        // group can then be empty. to get around this, if we remove, then we check everything again for
        // newly emptied groups. the max number of times this will execute is the depth of the group tree.
        let checkAgain = true;
        const groupShouldBeRemoved = (rowNode) => {
            // because of the while loop below, it's possible we already moved the node,
            // so double check before trying to remove again.
            const mapKey = this.getChildrenMappedKey(rowNode.key, rowNode.rowGroupColumn);
            const parentRowNode = rowNode.parent;
            const groupAlreadyRemoved = (parentRowNode && parentRowNode.childrenMapped) ?
                !parentRowNode.childrenMapped[mapKey] : true;
            if (groupAlreadyRemoved) {
                // if not linked, then group was already removed
                return false;
            }
            // if still not removed, then we remove if this group is empty
            return !!rowNode.isEmptyRowGroupNode();
        };
        while (checkAgain) {
            checkAgain = false;
            const batchRemover = new BatchRemover();
            possibleEmptyGroups.forEach(possibleEmptyGroup => {
                // remove empty groups
                this.forEachParentGroup(details, possibleEmptyGroup, rowNode => {
                    if (groupShouldBeRemoved(rowNode)) {
                        checkAgain = true;
                        this.removeFromParent(rowNode, batchRemover);
                        // we remove selection on filler nodes here, as the selection would not be removed
                        // from the RowNodeManager, as filler nodes don't exist on the RowNodeManager
                        rowNode.setSelectedParams({ newValue: false, source: 'rowGroupChanged' });
                    }
                });
            });
            batchRemover.flush();
        }
    }
    // removes the node from the parent by:
    // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)
    // b) removing from childrenMapped (immediately)
    // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed
    // d) setRowIndex(null) - as the rowNode will no longer be displayed.
    removeFromParent(child, batchRemover) {
        if (child.parent) {
            if (batchRemover) {
                batchRemover.removeFromChildrenAfterGroup(child.parent, child);
            }
            else {
                _.removeFromArray(child.parent.childrenAfterGroup, child);
                child.parent.updateHasChildren();
            }
        }
        const mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);
        if (child.parent && child.parent.childrenMapped) {
            child.parent.childrenMapped[mapKey] = undefined;
        }
        // this is important for transition, see rowComp removeFirstPassFuncs. when doing animation and
        // remove, if rowTop is still present, the rowComp thinks it's just moved position.
        child.setRowTop(null);
        child.setRowIndex(null);
    }
    addToParent(child, parent) {
        const mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);
        if (parent) {
            const children = parent.childrenMapped != null;
            if (children) {
                parent.childrenMapped[mapKey] = child;
            }
            parent.childrenAfterGroup.push(child);
            parent.updateHasChildren();
        }
    }
    areGroupColsEqual(d1, d2) {
        if (d1 == null || d2 == null || d1.pivotMode !== d2.pivotMode) {
            return false;
        }
        return _.areEqual(d1.groupedCols, d2.groupedCols) && _.areEqual(d1.keyCreators, d2.keyCreators);
    }
    checkAllGroupDataAfterColsChanged(details) {
        const recurse = (rowNodes) => {
            if (!rowNodes) {
                return;
            }
            rowNodes.forEach(rowNode => {
                const isLeafNode = !details.usingTreeData && !rowNode.group;
                if (isLeafNode) {
                    return;
                }
                const groupInfo = {
                    field: rowNode.field,
                    key: rowNode.key,
                    rowGroupColumn: rowNode.rowGroupColumn,
                    leafNode: rowNode.allLeafChildren[0],
                };
                this.setGroupData(rowNode, groupInfo, details);
                recurse(rowNode.childrenAfterGroup);
            });
        };
        recurse(details.rootNode.childrenAfterGroup);
    }
    shotgunResetEverything(details, afterColumnsChanged) {
        if (this.noChangeInGroupingColumns(details, afterColumnsChanged)) {
            return;
        }
        // groups are about to get disposed, so need to deselect any that are selected
        this.selectionService.filterFromSelection((node) => node && !node.group);
        const { rootNode, groupedCols } = details;
        // because we are not creating the root node each time, we have the logic
        // here to change leafGroup once.
        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting
        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.
        rootNode.leafGroup = details.usingTreeData ? false : groupedCols.length === 0;
        // we are doing everything from scratch, so reset childrenAfterGroup and childrenMapped from the rootNode
        rootNode.childrenAfterGroup = [];
        rootNode.childrenMapped = {};
        rootNode.updateHasChildren();
        const sibling = rootNode.sibling;
        if (sibling) {
            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;
            sibling.childrenMapped = rootNode.childrenMapped;
        }
        this.insertNodes(rootNode.allLeafChildren, details, false);
    }
    noChangeInGroupingColumns(details, afterColumnsChanged) {
        let noFurtherProcessingNeeded = false;
        const groupDisplayColumns = this.columnModel.getGroupDisplayColumns();
        const newGroupDisplayColIds = groupDisplayColumns ?
            groupDisplayColumns.map(c => c.getId()).join('-') : '';
        if (afterColumnsChanged) {
            // we only need to redo grouping if doing normal grouping (ie not tree data)
            // and the group cols have changed.
            noFurtherProcessingNeeded = details.usingTreeData || this.areGroupColsEqual(details, this.oldGroupingDetails);
            // if the group display cols have changed, then we need to update rowNode.groupData
            // (regardless of tree data or row grouping)
            if (this.oldGroupDisplayColIds !== newGroupDisplayColIds) {
                this.checkAllGroupDataAfterColsChanged(details);
            }
        }
        this.oldGroupingDetails = details;
        this.oldGroupDisplayColIds = newGroupDisplayColIds;
        return noFurtherProcessingNeeded;
    }
    insertNodes(newRowNodes, details, isMove) {
        newRowNodes.forEach(rowNode => {
            this.insertOneNode(rowNode, details, isMove);
            if (details.changedPath.isActive()) {
                details.changedPath.addParentNode(rowNode.parent);
            }
        });
    }
    insertOneNode(childNode, details, isMove, batchRemover) {
        const path = this.getGroupInfo(childNode, details);
        const parentGroup = this.findParentForNode(childNode, path, details, batchRemover);
        if (!parentGroup.group) {
            console.warn(`AG Grid: duplicate group keys for row data, keys should be unique`, [parentGroup.data, childNode.data]);
        }
        if (details.usingTreeData) {
            this.swapGroupWithUserNode(parentGroup, childNode, isMove);
        }
        else {
            childNode.parent = parentGroup;
            childNode.level = path.length;
            parentGroup.childrenAfterGroup.push(childNode);
            parentGroup.updateHasChildren();
        }
    }
    findParentForNode(childNode, path, details, batchRemover) {
        let nextNode = details.rootNode;
        path.forEach((groupInfo, level) => {
            nextNode = this.getOrCreateNextNode(nextNode, groupInfo, level, details);
            // node gets added to all group nodes.
            // note: we do not add to rootNode here, as the rootNode is the master list of rowNodes
            if (!(batchRemover === null || batchRemover === void 0 ? void 0 : batchRemover.isRemoveFromAllLeafChildren(nextNode, childNode))) {
                nextNode.allLeafChildren.push(childNode);
            }
            else {
                // if this node is about to be removed, prevent that
                batchRemover === null || batchRemover === void 0 ? void 0 : batchRemover.preventRemoveFromAllLeafChildren(nextNode, childNode);
            }
        });
        return nextNode;
    }
    swapGroupWithUserNode(fillerGroup, userGroup, isMove) {
        userGroup.parent = fillerGroup.parent;
        userGroup.key = fillerGroup.key;
        userGroup.field = fillerGroup.field;
        userGroup.groupData = fillerGroup.groupData;
        userGroup.level = fillerGroup.level;
        // AG-3441 - preserve the existing expanded status of the node if we're moving it, so that
        // you can drag a sub tree from one parent to another without changing its expansion
        if (!isMove) {
            userGroup.expanded = fillerGroup.expanded;
        }
        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting
        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.
        userGroup.leafGroup = fillerGroup.leafGroup;
        // always null for userGroups, as row grouping is not allowed when doing tree data
        userGroup.rowGroupIndex = fillerGroup.rowGroupIndex;
        userGroup.allLeafChildren = fillerGroup.allLeafChildren;
        userGroup.childrenAfterGroup = fillerGroup.childrenAfterGroup;
        userGroup.childrenMapped = fillerGroup.childrenMapped;
        userGroup.sibling = fillerGroup.sibling;
        userGroup.updateHasChildren();
        this.removeFromParent(fillerGroup);
        userGroup.childrenAfterGroup.forEach((rowNode) => rowNode.parent = userGroup);
        this.addToParent(userGroup, fillerGroup.parent);
    }
    getOrCreateNextNode(parentGroup, groupInfo, level, details) {
        const key = this.getChildrenMappedKey(groupInfo.key, groupInfo.rowGroupColumn);
        let nextNode = parentGroup.childrenMapped ? parentGroup.childrenMapped[key] : undefined;
        if (!nextNode) {
            nextNode = this.createGroup(groupInfo, parentGroup, level, details);
            // attach the new group to the parent
            this.addToParent(nextNode, parentGroup);
        }
        return nextNode;
    }
    createGroup(groupInfo, parent, level, details) {
        const groupNode = new RowNode(this.beans);
        groupNode.group = true;
        groupNode.field = groupInfo.field;
        groupNode.rowGroupColumn = groupInfo.rowGroupColumn;
        this.setGroupData(groupNode, groupInfo, details);
        groupNode.key = groupInfo.key;
        groupNode.id = this.createGroupId(groupNode, parent, details.usingTreeData, level);
        groupNode.level = level;
        groupNode.leafGroup = details.usingTreeData ? false : level === (details.groupedColCount - 1);
        groupNode.allLeafChildren = [];
        // why is this done here? we are not updating the children count as we go,
        // i suspect this is updated in the filter stage
        groupNode.setAllChildrenCount(0);
        groupNode.rowGroupIndex = details.usingTreeData ? null : level;
        groupNode.childrenAfterGroup = [];
        groupNode.childrenMapped = {};
        groupNode.updateHasChildren();
        groupNode.parent = details.includeParents ? parent : null;
        this.setExpandedInitialValue(details, groupNode);
        return groupNode;
    }
    createGroupId(node, parent, usingTreeData, level) {
        let createGroupId;
        if (usingTreeData) {
            createGroupId = (node, parent, level) => {
                if (level < 0) {
                    return null;
                } // root node
                const parentId = parent ? createGroupId(parent, parent.parent, level - 1) : null;
                return `${parentId == null ? '' : parentId + '-'}${level}-${node.key}`;
            };
        }
        else {
            createGroupId = (node, parent) => {
                if (!node.rowGroupColumn) {
                    return null;
                } // root node
                const parentId = parent ? createGroupId(parent, parent.parent, 0) : null;
                return `${parentId == null ? '' : parentId + '-'}${node.rowGroupColumn.getColId()}-${node.key}`;
            };
        }
        // we put 'row-group-' before the group id, so it doesn't clash with standard row id's. we also use 't-' and 'b-'
        // for top pinned and bottom pinned rows.
        return RowNode.ID_PREFIX_ROW_GROUP + createGroupId(node, parent, level);
    }
    setGroupData(groupNode, groupInfo, details) {
        groupNode.groupData = {};
        const groupDisplayCols = this.columnModel.getGroupDisplayColumns();
        groupDisplayCols.forEach(col => {
            // newGroup.rowGroupColumn=null when working off GroupInfo, and we always display the group in the group column
            // if rowGroupColumn is present, then it's grid row grouping and we only include if configuration says so
            const isTreeData = details.usingTreeData;
            if (isTreeData) {
                groupNode.groupData[col.getColId()] = groupInfo.key;
                return;
            }
            const groupColumn = groupNode.rowGroupColumn;
            const isRowGroupDisplayed = groupColumn !== null && col.isRowGroupDisplayed(groupColumn.getId());
            if (isRowGroupDisplayed) {
                if (details.suppressGroupMaintainValueType) {
                    groupNode.groupData[col.getColId()] = groupInfo.key;
                }
                else {
                    // if maintain group value type, get the value from any leaf node.
                    groupNode.groupData[col.getColId()] = this.valueService.getValue(groupColumn, groupInfo.leafNode);
                }
            }
        });
    }
    getChildrenMappedKey(key, rowGroupColumn) {
        if (rowGroupColumn) {
            // grouping by columns
            return rowGroupColumn.getId() + '-' + key;
        }
        // tree data - we don't have rowGroupColumns
        return key;
    }
    setExpandedInitialValue(details, groupNode) {
        // if pivoting the leaf group is never expanded as we do not show leaf rows
        if (details.pivotMode && groupNode.leafGroup) {
            groupNode.expanded = false;
            return;
        }
        // use callback if exists
        const userCallback = details.isGroupOpenByDefault;
        if (userCallback) {
            const params = {
                rowNode: groupNode,
                field: groupNode.field,
                key: groupNode.key,
                level: groupNode.level,
                rowGroupColumn: groupNode.rowGroupColumn
            };
            groupNode.expanded = userCallback(params) == true;
            return;
        }
        // use expandByDefault if exists
        const { expandByDefault } = details;
        if (details.expandByDefault === -1) {
            groupNode.expanded = true;
            return;
        }
        // otherwise
        groupNode.expanded = groupNode.level < expandByDefault;
    }
    getGroupInfo(rowNode, details) {
        if (details.usingTreeData) {
            return this.getGroupInfoFromCallback(rowNode, details);
        }
        return this.getGroupInfoFromGroupColumns(rowNode, details);
    }
    getGroupInfoFromCallback(rowNode, details) {
        const keys = details.getDataPath ? details.getDataPath(rowNode.data) : null;
        if (keys === null || keys === undefined || keys.length === 0) {
            _.warnOnce(`getDataPath() should not return an empty path for data ${rowNode.data}`);
        }
        const groupInfoMapper = (key) => ({ key, field: null, rowGroupColumn: null });
        return keys ? keys.map(groupInfoMapper) : [];
    }
    getGroupInfoFromGroupColumns(rowNode, details) {
        const res = [];
        details.groupedCols.forEach(groupCol => {
            let key = this.valueService.getKeyForNode(groupCol, rowNode);
            let keyExists = key !== null && key !== undefined && key !== '';
            // unbalanced tree and pivot mode don't work together - not because of the grid, it doesn't make
            // mathematical sense as you are building up a cube. so if pivot mode, we put in a blank key where missing.
            // this keeps the tree balanced and hence can be represented as a group.
            const createGroupForEmpty = details.pivotMode || !details.groupAllowUnbalanced;
            if (createGroupForEmpty && !keyExists) {
                key = '';
                keyExists = true;
            }
            if (keyExists) {
                const item = {
                    key: key,
                    field: groupCol.getColDef().field,
                    rowGroupColumn: groupCol,
                    leafNode: rowNode,
                };
                res.push(item);
            }
        });
        return res;
    }
};
__decorate$17([
    Autowired('columnModel')
], GroupStage.prototype, "columnModel", void 0);
__decorate$17([
    Autowired('selectableService')
], GroupStage.prototype, "selectableService", void 0);
__decorate$17([
    Autowired('valueService')
], GroupStage.prototype, "valueService", void 0);
__decorate$17([
    Autowired('beans')
], GroupStage.prototype, "beans", void 0);
__decorate$17([
    Autowired('selectionService')
], GroupStage.prototype, "selectionService", void 0);
GroupStage = __decorate$17([
    Bean('groupStage')
], GroupStage);

var __decorate$18 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PivotColDefService_1;
let PivotColDefService = PivotColDefService_1 = class PivotColDefService extends BeanStub {
    init() {
        const getFieldSeparator = () => { var _a; return (_a = this.gos.get('serverSidePivotResultFieldSeparator')) !== null && _a !== void 0 ? _a : '_'; };
        this.fieldSeparator = getFieldSeparator();
        this.addManagedPropertyListener('serverSidePivotResultFieldSeparator', () => { this.fieldSeparator = getFieldSeparator(); });
        const getPivotDefaultExpanded = () => this.gos.get('pivotDefaultExpanded');
        this.pivotDefaultExpanded = getPivotDefaultExpanded();
        this.addManagedPropertyListener('pivotDefaultExpanded', () => { this.pivotDefaultExpanded = getPivotDefaultExpanded(); });
    }
    createPivotColumnDefs(uniqueValues) {
        // this is passed to the columnModel, to configure the columns and groups we show
        const pivotColumnGroupDefs = this.createPivotColumnsFromUniqueValues(uniqueValues);
        function extractColDefs(input, arr = []) {
            input.forEach((def) => {
                if (def.children !== undefined) {
                    extractColDefs(def.children, arr);
                }
                else {
                    arr.push(def);
                }
            });
            return arr;
        }
        const pivotColumnDefs = extractColDefs(pivotColumnGroupDefs);
        // additional columns that contain the aggregated total for each value column per row
        this.addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs);
        // additional group columns that contain child totals for each collapsed child column / group
        this.addExpandablePivotGroups(pivotColumnGroupDefs, pivotColumnDefs);
        // additional group columns that contain an aggregated total across all child columns
        this.addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs);
        // we clone, so the colDefs in pivotColumnsGroupDefs and pivotColumnDefs are not shared. this is so that
        // any changes the user makes (via processSecondaryColumnDefinitions) don't impact the internal aggregations,
        // as these use the col defs also
        const pivotColumnDefsClone = pivotColumnDefs.map(colDef => _.cloneObject(colDef));
        return {
            pivotColumnGroupDefs: pivotColumnGroupDefs,
            pivotColumnDefs: pivotColumnDefsClone
        };
    }
    createPivotColumnsFromUniqueValues(uniqueValues) {
        const pivotColumns = this.columnModel.getPivotColumns();
        const maxDepth = pivotColumns.length;
        const pivotColumnGroupDefs = this.recursivelyBuildGroup(0, uniqueValues, [], maxDepth, pivotColumns);
        return pivotColumnGroupDefs;
    }
    recursivelyBuildGroup(index, uniqueValue, pivotKeys, maxDepth, primaryPivotColumns) {
        const measureColumns = this.columnModel.getValueColumns();
        if (index >= maxDepth) { // Base case - build the measure columns
            return this.buildMeasureCols(pivotKeys);
        }
        // sort by either user provided comparator, or our own one
        const primaryPivotColumnDefs = primaryPivotColumns[index].getColDef();
        const comparator = this.headerNameComparator.bind(this, primaryPivotColumnDefs.pivotComparator);
        // Base case for the compact layout, instead of recursing build the last layer of groups as measure columns instead
        if (measureColumns.length === 1 && this.gridOptionsService.get('removePivotHeaderRowWhenSingleValueColumn') && index === maxDepth - 1) {
            const leafCols = [];
            _.iterateObject(uniqueValue, (key) => {
                const newPivotKeys = [...pivotKeys, key];
                const colDef = this.createColDef(measureColumns[0], key, newPivotKeys);
                colDef.columnGroupShow = 'open';
                leafCols.push(colDef);
            });
            leafCols.sort(comparator);
            return leafCols;
        }
        // Recursive case
        const groups = [];
        _.iterateObject(uniqueValue, (key, value) => {
            // expand group by default based on depth of group. (pivotDefaultExpanded provides desired level of depth for expanding group by default)
            const openByDefault = this.pivotDefaultExpanded === -1 || (index < this.pivotDefaultExpanded);
            const newPivotKeys = [...pivotKeys, key];
            groups.push({
                children: this.recursivelyBuildGroup(index + 1, value, newPivotKeys, maxDepth, primaryPivotColumns),
                headerName: key,
                pivotKeys: newPivotKeys,
                columnGroupShow: 'open',
                openByDefault: openByDefault,
                groupId: this.generateColumnGroupId(newPivotKeys),
            });
        });
        groups.sort(comparator);
        return groups;
    }
    buildMeasureCols(pivotKeys) {
        const measureColumns = this.columnModel.getValueColumns();
        if (measureColumns.length === 0) {
            // if no value columns selected, then we insert one blank column, so the user at least sees columns
            // rendered. otherwise the grid would render with no columns (just empty groups) which would give the
            // impression that the grid is broken
            return [this.createColDef(null, '-', pivotKeys)];
        }
        return measureColumns.map((measureCol) => {
            const columnName = this.columnModel.getDisplayNameForColumn(measureCol, 'header');
            return Object.assign(Object.assign({}, this.createColDef(measureCol, columnName, pivotKeys)), { columnGroupShow: 'open' });
        });
    }
    ;
    addExpandablePivotGroups(pivotColumnGroupDefs, pivotColumnDefs) {
        if (this.gridOptionsService.get('suppressExpandablePivotGroups') ||
            this.gridOptionsService.get('pivotColumnGroupTotals')) {
            return;
        }
        const recursivelyAddSubTotals = (groupDef, currentPivotColumnDefs, acc) => {
            const group = groupDef;
            if (group.children) {
                const childAcc = new Map();
                group.children.forEach((grp) => {
                    recursivelyAddSubTotals(grp, currentPivotColumnDefs, childAcc);
                });
                const firstGroup = !group.children.some(child => child.children);
                this.columnModel.getValueColumns().forEach(valueColumn => {
                    const columnName = this.columnModel.getDisplayNameForColumn(valueColumn, 'header');
                    const totalColDef = this.createColDef(valueColumn, columnName, groupDef.pivotKeys);
                    totalColDef.pivotTotalColumnIds = childAcc.get(valueColumn.getColId());
                    totalColDef.columnGroupShow = 'closed';
                    totalColDef.aggFunc = valueColumn.getAggFunc();
                    if (!firstGroup) {
                        // add total colDef to group and pivot colDefs array
                        const children = groupDef.children;
                        children.push(totalColDef);
                        currentPivotColumnDefs.push(totalColDef);
                    }
                });
                this.merge(acc, childAcc);
            }
            else {
                const def = groupDef;
                // check that value column exists, i.e. aggFunc is supplied
                if (!def.pivotValueColumn) {
                    return;
                }
                const pivotValueColId = def.pivotValueColumn.getColId();
                const arr = acc.has(pivotValueColId) ? acc.get(pivotValueColId) : [];
                arr.push(def.colId);
                acc.set(pivotValueColId, arr);
            }
        };
        pivotColumnGroupDefs.forEach((groupDef) => {
            recursivelyAddSubTotals(groupDef, pivotColumnDefs, new Map());
        });
    }
    addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs) {
        if (!this.gridOptionsService.get('pivotColumnGroupTotals')) {
            return;
        }
        const insertAfter = this.gridOptionsService.get('pivotColumnGroupTotals') === 'after';
        const valueCols = this.columnModel.getValueColumns();
        const aggFuncs = valueCols.map(valueCol => valueCol.getAggFunc());
        // don't add pivot totals if there is less than 1 aggFunc or they are not all the same
        if (!aggFuncs || aggFuncs.length < 1 || !this.sameAggFuncs(aggFuncs)) {
            // console.warn('AG Grid: aborting adding pivot total columns - value columns require same aggFunc');
            return;
        }
        // arbitrarily select a value column to use as a template for pivot columns
        const valueColumn = valueCols[0];
        pivotColumnGroupDefs.forEach((groupDef) => {
            this.recursivelyAddPivotTotal(groupDef, pivotColumnDefs, valueColumn, insertAfter);
        });
    }
    recursivelyAddPivotTotal(groupDef, pivotColumnDefs, valueColumn, insertAfter) {
        const group = groupDef;
        if (!group.children) {
            const def = groupDef;
            return def.colId ? [def.colId] : null;
        }
        let colIds = [];
        // need to recurse children first to obtain colIds used in the aggregation stage
        group.children
            .forEach((grp) => {
            const childColIds = this.recursivelyAddPivotTotal(grp, pivotColumnDefs, valueColumn, insertAfter);
            if (childColIds) {
                colIds = colIds.concat(childColIds);
            }
        });
        // only add total colDef if there is more than 1 child node
        if (group.children.length > 1) {
            const localeTextFunc = this.localeService.getLocaleTextFunc();
            const headerName = localeTextFunc('pivotColumnGroupTotals', 'Total');
            //create total colDef using an arbitrary value column as a template
            const totalColDef = this.createColDef(valueColumn, headerName, groupDef.pivotKeys, true);
            totalColDef.pivotTotalColumnIds = colIds;
            totalColDef.aggFunc = valueColumn.getAggFunc();
            // add total colDef to group and pivot colDefs array
            const children = groupDef.children;
            insertAfter ? children.push(totalColDef) : children.unshift(totalColDef);
            pivotColumnDefs.push(totalColDef);
        }
        return colIds;
    }
    addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs) {
        if (!this.gridOptionsService.get('pivotRowTotals')) {
            return;
        }
        const insertAfter = this.gridOptionsService.get('pivotRowTotals') === 'after';
        const valueColumns = this.columnModel.getValueColumns();
        // order of row group totals depends on position
        const valueCols = insertAfter ? valueColumns.slice() : valueColumns.slice().reverse();
        for (let i = 0; i < valueCols.length; i++) {
            const valueCol = valueCols[i];
            let colIds = [];
            pivotColumnGroupDefs.forEach((groupDef) => {
                colIds = colIds.concat(this.extractColIdsForValueColumn(groupDef, valueCol));
            });
            const withGroup = valueCols.length > 1 || !this.gridOptionsService.get('removePivotHeaderRowWhenSingleValueColumn');
            this.createRowGroupTotal(pivotColumnGroupDefs, pivotColumnDefs, valueCol, colIds, insertAfter, withGroup);
        }
    }
    extractColIdsForValueColumn(groupDef, valueColumn) {
        const group = groupDef;
        if (!group.children) {
            const colDef = group;
            return colDef.pivotValueColumn === valueColumn && colDef.colId ? [colDef.colId] : [];
        }
        let colIds = [];
        group.children
            .forEach((grp) => {
            this.extractColIdsForValueColumn(grp, valueColumn);
            const childColIds = this.extractColIdsForValueColumn(grp, valueColumn);
            colIds = colIds.concat(childColIds);
        });
        return colIds;
    }
    createRowGroupTotal(parentChildren, pivotColumnDefs, valueColumn, colIds, insertAfter, addGroup) {
        const measureColumns = this.columnModel.getValueColumns();
        let colDef;
        if (measureColumns.length === 0) {
            colDef = this.createColDef(null, '-', []);
        }
        else {
            const columnName = this.columnModel.getDisplayNameForColumn(valueColumn, 'header');
            colDef = this.createColDef(valueColumn, columnName, []);
            colDef.pivotTotalColumnIds = colIds;
        }
        colDef.colId = PivotColDefService_1.PIVOT_ROW_TOTAL_PREFIX + colDef.colId;
        pivotColumnDefs.push(colDef);
        const valueGroup = addGroup ? {
            children: [colDef],
            pivotKeys: [],
            groupId: `${PivotColDefService_1.PIVOT_ROW_TOTAL_PREFIX}_pivotGroup_${valueColumn.getColId()}`,
        } : colDef;
        insertAfter ? parentChildren.push(valueGroup) : parentChildren.unshift(valueGroup);
    }
    createColDef(valueColumn, headerName, pivotKeys, totalColumn = false) {
        const colDef = {};
        // This is null when there are no measure columns and we're creating placeholder columns
        if (valueColumn) {
            const colDefToCopy = valueColumn.getColDef();
            Object.assign(colDef, colDefToCopy);
            // even if original column was hidden, we always show the pivot value column, otherwise it would be
            // very confusing for people thinking the pivot is broken
            colDef.hide = false;
        }
        colDef.headerName = headerName;
        colDef.colId = this.generateColumnId(pivotKeys || [], valueColumn && !totalColumn ? valueColumn.getColId() : '');
        // pivot columns repeat over field, so it makes sense to use the unique id instead. For example if you want to
        // assign values to pinned bottom rows using setPinnedBottomRowData the value service will use this colId.
        colDef.field = colDef.colId;
        // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId
        // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects
        colDef.valueGetter = (params) => { var _a; return (_a = params.data) === null || _a === void 0 ? void 0 : _a[params.colDef.field]; };
        colDef.pivotKeys = pivotKeys;
        colDef.pivotValueColumn = valueColumn;
        if (colDef.filter === true) {
            colDef.filter = 'agNumberColumnFilter';
        }
        return colDef;
    }
    sameAggFuncs(aggFuncs) {
        if (aggFuncs.length == 1) {
            return true;
        }
        //check if all aggFunc's match
        for (let i = 1; i < aggFuncs.length; i++) {
            if (aggFuncs[i] !== aggFuncs[0]) {
                return false;
            }
        }
        return true;
    }
    headerNameComparator(userComparator, a, b) {
        if (userComparator) {
            return userComparator(a.headerName, b.headerName);
        }
        else {
            if (a.headerName && !b.headerName) {
                return 1;
            }
            else if (!a.headerName && b.headerName) {
                return -1;
            }
            // slightly naff here - just to satify typescript
            // really should be &&, but if so ts complains
            // the above if/else checks would deal with either being falsy, so at this stage if either are falsy, both are
            // ..still naff though
            if (!a.headerName || !b.headerName) {
                return 0;
            }
            if (a.headerName < b.headerName) {
                return -1;
            }
            if (a.headerName > b.headerName) {
                return 1;
            }
            return 0;
        }
    }
    merge(m1, m2) {
        m2.forEach((value, key, map) => {
            const existingList = m1.has(key) ? m1.get(key) : [];
            const updatedList = [...existingList, ...value];
            m1.set(key, updatedList);
        });
    }
    generateColumnGroupId(pivotKeys) {
        const pivotCols = this.columnModel.getPivotColumns().map((col) => col.getColId());
        return `pivotGroup_${pivotCols.join('-')}_${pivotKeys.join('-')}`;
    }
    generateColumnId(pivotKeys, measureColumnId) {
        const pivotCols = this.columnModel.getPivotColumns().map((col) => col.getColId());
        return `pivot_${pivotCols.join('-')}_${pivotKeys.join('-')}_${measureColumnId}`;
    }
    /**
     * Used by the SSRM to create secondary columns from provided fields
     * @param fields
     */
    createColDefsFromFields(fields) {
        // tear the ids down into groups, while this could be done in-step with the next stage, the lookup is faster 
        // than searching col group children array for the right group
        const uniqueValues = {};
        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            const parts = field.split(this.fieldSeparator);
            let level = uniqueValues;
            for (let p = 0; p < parts.length; p++) {
                const part = parts[p];
                if (level[part] == null) {
                    level[part] = {};
                }
                level = level[part];
            }
        }
        const uniqueValuesToGroups = (id, key, uniqueValues, depth) => {
            var _a;
            const children = [];
            for (let key in uniqueValues) {
                const item = uniqueValues[key];
                const child = uniqueValuesToGroups(`${id}${this.fieldSeparator}${key}`, key, item, depth + 1);
                children.push(child);
            }
            if (children.length === 0) {
                const potentialAggCol = this.columnModel.getPrimaryColumn(key);
                if (potentialAggCol) {
                    const headerName = (_a = this.columnModel.getDisplayNameForColumn(potentialAggCol, 'header')) !== null && _a !== void 0 ? _a : key;
                    const colDef = this.createColDef(potentialAggCol, headerName, undefined, false);
                    colDef.colId = id;
                    colDef.aggFunc = potentialAggCol.getAggFunc();
                    colDef.valueGetter = (params) => { var _a; return (_a = params.data) === null || _a === void 0 ? void 0 : _a[id]; };
                    return colDef;
                }
                const col = {
                    colId: id,
                    headerName: key,
                    // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId
                    // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects
                    valueGetter: (params) => { var _a; return (_a = params.data) === null || _a === void 0 ? void 0 : _a[id]; },
                };
                return col;
            }
            // this is a bit sketchy. As the fields can be anything we just build groups as deep as the fields go.
            // nothing says user has to give us groups the same depth.
            const collapseSingleChildren = this.gridOptionsService.get('removePivotHeaderRowWhenSingleValueColumn');
            if (collapseSingleChildren && children.length === 1 && 'colId' in children[0]) {
                children[0].headerName = key;
                return children[0];
            }
            const group = {
                openByDefault: this.pivotDefaultExpanded === -1 || depth < this.pivotDefaultExpanded,
                groupId: id,
                headerName: key,
                children,
            };
            return group;
        };
        const res = [];
        for (let key in uniqueValues) {
            const item = uniqueValues[key];
            const col = uniqueValuesToGroups(key, key, item, 0);
            res.push(col);
        }
        return res;
    }
};
PivotColDefService.PIVOT_ROW_TOTAL_PREFIX = 'PivotRowTotal_';
__decorate$18([
    Autowired('columnModel')
], PivotColDefService.prototype, "columnModel", void 0);
__decorate$18([
    Autowired('gridOptionsService')
], PivotColDefService.prototype, "gos", void 0);
__decorate$18([
    PostConstruct
], PivotColDefService.prototype, "init", null);
PivotColDefService = PivotColDefService_1 = __decorate$18([
    Bean('pivotColDefService')
], PivotColDefService);

var __decorate$19 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let PivotStage = class PivotStage extends BeanStub {
    constructor() {
        super(...arguments);
        this.uniqueValues = {};
    }
    execute(params) {
        const changedPath = params.changedPath;
        if (this.columnModel.isPivotActive()) {
            this.executePivotOn(changedPath);
        }
        else {
            this.executePivotOff(changedPath);
        }
    }
    executePivotOff(changedPath) {
        this.aggregationColumnsHashLastTime = null;
        this.uniqueValues = {};
        if (this.columnModel.isSecondaryColumnsPresent()) {
            this.columnModel.setSecondaryColumns(null, "rowModelUpdated");
            if (changedPath) {
                changedPath.setInactive();
            }
        }
    }
    executePivotOn(changedPath) {
        const uniqueValues = this.bucketUpRowNodes(changedPath);
        const uniqueValuesChanged = this.setUniqueValues(uniqueValues);
        const aggregationColumns = this.columnModel.getValueColumns();
        const aggregationColumnsHash = aggregationColumns.map((column) => `${column.getId()}-${column.getColDef().headerName}`).join('#');
        const aggregationFuncsHash = aggregationColumns.map((column) => column.getAggFunc().toString()).join('#');
        const aggregationColumnsChanged = this.aggregationColumnsHashLastTime !== aggregationColumnsHash;
        const aggregationFuncsChanged = this.aggregationFuncsHashLastTime !== aggregationFuncsHash;
        this.aggregationColumnsHashLastTime = aggregationColumnsHash;
        this.aggregationFuncsHashLastTime = aggregationFuncsHash;
        const groupColumnsHash = this.columnModel.getRowGroupColumns().map((column) => column.getId()).join('#');
        const groupColumnsChanged = groupColumnsHash !== this.groupColumnsHashLastTime;
        this.groupColumnsHashLastTime = groupColumnsHash;
        const pivotRowTotals = this.gridOptionsService.get('pivotRowTotals');
        const pivotColumnGroupTotals = this.gridOptionsService.get('pivotColumnGroupTotals');
        const suppressExpandablePivotGroups = this.gridOptionsService.get('suppressExpandablePivotGroups');
        const removePivotHeaderRowWhenSingleValueColumn = this.gridOptionsService.get('removePivotHeaderRowWhenSingleValueColumn');
        const anyGridOptionsChanged = (pivotRowTotals !== this.pivotRowTotalsLastTime || pivotColumnGroupTotals !== this.pivotColumnGroupTotalsLastTime ||
            suppressExpandablePivotGroups !== this.suppressExpandablePivotGroupsLastTime || removePivotHeaderRowWhenSingleValueColumn !== this.removePivotHeaderRowWhenSingleValueColumnLastTime);
        this.pivotRowTotalsLastTime = pivotRowTotals;
        this.pivotColumnGroupTotalsLastTime = pivotColumnGroupTotals;
        this.suppressExpandablePivotGroupsLastTime = suppressExpandablePivotGroups;
        this.removePivotHeaderRowWhenSingleValueColumnLastTime = removePivotHeaderRowWhenSingleValueColumn;
        if (uniqueValuesChanged || aggregationColumnsChanged || groupColumnsChanged || aggregationFuncsChanged || anyGridOptionsChanged) {
            const { pivotColumnGroupDefs, pivotColumnDefs } = this.pivotColDefService.createPivotColumnDefs(this.uniqueValues);
            this.pivotColumnDefs = pivotColumnDefs;
            this.columnModel.setSecondaryColumns(pivotColumnGroupDefs, "rowModelUpdated");
            // because the secondary columns have changed, then the aggregation needs to visit the whole
            // tree again, so we make the changedPath not active, to force aggregation to visit all paths.
            if (changedPath) {
                changedPath.setInactive();
            }
        }
    }
    setUniqueValues(newValues) {
        const json1 = JSON.stringify(newValues);
        const json2 = JSON.stringify(this.uniqueValues);
        const uniqueValuesChanged = json1 !== json2;
        // we only continue the below if the unique values are different, as otherwise
        // the result will be the same as the last time we did it
        if (uniqueValuesChanged) {
            this.uniqueValues = newValues;
            return true;
        }
        else {
            return false;
        }
    }
    bucketUpRowNodes(changedPath) {
        // accessed from inside inner function
        const uniqueValues = {};
        // ensure childrenMapped is cleared, as if a node has been filtered out it should not have mapped children.
        changedPath.forEachChangedNodeDepthFirst(node => {
            if (node.leafGroup) {
                node.childrenMapped = null;
            }
        });
        const recursivelyBucketFilteredChildren = (node) => {
            var _a;
            if (node.leafGroup) {
                this.bucketRowNode(node, uniqueValues);
            }
            else {
                (_a = node.childrenAfterFilter) === null || _a === void 0 ? void 0 : _a.forEach(recursivelyBucketFilteredChildren);
            }
        };
        changedPath.executeFromRootNode(recursivelyBucketFilteredChildren);
        return uniqueValues;
    }
    bucketRowNode(rowNode, uniqueValues) {
        const pivotColumns = this.columnModel.getPivotColumns();
        if (pivotColumns.length === 0) {
            rowNode.childrenMapped = null;
        }
        else {
            rowNode.childrenMapped = this.bucketChildren(rowNode.childrenAfterFilter, pivotColumns, 0, uniqueValues);
        }
        if (rowNode.sibling) {
            rowNode.sibling.childrenMapped = rowNode.childrenMapped;
        }
    }
    bucketChildren(children, pivotColumns, pivotIndex, uniqueValues) {
        const mappedChildren = {};
        const pivotColumn = pivotColumns[pivotIndex];
        // map the children out based on the pivot column
        children.forEach((child) => {
            let key = this.valueService.getKeyForNode(pivotColumn, child);
            if (_.missing(key)) {
                key = '';
            }
            if (!uniqueValues[key]) {
                uniqueValues[key] = {};
            }
            if (!mappedChildren[key]) {
                mappedChildren[key] = [];
            }
            mappedChildren[key].push(child);
        });
        // if it's the last pivot column, return as is, otherwise go one level further in the map
        if (pivotIndex === pivotColumns.length - 1) {
            return mappedChildren;
        }
        else {
            const result = {};
            _.iterateObject(mappedChildren, (key, value) => {
                result[key] = this.bucketChildren(value, pivotColumns, pivotIndex + 1, uniqueValues[key]);
            });
            return result;
        }
    }
    getPivotColumnDefs() {
        return this.pivotColumnDefs;
    }
};
__decorate$19([
    Autowired('valueService')
], PivotStage.prototype, "valueService", void 0);
__decorate$19([
    Autowired('columnModel')
], PivotStage.prototype, "columnModel", void 0);
__decorate$19([
    Autowired('pivotColDefService')
], PivotStage.prototype, "pivotColDefService", void 0);
PivotStage = __decorate$19([
    Bean('pivotStage')
], PivotStage);

var __decorate$1a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AggFuncService_1;
// @ts-ignore
const AGBigInt = typeof BigInt === 'undefined' ? null : BigInt;
const defaultAggFuncNames = {
    sum: 'Sum',
    first: 'First',
    last: 'Last',
    min: 'Min',
    max: 'Max',
    count: 'Count',
    avg: 'Average',
};
let AggFuncService = AggFuncService_1 = class AggFuncService extends BeanStub {
    constructor() {
        super(...arguments);
        this.aggFuncsMap = {};
        this.initialised = false;
    }
    init() {
        if (this.initialised) {
            return;
        }
        this.initialiseWithDefaultAggregations();
        this.addAggFuncs(this.gridOptionsService.get('aggFuncs'));
    }
    initialiseWithDefaultAggregations() {
        this.aggFuncsMap[AggFuncService_1.AGG_SUM] = aggSum;
        this.aggFuncsMap[AggFuncService_1.AGG_FIRST] = aggFirst;
        this.aggFuncsMap[AggFuncService_1.AGG_LAST] = aggLast;
        this.aggFuncsMap[AggFuncService_1.AGG_MIN] = aggMin;
        this.aggFuncsMap[AggFuncService_1.AGG_MAX] = aggMax;
        this.aggFuncsMap[AggFuncService_1.AGG_COUNT] = aggCount;
        this.aggFuncsMap[AggFuncService_1.AGG_AVG] = aggAvg;
        this.initialised = true;
    }
    isAggFuncPossible(column, func) {
        const allKeys = this.getFuncNames(column);
        const allowed = _.includes(allKeys, func);
        const funcExists = _.exists(this.aggFuncsMap[func]);
        return allowed && funcExists;
    }
    getDefaultFuncLabel(fctName) {
        var _a;
        return (_a = defaultAggFuncNames[fctName]) !== null && _a !== void 0 ? _a : fctName;
    }
    getDefaultAggFunc(column) {
        const defaultAgg = column.getColDef().defaultAggFunc;
        if (_.exists(defaultAgg) && this.isAggFuncPossible(column, defaultAgg)) {
            return defaultAgg;
        }
        if (this.isAggFuncPossible(column, AggFuncService_1.AGG_SUM)) {
            return AggFuncService_1.AGG_SUM;
        }
        const allKeys = this.getFuncNames(column);
        return _.existsAndNotEmpty(allKeys) ? allKeys[0] : null;
    }
    addAggFuncs(aggFuncs) {
        this.init();
        _.iterateObject(aggFuncs, (key, aggFunc) => {
            this.aggFuncsMap[key] = aggFunc;
        });
    }
    getAggFunc(name) {
        this.init();
        return this.aggFuncsMap[name];
    }
    getFuncNames(column) {
        const userAllowedFuncs = column.getColDef().allowedAggFuncs;
        return userAllowedFuncs == null ? Object.keys(this.aggFuncsMap).sort() : userAllowedFuncs;
    }
    clear() {
        this.aggFuncsMap = {};
    }
};
AggFuncService.AGG_SUM = 'sum';
AggFuncService.AGG_FIRST = 'first';
AggFuncService.AGG_LAST = 'last';
AggFuncService.AGG_MIN = 'min';
AggFuncService.AGG_MAX = 'max';
AggFuncService.AGG_COUNT = 'count';
AggFuncService.AGG_AVG = 'avg';
__decorate$1a([
    PostConstruct
], AggFuncService.prototype, "init", null);
AggFuncService = AggFuncService_1 = __decorate$1a([
    Bean('aggFuncService')
], AggFuncService);
function aggSum(params) {
    const { values } = params;
    let result = null; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (typeof value === 'number') {
            if (result === null) {
                result = value;
            }
            else {
                if (AGBigInt) {
                    result += typeof result === 'number' ? value : AGBigInt(value);
                }
                else {
                    result += value;
                }
            }
        }
        else if (typeof value === 'bigint') {
            if (result === null) {
                result = value;
            }
            else {
                result = (typeof result === 'bigint' ? result : AGBigInt(result)) + value;
            }
        }
    }
    return result;
}
function aggFirst(params) {
    return params.values.length > 0 ? params.values[0] : null;
}
function aggLast(params) {
    return params.values.length > 0 ? _.last(params.values) : null;
}
function aggMin(params) {
    const { values } = params;
    let result = null;
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result > value)) {
            result = value;
        }
    }
    return result;
}
function aggMax(params) {
    const { values } = params;
    let result = null;
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result < value)) {
            result = value;
        }
    }
    return result;
}
function aggCount(params) {
    var _a, _b;
    const { values } = params;
    let result = 0;
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        // check if the value is from a group, in which case use the group's count
        result += value != null && typeof value.value === 'number' ? value.value : 1;
    }
    // the previous aggregation data
    const existingAggData = (_b = (_a = params.rowNode) === null || _a === void 0 ? void 0 : _a.aggData) === null || _b === void 0 ? void 0 : _b[params.column.getColId()];
    if (existingAggData && existingAggData.value === result) {
        // the underlying values haven't changed, return the old object to avoid triggering change detection
        return existingAggData;
    }
    // it's important to wrap it in the object so we can determine if this is a group level
    return {
        value: result,
        toString: function () {
            return this.value.toString();
        },
        // used for sorting
        toNumber: function () {
            return this.value;
        }
    };
}
// the average function is tricky as the multiple levels require weighted averages
// for the non-leaf node aggregations.
function aggAvg(params) {
    var _a, _b, _c;
    const { values } = params;
    let sum = 0; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please
    let count = 0;
    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code
    for (let i = 0; i < values.length; i++) {
        const currentValue = values[i];
        let valueToAdd = null;
        if (typeof currentValue === 'number' || typeof currentValue === 'bigint') {
            valueToAdd = currentValue;
            count++;
        }
        else if (currentValue != null && (typeof currentValue.value === 'number' || typeof currentValue.value === 'bigint') && typeof currentValue.count === 'number') {
            // we are aggregating groups, so we take the aggregated values to calculated a weighted average
            if (AGBigInt) {
                valueToAdd = currentValue.value * (typeof currentValue.value === 'number' ? currentValue.count : AGBigInt(currentValue.count));
            }
            else {
                valueToAdd = currentValue.value * currentValue.count;
            }
            count += currentValue.count;
        }
        if (typeof valueToAdd === 'number') {
            if (AGBigInt) {
                sum += typeof sum === 'number' ? valueToAdd : AGBigInt(valueToAdd);
            }
            else {
                sum += valueToAdd;
            }
        }
        else if (typeof valueToAdd === 'bigint') {
            sum = (typeof sum === 'bigint' ? sum : AGBigInt(sum)) + valueToAdd;
        }
    }
    let value = null;
    // avoid divide by zero error
    if (count > 0) {
        if (AGBigInt) {
            value = sum / (typeof sum === 'number' ? count : AGBigInt(count));
        }
        else {
            value = sum / count;
        }
    }
    // the previous aggregation data
    const existingAggData = (_b = (_a = params.rowNode) === null || _a === void 0 ? void 0 : _a.aggData) === null || _b === void 0 ? void 0 : _b[(_c = params.column) === null || _c === void 0 ? void 0 : _c.getColId()];
    if (existingAggData && existingAggData.count === count && existingAggData.value === value) {
        // the underlying values haven't changed, return the old object to avoid triggering change detection
        return existingAggData;
    }
    // the result will be an object. when this cell is rendered, only the avg is shown.
    // however when this cell is part of another aggregation, the count is also needed
    // to create a weighted average for the next level.
    return {
        count,
        value,
        // the grid by default uses toString to render values for an object, so this
        // is a trick to get the default cellRenderer to display the avg value
        toString: function () {
            return typeof this.value === 'number' || typeof this.value === 'bigint' ? this.value.toString() : '';
        },
        // used for sorting
        toNumber: function () {
            return this.value;
        }
    };
}

var __decorate$1b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class DropZoneColumnComp extends Component {
    constructor(column, dragSourceDropTarget, ghost, dropZonePurpose, horizontal) {
        super();
        this.column = column;
        this.dragSourceDropTarget = dragSourceDropTarget;
        this.ghost = ghost;
        this.dropZonePurpose = dropZonePurpose;
        this.horizontal = horizontal;
        this.popupShowing = false;
    }
    init() {
        this.setTemplate(DropZoneColumnComp.TEMPLATE);
        const eGui = this.getGui();
        const isFunctionsReadOnly = this.gridOptionsService.get('functionsReadOnly');
        this.addElementClasses(eGui);
        this.addElementClasses(this.eDragHandle, 'drag-handle');
        this.addElementClasses(this.eText, 'text');
        this.addElementClasses(this.eButton, 'button');
        this.eDragHandle.appendChild(_.createIconNoSpan('columnDrag', this.gridOptionsService));
        this.eButton.appendChild(_.createIconNoSpan('cancel', this.gridOptionsService));
        this.setupSort();
        this.displayName = this.columnModel.getDisplayNameForColumn(this.column, 'columnDrop');
        this.setupComponents();
        if (!this.ghost && !isFunctionsReadOnly) {
            this.addDragSource();
        }
        this.setupAria();
        this.addManagedListener(this.eventService, Column.EVENT_SORT_CHANGED, () => {
            this.setupAria();
        });
        this.setupTooltip();
        this.activateTabIndex();
        const checkColumnLock = () => {
            const isLocked = this.isGroupingAndLocked();
            _.setDisplayed(this.eButton, !isLocked && !this.gridOptionsService.get('functionsReadOnly'));
            this.eDragHandle.classList.toggle('ag-column-select-column-readonly', isLocked);
            this.setupAria();
        };
        checkColumnLock();
        if (this.isGroupingZone()) {
            this.addManagedPropertyListener('groupLockGroupColumns', () => checkColumnLock());
        }
    }
    getColumn() {
        return this.column;
    }
    setupAria() {
        const translate = this.localeService.getLocaleTextFunc();
        const { name, aggFuncName } = this.getColumnAndAggFuncName();
        const aggSeparator = translate('ariaDropZoneColumnComponentAggFuncSeparator', ' of ');
        const sortDirection = {
            asc: translate('ariaDropZoneColumnComponentSortAscending', 'ascending'),
            desc: translate('ariaDropZoneColumnComponentSortDescending', 'descending'),
        };
        const columnSort = this.column.getSort();
        const isSortSuppressed = this.gridOptionsService.get('rowGroupPanelSuppressSort');
        const ariaInstructions = [
            [
                aggFuncName && `${aggFuncName}${aggSeparator}`,
                name,
                this.isGroupingZone() && !isSortSuppressed && columnSort && `, ${sortDirection[columnSort]}`
            ].filter(part => !!part).join(''),
        ];
        const isFunctionsReadOnly = this.gridOptionsService.get('functionsReadOnly');
        if (this.isAggregationZone() && !isFunctionsReadOnly) {
            const aggregationMenuAria = translate('ariaDropZoneColumnValueItemDescription', 'Press ENTER to change the aggregation type');
            ariaInstructions.push(aggregationMenuAria);
        }
        if (this.isGroupingZone() && this.column.isSortable() && !isSortSuppressed) {
            const sortProgressAria = translate('ariaDropZoneColumnGroupItemDescription', 'Press ENTER to sort');
            ariaInstructions.push(sortProgressAria);
        }
        if (!this.isGroupingAndLocked()) {
            const deleteAria = translate('ariaDropZoneColumnComponentDescription', 'Press DELETE to remove');
            ariaInstructions.push(deleteAria);
        }
        _.setAriaLabel(this.getGui(), ariaInstructions.join('. '));
    }
    setupTooltip() {
        const refresh = () => {
            const newTooltipText = this.column.getColDef().headerTooltip;
            this.setTooltip(newTooltipText);
        };
        refresh();
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refresh);
    }
    setupSort() {
        const canSort = this.column.isSortable();
        const isGroupingZone = this.isGroupingZone();
        if (!canSort || !isGroupingZone) {
            return;
        }
        if (!this.gridOptionsService.get('rowGroupPanelSuppressSort')) {
            this.eSortIndicator.setupSort(this.column, true);
            const performSort = (event) => {
                event.preventDefault();
                const sortUsingCtrl = this.gridOptionsService.get('multiSortKey') === 'ctrl';
                const multiSort = sortUsingCtrl ? (event.ctrlKey || event.metaKey) : event.shiftKey;
                this.sortController.progressSort(this.column, multiSort, 'uiColumnSorted');
            };
            this.addGuiEventListener('click', performSort);
            this.addGuiEventListener('keydown', (e) => {
                const isEnter = e.key === KeyCode.ENTER;
                if (isEnter && this.isGroupingZone()) {
                    performSort(e);
                }
            });
        }
    }
    addDragSource() {
        const { dragAndDropService, displayName, eDragHandle, column } = this;
        const dragSource = {
            type: DragSourceType.ToolPanel,
            eElement: eDragHandle,
            getDefaultIconName: () => DragAndDropService.ICON_HIDE,
            getDragItem: () => this.createDragItem(column),
            dragItemName: displayName
        };
        dragAndDropService.addDragSource(dragSource, true);
        this.addDestroyFunc(() => dragAndDropService.removeDragSource(dragSource));
    }
    createDragItem(column) {
        const visibleState = {};
        visibleState[column.getId()] = column.isVisible();
        return {
            columns: [column],
            visibleState: visibleState
        };
    }
    setupComponents() {
        this.setTextValue();
        this.setupRemove();
        if (this.ghost) {
            this.addCssClass('ag-column-drop-cell-ghost');
        }
        if (this.isAggregationZone() && !this.gridOptionsService.get('functionsReadOnly')) {
            this.addGuiEventListener('click', this.onShowAggFuncSelection.bind(this));
        }
    }
    isGroupingAndLocked() {
        return this.isGroupingZone() && this.columnModel.isColumnGroupingLocked(this.column);
    }
    setupRemove() {
        _.setDisplayed(this.eButton, !this.isGroupingAndLocked() && !this.gridOptionsService.get('functionsReadOnly'));
        const agEvent = { type: DropZoneColumnComp.EVENT_COLUMN_REMOVE };
        this.addGuiEventListener('keydown', (e) => {
            const isEnter = e.key === KeyCode.ENTER;
            const isDelete = e.key === KeyCode.DELETE;
            if (isDelete) {
                if (!this.isGroupingAndLocked()) {
                    e.preventDefault();
                    this.dispatchEvent(agEvent);
                }
            }
            if (isEnter && this.isAggregationZone() && !this.gridOptionsService.get('functionsReadOnly')) {
                e.preventDefault();
                this.onShowAggFuncSelection();
            }
        });
        this.addManagedListener(this.eButton, 'click', (mouseEvent) => {
            this.dispatchEvent(agEvent);
            mouseEvent.stopPropagation();
        });
        const touchListener = new TouchListener(this.eButton);
        this.addManagedListener(touchListener, TouchListener.EVENT_TAP, () => {
            this.dispatchEvent(agEvent);
        });
        this.addDestroyFunc(touchListener.destroy.bind(touchListener));
    }
    getColumnAndAggFuncName() {
        const name = this.displayName;
        let aggFuncName = '';
        if (this.isAggregationZone()) {
            const aggFunc = this.column.getAggFunc();
            // if aggFunc is a string, we can use it, but if it's a function, then we swap with 'func'
            const aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'agg';
            const localeTextFunc = this.localeService.getLocaleTextFunc();
            aggFuncName = localeTextFunc(aggFuncString, aggFuncString);
        }
        return { name, aggFuncName };
    }
    setTextValue() {
        const { name, aggFuncName } = this.getColumnAndAggFuncName();
        const displayValue = this.isAggregationZone() ? `${aggFuncName}(${name})` : name;
        const displayValueSanitised = _.escapeString(displayValue);
        this.eText.innerHTML = displayValueSanitised;
    }
    onShowAggFuncSelection() {
        if (this.popupShowing) {
            return;
        }
        this.popupShowing = true;
        const virtualList = new VirtualList({ cssIdentifier: 'select-agg-func' });
        const rows = this.aggFuncService.getFuncNames(this.column);
        const eGui = this.getGui();
        const virtualListGui = virtualList.getGui();
        virtualList.setModel({
            getRow: function (index) { return rows[index]; },
            getRowCount: function () { return rows.length; }
        });
        this.getContext().createBean(virtualList);
        const ePopup = _.loadTemplate(/* html*/ `<div class="ag-select-agg-func-popup"></div>`);
        ePopup.style.top = '0px';
        ePopup.style.left = '0px';
        ePopup.appendChild(virtualListGui);
        ePopup.style.width = `${eGui.clientWidth}px`;
        const focusoutListener = this.addManagedListener(ePopup, 'focusout', (e) => {
            if (!ePopup.contains(e.relatedTarget) && addPopupRes) {
                addPopupRes.hideFunc();
            }
        });
        const popupHiddenFunc = (callbackEvent) => {
            this.destroyBean(virtualList);
            this.popupShowing = false;
            if ((callbackEvent === null || callbackEvent === void 0 ? void 0 : callbackEvent.key) === 'Escape') {
                eGui.focus();
            }
            if (focusoutListener) {
                focusoutListener();
            }
        };
        const translate = this.localeService.getLocaleTextFunc();
        const addPopupRes = this.popupService.addPopup({
            modal: true,
            eChild: ePopup,
            closeOnEsc: true,
            closedCallback: popupHiddenFunc,
            ariaLabel: translate('ariaLabelAggregationFunction', 'Aggregation Function')
        });
        if (addPopupRes) {
            virtualList.setComponentCreator(this.createAggSelect.bind(this, addPopupRes.hideFunc));
        }
        virtualList.addGuiEventListener('keydown', (e) => {
            if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {
                const row = virtualList.getLastFocusedRow();
                if (row == null) {
                    return;
                }
                const comp = virtualList.getComponentAt(row);
                if (comp) {
                    comp.selectItem();
                }
            }
        });
        this.popupService.positionPopupByComponent({
            type: 'aggFuncSelect',
            eventSource: eGui,
            ePopup: ePopup,
            keepWithinBounds: true,
            column: this.column,
            position: 'under'
        });
        virtualList.refresh();
        let rowToFocus = rows.findIndex(r => r === this.column.getAggFunc());
        if (rowToFocus === -1) {
            rowToFocus = 0;
        }
        virtualList.focusRow(rowToFocus);
    }
    createAggSelect(hidePopup, value) {
        const itemSelected = () => {
            hidePopup();
            if (this.gridOptionsService.get('functionsPassive')) {
                const event = {
                    type: Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST,
                    columns: [this.column],
                    aggFunc: value
                };
                this.eventService.dispatchEvent(event);
            }
            else {
                this.columnModel.setColumnAggFunc(this.column, value, "toolPanelDragAndDrop");
            }
        };
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const aggFuncString = value.toString();
        const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);
        const comp = new AggItemComp(itemSelected, aggFuncStringTranslated);
        return comp;
    }
    addElementClasses(el, suffix) {
        suffix = suffix ? `-${suffix}` : '';
        const direction = this.horizontal ? 'horizontal' : 'vertical';
        el.classList.add(`ag-column-drop-cell${suffix}`, `ag-column-drop-${direction}-cell${suffix}`);
    }
    isAggregationZone() {
        return this.dropZonePurpose === 'aggregation';
    }
    isGroupingZone() {
        return this.dropZonePurpose === 'rowGroup';
    }
    destroy() {
        super.destroy();
        this.column = null;
        this.dragSourceDropTarget = null;
    }
}
DropZoneColumnComp.EVENT_COLUMN_REMOVE = 'columnRemove';
DropZoneColumnComp.TEMPLATE = `<span role="option">
          <span ref="eDragHandle" class="ag-drag-handle ag-column-drop-cell-drag-handle" role="presentation"></span>
          <span ref="eText" class="ag-column-drop-cell-text" aria-hidden="true"></span>
          <ag-sort-indicator ref="eSortIndicator"></ag-sort-indicator>
          <span ref="eButton" class="ag-column-drop-cell-button" role="presentation"></span>
        </span>`;
__decorate$1b([
    Autowired('dragAndDropService')
], DropZoneColumnComp.prototype, "dragAndDropService", void 0);
__decorate$1b([
    Autowired('columnModel')
], DropZoneColumnComp.prototype, "columnModel", void 0);
__decorate$1b([
    Autowired('popupService')
], DropZoneColumnComp.prototype, "popupService", void 0);
__decorate$1b([
    Optional('aggFuncService')
], DropZoneColumnComp.prototype, "aggFuncService", void 0);
__decorate$1b([
    Autowired('sortController')
], DropZoneColumnComp.prototype, "sortController", void 0);
__decorate$1b([
    RefSelector('eText')
], DropZoneColumnComp.prototype, "eText", void 0);
__decorate$1b([
    RefSelector('eDragHandle')
], DropZoneColumnComp.prototype, "eDragHandle", void 0);
__decorate$1b([
    RefSelector('eButton')
], DropZoneColumnComp.prototype, "eButton", void 0);
__decorate$1b([
    RefSelector('eSortIndicator')
], DropZoneColumnComp.prototype, "eSortIndicator", void 0);
__decorate$1b([
    PostConstruct
], DropZoneColumnComp.prototype, "init", null);
class AggItemComp extends Component {
    constructor(itemSelected, value) {
        super(/* html */ `<div class="ag-select-agg-func-item"/>`);
        this.selectItem = itemSelected;
        this.getGui().innerText = value;
        this.addGuiEventListener('click', this.selectItem);
    }
}

var __decorate$1c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class BaseDropZonePanel extends Component {
    constructor(horizontal, dropZonePurpose) {
        super(/* html */ `<div class="ag-unselectable" role="presentation"></div>`);
        this.horizontal = horizontal;
        this.dropZonePurpose = dropZonePurpose;
        this.state = BaseDropZonePanel.STATE_NOT_DRAGGING;
        this.guiDestroyFunctions = [];
        this.childColumnComponents = [];
        this.resizeEnabled = false;
        this.addElementClasses(this.getGui());
        this.eColumnDropList = document.createElement('div');
        this.addElementClasses(this.eColumnDropList, 'list');
        _.setAriaRole(this.eColumnDropList, 'listbox');
    }
    isHorizontal() {
        return this.horizontal;
    }
    toggleResizable(resizable) {
        this.positionableFeature.setResizable(resizable ? { bottom: true } : false);
        this.resizeEnabled = resizable;
    }
    setBeans(beans) {
        this.beans = beans;
    }
    isSourceEventFromTarget(draggingEvent) {
        const { dropZoneTarget, dragSource } = draggingEvent;
        return dropZoneTarget.contains(dragSource.eElement);
    }
    destroy() {
        this.destroyGui();
        super.destroy();
    }
    destroyGui() {
        this.guiDestroyFunctions.forEach(func => func());
        this.guiDestroyFunctions.length = 0;
        this.childColumnComponents.length = 0;
        _.clearElement(this.getGui());
        _.clearElement(this.eColumnDropList);
    }
    init(params) {
        this.params = params;
        this.createManagedBean(new ManagedFocusFeature(this.getFocusableElement(), {
            handleKeyDown: this.handleKeyDown.bind(this)
        }));
        this.addManagedListener(this.beans.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.refreshGui.bind(this));
        this.addManagedPropertyListeners(['functionsReadOnly', 'rowGroupPanelSuppressSort', 'groupLockGroupColumns'], this.refreshGui.bind(this));
        this.setupDropTarget();
        this.positionableFeature = new PositionableFeature(this.getGui(), { minHeight: 100 });
        this.createManagedBean(this.positionableFeature);
        // we don't know if this bean will be initialised before columnModel.
        // if columnModel first, then below will work
        // if columnModel second, then below will put blank in, and then above event gets first when columnModel is set up
        this.refreshGui();
        _.setAriaLabel(this.eColumnDropList, this.getAriaLabel());
    }
    handleKeyDown(e) {
        const isVertical = !this.horizontal;
        let isNext = e.key === KeyCode.DOWN;
        let isPrevious = e.key === KeyCode.UP;
        if (!isVertical) {
            const isRtl = this.gridOptionsService.get('enableRtl');
            isNext = (!isRtl && e.key === KeyCode.RIGHT) || (isRtl && e.key === KeyCode.LEFT);
            isPrevious = (!isRtl && e.key === KeyCode.LEFT) || (isRtl && e.key === KeyCode.RIGHT);
        }
        if (!isNext && !isPrevious) {
            return;
        }
        const el = this.focusService.findNextFocusableElement(this.getFocusableElement(), false, isPrevious);
        if (el) {
            e.preventDefault();
            el.focus();
        }
    }
    addElementClasses(el, suffix) {
        suffix = suffix ? `-${suffix}` : '';
        const direction = this.horizontal ? 'horizontal' : 'vertical';
        el.classList.add(`ag-column-drop${suffix}`, `ag-column-drop-${direction}${suffix}`);
    }
    setupDropTarget() {
        this.dropTarget = {
            getContainer: this.getGui.bind(this),
            getIconName: this.getIconName.bind(this),
            onDragging: this.onDragging.bind(this),
            onDragEnter: this.onDragEnter.bind(this),
            onDragLeave: this.onDragLeave.bind(this),
            onDragStop: this.onDragStop.bind(this),
            isInterestedIn: this.isInterestedIn.bind(this)
        };
        this.beans.dragAndDropService.addDropTarget(this.dropTarget);
    }
    isInterestedIn(type) {
        // not interested in row drags
        return type === DragSourceType.HeaderCell || type === DragSourceType.ToolPanel;
    }
    minimumAllowedNewInsertIndex() {
        const numberOfLockedCols = this.gridOptionsService.get('groupLockGroupColumns');
        const numberOfGroupCols = this.colModel.getRowGroupColumns().length;
        if (numberOfLockedCols === -1) {
            return numberOfGroupCols;
        }
        return Math.min(numberOfLockedCols, numberOfGroupCols);
    }
    checkInsertIndex(draggingEvent) {
        const newIndex = this.getNewInsertIndex(draggingEvent);
        // <0 happens when drag is no a direction we are interested in, eg drag is up/down but in horizontal panel
        if (newIndex < 0) {
            return false;
        }
        const minimumAllowedIndex = this.minimumAllowedNewInsertIndex();
        const newAdjustedIndex = Math.max(minimumAllowedIndex, newIndex);
        const changed = newAdjustedIndex !== this.insertIndex;
        if (changed) {
            this.insertIndex = newAdjustedIndex;
        }
        return changed;
    }
    getNewInsertIndex(draggingEvent) {
        const mouseEvent = draggingEvent.event;
        const mouseLocation = this.horizontal ? mouseEvent.clientX : mouseEvent.clientY;
        const boundsList = this.childColumnComponents.map(col => (col.getGui().getBoundingClientRect()));
        // find the non-ghost component we're hovering
        const hoveredIndex = boundsList.findIndex(rect => (this.horizontal ? (rect.right > mouseLocation && rect.left < mouseLocation) : (rect.top < mouseLocation && rect.bottom > mouseLocation)));
        // not hovering a non-ghost component
        if (hoveredIndex === -1) {
            const enableRtl = this.beans.gridOptionsService.get('enableRtl');
            // if mouse is below or right of all components then new index should be placed last
            const isLast = boundsList.every(rect => (mouseLocation > (this.horizontal ? rect.right : rect.bottom)));
            if (isLast) {
                return enableRtl && this.horizontal ? 0 : this.childColumnComponents.length;
            }
            // if mouse is above or left of all components, new index is first
            const isFirst = boundsList.every(rect => (mouseLocation < (this.horizontal ? rect.left : rect.top)));
            if (isFirst) {
                return enableRtl && this.horizontal ? this.childColumnComponents.length : 0;
            }
            // must be hovering a ghost, don't change the index
            return this.insertIndex;
        }
        // if the old index is equal to or less than the index of our new target
        // we need to shift right, to insert after rather than before
        if (this.insertIndex <= hoveredIndex) {
            return hoveredIndex + 1;
        }
        return hoveredIndex;
    }
    checkDragStartedBySelf(draggingEvent) {
        if (this.state !== BaseDropZonePanel.STATE_NOT_DRAGGING) {
            return;
        }
        this.state = BaseDropZonePanel.STATE_REARRANGE_COLUMNS;
        this.potentialDndColumns = draggingEvent.dragSource.getDragItem().columns || [];
        this.refreshGui();
        this.checkInsertIndex(draggingEvent);
        this.refreshGui();
    }
    onDragging(draggingEvent) {
        this.checkDragStartedBySelf(draggingEvent);
        if (this.checkInsertIndex(draggingEvent)) {
            this.refreshGui();
        }
    }
    onDragEnter(draggingEvent) {
        // this will contain all columns that are potential drops
        const dragColumns = draggingEvent.dragSource.getDragItem().columns || [];
        this.state = BaseDropZonePanel.STATE_NEW_COLUMNS_IN;
        // take out columns that are not droppable
        const goodDragColumns = dragColumns.filter(col => this.isColumnDroppable(col, draggingEvent));
        const alreadyPresent = goodDragColumns.every(col => this.childColumnComponents.map(cmp => cmp.getColumn()).indexOf(col) !== -1);
        if (goodDragColumns.length === 0) {
            return;
        }
        this.potentialDndColumns = goodDragColumns;
        if (alreadyPresent) {
            this.state = BaseDropZonePanel.STATE_NOT_DRAGGING;
            return;
        }
        const hideColumnOnExit = this.isRowGroupPanel() && !this.gridOptionsService.get('suppressRowGroupHidesColumns') && !draggingEvent.fromNudge;
        if (hideColumnOnExit) {
            const dragItem = draggingEvent.dragSource.getDragItem();
            const columns = dragItem.columns;
            this.setColumnsVisible(columns, false, "uiColumnDragged");
        }
        this.checkInsertIndex(draggingEvent);
        this.refreshGui();
    }
    setColumnsVisible(columns, visible, source) {
        if (columns) {
            const allowedCols = columns.filter(c => !c.getColDef().lockVisible);
            this.colModel.setColumnsVisible(allowedCols, visible, source);
        }
    }
    isPotentialDndColumns() {
        return _.existsAndNotEmpty(this.potentialDndColumns);
    }
    isRowGroupPanel() {
        return this.dropZonePurpose === 'rowGroup';
    }
    onDragLeave(draggingEvent) {
        // if the dragging started from us, we remove the group, however if it started
        // some place else, then we don't, as it was only 'asking'
        if (this.state === BaseDropZonePanel.STATE_REARRANGE_COLUMNS) {
            const columns = draggingEvent.dragSource.getDragItem().columns || [];
            this.removeColumns(columns);
        }
        if (this.isPotentialDndColumns()) {
            const showColumnOnExit = this.isRowGroupPanel() && !this.gridOptionsService.get('suppressMakeColumnVisibleAfterUnGroup') && !draggingEvent.fromNudge;
            if (showColumnOnExit) {
                const dragItem = draggingEvent.dragSource.getDragItem();
                this.setColumnsVisible(dragItem.columns, true, "uiColumnDragged");
            }
            this.potentialDndColumns = [];
            this.refreshGui();
        }
        this.state = BaseDropZonePanel.STATE_NOT_DRAGGING;
    }
    onDragStop() {
        if (this.isPotentialDndColumns()) {
            let success = false;
            if (this.state === BaseDropZonePanel.STATE_NEW_COLUMNS_IN) {
                this.addColumns(this.potentialDndColumns);
                success = true;
            }
            else {
                success = this.rearrangeColumns(this.potentialDndColumns);
            }
            this.potentialDndColumns = [];
            // If the function is passive, then we don't refresh, as we assume the client application
            // is going to call setRowGroups / setPivots / setValues at a later point which will then
            // cause a refresh. This gives a nice GUI where the ghost stays until the app has caught
            // up with the changes. However, if there was no change in the order, then we do need to
            // refresh to reset the columns
            if (!this.beans.gridOptionsService.get('functionsPassive') || !success) {
                this.refreshGui();
            }
        }
        this.state = BaseDropZonePanel.STATE_NOT_DRAGGING;
    }
    removeColumns(columnsToRemove) {
        const newColumnList = this.getExistingColumns().filter(col => !_.includes(columnsToRemove, col));
        this.updateColumns(newColumnList);
    }
    addColumns(columnsToAdd) {
        if (!columnsToAdd) {
            return;
        }
        const newColumnList = this.getExistingColumns().slice();
        const colsToAddNoDuplicates = columnsToAdd.filter(col => newColumnList.indexOf(col) < 0);
        _.insertArrayIntoArray(newColumnList, colsToAddNoDuplicates, this.insertIndex);
        this.updateColumns(newColumnList);
    }
    rearrangeColumns(columnsToAdd) {
        const newColumnList = this.getNonGhostColumns().slice();
        _.insertArrayIntoArray(newColumnList, columnsToAdd, this.insertIndex);
        if (_.areEqual(newColumnList, this.getExistingColumns())) {
            return false;
        }
        this.updateColumns(newColumnList);
        return true;
    }
    refreshGui() {
        // we reset the scroll position after the refresh.
        // if we don't do this, then the list will always scroll to the top
        // each time we refresh it. this is because part of the refresh empties
        // out the list which sets scroll to zero. so the user could be just
        // reordering the list - we want to prevent the resetting of the scroll.
        // this is relevant for vertical display only (as horizontal has no scroll)
        const scrollTop = this.eColumnDropList.scrollTop;
        const resizeEnabled = this.resizeEnabled;
        const focusedIndex = this.getFocusedItem();
        let alternateElement = this.focusService.findNextFocusableElement();
        if (!alternateElement) {
            alternateElement = this.focusService.findNextFocusableElement(undefined, false, true);
        }
        this.toggleResizable(false);
        this.destroyGui();
        this.addIconAndTitleToGui();
        this.addEmptyMessageToGui();
        this.addColumnsToGui();
        if (!this.isHorizontal()) {
            this.eColumnDropList.scrollTop = scrollTop;
        }
        if (resizeEnabled) {
            this.toggleResizable(resizeEnabled);
        }
        // focus should only be restored when keyboard mode
        // otherwise mouse clicks will cause containers to scroll
        // without no apparent reason.
        if (this.focusService.isKeyboardMode()) {
            this.restoreFocus(focusedIndex, alternateElement);
        }
    }
    getFocusedItem() {
        const eGui = this.getGui();
        const activeElement = this.gridOptionsService.getDocument().activeElement;
        if (!eGui.contains(activeElement)) {
            return -1;
        }
        const items = Array.from(eGui.querySelectorAll('.ag-column-drop-cell'));
        return items.indexOf(activeElement);
    }
    restoreFocus(index, alternateElement) {
        const eGui = this.getGui();
        const items = Array.from(eGui.querySelectorAll('.ag-column-drop-cell'));
        if (index === -1) {
            return;
        }
        if (items.length === 0) {
            alternateElement.focus();
        }
        const indexToFocus = Math.min(items.length - 1, index);
        const el = items[indexToFocus];
        if (el) {
            el.focus();
        }
    }
    getNonGhostColumns() {
        const existingColumns = this.getExistingColumns();
        if (this.isPotentialDndColumns()) {
            return existingColumns.filter(column => !_.includes(this.potentialDndColumns, column));
        }
        return existingColumns;
    }
    addColumnsToGui() {
        const nonGhostColumns = this.getNonGhostColumns();
        const itemsToAddToGui = nonGhostColumns.map(column => (this.createColumnComponent(column, false)));
        if (this.isPotentialDndColumns()) {
            const dndColumns = this.potentialDndColumns.map(column => (this.createColumnComponent(column, true)));
            if (this.insertIndex >= itemsToAddToGui.length) {
                itemsToAddToGui.push(...dndColumns);
            }
            else {
                itemsToAddToGui.splice(this.insertIndex, 0, ...dndColumns);
            }
        }
        this.appendChild(this.eColumnDropList);
        itemsToAddToGui.forEach((columnComponent, index) => {
            if (index > 0) {
                this.addArrow(this.eColumnDropList);
            }
            this.eColumnDropList.appendChild(columnComponent.getGui());
        });
        this.addAriaLabelsToComponents();
    }
    addAriaLabelsToComponents() {
        this.childColumnComponents.forEach((comp, idx) => {
            const eGui = comp.getGui();
            _.setAriaPosInSet(eGui, idx + 1);
            _.setAriaSetSize(eGui, this.childColumnComponents.length);
        });
    }
    createColumnComponent(column, ghost) {
        const columnComponent = new DropZoneColumnComp(column, this.dropTarget, ghost, this.dropZonePurpose, this.horizontal);
        columnComponent.addEventListener(DropZoneColumnComp.EVENT_COLUMN_REMOVE, this.removeColumns.bind(this, [column]));
        this.beans.context.createBean(columnComponent);
        this.guiDestroyFunctions.push(() => this.destroyBean(columnComponent));
        if (!ghost) {
            this.childColumnComponents.push(columnComponent);
        }
        return columnComponent;
    }
    addIconAndTitleToGui() {
        const eGroupIcon = this.params.icon;
        const eTitleBar = document.createElement('div');
        _.setAriaHidden(eTitleBar, true);
        this.addElementClasses(eTitleBar, 'title-bar');
        this.addElementClasses(eGroupIcon, 'icon');
        this.addOrRemoveCssClass('ag-column-drop-empty', this.isExistingColumnsEmpty());
        eTitleBar.appendChild(eGroupIcon);
        if (!this.horizontal) {
            const eTitle = document.createElement('span');
            this.addElementClasses(eTitle, 'title');
            eTitle.innerHTML = this.params.title;
            eTitleBar.appendChild(eTitle);
        }
        this.appendChild(eTitleBar);
    }
    isExistingColumnsEmpty() {
        return this.getExistingColumns().length === 0;
    }
    addEmptyMessageToGui() {
        if (!this.isExistingColumnsEmpty() || this.isPotentialDndColumns()) {
            return;
        }
        const eMessage = document.createElement('span');
        eMessage.innerHTML = this.params.emptyMessage;
        this.addElementClasses(eMessage, 'empty-message');
        this.eColumnDropList.appendChild(eMessage);
    }
    addArrow(eParent) {
        // only add the arrows if the layout is horizontal
        if (this.horizontal) {
            // for RTL it's a left arrow, otherwise it's a right arrow
            const enableRtl = this.beans.gridOptionsService.get('enableRtl');
            const icon = _.createIconNoSpan(enableRtl ? 'smallLeft' : 'smallRight', this.beans.gridOptionsService);
            this.addElementClasses(icon, 'cell-separator');
            eParent.appendChild(icon);
        }
    }
}
BaseDropZonePanel.STATE_NOT_DRAGGING = 'notDragging';
BaseDropZonePanel.STATE_NEW_COLUMNS_IN = 'newColumnsIn';
BaseDropZonePanel.STATE_REARRANGE_COLUMNS = 'rearrangeColumns';
__decorate$1c([
    Autowired('columnModel')
], BaseDropZonePanel.prototype, "colModel", void 0);
__decorate$1c([
    Autowired('focusService')
], BaseDropZonePanel.prototype, "focusService", void 0);

var __decorate$1d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class RowGroupDropZonePanel extends BaseDropZonePanel {
    constructor(horizontal) {
        super(horizontal, 'rowGroup');
    }
    passBeansUp() {
        super.setBeans({
            gridOptionsService: this.gridOptionsService,
            eventService: this.eventService,
            context: this.getContext(),
            loggerFactory: this.loggerFactory,
            dragAndDropService: this.dragAndDropService
        });
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const emptyMessage = localeTextFunc('rowGroupColumnsEmptyMessage', 'Drag here to set row groups');
        const title = localeTextFunc('groups', 'Row Groups');
        super.init({
            dragAndDropIcon: DragAndDropService.ICON_GROUP,
            icon: _.createIconNoSpan('rowGroupPanel', this.gridOptionsService, null),
            emptyMessage: emptyMessage,
            title
        });
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshGui.bind(this));
    }
    getAriaLabel() {
        const translate = this.localeService.getLocaleTextFunc();
        const label = translate('ariaRowGroupDropZonePanelLabel', 'Row Groups');
        return label;
    }
    getTooltipParams() {
        const res = super.getTooltipParams();
        res.location = 'rowGroupColumnsList';
        return res;
    }
    isColumnDroppable(column, draggingEvent) {
        // we never allow grouping of secondary columns
        if (this.gridOptionsService.get('functionsReadOnly') || !column.isPrimary()) {
            return false;
        }
        return column.isAllowRowGroup() && (!column.isRowGroupActive() || this.isSourceEventFromTarget(draggingEvent));
    }
    updateColumns(columns) {
        if (this.gridOptionsService.get('functionsPassive')) {
            const event = {
                type: Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST,
                columns: columns
            };
            this.eventService.dispatchEvent(event);
        }
        else {
            this.columnModel.setRowGroupColumns(columns, "toolPanelUi");
        }
    }
    getIconName() {
        return this.isPotentialDndColumns() ? DragAndDropService.ICON_GROUP : DragAndDropService.ICON_NOT_ALLOWED;
    }
    getExistingColumns() {
        return this.columnModel.getRowGroupColumns();
    }
}
__decorate$1d([
    Autowired('columnModel')
], RowGroupDropZonePanel.prototype, "columnModel", void 0);
__decorate$1d([
    Autowired('loggerFactory')
], RowGroupDropZonePanel.prototype, "loggerFactory", void 0);
__decorate$1d([
    Autowired('dragAndDropService')
], RowGroupDropZonePanel.prototype, "dragAndDropService", void 0);
__decorate$1d([
    PostConstruct
], RowGroupDropZonePanel.prototype, "passBeansUp", null);

var __decorate$1e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class PivotDropZonePanel extends BaseDropZonePanel {
    constructor(horizontal) {
        super(horizontal, 'pivot');
    }
    passBeansUp() {
        super.setBeans({
            gridOptionsService: this.gridOptionsService,
            eventService: this.eventService,
            context: this.getContext(),
            loggerFactory: this.loggerFactory,
            dragAndDropService: this.dragAndDropService
        });
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const emptyMessage = localeTextFunc('pivotColumnsEmptyMessage', 'Drag here to set column labels');
        const title = localeTextFunc('pivots', 'Column Labels');
        super.init({
            dragAndDropIcon: DragAndDropService.ICON_GROUP,
            icon: _.createIconNoSpan('pivotPanel', this.gridOptionsService, null),
            emptyMessage: emptyMessage,
            title: title
        });
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.refresh.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refresh.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.checkVisibility.bind(this));
        this.refresh();
    }
    getAriaLabel() {
        const translate = this.localeService.getLocaleTextFunc();
        const label = translate('ariaPivotDropZonePanelLabel', 'Column Labels');
        return label;
    }
    getTooltipParams() {
        const res = super.getTooltipParams();
        res.location = 'pivotColumnsList';
        return res;
    }
    refresh() {
        this.checkVisibility();
        this.refreshGui();
    }
    checkVisibility() {
        const pivotMode = this.columnModel.isPivotMode();
        if (this.isHorizontal()) {
            // what we do for horizontal (ie the pivot panel at the top) depends
            // on the user property as well as pivotMode.
            switch (this.gridOptionsService.get('pivotPanelShow')) {
                case 'always':
                    this.setDisplayed(pivotMode);
                    break;
                case 'onlyWhenPivoting':
                    const pivotActive = this.columnModel.isPivotActive();
                    this.setDisplayed(pivotMode && pivotActive);
                    break;
                default:
                    // never show it
                    this.setDisplayed(false);
                    break;
            }
        }
        else {
            // in toolPanel, the pivot panel is always shown when pivot mode is on
            this.setDisplayed(pivotMode);
        }
    }
    isColumnDroppable(column, draggingEvent) {
        // we never allow grouping of secondary columns
        if (this.gridOptionsService.get('functionsReadOnly') || !column.isPrimary()) {
            return false;
        }
        return column.isAllowPivot() && (!column.isPivotActive() || this.isSourceEventFromTarget(draggingEvent));
    }
    updateColumns(columns) {
        if (this.gridOptionsService.get('functionsPassive')) {
            const event = {
                type: Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST,
                columns: columns
            };
            this.eventService.dispatchEvent(event);
        }
        else {
            this.columnModel.setPivotColumns(columns, "toolPanelUi");
        }
    }
    getIconName() {
        return this.isPotentialDndColumns() ? DragAndDropService.ICON_PIVOT : DragAndDropService.ICON_NOT_ALLOWED;
    }
    getExistingColumns() {
        return this.columnModel.getPivotColumns();
    }
}
__decorate$1e([
    Autowired('columnModel')
], PivotDropZonePanel.prototype, "columnModel", void 0);
__decorate$1e([
    Autowired('loggerFactory')
], PivotDropZonePanel.prototype, "loggerFactory", void 0);
__decorate$1e([
    Autowired('dragAndDropService')
], PivotDropZonePanel.prototype, "dragAndDropService", void 0);
__decorate$1e([
    PostConstruct
], PivotDropZonePanel.prototype, "passBeansUp", null);

var __decorate$1f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class GridHeaderDropZones extends Component {
    constructor() {
        super();
    }
    postConstruct() {
        this.setGui(this.createNorthPanel());
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onRowGroupChanged());
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.onRowGroupChanged());
        this.addManagedPropertyListener('rowGroupPanelShow', () => this.onRowGroupChanged());
        this.addManagedPropertyListener('pivotPanelShow', () => this.onPivotPanelShow());
        this.onRowGroupChanged();
    }
    createNorthPanel() {
        const topPanelGui = document.createElement('div');
        topPanelGui.classList.add('ag-column-drop-wrapper');
        _.setAriaRole(topPanelGui, 'presentation');
        this.rowGroupComp = new RowGroupDropZonePanel(true);
        this.createManagedBean(this.rowGroupComp);
        this.pivotComp = new PivotDropZonePanel(true);
        this.createManagedBean(this.pivotComp);
        topPanelGui.appendChild(this.rowGroupComp.getGui());
        topPanelGui.appendChild(this.pivotComp.getGui());
        this.addManagedListener(this.rowGroupComp, Component.EVENT_DISPLAYED_CHANGED, () => this.onDropPanelVisible());
        this.addManagedListener(this.pivotComp, Component.EVENT_DISPLAYED_CHANGED, () => this.onDropPanelVisible());
        this.onDropPanelVisible();
        return topPanelGui;
    }
    onDropPanelVisible() {
        const bothDisplayed = this.rowGroupComp.isDisplayed() && this.pivotComp.isDisplayed();
        this.rowGroupComp.addOrRemoveCssClass('ag-column-drop-horizontal-half-width', bothDisplayed);
        this.pivotComp.addOrRemoveCssClass('ag-column-drop-horizontal-half-width', bothDisplayed);
    }
    onRowGroupChanged() {
        if (!this.rowGroupComp) {
            return;
        }
        const rowGroupPanelShow = this.gridOptionsService.get('rowGroupPanelShow');
        if (rowGroupPanelShow === 'always') {
            this.rowGroupComp.setDisplayed(true);
        }
        else if (rowGroupPanelShow === 'onlyWhenGrouping') {
            const grouping = !this.columnModel.isRowGroupEmpty();
            this.rowGroupComp.setDisplayed(grouping);
        }
        else {
            this.rowGroupComp.setDisplayed(false);
        }
    }
    onPivotPanelShow() {
        if (!this.pivotComp) {
            return;
        }
        const pivotPanelShow = this.gridOptionsService.get('pivotPanelShow');
        if (pivotPanelShow === 'always') {
            this.pivotComp.setDisplayed(true);
        }
        else if (pivotPanelShow === 'onlyWhenPivoting') {
            const pivoting = this.columnModel.isPivotActive();
            this.pivotComp.setDisplayed(pivoting);
        }
        else {
            this.pivotComp.setDisplayed(false);
        }
    }
}
__decorate$1f([
    Autowired('columnModel')
], GridHeaderDropZones.prototype, "columnModel", void 0);
__decorate$1f([
    PostConstruct
], GridHeaderDropZones.prototype, "postConstruct", null);

var __decorate$1g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let FilterAggregatesStage = class FilterAggregatesStage extends BeanStub {
    execute(params) {
        const isPivotMode = this.columnModel.isPivotMode();
        const isAggFilterActive = this.filterManager.isAggregateFilterPresent()
            || this.filterManager.isAggregateQuickFilterPresent();
        // This is the default filter for applying only to leaf nodes, realistically this should not apply as primary agg columns,
        // should not be applied by the filterManager if getGroupAggFiltering is missing. Predicate will apply filters to leaf level.
        const defaultPrimaryColumnPredicate = (params) => !params.node.group;
        // Default secondary column predicate, selecting only leaf level groups.
        const defaultSecondaryColumnPredicate = ((params) => params.node.leafGroup);
        // The predicate to determine whether filters should apply to this row. Either defined by the user in groupAggFiltering or a default depending
        // on current pivot mode status.
        const applyFilterToNode = this.gridOptionsService.getGroupAggFiltering()
            || (isPivotMode ? defaultSecondaryColumnPredicate : defaultPrimaryColumnPredicate);
        const { changedPath } = params;
        const preserveChildren = (node, recursive = false) => {
            if (node.childrenAfterFilter) {
                node.childrenAfterAggFilter = node.childrenAfterFilter;
                if (recursive) {
                    node.childrenAfterAggFilter.forEach((child) => preserveChildren(child, recursive));
                }
                this.setAllChildrenCount(node);
            }
            if (node.sibling) {
                node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;
            }
        };
        const filterChildren = (node) => {
            var _a;
            node.childrenAfterAggFilter = ((_a = node.childrenAfterFilter) === null || _a === void 0 ? void 0 : _a.filter((child) => {
                var _a;
                const shouldFilterRow = applyFilterToNode({ node: child });
                if (shouldFilterRow) {
                    const doesNodePassFilter = this.filterManager.doesRowPassAggregateFilters({ rowNode: child });
                    if (doesNodePassFilter) {
                        // Node has passed, so preserve children
                        preserveChildren(child, true);
                        return true;
                    }
                }
                const hasChildPassed = (_a = child.childrenAfterAggFilter) === null || _a === void 0 ? void 0 : _a.length;
                return hasChildPassed;
            })) || null;
            this.setAllChildrenCount(node);
            if (node.sibling) {
                node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;
            }
        };
        changedPath.forEachChangedNodeDepthFirst(isAggFilterActive ? filterChildren : preserveChildren, true);
    }
    setAllChildrenCountTreeData(rowNode) {
        // for tree data, we include all children, groups and leafs
        let allChildrenCount = 0;
        rowNode.childrenAfterAggFilter.forEach((child) => {
            // include child itself
            allChildrenCount++;
            // include children of children
            allChildrenCount += child.allChildrenCount;
        });
        rowNode.setAllChildrenCount(allChildrenCount);
    }
    setAllChildrenCountGridGrouping(rowNode) {
        // for grid data, we only count the leafs
        let allChildrenCount = 0;
        rowNode.childrenAfterAggFilter.forEach((child) => {
            if (child.group) {
                allChildrenCount += child.allChildrenCount;
            }
            else {
                allChildrenCount++;
            }
        });
        rowNode.setAllChildrenCount(allChildrenCount);
    }
    setAllChildrenCount(rowNode) {
        if (!rowNode.hasChildren()) {
            rowNode.setAllChildrenCount(null);
            return;
        }
        if (this.gridOptionsService.get('treeData')) {
            this.setAllChildrenCountTreeData(rowNode);
        }
        else {
            this.setAllChildrenCountGridGrouping(rowNode);
        }
    }
};
__decorate$1g([
    Autowired('filterManager')
], FilterAggregatesStage.prototype, "filterManager", void 0);
__decorate$1g([
    Autowired('columnModel')
], FilterAggregatesStage.prototype, "columnModel", void 0);
FilterAggregatesStage = __decorate$1g([
    Bean('filterAggregatesStage')
], FilterAggregatesStage);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$7 = '31.1.1';

var __decorate$1h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class GroupFilter extends TabGuardComp {
    constructor() {
        super(/* html */ `
            <div class="ag-group-filter">
                <div ref="eGroupField"></div>
                <div ref="eUnderlyingFilter"></div>
            </div>
        `);
    }
    postConstruct() {
        this.initialiseTabGuard({});
    }
    init(params) {
        this.params = params;
        this.validateParams();
        return this.updateGroups().then(() => {
            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onColumnRowGroupChanged());
        });
    }
    validateParams() {
        const { colDef } = this.params;
        if (colDef.field) {
            _.warnOnce('Group Column Filter does not work with the colDef property "field". This property will be ignored.');
        }
        if (colDef.filterValueGetter) {
            _.warnOnce('Group Column Filter does not work with the colDef property "filterValueGetter". This property will be ignored.');
        }
        if (colDef.filterParams) {
            _.warnOnce('Group Column Filter does not work with the colDef property "filterParams". This property will be ignored.');
        }
    }
    updateGroups() {
        const sourceColumns = this.updateGroupField();
        return this.getUnderlyingFilters(sourceColumns);
    }
    getSourceColumns() {
        this.groupColumn = this.params.column;
        if (this.gridOptionsService.get('treeData')) {
            _.warnOnce('Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter.');
            return [];
        }
        const sourceColumns = this.columnModel.getSourceColumnsForGroupColumn(this.groupColumn);
        if (!sourceColumns) {
            _.warnOnce('Group Column Filter only works on group columns. Please use a different filter.');
            return [];
        }
        return sourceColumns;
    }
    updateGroupField() {
        _.clearElement(this.eGroupField);
        if (this.eGroupFieldSelect) {
            this.destroyBean(this.eGroupFieldSelect);
        }
        const allSourceColumns = this.getSourceColumns();
        const sourceColumns = allSourceColumns.filter(sourceColumn => sourceColumn.isFilterAllowed());
        if (!sourceColumns.length) {
            this.selectedColumn = undefined;
            _.setDisplayed(this.eGroupField, false);
            return null;
        }
        if (allSourceColumns.length === 1) {
            // we only want to hide the group field element if there's only one group column.
            // If there's one group column that has a filter, but multiple columns in total,
            // we should still show the select so the user knows which column it's for.
            this.selectedColumn = sourceColumns[0];
            _.setDisplayed(this.eGroupField, false);
        }
        else {
            // keep the old selected column if it's still valid
            if (!this.selectedColumn || !sourceColumns.some(column => column.getId() === this.selectedColumn.getId())) {
                this.selectedColumn = sourceColumns[0];
            }
            this.createGroupFieldSelectElement(sourceColumns);
            this.eGroupField.appendChild(this.eGroupFieldSelect.getGui());
            this.eGroupField.appendChild(_.loadTemplate(/* html */ `<div class="ag-filter-separator"></div>`));
            _.setDisplayed(this.eGroupField, true);
        }
        return sourceColumns;
    }
    createGroupFieldSelectElement(sourceColumns) {
        this.eGroupFieldSelect = this.createManagedBean(new AgSelect());
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        this.eGroupFieldSelect.setLabel(localeTextFunc('groupFilterSelect', 'Select field:'));
        this.eGroupFieldSelect.setLabelAlignment('top');
        this.eGroupFieldSelect.addOptions(sourceColumns.map(sourceColumn => {
            var _a;
            return ({
                value: sourceColumn.getId(),
                text: (_a = this.columnModel.getDisplayNameForColumn(sourceColumn, 'groupFilter', false)) !== null && _a !== void 0 ? _a : undefined
            });
        }));
        this.eGroupFieldSelect.setValue(this.selectedColumn.getId());
        this.eGroupFieldSelect.onValueChange((newValue) => this.updateSelectedColumn(newValue));
        this.eGroupFieldSelect.addCssClass('ag-group-filter-field-select-wrapper');
        if (sourceColumns.length === 1) {
            this.eGroupFieldSelect.setDisabled(true);
        }
    }
    getUnderlyingFilters(sourceColumns) {
        if (!sourceColumns) {
            this.filterColumnPairs = undefined;
            this.selectedFilter = undefined;
            this.groupColumn.setFilterActive(false, 'columnRowGroupChanged');
            return AgPromise.resolve();
        }
        const filterPromises = [];
        const filterColumnPairs = [];
        sourceColumns.forEach(column => {
            const filterWrapper = this.filterManager.getOrCreateFilterWrapper(column, 'COLUMN_MENU');
            if (filterWrapper === null || filterWrapper === void 0 ? void 0 : filterWrapper.filterPromise) {
                filterPromises.push(filterWrapper.filterPromise.then(filter => {
                    if (filter) {
                        filterColumnPairs.push({
                            filter,
                            column
                        });
                    }
                    if (column.getId() === this.selectedColumn.getId()) {
                        this.selectedFilter = filter !== null && filter !== void 0 ? filter : undefined;
                    }
                    return filter;
                }));
            }
        });
        return AgPromise.all(filterPromises).then(() => {
            this.filterColumnPairs = filterColumnPairs;
            this.groupColumn.setFilterActive(this.isFilterActive(), 'columnRowGroupChanged');
        });
    }
    addUnderlyingFilterElement() {
        _.clearElement(this.eUnderlyingFilter);
        if (!this.selectedColumn) {
            return AgPromise.resolve();
        }
        const filterWrapper = this.filterManager.getOrCreateFilterWrapper(this.selectedColumn, 'COLUMN_MENU');
        if (!filterWrapper) {
            return AgPromise.resolve();
        }
        return filterWrapper.guiPromise.then(gui => {
            var _a;
            this.eUnderlyingFilter.appendChild(gui);
            (_a = filterWrapper.filterPromise) === null || _a === void 0 ? void 0 : _a.then(filter => {
                var _a, _b;
                (_a = filter === null || filter === void 0 ? void 0 : filter.afterGuiAttached) === null || _a === void 0 ? void 0 : _a.call(filter, this.afterGuiAttachedParams);
                if (!((_b = this.afterGuiAttachedParams) === null || _b === void 0 ? void 0 : _b.suppressFocus) && this.eGroupFieldSelect && !this.eGroupFieldSelect.isDisabled()) {
                    this.eGroupFieldSelect.getFocusableElement().focus();
                }
            });
        });
    }
    updateSelectedColumn(columnId) {
        var _a, _b;
        if (!columnId) {
            return;
        }
        (_b = (_a = this.selectedFilter) === null || _a === void 0 ? void 0 : _a.afterGuiDetached) === null || _b === void 0 ? void 0 : _b.call(_a);
        const selectedFilterColumnPair = this.getFilterColumnPair(columnId);
        this.selectedColumn = selectedFilterColumnPair === null || selectedFilterColumnPair === void 0 ? void 0 : selectedFilterColumnPair.column;
        this.selectedFilter = selectedFilterColumnPair === null || selectedFilterColumnPair === void 0 ? void 0 : selectedFilterColumnPair.filter;
        this.dispatchEvent({
            type: GroupFilter.EVENT_SELECTED_COLUMN_CHANGED
        });
        this.addUnderlyingFilterElement();
    }
    isFilterActive() {
        var _a;
        return !!((_a = this.filterColumnPairs) === null || _a === void 0 ? void 0 : _a.some(({ filter }) => filter.isFilterActive()));
    }
    doesFilterPass() {
        return true;
    }
    getModel() {
        return null;
    }
    setModel() {
        return AgPromise.resolve();
    }
    afterGuiAttached(params) {
        this.afterGuiAttachedParams = params;
        this.addUnderlyingFilterElement();
    }
    afterGuiDetached() {
        var _a, _b;
        _.clearElement(this.eUnderlyingFilter);
        (_b = (_a = this.selectedFilter) === null || _a === void 0 ? void 0 : _a.afterGuiDetached) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    onColumnRowGroupChanged() {
        this.updateGroups().then(() => {
            this.dispatchEvent({
                type: GroupFilter.EVENT_COLUMN_ROW_GROUP_CHANGED
            });
            this.eventService.dispatchEvent({
                type: 'filterAllowedUpdated'
            });
        });
    }
    getFilterColumnPair(columnId) {
        var _a;
        if (!columnId) {
            return undefined;
        }
        return (_a = this.filterColumnPairs) === null || _a === void 0 ? void 0 : _a.find(({ column }) => column.getId() === columnId);
    }
    getSelectedFilter() {
        return this.selectedFilter;
    }
    getSelectedColumn() {
        return this.selectedColumn;
    }
    isFilterAllowed() {
        return !!this.selectedColumn;
    }
    destroy() {
        super.destroy();
    }
}
GroupFilter.EVENT_COLUMN_ROW_GROUP_CHANGED = 'columnRowGroupChanged';
GroupFilter.EVENT_SELECTED_COLUMN_CHANGED = 'selectedColumnChanged';
__decorate$1h([
    Autowired('filterManager')
], GroupFilter.prototype, "filterManager", void 0);
__decorate$1h([
    Autowired('columnModel')
], GroupFilter.prototype, "columnModel", void 0);
__decorate$1h([
    RefSelector('eGroupField')
], GroupFilter.prototype, "eGroupField", void 0);
__decorate$1h([
    RefSelector('eUnderlyingFilter')
], GroupFilter.prototype, "eUnderlyingFilter", void 0);
__decorate$1h([
    PostConstruct
], GroupFilter.prototype, "postConstruct", null);

var __decorate$1i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class GroupFloatingFilterComp extends Component {
    constructor() {
        super(/* html */ `
            <div ref="eFloatingFilter" class="ag-group-floating-filter ag-floating-filter-input" role="presentation"></div>
        `);
        this.haveAddedColumnListeners = false;
    }
    init(params) {
        this.params = params;
        // we only support showing the underlying floating filter for multiple group columns
        const canShowUnderlyingFloatingFilter = this.gridOptionsService.get('groupDisplayType') === 'multipleColumns';
        return new AgPromise(resolve => {
            this.params.parentFilterInstance(parentFilterInstance => {
                this.parentFilterInstance = parentFilterInstance;
                if (canShowUnderlyingFloatingFilter) {
                    this.setupUnderlyingFloatingFilterElement().then(() => resolve());
                }
                else {
                    this.setupReadOnlyFloatingFilterElement();
                    resolve();
                }
            });
        }).then(() => {
            this.addManagedListener(this.parentFilterInstance, GroupFilter.EVENT_SELECTED_COLUMN_CHANGED, () => this.onSelectedColumnChanged());
            this.addManagedListener(this.parentFilterInstance, GroupFilter.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onColumnRowGroupChanged());
        });
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        this.params = params;
        this.setParams();
    }
    setParams() {
        var _a;
        const displayName = this.columnModel.getDisplayNameForColumn(this.params.column, 'header', true);
        const translate = this.localeService.getLocaleTextFunc();
        (_a = this.eFloatingFilterText) === null || _a === void 0 ? void 0 : _a.setInputAriaLabel(`${displayName} ${translate('ariaFilterInput', 'Filter Input')}`);
    }
    setupReadOnlyFloatingFilterElement() {
        if (!this.eFloatingFilterText) {
            this.eFloatingFilterText = this.createManagedBean(new AgInputTextField());
            this.eFloatingFilterText
                .setDisabled(true)
                .addGuiEventListener('click', () => this.params.showParentFilter());
            this.setParams();
        }
        this.updateDisplayedValue();
        this.eFloatingFilter.appendChild(this.eFloatingFilterText.getGui());
    }
    setupUnderlyingFloatingFilterElement() {
        this.showingUnderlyingFloatingFilter = false;
        this.underlyingFloatingFilter = undefined;
        _.clearElement(this.eFloatingFilter);
        const column = this.parentFilterInstance.getSelectedColumn();
        // we can only show the underlying filter if there is one instance (e.g. the underlying column is not visible)
        if (column && !column.isVisible()) {
            const compDetails = this.filterManager.getFloatingFilterCompDetails(column, this.params.showParentFilter);
            if (compDetails) {
                this.compDetails = compDetails;
                if (!this.haveAddedColumnListeners) {
                    this.haveAddedColumnListeners = true;
                    this.addManagedListener(column, Column.EVENT_VISIBLE_CHANGED, this.onColumnVisibleChanged.bind(this));
                    this.addManagedListener(column, Column.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this));
                }
                return compDetails.newAgStackInstance().then(floatingFilter => {
                    var _a, _b;
                    this.underlyingFloatingFilter = floatingFilter;
                    (_a = this.underlyingFloatingFilter) === null || _a === void 0 ? void 0 : _a.onParentModelChanged((_b = this.parentFilterInstance.getSelectedFilter()) === null || _b === void 0 ? void 0 : _b.getModel());
                    this.appendChild(floatingFilter.getGui());
                    this.showingUnderlyingFloatingFilter = true;
                });
            }
        }
        // fallback to the read-only version
        this.setupReadOnlyFloatingFilterElement();
        return AgPromise.resolve();
    }
    onColumnVisibleChanged() {
        this.setupUnderlyingFloatingFilterElement();
    }
    onColDefChanged(event) {
        var _a, _b, _c;
        if (!event.column) {
            return;
        }
        const compDetails = this.filterManager.getFloatingFilterCompDetails(event.column, this.params.showParentFilter);
        if (compDetails) {
            if ((_a = this.underlyingFloatingFilter) === null || _a === void 0 ? void 0 : _a.refresh) {
                this.underlyingFloatingFilter.refresh(compDetails.params);
            }
            else {
                (_c = (_b = this.underlyingFloatingFilter) === null || _b === void 0 ? void 0 : _b.onParamsUpdated) === null || _c === void 0 ? void 0 : _c.call(_b, compDetails.params);
            }
        }
    }
    onParentModelChanged(_model, event) {
        var _a, _b;
        if (this.showingUnderlyingFloatingFilter) {
            (_a = this.underlyingFloatingFilter) === null || _a === void 0 ? void 0 : _a.onParentModelChanged((_b = this.parentFilterInstance.getSelectedFilter()) === null || _b === void 0 ? void 0 : _b.getModel(), event);
        }
        else {
            this.updateDisplayedValue();
        }
    }
    updateDisplayedValue() {
        if (!this.parentFilterInstance || !this.eFloatingFilterText) {
            return;
        }
        const selectedFilter = this.parentFilterInstance.getSelectedFilter();
        if (!selectedFilter) {
            this.eFloatingFilterText.setValue('');
            this.eFloatingFilterText.setDisplayed(false);
            return;
        }
        this.eFloatingFilterText.setDisplayed(true);
        if (selectedFilter.getModelAsString) {
            const filterModel = selectedFilter.getModel();
            this.eFloatingFilterText.setValue(filterModel == null ? '' : selectedFilter.getModelAsString(filterModel));
        }
        else {
            this.eFloatingFilterText.setValue('');
        }
    }
    onSelectedColumnChanged() {
        if (!this.showingUnderlyingFloatingFilter) {
            this.updateDisplayedValue();
        }
    }
    onColumnRowGroupChanged() {
        if (!this.showingUnderlyingFloatingFilter) {
            this.updateDisplayedValue();
        }
    }
    destroy() {
        super.destroy();
    }
}
__decorate$1i([
    Autowired('columnModel')
], GroupFloatingFilterComp.prototype, "columnModel", void 0);
__decorate$1i([
    Autowired('filterManager')
], GroupFloatingFilterComp.prototype, "filterManager", void 0);
__decorate$1i([
    RefSelector('eFloatingFilter')
], GroupFloatingFilterComp.prototype, "eFloatingFilter", void 0);

const RowGroupingModule = {
    version: VERSION$7,
    moduleName: ModuleNames.RowGroupingModule,
    beans: [AggregationStage, FilterAggregatesStage, GroupStage, PivotColDefService, PivotStage, AggFuncService],
    agStackComponents: [
        { componentName: 'AgGridHeaderDropZones', componentClass: GridHeaderDropZones }
    ],
    userComponents: [
        { componentName: 'agGroupColumnFilter', componentClass: GroupFilter },
        { componentName: 'agGroupColumnFloatingFilter', componentClass: GroupFloatingFilterComp },
    ],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

var __decorate$1j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ValuesDropZonePanel extends BaseDropZonePanel {
    constructor(horizontal) {
        super(horizontal, 'aggregation');
    }
    passBeansUp() {
        super.setBeans({
            gridOptionsService: this.gridOptionsService,
            eventService: this.eventService,
            context: this.getContext(),
            loggerFactory: this.loggerFactory,
            dragAndDropService: this.dragAndDropService
        });
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const emptyMessage = localeTextFunc('valueColumnsEmptyMessage', 'Drag here to aggregate');
        const title = localeTextFunc('values', 'Values');
        super.init({
            dragAndDropIcon: DragAndDropService.ICON_AGGREGATE,
            icon: _.createIconNoSpan('valuePanel', this.gridOptionsService, null),
            emptyMessage: emptyMessage,
            title: title
        });
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.refreshGui.bind(this));
    }
    getAriaLabel() {
        const translate = this.localeService.getLocaleTextFunc();
        const label = translate('ariaValuesDropZonePanelLabel', 'Values');
        return label;
    }
    getTooltipParams() {
        const res = super.getTooltipParams();
        res.location = 'valueColumnsList';
        return res;
    }
    getIconName() {
        return this.isPotentialDndColumns() ? DragAndDropService.ICON_AGGREGATE : DragAndDropService.ICON_NOT_ALLOWED;
    }
    isColumnDroppable(column, draggingEvent) {
        // we never allow grouping of secondary columns
        if (this.gridOptionsService.get('functionsReadOnly') || !column.isPrimary()) {
            return false;
        }
        return column.isAllowValue() && (!column.isValueActive() || this.isSourceEventFromTarget(draggingEvent));
    }
    updateColumns(columns) {
        if (this.gridOptionsService.get('functionsPassive')) {
            const event = {
                type: Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST,
                columns: columns
            };
            this.eventService.dispatchEvent(event);
        }
        else {
            this.columnModel.setValueColumns(columns, "toolPanelUi");
        }
    }
    getExistingColumns() {
        return this.columnModel.getValueColumns();
    }
}
__decorate$1j([
    Autowired('columnModel')
], ValuesDropZonePanel.prototype, "columnModel", void 0);
__decorate$1j([
    Autowired('loggerFactory')
], ValuesDropZonePanel.prototype, "loggerFactory", void 0);
__decorate$1j([
    Autowired('dragAndDropService')
], ValuesDropZonePanel.prototype, "dragAndDropService", void 0);
__decorate$1j([
    PostConstruct
], ValuesDropZonePanel.prototype, "passBeansUp", null);

var __decorate$1k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class PrimaryColsPanel extends Component {
    constructor() {
        super(PrimaryColsPanel.TEMPLATE);
    }
    // we allow dragging in the toolPanel, but not when this component appears in the column menu
    init(allowDragging, params, eventType) {
        this.allowDragging = allowDragging;
        this.params = params;
        this.eventType = eventType;
        this.primaryColsHeaderPanel.init(this.params);
        const hideFilter = this.params.suppressColumnFilter;
        const hideSelect = this.params.suppressColumnSelectAll;
        const hideExpand = this.params.suppressColumnExpandAll;
        if (hideExpand && hideFilter && hideSelect) {
            this.primaryColsHeaderPanel.setDisplayed(false);
        }
        this.addManagedListener(this.primaryColsListPanel, 'groupExpanded', this.onGroupExpanded.bind(this));
        this.addManagedListener(this.primaryColsListPanel, 'selectionChanged', this.onSelectionChange.bind(this));
        this.primaryColsListPanel.init(this.params, this.allowDragging, this.eventType);
        this.addManagedListener(this.primaryColsHeaderPanel, 'expandAll', this.onExpandAll.bind(this));
        this.addManagedListener(this.primaryColsHeaderPanel, 'collapseAll', this.onCollapseAll.bind(this));
        this.addManagedListener(this.primaryColsHeaderPanel, 'selectAll', this.onSelectAll.bind(this));
        this.addManagedListener(this.primaryColsHeaderPanel, 'unselectAll', this.onUnselectAll.bind(this));
        this.addManagedListener(this.primaryColsHeaderPanel, 'filterChanged', this.onFilterChanged.bind(this));
        this.positionableFeature = new PositionableFeature(this.getGui(), { minHeight: 100 });
        this.createManagedBean(this.positionableFeature);
    }
    toggleResizable(resizable) {
        this.positionableFeature.setResizable(resizable ? { bottom: true } : false);
    }
    onExpandAll() {
        this.primaryColsListPanel.doSetExpandedAll(true);
    }
    onCollapseAll() {
        this.primaryColsListPanel.doSetExpandedAll(false);
    }
    expandGroups(groupIds) {
        this.primaryColsListPanel.setGroupsExpanded(true, groupIds);
    }
    collapseGroups(groupIds) {
        this.primaryColsListPanel.setGroupsExpanded(false, groupIds);
    }
    setColumnLayout(colDefs) {
        this.primaryColsListPanel.setColumnLayout(colDefs);
    }
    onFilterChanged(event) {
        this.primaryColsListPanel.setFilterText(event.filterText);
    }
    syncLayoutWithGrid() {
        this.primaryColsListPanel.onColumnsChanged();
    }
    onSelectAll() {
        this.primaryColsListPanel.doSetSelectedAll(true);
    }
    onUnselectAll() {
        this.primaryColsListPanel.doSetSelectedAll(false);
    }
    onGroupExpanded(event) {
        this.primaryColsHeaderPanel.setExpandState(event.state);
        this.params.onStateUpdated();
    }
    onSelectionChange(event) {
        this.primaryColsHeaderPanel.setSelectionState(event.state);
    }
    getExpandedGroups() {
        return this.primaryColsListPanel.getExpandedGroups();
    }
}
PrimaryColsPanel.TEMPLATE = `<div class="ag-column-select">
            <ag-primary-cols-header ref="primaryColsHeaderPanel"></ag-primary-cols-header>
            <ag-primary-cols-list ref="primaryColsListPanel"></ag-primary-cols-list>
        </div>`;
__decorate$1k([
    RefSelector('primaryColsHeaderPanel')
], PrimaryColsPanel.prototype, "primaryColsHeaderPanel", void 0);
__decorate$1k([
    RefSelector('primaryColsListPanel')
], PrimaryColsPanel.prototype, "primaryColsListPanel", void 0);

class ColumnToolPanel extends Component {
    constructor() {
        super(ColumnToolPanel.TEMPLATE);
        this.initialised = false;
        this.childDestroyFuncs = [];
    }
    // lazy initialise the panel
    setVisible(visible) {
        super.setDisplayed(visible);
        if (visible && !this.initialised) {
            this.init(this.params);
        }
    }
    init(params) {
        const defaultParams = this.gridOptionsService.addGridCommonParams({
            suppressColumnMove: false,
            suppressColumnSelectAll: false,
            suppressColumnFilter: false,
            suppressColumnExpandAll: false,
            contractColumnSelection: false,
            suppressPivotMode: false,
            suppressRowGroups: false,
            suppressValues: false,
            suppressPivots: false,
            suppressSyncLayoutWithGrid: false,
        });
        this.params = Object.assign(Object.assign({}, defaultParams), params);
        if (this.isRowGroupingModuleLoaded() && !this.params.suppressPivotMode) {
            // DO NOT CHANGE TO createManagedBean
            this.pivotModePanel = this.createBean(new PivotModePanel());
            this.childDestroyFuncs.push(() => this.destroyBean(this.pivotModePanel));
            this.appendChild(this.pivotModePanel);
        }
        // DO NOT CHANGE TO createManagedBean
        this.primaryColsPanel = this.createBean(new PrimaryColsPanel());
        this.childDestroyFuncs.push(() => this.destroyBean(this.primaryColsPanel));
        this.primaryColsPanel.init(true, this.params, "toolPanelUi");
        this.primaryColsPanel.addCssClass('ag-column-panel-column-select');
        this.appendChild(this.primaryColsPanel);
        if (this.isRowGroupingModuleLoaded()) {
            if (!this.params.suppressRowGroups) {
                // DO NOT CHANGE TO createManagedBean
                this.rowGroupDropZonePanel = this.createBean(new RowGroupDropZonePanel(false));
                this.childDestroyFuncs.push(() => this.destroyBean(this.rowGroupDropZonePanel));
                this.appendChild(this.rowGroupDropZonePanel);
            }
            if (!this.params.suppressValues) {
                // DO NOT CHANGE TO createManagedBean
                this.valuesDropZonePanel = this.createBean(new ValuesDropZonePanel(false));
                this.childDestroyFuncs.push(() => this.destroyBean(this.valuesDropZonePanel));
                this.appendChild(this.valuesDropZonePanel);
            }
            if (!this.params.suppressPivots) {
                // DO NOT CHANGE TO createManagedBean
                this.pivotDropZonePanel = this.createBean(new PivotDropZonePanel(false));
                this.childDestroyFuncs.push(() => this.destroyBean(this.pivotDropZonePanel));
                this.appendChild(this.pivotDropZonePanel);
            }
            this.setLastVisible();
            const pivotModeListener = this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, () => {
                this.resetChildrenHeight();
                this.setLastVisible();
            });
            this.childDestroyFuncs.push(() => pivotModeListener());
        }
        this.initialised = true;
    }
    setPivotModeSectionVisible(visible) {
        if (!this.isRowGroupingModuleLoaded()) {
            return;
        }
        if (this.pivotModePanel) {
            this.pivotModePanel.setDisplayed(visible);
        }
        else if (visible) {
            this.pivotModePanel = this.createBean(new PivotModePanel());
            // ensure pivot mode panel is positioned at the top of the columns tool panel
            this.getGui().insertBefore(this.pivotModePanel.getGui(), this.getGui().firstChild);
            this.childDestroyFuncs.push(() => this.destroyBean(this.pivotModePanel));
        }
        this.setLastVisible();
    }
    setRowGroupsSectionVisible(visible) {
        if (!this.isRowGroupingModuleLoaded()) {
            return;
        }
        if (this.rowGroupDropZonePanel) {
            this.rowGroupDropZonePanel.setDisplayed(visible);
        }
        else if (visible) {
            this.rowGroupDropZonePanel = this.createManagedBean(new RowGroupDropZonePanel(false));
            this.appendChild(this.rowGroupDropZonePanel);
        }
        this.setLastVisible();
    }
    setValuesSectionVisible(visible) {
        if (!this.isRowGroupingModuleLoaded()) {
            return;
        }
        if (this.valuesDropZonePanel) {
            this.valuesDropZonePanel.setDisplayed(visible);
        }
        else if (visible) {
            this.valuesDropZonePanel = this.createManagedBean(new ValuesDropZonePanel(false));
            this.appendChild(this.valuesDropZonePanel);
        }
        this.setLastVisible();
    }
    setPivotSectionVisible(visible) {
        if (!this.isRowGroupingModuleLoaded()) {
            return;
        }
        if (this.pivotDropZonePanel) {
            this.pivotDropZonePanel.setDisplayed(visible);
        }
        else if (visible) {
            this.pivotDropZonePanel = this.createManagedBean(new PivotDropZonePanel(false));
            this.appendChild(this.pivotDropZonePanel);
            this.pivotDropZonePanel.setDisplayed(visible);
        }
        this.setLastVisible();
    }
    setResizers() {
        [
            this.primaryColsPanel,
            this.rowGroupDropZonePanel,
            this.valuesDropZonePanel,
            this.pivotDropZonePanel
        ].forEach(panel => {
            if (!panel) {
                return;
            }
            const eGui = panel.getGui();
            panel.toggleResizable(!eGui.classList.contains('ag-last-column-drop') && !eGui.classList.contains('ag-hidden'));
        });
    }
    setLastVisible() {
        const eGui = this.getGui();
        const columnDrops = Array.prototype.slice.call(eGui.querySelectorAll('.ag-column-drop'));
        columnDrops.forEach(columnDrop => columnDrop.classList.remove('ag-last-column-drop'));
        const columnDropEls = eGui.querySelectorAll('.ag-column-drop:not(.ag-hidden)');
        const lastVisible = _.last(columnDropEls);
        if (lastVisible) {
            lastVisible.classList.add('ag-last-column-drop');
        }
        this.setResizers();
    }
    resetChildrenHeight() {
        const eGui = this.getGui();
        const children = eGui.children;
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            child.style.removeProperty('height');
            child.style.removeProperty('flex');
        }
    }
    isRowGroupingModuleLoaded() {
        return ModuleRegistry.__assertRegistered(ModuleNames.RowGroupingModule, 'Row Grouping', this.context.getGridId());
    }
    expandColumnGroups(groupIds) {
        this.primaryColsPanel.expandGroups(groupIds);
    }
    collapseColumnGroups(groupIds) {
        this.primaryColsPanel.collapseGroups(groupIds);
    }
    setColumnLayout(colDefs) {
        this.primaryColsPanel.setColumnLayout(colDefs);
    }
    syncLayoutWithGrid() {
        this.primaryColsPanel.syncLayoutWithGrid();
    }
    destroyChildren() {
        this.childDestroyFuncs.forEach(func => func());
        this.childDestroyFuncs.length = 0;
        _.clearElement(this.getGui());
    }
    refresh(params) {
        this.destroyChildren();
        this.init(params);
        return true;
    }
    getState() {
        return {
            expandedGroupIds: this.primaryColsPanel.getExpandedGroups()
        };
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so this must be public.
    destroy() {
        this.destroyChildren();
        super.destroy();
    }
}
ColumnToolPanel.TEMPLATE = `<div class="ag-column-panel"></div>`;

var __decorate$1l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class HorizontalResizeComp extends Component {
    constructor() {
        super(/* html */ `<div class="ag-tool-panel-horizontal-resize"></div>`);
        this.minWidth = 100;
        this.maxWidth = null;
    }
    setElementToResize(elementToResize) {
        this.elementToResize = elementToResize;
    }
    postConstruct() {
        const finishedWithResizeFunc = this.horizontalResizeService.addResizeBar({
            eResizeBar: this.getGui(),
            dragStartPixels: 1,
            onResizeStart: this.onResizeStart.bind(this),
            onResizing: this.onResizing.bind(this),
            onResizeEnd: this.onResizeEnd.bind(this)
        });
        this.addDestroyFunc(finishedWithResizeFunc);
        this.setInverted(this.gridOptionsService.get('enableRtl'));
    }
    dispatchResizeEvent(start, end, width) {
        const event = {
            type: Events.EVENT_TOOL_PANEL_SIZE_CHANGED,
            width: width,
            started: start,
            ended: end,
        };
        this.eventService.dispatchEvent(event);
    }
    onResizeStart() {
        this.startingWidth = this.elementToResize.offsetWidth;
        this.dispatchResizeEvent(true, false, this.startingWidth);
    }
    onResizeEnd(delta) {
        return this.onResizing(delta, true);
    }
    onResizing(delta, isEnd = false) {
        const direction = this.inverted ? -1 : 1;
        let newWidth = Math.max(this.minWidth, Math.floor(this.startingWidth - (delta * direction)));
        if (this.maxWidth != null) {
            newWidth = Math.min(this.maxWidth, newWidth);
        }
        this.elementToResize.style.width = `${newWidth}px`;
        this.dispatchResizeEvent(false, isEnd, newWidth);
    }
    setInverted(inverted) {
        this.inverted = inverted;
    }
    setMaxWidth(value) {
        this.maxWidth = value;
    }
    setMinWidth(value) {
        if (value != null) {
            this.minWidth = value;
        }
        else {
            this.minWidth = 100;
        }
    }
}
__decorate$1l([
    Autowired('horizontalResizeService')
], HorizontalResizeComp.prototype, "horizontalResizeService", void 0);
__decorate$1l([
    PostConstruct
], HorizontalResizeComp.prototype, "postConstruct", null);

var __decorate$1m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SideBarButtonComp extends Component {
    constructor(toolPanelDef) {
        super();
        this.toolPanelDef = toolPanelDef;
    }
    getToolPanelId() {
        return this.toolPanelDef.id;
    }
    postConstruct() {
        const template = this.createTemplate();
        this.setTemplate(template);
        this.setLabel();
        this.setIcon();
        this.addManagedListener(this.eToggleButton, 'click', this.onButtonPressed.bind(this));
        this.eToggleButton.setAttribute('id', `ag-${this.getCompId()}-button`);
    }
    createTemplate() {
        const res = /* html */ `<div class="ag-side-button" role="presentation">
                <button type="button" ref="eToggleButton" tabindex="-1" role="tab" aria-expanded="false" class="ag-button ag-side-button-button">
                    <div ref="eIconWrapper" class="ag-side-button-icon-wrapper" aria-hidden="true"></div>
                    <span ref ="eLabel" class="ag-side-button-label"></span>
                </button>
            </div>`;
        return res;
    }
    setLabel() {
        const translate = this.localeService.getLocaleTextFunc();
        const def = this.toolPanelDef;
        const label = translate(def.labelKey, def.labelDefault);
        this.eLabel.innerText = label;
    }
    setIcon() {
        this.eIconWrapper.insertAdjacentElement('afterbegin', _.createIconNoSpan(this.toolPanelDef.iconKey, this.gridOptionsService));
    }
    onButtonPressed() {
        this.dispatchEvent({ type: SideBarButtonComp.EVENT_TOGGLE_BUTTON_CLICKED });
    }
    setSelected(selected) {
        this.addOrRemoveCssClass('ag-selected', selected);
        _.setAriaExpanded(this.eToggleButton, selected);
    }
    getButtonElement() {
        return this.eToggleButton;
    }
}
SideBarButtonComp.EVENT_TOGGLE_BUTTON_CLICKED = 'toggleButtonClicked';
__decorate$1m([
    RefSelector('eToggleButton')
], SideBarButtonComp.prototype, "eToggleButton", void 0);
__decorate$1m([
    RefSelector('eIconWrapper')
], SideBarButtonComp.prototype, "eIconWrapper", void 0);
__decorate$1m([
    RefSelector('eLabel')
], SideBarButtonComp.prototype, "eLabel", void 0);
__decorate$1m([
    PostConstruct
], SideBarButtonComp.prototype, "postConstruct", null);

var __decorate$1n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SideBarButtonsComp extends Component {
    constructor() {
        super(SideBarButtonsComp.TEMPLATE);
        this.buttonComps = [];
    }
    postConstruct() {
        this.addManagedListener(this.getFocusableElement(), 'keydown', this.handleKeyDown.bind(this));
    }
    handleKeyDown(e) {
        if (e.key !== KeyCode.TAB || !e.shiftKey) {
            return;
        }
        const lastColumn = _.last(this.columnModel.getAllDisplayedColumns());
        if (this.focusService.focusGridView(lastColumn, true)) {
            e.preventDefault();
        }
    }
    setActiveButton(id) {
        this.buttonComps.forEach(comp => {
            comp.setSelected(id === comp.getToolPanelId());
        });
    }
    addButtonComp(def) {
        const buttonComp = this.createBean(new SideBarButtonComp(def));
        this.buttonComps.push(buttonComp);
        this.appendChild(buttonComp);
        buttonComp.addEventListener(SideBarButtonComp.EVENT_TOGGLE_BUTTON_CLICKED, () => {
            this.dispatchEvent({
                type: SideBarButtonsComp.EVENT_SIDE_BAR_BUTTON_CLICKED,
                toolPanelId: def.id
            });
        });
        return buttonComp;
    }
    clearButtons() {
        this.buttonComps = this.destroyBeans(this.buttonComps);
        _.clearElement(this.getGui());
    }
}
SideBarButtonsComp.EVENT_SIDE_BAR_BUTTON_CLICKED = 'sideBarButtonClicked';
SideBarButtonsComp.TEMPLATE = `<div class="ag-side-buttons" role="tablist"></div>`;
__decorate$1n([
    Autowired('focusService')
], SideBarButtonsComp.prototype, "focusService", void 0);
__decorate$1n([
    Autowired('columnModel')
], SideBarButtonsComp.prototype, "columnModel", void 0);
__decorate$1n([
    PostConstruct
], SideBarButtonsComp.prototype, "postConstruct", null);
__decorate$1n([
    PreDestroy
], SideBarButtonsComp.prototype, "clearButtons", null);

class SideBarDefParser {
    static parse(toParse) {
        if (!toParse) {
            return undefined;
        }
        if (toParse === true) {
            return {
                toolPanels: [
                    SideBarDefParser.DEFAULT_COLUMN_COMP,
                    SideBarDefParser.DEFAULT_FILTER_COMP,
                ],
                defaultToolPanel: 'columns'
            };
        }
        if (typeof toParse === 'string') {
            return SideBarDefParser.parse([toParse]);
        }
        if (Array.isArray(toParse)) {
            const comps = [];
            toParse.forEach(key => {
                const lookupResult = SideBarDefParser.DEFAULT_BY_KEY[key];
                if (!lookupResult) {
                    console.warn(`AG Grid: the key ${key} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(SideBarDefParser.DEFAULT_BY_KEY).join(',')}`);
                    return;
                }
                comps.push(lookupResult);
            });
            if (comps.length === 0) {
                return undefined;
            }
            return {
                toolPanels: comps,
                defaultToolPanel: comps[0].id
            };
        }
        const result = {
            toolPanels: SideBarDefParser.parseComponents(toParse.toolPanels),
            defaultToolPanel: toParse.defaultToolPanel,
            hiddenByDefault: toParse.hiddenByDefault,
            position: toParse.position
        };
        return result;
    }
    static parseComponents(from) {
        const result = [];
        if (!from) {
            return result;
        }
        from.forEach((it) => {
            let toAdd = null;
            if (typeof it === 'string') {
                const lookupResult = SideBarDefParser.DEFAULT_BY_KEY[it];
                if (!lookupResult) {
                    console.warn(`AG Grid: the key ${it} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(SideBarDefParser.DEFAULT_BY_KEY).join(',')}`);
                    return;
                }
                toAdd = lookupResult;
            }
            else {
                toAdd = it;
            }
            result.push(toAdd);
        });
        return result;
    }
}
SideBarDefParser.DEFAULT_COLUMN_COMP = {
    id: 'columns',
    labelDefault: 'Columns',
    labelKey: 'columns',
    iconKey: 'columns',
    toolPanel: 'agColumnsToolPanel',
};
SideBarDefParser.DEFAULT_FILTER_COMP = {
    id: 'filters',
    labelDefault: 'Filters',
    labelKey: 'filters',
    iconKey: 'filter',
    toolPanel: 'agFiltersToolPanel',
};
SideBarDefParser.DEFAULT_BY_KEY = {
    columns: SideBarDefParser.DEFAULT_COLUMN_COMP,
    filters: SideBarDefParser.DEFAULT_FILTER_COMP
};

var __decorate$1o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ToolPanelWrapper extends Component {
    constructor() {
        super(ToolPanelWrapper.TEMPLATE);
    }
    setupResize() {
        const eGui = this.getGui();
        const resizeBar = this.resizeBar = this.createManagedBean(new HorizontalResizeComp());
        eGui.setAttribute('id', `ag-${this.getCompId()}`);
        resizeBar.setElementToResize(eGui);
        this.appendChild(resizeBar);
    }
    getToolPanelId() {
        return this.toolPanelId;
    }
    setToolPanelDef(toolPanelDef, params) {
        const { id, minWidth, maxWidth, width } = toolPanelDef;
        this.toolPanelId = id;
        this.width = width;
        const compDetails = this.userComponentFactory.getToolPanelCompDetails(toolPanelDef, params);
        const componentPromise = compDetails.newAgStackInstance();
        this.params = compDetails.params;
        if (componentPromise == null) {
            console.warn(`AG Grid: error processing tool panel component ${id}. You need to specify 'toolPanel'`);
            return;
        }
        componentPromise.then(this.setToolPanelComponent.bind(this));
        if (minWidth != null) {
            this.resizeBar.setMinWidth(minWidth);
        }
        if (maxWidth != null) {
            this.resizeBar.setMaxWidth(maxWidth);
        }
    }
    setToolPanelComponent(compInstance) {
        this.toolPanelCompInstance = compInstance;
        this.appendChild(compInstance.getGui());
        this.addDestroyFunc(() => {
            this.destroyBean(compInstance);
        });
        if (this.width) {
            this.getGui().style.width = `${this.width}px`;
        }
    }
    getToolPanelInstance() {
        return this.toolPanelCompInstance;
    }
    setResizerSizerSide(side) {
        const isRtl = this.gridOptionsService.get('enableRtl');
        const isLeft = side === 'left';
        const inverted = isRtl ? isLeft : !isLeft;
        this.resizeBar.setInverted(inverted);
    }
    refresh() {
        this.toolPanelCompInstance.refresh(this.params);
    }
}
ToolPanelWrapper.TEMPLATE = `<div class="ag-tool-panel-wrapper" role="tabpanel"/>`;
__decorate$1o([
    Autowired("userComponentFactory")
], ToolPanelWrapper.prototype, "userComponentFactory", void 0);
__decorate$1o([
    PostConstruct
], ToolPanelWrapper.prototype, "setupResize", null);

var __decorate$1p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SideBarComp extends Component {
    constructor() {
        super(SideBarComp.TEMPLATE);
        this.toolPanelWrappers = [];
    }
    postConstruct() {
        var _a;
        this.sideBarButtonsComp.addEventListener(SideBarButtonsComp.EVENT_SIDE_BAR_BUTTON_CLICKED, this.onToolPanelButtonClicked.bind(this));
        const { sideBar: sideBarState } = (_a = this.gridOptionsService.get('initialState')) !== null && _a !== void 0 ? _a : {};
        this.setSideBarDef({
            sideBarDef: SideBarDefParser.parse(this.gridOptionsService.get('sideBar')),
            sideBarState
        });
        this.addManagedPropertyListener('sideBar', this.onSideBarUpdated.bind(this));
        this.sideBarService.registerSideBarComp(this);
        this.createManagedBean(new ManagedFocusFeature(this.getFocusableElement(), {
            onTabKeyDown: this.onTabKeyDown.bind(this),
            handleKeyDown: this.handleKeyDown.bind(this)
        }));
    }
    onTabKeyDown(e) {
        if (e.defaultPrevented) {
            return;
        }
        const { focusService, sideBarButtonsComp } = this;
        const eGui = this.getGui();
        const sideBarGui = sideBarButtonsComp.getGui();
        const eDocument = this.gridOptionsService.getDocument();
        const activeElement = eDocument.activeElement;
        const openPanel = eGui.querySelector('.ag-tool-panel-wrapper:not(.ag-hidden)');
        const target = e.target;
        if (!openPanel) {
            return;
        }
        if (sideBarGui.contains(activeElement)) {
            if (focusService.focusInto(openPanel, e.shiftKey)) {
                e.preventDefault();
            }
            return;
        }
        // only handle backwards focus to target the sideBar buttons
        if (!e.shiftKey) {
            return;
        }
        let nextEl = null;
        if (openPanel.contains(activeElement)) {
            nextEl = this.focusService.findNextFocusableElement(openPanel, undefined, true);
        }
        else if (focusService.isTargetUnderManagedComponent(openPanel, target) && e.shiftKey) {
            nextEl = this.focusService.findFocusableElementBeforeTabGuard(openPanel, target);
        }
        if (!nextEl) {
            nextEl = sideBarGui.querySelector('.ag-selected button');
        }
        if (nextEl && nextEl !== e.target) {
            e.preventDefault();
            nextEl.focus();
        }
    }
    handleKeyDown(e) {
        const eDocument = this.gridOptionsService.getDocument();
        if (!this.sideBarButtonsComp.getGui().contains(eDocument.activeElement)) {
            return;
        }
        const sideBarGui = this.sideBarButtonsComp.getGui();
        const buttons = Array.prototype.slice.call(sideBarGui.querySelectorAll('.ag-side-button'));
        const currentButton = eDocument.activeElement;
        const currentPos = buttons.findIndex(button => button.contains(currentButton));
        let nextPos = null;
        switch (e.key) {
            case KeyCode.LEFT:
            case KeyCode.UP:
                nextPos = Math.max(0, currentPos - 1);
                break;
            case KeyCode.RIGHT:
            case KeyCode.DOWN:
                nextPos = Math.min(currentPos + 1, buttons.length - 1);
                break;
        }
        if (nextPos === null) {
            return;
        }
        const innerButton = buttons[nextPos].querySelector('button');
        if (innerButton) {
            innerButton.focus();
            e.preventDefault();
        }
    }
    onToolPanelButtonClicked(event) {
        const id = event.toolPanelId;
        const openedItem = this.openedItem();
        // if item was already open, we close it
        if (openedItem === id) {
            this.openToolPanel(undefined, 'sideBarButtonClicked'); // passing undefined closes
        }
        else {
            this.openToolPanel(id, 'sideBarButtonClicked');
        }
    }
    clearDownUi() {
        this.sideBarButtonsComp.clearButtons();
        this.destroyToolPanelWrappers();
    }
    setSideBarDef({ sideBarDef, sideBarState, existingToolPanelWrappers }) {
        // initially hide side bar
        this.setDisplayed(false);
        this.sideBar = sideBarDef;
        if (!!this.sideBar && !!this.sideBar.toolPanels) {
            const toolPanelDefs = this.sideBar.toolPanels;
            this.createToolPanelsAndSideButtons(toolPanelDefs, sideBarState, existingToolPanelWrappers);
            if (!this.toolPanelWrappers.length) {
                return;
            }
            const shouldDisplaySideBar = sideBarState ? sideBarState.visible : !this.sideBar.hiddenByDefault;
            this.setDisplayed(shouldDisplaySideBar);
            this.setSideBarPosition(sideBarState ? sideBarState.position : this.sideBar.position);
            if (shouldDisplaySideBar) {
                if (sideBarState) {
                    const { openToolPanel } = sideBarState;
                    if (openToolPanel) {
                        this.openToolPanel(openToolPanel, 'sideBarInitializing');
                    }
                }
                else {
                    this.openToolPanel(this.sideBar.defaultToolPanel, 'sideBarInitializing');
                }
            }
        }
    }
    getDef() {
        return this.sideBar;
    }
    setSideBarPosition(position) {
        if (!position) {
            position = 'right';
        }
        this.position = position;
        const isLeft = position === 'left';
        const resizerSide = isLeft ? 'right' : 'left';
        this.addOrRemoveCssClass('ag-side-bar-left', isLeft);
        this.addOrRemoveCssClass('ag-side-bar-right', !isLeft);
        this.toolPanelWrappers.forEach(wrapper => {
            wrapper.setResizerSizerSide(resizerSide);
        });
        this.eventService.dispatchEvent({ type: Events.EVENT_SIDE_BAR_UPDATED });
        return this;
    }
    setDisplayed(displayed, options) {
        super.setDisplayed(displayed, options);
        this.eventService.dispatchEvent({ type: Events.EVENT_SIDE_BAR_UPDATED });
    }
    getState() {
        const toolPanels = {};
        this.toolPanelWrappers.forEach(wrapper => {
            var _a, _b;
            toolPanels[wrapper.getToolPanelId()] = (_b = (_a = wrapper.getToolPanelInstance()) === null || _a === void 0 ? void 0 : _a.getState) === null || _b === void 0 ? void 0 : _b.call(_a);
        });
        return {
            visible: this.isDisplayed(),
            position: this.position,
            openToolPanel: this.openedItem(),
            toolPanels
        };
    }
    createToolPanelsAndSideButtons(defs, sideBarState, existingToolPanelWrappers) {
        var _a;
        for (const def of defs) {
            this.createToolPanelAndSideButton(def, (_a = sideBarState === null || sideBarState === void 0 ? void 0 : sideBarState.toolPanels) === null || _a === void 0 ? void 0 : _a[def.id], existingToolPanelWrappers === null || existingToolPanelWrappers === void 0 ? void 0 : existingToolPanelWrappers[def.id]);
        }
    }
    validateDef(def) {
        if (def.id == null) {
            console.warn(`AG Grid: please review all your toolPanel components, it seems like at least one of them doesn't have an id`);
            return false;
        }
        // helpers, in case user doesn't have the right module loaded
        if (def.toolPanel === 'agColumnsToolPanel') {
            const moduleMissing = !ModuleRegistry.__assertRegistered(ModuleNames.ColumnsToolPanelModule, 'Column Tool Panel', this.context.getGridId());
            if (moduleMissing) {
                return false;
            }
        }
        if (def.toolPanel === 'agFiltersToolPanel') {
            const moduleMissing = !ModuleRegistry.__assertRegistered(ModuleNames.FiltersToolPanelModule, 'Filters Tool Panel', this.context.getGridId());
            if (moduleMissing) {
                return false;
            }
            if (this.filterManager.isAdvancedFilterEnabled()) {
                _.warnOnce('Advanced Filter does not work with Filters Tool Panel. Filters Tool Panel has been disabled.');
                return false;
            }
        }
        return true;
    }
    createToolPanelAndSideButton(def, initialState, existingToolPanelWrapper) {
        if (!this.validateDef(def)) {
            return;
        }
        const button = this.sideBarButtonsComp.addButtonComp(def);
        let wrapper;
        if (existingToolPanelWrapper) {
            wrapper = existingToolPanelWrapper;
        }
        else {
            wrapper = this.getContext().createBean(new ToolPanelWrapper());
            wrapper.setToolPanelDef(def, {
                initialState,
                onStateUpdated: () => this.eventService.dispatchEvent({ type: Events.EVENT_SIDE_BAR_UPDATED })
            });
        }
        wrapper.setDisplayed(false);
        const wrapperGui = wrapper.getGui();
        this.appendChild(wrapperGui);
        this.toolPanelWrappers.push(wrapper);
        _.setAriaControls(button.getButtonElement(), wrapperGui);
    }
    refresh() {
        this.toolPanelWrappers.forEach(wrapper => wrapper.refresh());
    }
    openToolPanel(key, source = 'api') {
        const currentlyOpenedKey = this.openedItem();
        if (currentlyOpenedKey === key) {
            return;
        }
        this.toolPanelWrappers.forEach(wrapper => {
            const show = key === wrapper.getToolPanelId();
            wrapper.setDisplayed(show);
        });
        const newlyOpenedKey = this.openedItem();
        const openToolPanelChanged = currentlyOpenedKey !== newlyOpenedKey;
        if (openToolPanelChanged) {
            this.sideBarButtonsComp.setActiveButton(key);
            this.raiseToolPanelVisibleEvent(key, currentlyOpenedKey !== null && currentlyOpenedKey !== void 0 ? currentlyOpenedKey : undefined, source);
        }
    }
    getToolPanelInstance(key) {
        const toolPanelWrapper = this.toolPanelWrappers.filter(toolPanel => toolPanel.getToolPanelId() === key)[0];
        if (!toolPanelWrapper) {
            console.warn(`AG Grid: unable to lookup Tool Panel as invalid key supplied: ${key}`);
            return;
        }
        return toolPanelWrapper.getToolPanelInstance();
    }
    raiseToolPanelVisibleEvent(key, previousKey, source) {
        const switchingToolPanel = !!key && !!previousKey;
        if (previousKey) {
            const event = {
                type: Events.EVENT_TOOL_PANEL_VISIBLE_CHANGED,
                source,
                key: previousKey,
                visible: false,
                switchingToolPanel,
            };
            this.eventService.dispatchEvent(event);
        }
        if (key) {
            const event = {
                type: Events.EVENT_TOOL_PANEL_VISIBLE_CHANGED,
                source,
                key,
                visible: true,
                switchingToolPanel,
            };
            this.eventService.dispatchEvent(event);
        }
    }
    close(source = 'api') {
        this.openToolPanel(undefined, source);
    }
    isToolPanelShowing() {
        return !!this.openedItem();
    }
    openedItem() {
        let activeToolPanel = null;
        this.toolPanelWrappers.forEach(wrapper => {
            if (wrapper.isDisplayed()) {
                activeToolPanel = wrapper.getToolPanelId();
            }
        });
        return activeToolPanel;
    }
    onSideBarUpdated() {
        var _a;
        const sideBarDef = SideBarDefParser.parse(this.gridOptionsService.get('sideBar'));
        let existingToolPanelWrappers = {};
        if (sideBarDef && this.sideBar) {
            (_a = sideBarDef.toolPanels) === null || _a === void 0 ? void 0 : _a.forEach((toolPanelDef) => {
                var _a, _b;
                const { id } = toolPanelDef;
                if (!id) {
                    return;
                }
                const existingToolPanelDef = (_a = this.sideBar.toolPanels) === null || _a === void 0 ? void 0 : _a.find((toolPanelDefToCheck) => toolPanelDefToCheck.id === id);
                if (!existingToolPanelDef || toolPanelDef.toolPanel !== existingToolPanelDef.toolPanel) {
                    return;
                }
                const toolPanelWrapper = this.toolPanelWrappers.find(toolPanel => toolPanel.getToolPanelId() === id);
                if (!toolPanelWrapper) {
                    return;
                }
                const params = this.gridOptionsService.addGridCommonParams(Object.assign(Object.assign({}, ((_b = toolPanelDef.toolPanelParams) !== null && _b !== void 0 ? _b : {})), { onStateUpdated: () => this.eventService.dispatchEvent({ type: Events.EVENT_SIDE_BAR_UPDATED }) }));
                const hasRefreshed = toolPanelWrapper.getToolPanelInstance().refresh(params);
                if (hasRefreshed !== true) {
                    return;
                }
                this.toolPanelWrappers = this.toolPanelWrappers.filter(toolPanel => toolPanel !== toolPanelWrapper);
                _.removeFromParent(toolPanelWrapper.getGui());
                existingToolPanelWrappers[id] = toolPanelWrapper;
            });
        }
        this.clearDownUi();
        // don't re-assign initial state
        this.setSideBarDef({ sideBarDef, existingToolPanelWrappers });
    }
    destroyToolPanelWrappers() {
        this.toolPanelWrappers.forEach(wrapper => {
            _.removeFromParent(wrapper.getGui());
            this.destroyBean(wrapper);
        });
        this.toolPanelWrappers.length = 0;
    }
    destroy() {
        this.destroyToolPanelWrappers();
        super.destroy();
    }
}
SideBarComp.TEMPLATE = `<div class="ag-side-bar ag-unselectable">
            <ag-side-bar-buttons ref="sideBarButtons"></ag-side-bar-buttons>
        </div>`;
__decorate$1p([
    Autowired('focusService')
], SideBarComp.prototype, "focusService", void 0);
__decorate$1p([
    Autowired('filterManager')
], SideBarComp.prototype, "filterManager", void 0);
__decorate$1p([
    Autowired('sideBarService')
], SideBarComp.prototype, "sideBarService", void 0);
__decorate$1p([
    RefSelector('sideBarButtons')
], SideBarComp.prototype, "sideBarButtonsComp", void 0);
__decorate$1p([
    PostConstruct
], SideBarComp.prototype, "postConstruct", null);

var __decorate$1q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ToolPanelColDefService = class ToolPanelColDefService extends BeanStub {
    constructor() {
        super(...arguments);
        this.isColGroupDef = (colDef) => colDef && typeof colDef.children !== 'undefined';
        this.getId = (colDef) => {
            return this.isColGroupDef(colDef) ? colDef.groupId : colDef.colId;
        };
    }
    createColumnTree(colDefs) {
        const invalidColIds = [];
        const createDummyColGroup = (abstractColDef, depth) => {
            if (this.isColGroupDef(abstractColDef)) {
                // creating 'dummy' group which is not associated with grid column group
                const groupDef = abstractColDef;
                const groupId = (typeof groupDef.groupId !== 'undefined') ? groupDef.groupId : groupDef.headerName;
                const group = new ProvidedColumnGroup(groupDef, groupId, false, depth);
                const children = [];
                groupDef.children.forEach(def => {
                    const child = createDummyColGroup(def, depth + 1);
                    // check column exists in case invalid colDef is supplied for primary column
                    if (child) {
                        children.push(child);
                    }
                });
                group.setChildren(children);
                return group;
            }
            else {
                const colDef = abstractColDef;
                const key = colDef.colId ? colDef.colId : colDef.field;
                const column = this.columnModel.getPrimaryColumn(key);
                if (!column) {
                    invalidColIds.push(colDef);
                }
                return column;
            }
        };
        const mappedResults = [];
        colDefs.forEach(colDef => {
            const result = createDummyColGroup(colDef, 0);
            if (result) {
                // only return correctly mapped colDef results
                mappedResults.push(result);
            }
        });
        if (invalidColIds.length > 0) {
            console.warn('AG Grid: unable to find grid columns for the supplied colDef(s):', invalidColIds);
        }
        return mappedResults;
    }
    syncLayoutWithGrid(syncLayoutCallback) {
        // extract ordered list of leaf path trees (column group hierarchy for each individual leaf column)
        const leafPathTrees = this.getLeafPathTrees();
        // merge leaf path tree taking split column groups into account
        const mergedColumnTrees = this.mergeLeafPathTrees(leafPathTrees);
        // sync layout with merged column trees
        syncLayoutCallback(mergedColumnTrees);
    }
    getLeafPathTrees() {
        // leaf tree paths are obtained by walking up the tree starting at a column until we reach the top level group.
        const getLeafPathTree = (node, childDef) => {
            let leafPathTree;
            // build up tree in reverse order
            if (node instanceof ProvidedColumnGroup) {
                if (node.isPadding()) {
                    // skip over padding groups
                    leafPathTree = childDef;
                }
                else {
                    const groupDef = Object.assign({}, node.getColGroupDef());
                    // ensure group contains groupId
                    groupDef.groupId = node.getGroupId();
                    groupDef.children = [childDef];
                    leafPathTree = groupDef;
                }
            }
            else {
                const colDef = Object.assign({}, node.getColDef());
                // ensure col contains colId
                colDef.colId = node.getColId();
                leafPathTree = colDef;
            }
            // walk tree
            const parent = node.getOriginalParent();
            if (parent) {
                // keep walking up the tree until we reach the root
                return getLeafPathTree(parent, leafPathTree);
            }
            else {
                // we have reached the root - exit with resulting leaf path tree
                return leafPathTree;
            }
        };
        // obtain a sorted list of all grid columns
        const allGridColumns = this.columnModel.getAllGridColumns();
        // only primary columns and non row group columns should appear in the tool panel
        const allPrimaryGridColumns = allGridColumns.filter(column => {
            const colDef = column.getColDef();
            return column.isPrimary() && !colDef.showRowGroup;
        });
        // construct a leaf path tree for each column
        return allPrimaryGridColumns.map(col => getLeafPathTree(col, col.getColDef()));
    }
    mergeLeafPathTrees(leafPathTrees) {
        const matchingRootGroupIds = (pathA, pathB) => {
            const bothPathsAreGroups = this.isColGroupDef(pathA) && this.isColGroupDef(pathB);
            return bothPathsAreGroups && this.getId(pathA) === this.getId(pathB);
        };
        const mergeTrees = (treeA, treeB) => {
            if (!this.isColGroupDef(treeB)) {
                return treeA;
            }
            const mergeResult = treeA;
            const groupToMerge = treeB;
            if (groupToMerge.children && groupToMerge.groupId) {
                const added = this.addChildrenToGroup(mergeResult, groupToMerge.groupId, groupToMerge.children[0]);
                if (added) {
                    return mergeResult;
                }
            }
            groupToMerge.children.forEach(child => mergeTrees(mergeResult, child));
            return mergeResult;
        };
        // we can't just merge the leaf path trees as groups can be split apart - instead only merge if leaf
        // path groups with the same root group id are contiguous.
        const mergeColDefs = [];
        for (let i = 1; i <= leafPathTrees.length; i++) {
            const first = leafPathTrees[i - 1];
            const second = leafPathTrees[i];
            if (matchingRootGroupIds(first, second)) {
                leafPathTrees[i] = mergeTrees(first, second);
            }
            else {
                mergeColDefs.push(first);
            }
        }
        return mergeColDefs;
    }
    addChildrenToGroup(tree, groupId, colDef) {
        const subGroupIsSplit = (currentSubGroup, currentSubGroupToAdd) => {
            const existingChildIds = currentSubGroup.children.map(this.getId);
            const childGroupAlreadyExists = _.includes(existingChildIds, this.getId(currentSubGroupToAdd));
            const lastChild = _.last(currentSubGroup.children);
            const lastChildIsDifferent = lastChild && this.getId(lastChild) !== this.getId(currentSubGroupToAdd);
            return childGroupAlreadyExists && lastChildIsDifferent;
        };
        if (!this.isColGroupDef(tree)) {
            return true;
        }
        const currentGroup = tree;
        const groupToAdd = colDef;
        if (subGroupIsSplit(currentGroup, groupToAdd)) {
            currentGroup.children.push(groupToAdd);
            return true;
        }
        if (currentGroup.groupId === groupId) {
            // add children that don't already exist to group
            const existingChildIds = currentGroup.children.map(this.getId);
            const colDefAlreadyPresent = _.includes(existingChildIds, this.getId(groupToAdd));
            if (!colDefAlreadyPresent) {
                currentGroup.children.push(groupToAdd);
                return true;
            }
        }
        // recurse until correct group is found to add children
        currentGroup.children.forEach(subGroup => this.addChildrenToGroup(subGroup, groupId, colDef));
        return false;
    }
};
__decorate$1q([
    Autowired('columnModel')
], ToolPanelColDefService.prototype, "columnModel", void 0);
ToolPanelColDefService = __decorate$1q([
    Bean('toolPanelColDefService')
], ToolPanelColDefService);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$8 = '31.1.1';

var __decorate$1r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SideBarService = class SideBarService extends BeanStub {
    registerSideBarComp(sideBarComp) {
        this.sideBarComp = sideBarComp;
    }
    getSideBarComp() {
        return this.sideBarComp;
    }
};
SideBarService = __decorate$1r([
    Bean('sideBarService')
], SideBarService);

const SideBarModule = {
    version: VERSION$8,
    moduleName: ModuleNames.SideBarModule,
    beans: [ToolPanelColDefService, SideBarService],
    agStackComponents: [
        { componentName: 'AgHorizontalResize', componentClass: HorizontalResizeComp },
        { componentName: 'AgSideBar', componentClass: SideBarComp },
        { componentName: 'AgSideBarButtons', componentClass: SideBarButtonsComp },
    ],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

var __decorate$1s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ModelItemUtils = class ModelItemUtils {
    selectAllChildren(colTree, selectAllChecked, eventType) {
        const cols = this.extractAllLeafColumns(colTree);
        this.setAllColumns(cols, selectAllChecked, eventType);
    }
    setColumn(col, selectAllChecked, eventType) {
        this.setAllColumns([col], selectAllChecked, eventType);
    }
    setAllColumns(cols, selectAllChecked, eventType) {
        if (this.columnModel.isPivotMode()) {
            this.setAllPivot(cols, selectAllChecked, eventType);
        }
        else {
            this.setAllVisible(cols, selectAllChecked, eventType);
        }
    }
    extractAllLeafColumns(allItems) {
        const res = [];
        const recursiveFunc = (items) => {
            items.forEach(item => {
                if (!item.isPassesFilter()) {
                    return;
                }
                if (item.isGroup()) {
                    recursiveFunc(item.getChildren());
                }
                else {
                    res.push(item.getColumn());
                }
            });
        };
        recursiveFunc(allItems);
        return res;
    }
    setAllVisible(columns, visible, eventType) {
        const colStateItems = [];
        columns.forEach(col => {
            if (col.getColDef().lockVisible) {
                return;
            }
            if (col.isVisible() != visible) {
                colStateItems.push({
                    colId: col.getId(),
                    hide: !visible
                });
            }
        });
        if (colStateItems.length > 0) {
            this.columnModel.applyColumnState({ state: colStateItems }, eventType);
        }
    }
    setAllPivot(columns, value, eventType) {
        if (this.gridOptionsService.get('functionsPassive')) {
            this.setAllPivotPassive(columns, value);
        }
        else {
            this.setAllPivotActive(columns, value, eventType);
        }
    }
    setAllPivotPassive(columns, value) {
        const copyOfPivotColumns = this.columnModel.getPivotColumns().slice();
        const copyOfValueColumns = this.columnModel.getValueColumns().slice();
        const copyOfRowGroupColumns = this.columnModel.getRowGroupColumns().slice();
        let pivotChanged = false;
        let valueChanged = false;
        let rowGroupChanged = false;
        const turnOnAction = (col) => {
            // don't change any column that's already got a function active
            if (col.isAnyFunctionActive()) {
                return;
            }
            if (col.isAllowValue()) {
                copyOfValueColumns.push(col);
                valueChanged = true;
            }
            else if (col.isAllowRowGroup()) {
                copyOfRowGroupColumns.push(col);
                pivotChanged = true;
            }
            else if (col.isAllowPivot()) {
                copyOfPivotColumns.push(col);
                rowGroupChanged = true;
            }
        };
        const turnOffAction = (col) => {
            if (!col.isAnyFunctionActive()) {
                return;
            }
            if (copyOfPivotColumns.indexOf(col) >= 0) {
                _.removeFromArray(copyOfPivotColumns, col);
                pivotChanged = true;
            }
            if (copyOfValueColumns.indexOf(col) >= 0) {
                _.removeFromArray(copyOfValueColumns, col);
                valueChanged = true;
            }
            if (copyOfRowGroupColumns.indexOf(col) >= 0) {
                _.removeFromArray(copyOfRowGroupColumns, col);
                rowGroupChanged = true;
            }
        };
        const action = value ? turnOnAction : turnOffAction;
        columns.forEach(action);
        if (pivotChanged) {
            const event = {
                type: Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST,
                columns: copyOfPivotColumns
            };
            this.eventService.dispatchEvent(event);
        }
        if (rowGroupChanged) {
            const event = {
                type: Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST,
                columns: copyOfRowGroupColumns
            };
            this.eventService.dispatchEvent(event);
        }
        if (valueChanged) {
            const event = {
                type: Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST,
                columns: copyOfRowGroupColumns
            };
            this.eventService.dispatchEvent(event);
        }
    }
    setAllPivotActive(columns, value, eventType) {
        const colStateItems = [];
        const turnOnAction = (col) => {
            // don't change any column that's already got a function active
            if (col.isAnyFunctionActive()) {
                return;
            }
            if (col.isAllowValue()) {
                const aggFunc = typeof col.getAggFunc() === 'string'
                    ? col.getAggFunc()
                    : this.aggFuncService.getDefaultAggFunc(col);
                colStateItems.push({
                    colId: col.getId(),
                    aggFunc: aggFunc
                });
            }
            else if (col.isAllowRowGroup()) {
                colStateItems.push({
                    colId: col.getId(),
                    rowGroup: true
                });
            }
            else if (col.isAllowPivot()) {
                colStateItems.push({
                    colId: col.getId(),
                    pivot: true
                });
            }
        };
        const turnOffAction = (col) => {
            const isActive = col.isPivotActive() || col.isRowGroupActive() || col.isValueActive();
            if (isActive) {
                colStateItems.push({
                    colId: col.getId(),
                    pivot: false,
                    rowGroup: false,
                    aggFunc: null
                });
            }
        };
        const action = value ? turnOnAction : turnOffAction;
        columns.forEach(action);
        if (colStateItems.length > 0) {
            this.columnModel.applyColumnState({ state: colStateItems }, eventType);
        }
    }
    updateColumns(params) {
        const { columns, visibleState, pivotState, eventType } = params;
        const state = columns.map(column => {
            const colId = column.getColId();
            if (this.columnModel.isPivotMode()) {
                const pivotStateForColumn = pivotState === null || pivotState === void 0 ? void 0 : pivotState[colId];
                return {
                    colId,
                    pivot: pivotStateForColumn === null || pivotStateForColumn === void 0 ? void 0 : pivotStateForColumn.pivot,
                    rowGroup: pivotStateForColumn === null || pivotStateForColumn === void 0 ? void 0 : pivotStateForColumn.rowGroup,
                    aggFunc: pivotStateForColumn === null || pivotStateForColumn === void 0 ? void 0 : pivotStateForColumn.aggFunc,
                };
            }
            else {
                return {
                    colId,
                    hide: !(visibleState === null || visibleState === void 0 ? void 0 : visibleState[colId])
                };
            }
        });
        this.columnModel.applyColumnState({ state }, eventType);
    }
    createPivotState(column) {
        return {
            pivot: column.isPivotActive(),
            rowGroup: column.isRowGroupActive(),
            aggFunc: column.isValueActive() ? column.getAggFunc() : undefined
        };
    }
};
__decorate$1s([
    Autowired('aggFuncService')
], ModelItemUtils.prototype, "aggFuncService", void 0);
__decorate$1s([
    Autowired('columnModel')
], ModelItemUtils.prototype, "columnModel", void 0);
__decorate$1s([
    Autowired('gridOptionsService')
], ModelItemUtils.prototype, "gridOptionsService", void 0);
__decorate$1s([
    Autowired('eventService')
], ModelItemUtils.prototype, "eventService", void 0);
ModelItemUtils = __decorate$1s([
    Bean('modelItemUtils')
], ModelItemUtils);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$9 = '31.1.1';

const ColumnsToolPanelModule = {
    version: VERSION$9,
    moduleName: ModuleNames.ColumnsToolPanelModule,
    beans: [ModelItemUtils],
    agStackComponents: [
        { componentName: 'AgPrimaryColsHeader', componentClass: PrimaryColsHeaderPanel },
        { componentName: 'AgPrimaryColsList', componentClass: PrimaryColsListPanel },
        { componentName: 'AgPrimaryCols', componentClass: PrimaryColsPanel }
    ],
    userComponents: [
        { componentName: 'agColumnsToolPanel', componentClass: ColumnToolPanel },
    ],
    dependantModules: [
        EnterpriseCoreModule,
        RowGroupingModule,
        SideBarModule
    ]
};

const coreFactory = {
    getTemplate(author) {
        const dt = new Date();
        const jsonDate = dt.toJSON();
        return {
            name: 'cp:coreProperties',
            properties: {
                prefixedAttributes: [{
                        prefix: "xmlns:",
                        map: {
                            cp: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
                            dc: 'http://purl.org/dc/elements/1.1/',
                            dcterms: 'http://purl.org/dc/terms/',
                            dcmitype: 'http://purl.org/dc/dcmitype/',
                            xsi: 'http://www.w3.org/2001/XMLSchema-instance'
                        }
                    }]
            },
            children: [{
                    name: 'dc:creator',
                    textNode: author
                }, {
                    name: 'dc:title',
                    textNode: 'Workbook'
                }, {
                    name: 'dcterms:created',
                    properties: {
                        rawMap: {
                            'xsi:type': 'dcterms:W3CDTF'
                        }
                    },
                    textNode: jsonDate
                }, {
                    name: 'dcterms:modified',
                    properties: {
                        rawMap: {
                            'xsi:type': 'dcterms:W3CDTF'
                        }
                    },
                    textNode: jsonDate
                }]
        };
    }
};

const contentTypeFactory = {
    getTemplate(config) {
        const { name, ContentType, Extension, PartName } = config;
        return {
            name,
            properties: {
                rawMap: {
                    Extension,
                    PartName,
                    ContentType
                }
            }
        };
    }
};

const contentTypesFactory = {
    getTemplate(sheetLen) {
        const worksheets = new Array(sheetLen).fill(undefined).map((v, i) => ({
            name: 'Override',
            ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',
            PartName: `/xl/worksheets/sheet${i + 1}.xml`
        }));
        const sheetsWithImages = ExcelXlsxFactory.worksheetImages.size;
        const imageTypesObject = {};
        ExcelXlsxFactory.workbookImageIds.forEach((v) => {
            imageTypesObject[v.type] = true;
        });
        const imageDocs = new Array(sheetsWithImages).fill(undefined).map((v, i) => ({
            name: 'Override',
            ContentType: 'application/vnd.openxmlformats-officedocument.drawing+xml',
            PartName: `/xl/drawings/drawing${i + 1}.xml`
        }));
        const imageTypes = Object.keys(imageTypesObject).map(ext => ({
            name: 'Default',
            ContentType: `image/${ext}`,
            Extension: ext
        }));
        const children = [
            ...imageTypes,
            {
                name: 'Default',
                Extension: 'rels',
                ContentType: 'application/vnd.openxmlformats-package.relationships+xml'
            }, {
                name: 'Default',
                ContentType: 'application/xml',
                Extension: 'xml'
            }, {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',
                PartName: "/xl/workbook.xml"
            },
            ...worksheets,
            {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-officedocument.theme+xml',
                PartName: '/xl/theme/theme1.xml'
            }, {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',
                PartName: '/xl/styles.xml'
            }, {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',
                PartName: '/xl/sharedStrings.xml'
            },
            ...imageDocs,
            {
                name: 'Override',
                ContentType: 'application/vnd.openxmlformats-package.core-properties+xml',
                PartName: '/docProps/core.xml'
            }
        ].map(contentType => contentTypeFactory.getTemplate(contentType));
        return {
            name: "Types",
            properties: {
                rawMap: {
                    xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
                }
            },
            children
        };
    }
};

const INCH_TO_EMU = 9525;
const numberFormatMap = {
    '0': 1,
    '0.00': 2,
    '#,##0': 3,
    '#,##0.00': 4,
    '0%': 9,
    '0.00%': 10,
    '0.00E+00': 11,
    '# ?/?': 12,
    '# ??/??': 13,
    'mm-dd-yy': 14,
    'd-mmm-yy': 15,
    'd-mmm': 16,
    'mmm-yy': 17,
    'h:mm AM/PM': 18,
    'h:mm:ss AM/PM': 19,
    'h:mm': 20,
    'h:mm:ss': 21,
    'm/d/yy h:mm': 22,
    '#,##0 ;(#,##0)': 37,
    '#,##0 ;[Red](#,##0)': 38,
    '#,##0.00;(#,##0.00)': 39,
    '#,##0.00;[Red](#,##0.00)': 40,
    'mm:ss': 45,
    '[h]:mm:ss': 46,
    'mmss.0': 47,
    '##0.0E+0': 48,
    '@': 49
};

const pixelsToPoint = (pixels) => {
    return Math.round(pixels * 72 / 96);
};
const pointsToPixel = (points) => {
    return Math.round(points * 96 / 72);
};
const pixelsToEMU = (value) => {
    return Math.ceil(value * INCH_TO_EMU);
};
const getFontFamilyId = (name) => {
    if (name === undefined) {
        return;
    }
    const families = ['Automatic', 'Roman', 'Swiss', 'Modern', 'Script', 'Decorative'];
    const pos = families.indexOf(name || 'Automatic');
    return Math.max(pos, 0);
};
const getHeightFromProperty = (rowIndex, height) => {
    if (!height) {
        return;
    }
    let finalHeight;
    if (typeof height === 'number') {
        finalHeight = height;
    }
    else {
        const heightFunc = height;
        finalHeight = heightFunc({ rowIndex });
    }
    return pixelsToPoint(finalHeight);
};
const setExcelImageTotalWidth = (image, columnsToExport) => {
    const { colSpan, column } = image.position;
    if (image.width) {
        if (colSpan) {
            const columnsInSpan = columnsToExport.slice(column - 1, column + colSpan - 1);
            let totalWidth = 0;
            for (let i = 0; i < columnsInSpan.length; i++) {
                const colWidth = columnsInSpan[i].getActualWidth();
                if (image.width < totalWidth + colWidth) {
                    image.position.colSpan = i + 1;
                    image.totalWidth = image.width;
                    image.width = image.totalWidth - totalWidth;
                    break;
                }
                totalWidth += colWidth;
            }
        }
        else {
            image.totalWidth = image.width;
        }
    }
};
const setExcelImageTotalHeight = (image, rowHeight) => {
    const { rowSpan, row } = image.position;
    if (image.height) {
        if (rowSpan) {
            let totalHeight = 0;
            let counter = 0;
            for (let i = row; i < row + rowSpan; i++) {
                const nextRowHeight = pointsToPixel(getHeightFromProperty(i, rowHeight) || 20);
                if (image.height < totalHeight + nextRowHeight) {
                    image.position.rowSpan = counter + 1;
                    image.totalHeight = image.height;
                    image.height = image.totalHeight - totalHeight;
                    break;
                }
                totalHeight += nextRowHeight;
                counter++;
            }
        }
        else {
            image.totalHeight = image.height;
        }
    }
};
const createXmlPart = (body) => {
    const header = XmlFactory.createHeader({
        encoding: 'UTF-8',
        standalone: 'yes'
    });
    const xmlBody = XmlFactory.createXml(body);
    return `${header}${xmlBody}`;
};
const getExcelColumnName = (colIdx) => {
    const startCode = 65;
    const tableWidth = 26;
    const fromCharCode = String.fromCharCode;
    const pos = Math.floor(colIdx / tableWidth);
    const tableIdx = colIdx % tableWidth;
    if (!pos || colIdx === tableWidth) {
        return fromCharCode(startCode + colIdx - 1);
    }
    if (!tableIdx) {
        return getExcelColumnName(pos - 1) + 'Z';
    }
    if (pos < tableWidth) {
        return fromCharCode(startCode + pos - 1) + fromCharCode(startCode + tableIdx - 1);
    }
    return getExcelColumnName(pos) + fromCharCode(startCode + tableIdx - 1);
};

const getAnchor = (name, imageAnchor) => ({
    name: `xdr:${name}`,
    children: [{
            name: 'xdr:col',
            textNode: (imageAnchor.col).toString()
        }, {
            name: 'xdr:colOff',
            textNode: imageAnchor.offsetX.toString()
        }, {
            name: 'xdr:row',
            textNode: imageAnchor.row.toString()
        }, {
            name: 'xdr:rowOff',
            textNode: imageAnchor.offsetY.toString()
        }]
});
const getExt = (image) => {
    const children = [{
            name: 'a:ext',
            properties: {
                rawMap: {
                    uri: '{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}'
                }
            },
            children: [{
                    name: 'a16:creationId',
                    properties: {
                        rawMap: {
                            'id': '{822E6D20-D7BC-2841-A643-D49A6EF008A2}',
                            'xmlns:a16': 'http://schemas.microsoft.com/office/drawing/2014/main'
                        }
                    }
                }]
        }];
    const recolor = image.recolor && image.recolor.toLowerCase();
    switch (recolor) {
        case 'grayscale':
        case 'sepia':
        case 'washout':
            children.push({
                name: 'a:ext',
                properties: {
                    rawMap: {
                        uri: '{C183D7F6-B498-43B3-948B-1728B52AA6E4}'
                    }
                },
                children: [{
                        name: 'adec:decorative',
                        properties: {
                            rawMap: {
                                'val': '0',
                                'xmlns:adec': 'http://schemas.microsoft.com/office/drawing/2017/decorative'
                            }
                        }
                    }]
            });
    }
    return {
        name: 'a:extLst',
        children
    };
};
const getNvPicPr = (image, index) => ({
    name: 'xdr:nvPicPr',
    children: [{
            name: 'xdr:cNvPr',
            properties: {
                rawMap: {
                    id: index,
                    name: image.id,
                    descr: image.altText != null ? image.altText : undefined
                }
            },
            children: [getExt(image)]
        }, {
            name: 'xdr:cNvPicPr',
            properties: {
                rawMap: {
                    preferRelativeResize: '0'
                }
            },
            children: [{
                    name: 'a:picLocks'
                }]
        }]
});
const getColorDetails = (color) => {
    if (!color.saturation && !color.tint) {
        return;
    }
    const ret = [];
    if (color.saturation) {
        ret.push({
            name: 'a:satMod',
            properties: {
                rawMap: {
                    val: color.saturation * 1000
                }
            }
        });
    }
    if (color.tint) {
        ret.push({
            name: 'a:tint',
            properties: {
                rawMap: {
                    val: color.tint * 1000
                }
            }
        });
    }
    return ret;
};
const getDuoTone = (primaryColor, secondaryColor) => {
    return ({
        name: 'a:duotone',
        children: [{
                name: 'a:prstClr',
                properties: {
                    rawMap: {
                        val: primaryColor.color
                    }
                },
                children: getColorDetails(primaryColor)
            }, {
                name: 'a:srgbClr',
                properties: {
                    rawMap: {
                        val: secondaryColor.color
                    }
                },
                children: getColorDetails(secondaryColor)
            }]
    });
};
const getBlipFill = (image, index) => {
    let blipChildren;
    if (image.transparency) {
        const transparency = Math.min(Math.max(image.transparency, 0), 100);
        blipChildren = [{
                name: 'a:alphaModFix',
                properties: {
                    rawMap: {
                        amt: 100000 - Math.round(transparency * 1000),
                    }
                }
            }];
    }
    if (image.recolor) {
        if (!blipChildren) {
            blipChildren = [];
        }
        switch (image.recolor.toLocaleLowerCase()) {
            case 'grayscale':
                blipChildren.push({ name: 'a:grayscl' });
                break;
            case 'sepia':
                blipChildren.push(getDuoTone({ color: 'black' }, { color: 'D9C3A5', tint: 50, saturation: 180 }));
                break;
            case 'washout':
                blipChildren.push({
                    name: 'a:lum',
                    properties: {
                        rawMap: {
                            bright: '70000',
                            contrast: '-70000'
                        }
                    }
                });
                break;
        }
    }
    return ({
        name: 'xdr:blipFill',
        children: [{
                name: 'a:blip',
                properties: {
                    rawMap: {
                        'cstate': 'print',
                        'r:embed': `rId${index}`,
                        'xmlns:r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
                    }
                },
                children: blipChildren
            }, {
                name: 'a:stretch',
                children: [{
                        name: 'a:fillRect'
                    }]
            }]
    });
};
const getSpPr = (image, imageBoxSize) => {
    const xfrm = {
        name: 'a:xfrm',
        children: [{
                name: 'a:off',
                properties: {
                    rawMap: {
                        x: 0,
                        y: 0
                    }
                }
            }, {
                name: 'a:ext',
                properties: {
                    rawMap: {
                        cx: imageBoxSize.width,
                        cy: imageBoxSize.height
                    }
                }
            }]
    };
    if (image.rotation) {
        const rotation = image.rotation;
        xfrm.properties = {
            rawMap: {
                rot: Math.min(Math.max(rotation, 0), 360) * 60000
            }
        };
    }
    const prstGeom = {
        name: 'a:prstGeom',
        properties: {
            rawMap: {
                prst: 'rect'
            }
        },
        children: [{ name: 'a:avLst' }]
    };
    const ret = {
        name: 'xdr:spPr',
        children: [xfrm, prstGeom]
    };
    return ret;
};
const getImageBoxSize = (image) => {
    image.fitCell = !!image.fitCell || (!image.width || !image.height);
    const { position = {}, fitCell, width = 0, height = 0, totalHeight, totalWidth } = image;
    const { offsetX = 0, offsetY = 0, row = 1, rowSpan = 1, column = 1, colSpan = 1 } = position;
    return {
        from: {
            row: row - 1,
            col: column - 1,
            offsetX: pixelsToEMU(offsetX),
            offsetY: pixelsToEMU(offsetY)
        },
        to: {
            row: (row - 1) + (fitCell ? 1 : rowSpan - 1),
            col: (column - 1) + (fitCell ? 1 : colSpan - 1),
            offsetX: pixelsToEMU(width + offsetX),
            offsetY: pixelsToEMU(height + offsetY)
        },
        height: pixelsToEMU(totalHeight || height),
        width: pixelsToEMU(totalWidth || width)
    };
};
const getPicture = (image, currentIndex, worksheetImageIndex, imageBoxSize) => {
    return {
        name: 'xdr:pic',
        children: [
            getNvPicPr(image, currentIndex + 1),
            getBlipFill(image, worksheetImageIndex + 1),
            getSpPr(image, imageBoxSize)
        ]
    };
};
const drawingFactory = {
    getTemplate(config) {
        const { sheetIndex } = config;
        const sheetImages = ExcelXlsxFactory.worksheetImages.get(sheetIndex);
        const sheetImageIds = ExcelXlsxFactory.worksheetImageIds.get(sheetIndex);
        const children = sheetImages.map((image, idx) => {
            const boxSize = getImageBoxSize(image);
            return ({
                name: 'xdr:twoCellAnchor',
                properties: {
                    rawMap: {
                        editAs: 'absolute'
                    }
                },
                children: [
                    getAnchor('from', boxSize.from),
                    getAnchor('to', boxSize.to),
                    getPicture(image, idx, sheetImageIds.get(image.id).index, boxSize),
                    { name: 'xdr:clientData' }
                ]
            });
        });
        return {
            name: 'xdr:wsDr',
            properties: {
                rawMap: {
                    'xmlns:a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
                    'xmlns:xdr': 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing'
                }
            },
            children
        };
    }
};

const getColorChildren = (props) => {
    const [type, innerType, val, lastClr] = props;
    return {
        name: `a:${type}`,
        children: [{
                name: `a:${innerType}`,
                properties: {
                    rawMap: {
                        val,
                        lastClr
                    }
                }
            }]
    };
};
const colorScheme = {
    getTemplate() {
        return {
            name: "a:clrScheme",
            properties: {
                rawMap: {
                    name: "Office"
                }
            },
            children: [
                getColorChildren(['dk1', 'sysClr', 'windowText', '000000']),
                getColorChildren(['lt1', 'sysClr', 'window', 'FFFFFF']),
                getColorChildren(['dk2', 'srgbClr', '44546A']),
                getColorChildren(['lt2', 'srgbClr', 'E7E6E6']),
                getColorChildren(['accent1', 'srgbClr', '4472C4']),
                getColorChildren(['accent2', 'srgbClr', 'ED7D31']),
                getColorChildren(['accent3', 'srgbClr', 'A5A5A5']),
                getColorChildren(['accent4', 'srgbClr', 'FFC000']),
                getColorChildren(['accent5', 'srgbClr', '5B9BD5']),
                getColorChildren(['accent6', 'srgbClr', '70AD47']),
                getColorChildren(['hlink', 'srgbClr', '0563C1']),
                getColorChildren(['folHlink', 'srgbClr', '954F72'])
            ]
        };
    }
};

const getFont$1 = (props) => {
    const [type, typeface, script, panose] = props;
    return {
        name: `a:${type}`,
        properties: {
            rawMap: {
                script,
                typeface,
                panose
            }
        }
    };
};
const fontScheme = {
    getTemplate() {
        return {
            name: "a:fontScheme",
            properties: {
                rawMap: {
                    name: "Office"
                }
            },
            children: [{
                    name: 'a:majorFont',
                    children: [
                        getFont$1(['latin', 'Calibri Light', undefined, '020F0302020204030204']),
                        getFont$1(['ea', '']),
                        getFont$1(['cs', '']),
                        getFont$1(['font', '游ゴシック Light', 'Jpan']),
                        getFont$1(['font', '맑은 고딕', 'Hang']),
                        getFont$1(['font', '等线 Light', 'Hans']),
                        getFont$1(['font', '新細明體', 'Hant']),
                        getFont$1(['font', 'Times New Roman', 'Arab']),
                        getFont$1(['font', 'Times New Roman', 'Hebr']),
                        getFont$1(['font', 'Tahoma', 'Thai']),
                        getFont$1(['font', 'Nyala', 'Ethi']),
                        getFont$1(['font', 'Vrinda', 'Beng']),
                        getFont$1(['font', 'Shruti', 'Gujr']),
                        getFont$1(['font', 'MoolBoran', 'Khmr']),
                        getFont$1(['font', 'Tunga', 'Knda']),
                        getFont$1(['font', 'Raavi', 'Guru']),
                        getFont$1(['font', 'Euphemia', 'Cans']),
                        getFont$1(['font', 'Plantagenet Cherokee', 'Cher']),
                        getFont$1(['font', 'Microsoft Yi Baiti', 'Yiii']),
                        getFont$1(['font', 'Microsoft Himalaya', 'Tibt']),
                        getFont$1(['font', 'MV Boli', 'Thaa']),
                        getFont$1(['font', 'Mangal', 'Deva']),
                        getFont$1(['font', 'Gautami', 'Telu']),
                        getFont$1(['font', 'Latha', 'Taml']),
                        getFont$1(['font', 'Estrangelo Edessa', 'Syrc']),
                        getFont$1(['font', 'Kalinga', 'Orya']),
                        getFont$1(['font', 'Kartika', 'Mlym']),
                        getFont$1(['font', 'DokChampa', 'Laoo']),
                        getFont$1(['font', 'Iskoola Pota', 'Sinh']),
                        getFont$1(['font', 'Mongolian Baiti', 'Mong']),
                        getFont$1(['font', 'Times New Roman', 'Viet']),
                        getFont$1(['font', 'Microsoft Uighur', 'Uigh']),
                        getFont$1(['font', 'Sylfaen', 'Geor']),
                        getFont$1(['font', 'Arial', 'Armn']),
                        getFont$1(['font', 'Leelawadee UI', 'Bugi']),
                        getFont$1(['font', 'Microsoft JhengHei', 'Bopo']),
                        getFont$1(['font', 'Javanese Text', 'Java']),
                        getFont$1(['font', 'Segoe UI', 'Lisu']),
                        getFont$1(['font', 'Myanmar Text', 'Mymr']),
                        getFont$1(['font', 'Ebrima', 'Nkoo']),
                        getFont$1(['font', 'Nirmala UI', 'Olck']),
                        getFont$1(['font', 'Ebrima', 'Osma']),
                        getFont$1(['font', 'Phagspa', 'Phag']),
                        getFont$1(['font', 'Estrangelo Edessa', 'Syrn']),
                        getFont$1(['font', 'Estrangelo Edessa', 'Syrj']),
                        getFont$1(['font', 'Estrangelo Edessa', 'Syre']),
                        getFont$1(['font', 'Nirmala UI', 'Sora']),
                        getFont$1(['font', 'Microsoft Tai Le', 'Tale']),
                        getFont$1(['font', 'Microsoft New Tai Lue', 'Talu']),
                        getFont$1(['font', 'Ebrima', 'Tfng'])
                    ]
                }, {
                    name: 'a:minorFont',
                    children: [
                        getFont$1(['latin', 'Calibri', undefined, '020F0502020204030204']),
                        getFont$1(['ea', '']),
                        getFont$1(['cs', '']),
                        getFont$1(['font', '游ゴシック', 'Jpan']),
                        getFont$1(['font', '맑은 고딕', 'Hang']),
                        getFont$1(['font', '等线', 'Hans']),
                        getFont$1(['font', '新細明體', 'Hant']),
                        getFont$1(['font', 'Arial', 'Arab']),
                        getFont$1(['font', 'Arial', 'Hebr']),
                        getFont$1(['font', 'Tahoma', 'Thai']),
                        getFont$1(['font', 'Nyala', 'Ethi']),
                        getFont$1(['font', 'Vrinda', 'Beng']),
                        getFont$1(['font', 'Shruti', 'Gujr']),
                        getFont$1(['font', 'DaunPenh', 'Khmr']),
                        getFont$1(['font', 'Tunga', 'Knda']),
                        getFont$1(['font', 'Raavi', 'Guru']),
                        getFont$1(['font', 'Euphemia', 'Cans']),
                        getFont$1(['font', 'Plantagenet Cherokee', 'Cher']),
                        getFont$1(['font', 'Microsoft Yi Baiti', 'Yiii']),
                        getFont$1(['font', 'Microsoft Himalaya', 'Tibt']),
                        getFont$1(['font', 'MV Boli', 'Thaa']),
                        getFont$1(['font', 'Mangal', 'Deva']),
                        getFont$1(['font', 'Gautami', 'Telu']),
                        getFont$1(['font', 'Latha', 'Taml']),
                        getFont$1(['font', 'Estrangelo Edessa', 'Syrc']),
                        getFont$1(['font', 'Kalinga', 'Orya']),
                        getFont$1(['font', 'Kartika', 'Mlym']),
                        getFont$1(['font', 'DokChampa', 'Laoo']),
                        getFont$1(['font', 'Iskoola Pota', 'Sinh']),
                        getFont$1(['font', 'Mongolian Baiti', 'Mong']),
                        getFont$1(['font', 'Arial', 'Viet']),
                        getFont$1(['font', 'Microsoft Uighur', 'Uigh']),
                        getFont$1(['font', 'Sylfaen', 'Geor']),
                        getFont$1(['font', 'Arial', 'Armn']),
                        getFont$1(['font', 'Leelawadee UI', 'Bugi']),
                        getFont$1(['font', 'Microsoft JhengHei', 'Bopo']),
                        getFont$1(['font', 'Javanese Text', 'Java']),
                        getFont$1(['font', 'Segoe UI', 'Lisu']),
                        getFont$1(['font', 'Myanmar Text', 'Mymr']),
                        getFont$1(['font', 'Ebrima', 'Nkoo']),
                        getFont$1(['font', 'Nirmala UI', 'Olck']),
                        getFont$1(['font', 'Ebrima', 'Osma']),
                        getFont$1(['font', 'Phagspa', 'Phag']),
                        getFont$1(['font', 'Estrangelo Edessa', 'Syrn']),
                        getFont$1(['font', 'Estrangelo Edessa', 'Syrj']),
                        getFont$1(['font', 'Estrangelo Edessa', 'Syre']),
                        getFont$1(['font', 'Nirmala UI', 'Sora']),
                        getFont$1(['font', 'Microsoft Tai Le', 'Tale']),
                        getFont$1(['font', 'Microsoft New Tai Lue', 'Talu']),
                        getFont$1(['font', 'Ebrima', 'Tfng'])
                    ]
                }]
        };
    }
};

const getPropertyVal = (name, val, children) => ({
    name: `a:${name}`,
    properties: {
        rawMap: {
            val
        }
    },
    children
});
const getGs = (props) => {
    const [pos, schemeColor, satMod, lumMod, tint, shade] = props;
    const children = [];
    children.push(getPropertyVal('satMod', satMod));
    if (lumMod) {
        children.push(getPropertyVal('lumMod', lumMod));
    }
    if (tint) {
        children.push(getPropertyVal('tint', tint));
    }
    if (shade) {
        children.push(getPropertyVal('shade', shade));
    }
    return {
        name: 'a:gs',
        properties: {
            rawMap: {
                pos
            }
        },
        children: [{
                name: 'a:schemeClr',
                properties: {
                    rawMap: {
                        val: schemeColor
                    }
                },
                children
            }]
    };
};
const getSolidFill = (val, children) => ({
    name: 'a:solidFill',
    children: [getPropertyVal('schemeClr', val, children)]
});
const getGradFill = (props) => {
    const [rotWithShape, gs1, gs2, gs3, lin] = props;
    const [ang, scaled] = lin;
    return {
        name: 'a:gradFill',
        properties: {
            rawMap: {
                rotWithShape
            }
        },
        children: [{
                name: 'a:gsLst',
                children: [
                    getGs(gs1),
                    getGs(gs2),
                    getGs(gs3)
                ]
            }, {
                name: 'a:lin',
                properties: {
                    rawMap: {
                        ang: ang,
                        scaled: scaled
                    }
                }
            }]
    };
};
const getLine = (props) => {
    const [w, cap, cmpd, algn] = props;
    return {
        name: 'a:ln',
        properties: {
            rawMap: { w, cap, cmpd, algn }
        },
        children: [
            getSolidFill('phClr'),
            getPropertyVal('prstDash', 'solid'),
            {
                name: 'a:miter',
                properties: {
                    rawMap: {
                        lim: '800000'
                    }
                }
            }
        ]
    };
};
const getEffectStyle = (shadow) => {
    const children = [];
    if (shadow) {
        const [blurRad, dist, dir, algn, rotWithShape] = shadow;
        children.push({
            name: 'a:outerShdw',
            properties: {
                rawMap: { blurRad, dist, dir, algn, rotWithShape }
            },
            children: [
                getPropertyVal('srgbClr', '000000', [getPropertyVal('alpha', '63000')])
            ]
        });
    }
    return {
        name: 'a:effectStyle',
        children: [Object.assign({}, {
                name: 'a:effectLst'
            }, children.length ? { children } : {})]
    };
};
const getFillStyleList = () => ({
    name: 'a:fillStyleLst',
    children: [
        getSolidFill('phClr'),
        getGradFill([
            '1',
            ['0', 'phClr', '105000', '110000', '67000'],
            ['50000', 'phClr', '103000', '105000', '73000'],
            ['100000', 'phClr', '109000', '105000', '81000'],
            ['5400000', '0']
        ]),
        getGradFill([
            '1',
            ['0', 'phClr', '103000', '102000', '94000'],
            ['50000', 'phClr', '110000', '100000', undefined, '100000'],
            ['100000', 'phClr', '120000', '99000', undefined, '78000'],
            ['5400000', '0']
        ])
    ]
});
const getLineStyleList = () => ({
    name: 'a:lnStyleLst',
    children: [
        getLine(['6350', 'flat', 'sng', 'ctr']),
        getLine(['12700', 'flat', 'sng', 'ctr']),
        getLine(['19050', 'flat', 'sng', 'ctr'])
    ]
});
const getEffectStyleList = () => ({
    name: 'a:effectStyleLst',
    children: [
        getEffectStyle(),
        getEffectStyle(),
        getEffectStyle(['57150', '19050', '5400000', 'ctr', '0'])
    ]
});
const getBgFillStyleList = () => ({
    name: 'a:bgFillStyleLst',
    children: [
        getSolidFill('phClr'),
        getSolidFill('phClr', [
            getPropertyVal('tint', '95000'),
            getPropertyVal('satMod', '170000'),
        ]),
        getGradFill([
            '1',
            ['0', 'phClr', '150000', '102000', '93000', '98000'],
            ['50000', 'phClr', '130000', '103000', '98000', '90000'],
            ['100000', 'phClr', '120000', undefined, undefined, '63000'],
            ['5400000', '0']
        ])
    ]
});
const formatScheme = {
    getTemplate() {
        return {
            name: "a:fmtScheme",
            properties: {
                rawMap: {
                    name: "Office"
                }
            },
            children: [
                getFillStyleList(),
                getLineStyleList(),
                getEffectStyleList(),
                getBgFillStyleList()
            ]
        };
    }
};

const themeElements = {
    getTemplate() {
        return {
            name: "a:themeElements",
            children: [
                colorScheme.getTemplate(),
                fontScheme.getTemplate(),
                formatScheme.getTemplate()
            ]
        };
    }
};

const officeTheme = {
    getTemplate() {
        return {
            name: "a:theme",
            properties: {
                prefixedAttributes: [{
                        prefix: "xmlns:",
                        map: {
                            a: "http://schemas.openxmlformats.org/drawingml/2006/main"
                        },
                    }],
                rawMap: {
                    name: "Office Theme"
                }
            },
            children: [
                themeElements.getTemplate(),
                {
                    name: 'a:objectDefaults'
                },
                {
                    name: 'a:extraClrSchemeLst'
                }
            ]
        };
    }
};

const buildSharedString = (strMap) => {
    const ret = [];
    for (const key of strMap.keys()) {
        const textNode = key.toString();
        const child = {
            name: 't',
            textNode: _.escapeString(textNode)
        };
        // if we have leading or trailing spaces, instruct Excel not to trim them
        const preserveSpaces = textNode.trim().length !== textNode.length;
        if (preserveSpaces) {
            child.properties = {
                rawMap: {
                    "xml:space": "preserve"
                }
            };
        }
        ret.push({
            name: 'si',
            children: [child]
        });
    }
    return ret;
};
const sharedStrings = {
    getTemplate(strings) {
        return {
            name: "sst",
            properties: {
                rawMap: {
                    xmlns: 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                    count: strings.size,
                    uniqueCount: strings.size
                }
            },
            children: buildSharedString(strings)
        };
    }
};

function prepareString(str) {
    const split = str.split(/(\[[^\]]*\])/);
    for (let i = 0; i < split.length; i++) {
        // excel formulas require symbols to be escaped. Excel also requires $ to be 
        // placed in quotes but only when the $ is not wrapped inside of square brackets.
        let currentString = split[i];
        if (!currentString.length) {
            continue;
        }
        if (!currentString.startsWith('[')) {
            currentString = currentString.replace(/\$/g, '"$"');
        }
        split[i] = _.escapeString(currentString);
    }
    return split.join('');
}
const numberFormatFactory = {
    getTemplate(numberFormat) {
        let { formatCode, numFmtId } = numberFormat;
        if (formatCode.length) {
            formatCode = prepareString(formatCode);
        }
        return {
            name: "numFmt",
            properties: {
                rawMap: {
                    formatCode,
                    numFmtId
                }
            }
        };
    }
};

const numberFormatsFactory = {
    getTemplate(numberFormats) {
        return {
            name: "numFmts",
            properties: {
                rawMap: {
                    count: numberFormats.length
                }
            },
            children: numberFormats.map(numberFormat => numberFormatFactory.getTemplate(numberFormat))
        };
    }
};

const fontFactory = {
    getTemplate(font) {
        const { size, colorTheme, color = 'FF000000', fontName = 'Calibri', family, scheme, italic, bold, strikeThrough, outline, shadow, underline, verticalAlign } = font;
        const children = [
            { name: 'sz', properties: { rawMap: { val: size } } },
            { name: 'color', properties: { rawMap: { theme: colorTheme, rgb: color } } },
            { name: 'name', properties: { rawMap: { val: fontName } } }
        ];
        if (family) {
            children.push({ name: 'family', properties: { rawMap: { val: family } } });
        }
        if (scheme) {
            children.push({ name: 'scheme', properties: { rawMap: { val: scheme } } });
        }
        if (italic) {
            children.push({ name: 'i' });
        }
        if (bold) {
            children.push({ name: 'b' });
        }
        if (strikeThrough) {
            children.push({ name: 'strike' });
        }
        if (outline) {
            children.push({ name: 'outline' });
        }
        if (shadow) {
            children.push({ name: 'shadow' });
        }
        if (underline) {
            children.push({ name: 'u', properties: { rawMap: { val: underline } } });
        }
        if (verticalAlign) {
            children.push({ name: 'vertAlign', properties: { rawMap: { val: verticalAlign } } });
        }
        return { name: "font", children };
    }
};

const fontsFactory = {
    getTemplate(fonts) {
        return {
            name: "fonts",
            properties: {
                rawMap: {
                    count: fonts.length
                }
            },
            children: fonts.map(font => fontFactory.getTemplate(font))
        };
    }
};

const fillFactory = {
    getTemplate(fill) {
        const { patternType, fgTheme, fgTint, fgRgb, bgRgb, bgIndexed } = fill;
        const pf = {
            name: 'patternFill',
            properties: {
                rawMap: {
                    patternType
                }
            }
        };
        if (fgTheme || fgTint || fgRgb) {
            pf.children = [{
                    name: 'fgColor',
                    properties: {
                        rawMap: {
                            theme: fgTheme,
                            tint: fgTint,
                            rgb: fgRgb
                        }
                    }
                }];
        }
        if (bgIndexed || bgRgb) {
            if (!pf.children) {
                pf.children = [];
            }
            pf.children.push({
                name: 'bgColor',
                properties: {
                    rawMap: {
                        indexed: bgIndexed,
                        rgb: bgRgb
                    }
                }
            });
        }
        return {
            name: "fill",
            children: [pf]
        };
    }
};

const fillsFactory = {
    getTemplate(fills) {
        return {
            name: "fills",
            properties: {
                rawMap: {
                    count: fills.length
                }
            },
            children: fills.map(fill => fillFactory.getTemplate(fill))
        };
    }
};

const getWeightName = (value) => {
    switch (value) {
        case 1: return 'thin';
        case 2: return 'medium';
        case 3: return 'thick';
        default: return 'hair';
    }
};
const mappedBorderNames = {
    None: 'None',
    Dot: 'Dotted',
    Dash: 'Dashed',
    Double: 'Double',
    DashDot: 'DashDot',
    DashDotDot: 'DashDotDot',
    SlantDashDot: 'SlantDashDot'
};
const mediumBorders = ['Dashed', 'DashDot', 'DashDotDot'];
const colorMap = {
    None: 'none',
    Solid: 'solid',
    Gray50: 'mediumGray',
    Gray75: 'darkGray',
    Gray25: 'lightGray',
    HorzStripe: 'darkHorizontal',
    VertStripe: 'darkVertical',
    ReverseDiagStripe: 'darkDown',
    DiagStripe: 'darkUp',
    DiagCross: 'darkGrid',
    ThickDiagCross: 'darkTrellis',
    ThinHorzStripe: 'lightHorizontal',
    ThinVertStripe: 'lightVertical',
    ThinReverseDiagStripe: 'lightDown',
    ThinDiagStripe: 'lightUp',
    ThinHorzCross: 'lightGrid',
    ThinDiagCross: 'lightTrellis',
    Gray125: 'gray125',
    Gray0625: 'gray0625'
};
const horizontalAlignmentMap = {
    Automatic: 'general',
    Left: 'left',
    Center: 'center',
    Right: 'right',
    Fill: 'fill',
    Justify: 'justify',
    CenterAcrossSelection: 'centerContinuous',
    Distributed: 'distributed',
    JustifyDistributed: 'justify'
};
const verticalAlignmentMap = {
    Automatic: undefined,
    Top: 'top',
    Bottom: 'bottom',
    Center: 'center',
    Justify: 'justify',
    Distributed: 'distributed',
    JustifyDistributed: 'justify'
};
const convertLegacyPattern = (name) => {
    if (!name) {
        return 'none';
    }
    return colorMap[name] || name;
};
const convertLegacyColor = (color) => {
    if (color == undefined) {
        return color;
    }
    if (color.charAt(0) === '#') {
        color = color.substring(1);
    }
    return color.length === 6 ? 'FF' + color : color;
};
const convertLegacyBorder = (type, weight) => {
    if (!type) {
        return 'thin';
    }
    // Legacy Types are: None, Continuous, Dash, Dot, DashDot, DashDotDot, SlantDashDot, and Double
    // Weight represents: 0—Hairline, 1—Thin , 2—Medium, 3—Thick
    // New types: none, thin, medium, dashed, dotted, thick, double, hair, mediumDashed, dashDot, mediumDashDot,
    // dashDotDot, mediumDashDotDot, slantDashDot
    const namedWeight = getWeightName(weight);
    const mappedName = mappedBorderNames[type];
    if (type === 'Continuous') {
        return namedWeight;
    }
    if (namedWeight === 'medium' && mediumBorders.indexOf(mappedName) !== -1) {
        return `medium${mappedName}`;
    }
    return mappedName.charAt(0).toLowerCase() + mappedName.substring(1);
};
const convertLegacyHorizontalAlignment = (alignment) => {
    return horizontalAlignmentMap[alignment] || 'general';
};
const convertLegacyVerticalAlignment = (alignment) => {
    return verticalAlignmentMap[alignment] || undefined;
};

const getBorderColor = (color) => {
    return {
        name: 'color',
        properties: {
            rawMap: {
                rgb: convertLegacyColor(color || '#000000')
            }
        }
    };
};
const borderFactory = {
    getTemplate(border) {
        const { left, right, top, bottom, diagonal } = border;
        const leftChildren = left ? [getBorderColor(left.color)] : undefined;
        const rightChildren = right ? [getBorderColor(right.color)] : undefined;
        const topChildren = top ? [getBorderColor(top.color)] : undefined;
        const bottomChildren = bottom ? [getBorderColor(bottom.color)] : undefined;
        const diagonalChildren = diagonal ? [getBorderColor(diagonal.color)] : undefined;
        return {
            name: 'border',
            children: [{
                    name: 'left',
                    properties: { rawMap: { style: left && left.style } },
                    children: leftChildren
                }, {
                    name: 'right',
                    properties: { rawMap: { style: right && right.style } },
                    children: rightChildren
                }, {
                    name: 'top',
                    properties: { rawMap: { style: top && top.style } },
                    children: topChildren
                }, {
                    name: 'bottom',
                    properties: { rawMap: { style: bottom && bottom.style } },
                    children: bottomChildren
                }, {
                    name: 'diagonal',
                    properties: { rawMap: { style: diagonal && diagonal.style } },
                    children: diagonalChildren
                }]
        };
    }
};

const bordersFactory = {
    getTemplate(borders) {
        return {
            name: "borders",
            properties: {
                rawMap: {
                    count: borders.length
                }
            },
            children: borders.map(border => borderFactory.getTemplate(border))
        };
    }
};

const getReadingOrderId = (readingOrder) => {
    const order = ['Context', 'LeftToRight', 'RightToLeft'];
    const pos = order.indexOf(readingOrder);
    return Math.max(pos, 0);
};
const alignmentFactory = {
    getTemplate(alignment) {
        const { horizontal, indent, readingOrder, rotate, shrinkToFit, vertical, wrapText } = alignment;
        return {
            name: 'alignment',
            properties: {
                rawMap: {
                    horizontal: horizontal && convertLegacyHorizontalAlignment(horizontal),
                    indent,
                    readingOrder: readingOrder && getReadingOrderId(readingOrder),
                    textRotation: rotate,
                    shrinkToFit,
                    vertical: vertical && convertLegacyVerticalAlignment(vertical),
                    wrapText
                }
            }
        };
    }
};

const protectionFactory = {
    getTemplate(protection) {
        const locked = protection.protected === false ? 0 : 1;
        const hidden = protection.hideFormula === true ? 1 : 0;
        return {
            name: 'protection',
            properties: {
                rawMap: {
                    hidden,
                    locked
                }
            }
        };
    }
};

const xfFactory = {
    getTemplate(xf) {
        const { alignment, borderId, fillId, fontId, numFmtId, protection, quotePrefix, xfId } = xf;
        const children = [];
        if (alignment) {
            children.push(alignmentFactory.getTemplate(alignment));
        }
        if (protection) {
            children.push(protectionFactory.getTemplate(protection));
        }
        return {
            name: "xf",
            properties: {
                rawMap: {
                    applyAlignment: alignment ? 1 : undefined,
                    applyProtection: protection ? 1 : undefined,
                    applyBorder: borderId ? 1 : undefined,
                    applyFill: fillId ? 1 : undefined,
                    borderId,
                    fillId,
                    applyFont: fontId ? 1 : undefined,
                    fontId,
                    applyNumberFormat: numFmtId ? 1 : undefined,
                    numFmtId,
                    quotePrefix: quotePrefix ? 1 : undefined,
                    xfId
                }
            },
            children: children.length ? children : undefined
        };
    }
};

const cellStylesXfsFactory = {
    getTemplate(xfs) {
        return {
            name: "cellStyleXfs",
            properties: {
                rawMap: {
                    count: xfs.length
                }
            },
            children: xfs.map(xf => xfFactory.getTemplate(xf))
        };
    }
};

const cellXfsFactory = {
    getTemplate(xfs) {
        return {
            name: "cellXfs",
            properties: {
                rawMap: {
                    count: xfs.length
                }
            },
            children: xfs.map(xf => xfFactory.getTemplate(xf))
        };
    }
};

const borderFactory$1 = {
    getTemplate(cellStyle) {
        const { builtinId, name, xfId } = cellStyle;
        return {
            name: "cellStyle",
            properties: {
                rawMap: {
                    builtinId,
                    name,
                    xfId
                }
            }
        };
    }
};

const cellStylesFactory = {
    getTemplate(cellStyles) {
        return {
            name: "cellStyles",
            properties: {
                rawMap: {
                    count: cellStyles.length
                }
            },
            children: cellStyles.map(cellStyle => borderFactory$1.getTemplate(cellStyle))
        };
    }
};

let stylesMap;
let registeredNumberFmts;
let registeredFonts;
let registeredFills;
let registeredBorders;
let registeredCellStyleXfs;
let registeredCellXfs;
let registeredCellStyles;
let currentSheet;
const getStyleName = (name, currentSheet) => {
    if (name.indexOf('mixedStyle') !== -1 && currentSheet > 1) {
        name += `_${currentSheet}`;
    }
    return name;
};
const resetStylesheetValues = () => {
    stylesMap = { base: 0 };
    registeredNumberFmts = [];
    registeredFonts = [{ fontName: 'Calibri', colorTheme: '1', family: '2', scheme: 'minor' }];
    registeredFills = [{ patternType: 'none', }, { patternType: 'gray125' }];
    registeredBorders = [{ left: undefined, right: undefined, top: undefined, bottom: undefined, diagonal: undefined }];
    registeredCellStyleXfs = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0 }];
    registeredCellXfs = [{ borderId: 0, fillId: 0, fontId: 0, numFmtId: 0, xfId: 0 }];
    registeredCellStyles = [{ builtinId: 0, name: 'Normal', xfId: 0 }];
};
const registerFill = (fill) => {
    const convertedPattern = convertLegacyPattern(fill.pattern);
    const convertedFillColor = convertLegacyColor(fill.color);
    const convertedPatternColor = convertLegacyColor(fill.patternColor);
    let pos = registeredFills.findIndex(currentFill => {
        const { patternType, fgRgb, bgRgb } = currentFill;
        if (patternType != convertedPattern ||
            fgRgb != convertedFillColor ||
            bgRgb != convertedPatternColor) {
            return false;
        }
        return true;
    });
    if (pos === -1) {
        pos = registeredFills.length;
        registeredFills.push({ patternType: convertedPattern, fgRgb: convertedFillColor, bgRgb: convertedPatternColor });
    }
    return pos;
};
const registerNumberFmt = (format) => {
    if (numberFormatMap[format]) {
        return numberFormatMap[format];
    }
    let pos = registeredNumberFmts.findIndex(currentFormat => currentFormat.formatCode === format);
    if (pos === -1) {
        pos = registeredNumberFmts.length + 164;
        registeredNumberFmts.push({ formatCode: format, numFmtId: pos });
    }
    else {
        pos = registeredNumberFmts[pos].numFmtId;
    }
    return pos;
};
const registerBorders = (borders) => {
    const { borderBottom, borderTop, borderLeft, borderRight } = borders;
    let bottomStyle;
    let topStyle;
    let leftStyle;
    let rightStyle;
    let bottomColor;
    let topColor;
    let leftColor;
    let rightColor;
    if (borderLeft) {
        leftStyle = convertLegacyBorder(borderLeft.lineStyle, borderLeft.weight);
        leftColor = convertLegacyColor(borderLeft.color);
    }
    if (borderRight) {
        rightStyle = convertLegacyBorder(borderRight.lineStyle, borderRight.weight);
        rightColor = convertLegacyColor(borderRight.color);
    }
    if (borderBottom) {
        bottomStyle = convertLegacyBorder(borderBottom.lineStyle, borderBottom.weight);
        bottomColor = convertLegacyColor(borderBottom.color);
    }
    if (borderTop) {
        topStyle = convertLegacyBorder(borderTop.lineStyle, borderTop.weight);
        topColor = convertLegacyColor(borderTop.color);
    }
    let pos = registeredBorders.findIndex(currentBorder => {
        const { left, right, top, bottom } = currentBorder;
        if (!left && (leftStyle || leftColor)) {
            return false;
        }
        if (!right && (rightStyle || rightColor)) {
            return false;
        }
        if (!top && (topStyle || topColor)) {
            return false;
        }
        if (!bottom && (bottomStyle || bottomColor)) {
            return false;
        }
        const { style: clS, color: clC } = left || {};
        const { style: crS, color: crC } = right || {};
        const { style: ctS, color: ctC } = top || {};
        const { style: cbS, color: cbC } = bottom || {};
        if (clS != leftStyle || clC != leftColor) {
            return false;
        }
        if (crS != rightStyle || crC != rightColor) {
            return false;
        }
        if (ctS != topStyle || ctC != topColor) {
            return false;
        }
        if (cbS != bottomStyle || cbC != bottomColor) {
            return false;
        }
        return true;
    });
    if (pos === -1) {
        pos = registeredBorders.length;
        registeredBorders.push({
            left: {
                style: leftStyle, color: leftColor
            },
            right: {
                style: rightStyle, color: rightColor
            },
            top: {
                style: topStyle, color: topColor
            },
            bottom: {
                style: bottomStyle, color: bottomColor
            },
            diagonal: {
                style: undefined,
                color: undefined
            }
        });
    }
    return pos;
};
const registerFont = (font) => {
    const { fontName: name = 'Calibri', color, size, bold, italic, outline, shadow, strikeThrough, underline, family, verticalAlign } = font;
    const convertedColor = convertLegacyColor(color);
    const familyId = getFontFamilyId(family);
    const convertedUnderline = underline ? underline.toLocaleLowerCase() : undefined;
    const convertedVerticalAlign = verticalAlign ? verticalAlign.toLocaleLowerCase() : undefined;
    let pos = registeredFonts.findIndex(currentFont => {
        if (currentFont.fontName != name ||
            currentFont.color != convertedColor ||
            currentFont.size != size ||
            currentFont.bold != bold ||
            currentFont.italic != italic ||
            currentFont.outline != outline ||
            currentFont.shadow != shadow ||
            currentFont.strikeThrough != strikeThrough ||
            currentFont.underline != convertedUnderline ||
            currentFont.verticalAlign != convertedVerticalAlign ||
            // @ts-ignore
            currentFont.family != familyId) {
            return false;
        }
        return true;
    });
    if (pos === -1) {
        pos = registeredFonts.length;
        registeredFonts.push({
            fontName: name,
            color: convertedColor,
            size,
            bold,
            italic,
            outline,
            shadow,
            strikeThrough,
            underline: convertedUnderline,
            verticalAlign: convertedVerticalAlign,
            family: familyId != null ? familyId.toString() : undefined
        });
    }
    return pos;
};
const registerStyle = (config) => {
    const { alignment, borders, font, interior, numberFormat, protection, quotePrefix } = config;
    let { id } = config;
    let currentFill = 0;
    let currentBorder = 0;
    let currentFont = 0;
    let currentNumberFmt = 0;
    if (!id) {
        return;
    }
    id = getStyleName(id, currentSheet);
    if (stylesMap[id] != undefined) {
        return;
    }
    if (interior) {
        currentFill = registerFill(interior);
    }
    if (borders) {
        currentBorder = registerBorders(borders);
    }
    if (font) {
        currentFont = registerFont(font);
    }
    if (numberFormat) {
        currentNumberFmt = registerNumberFmt(numberFormat.format);
    }
    stylesMap[id] = registeredCellXfs.length;
    registeredCellXfs.push({
        alignment,
        borderId: currentBorder || 0,
        fillId: currentFill || 0,
        fontId: currentFont || 0,
        numFmtId: currentNumberFmt || 0,
        protection,
        quotePrefix: quotePrefix,
        xfId: 0
    });
};
const stylesheetFactory = {
    getTemplate(defaultFontSize) {
        const numberFormats = numberFormatsFactory.getTemplate(registeredNumberFmts);
        const fonts = fontsFactory.getTemplate(registeredFonts.map(font => (Object.assign(Object.assign({}, font), { size: font.size != null ? font.size : defaultFontSize }))));
        const fills = fillsFactory.getTemplate(registeredFills);
        const borders = bordersFactory.getTemplate(registeredBorders);
        const cellStylesXfs = cellStylesXfsFactory.getTemplate(registeredCellStyleXfs);
        const cellXfs = cellXfsFactory.getTemplate(registeredCellXfs);
        const cellStyles = cellStylesFactory.getTemplate(registeredCellStyles);
        resetStylesheetValues();
        return {
            name: 'styleSheet',
            properties: {
                rawMap: {
                    'mc:Ignorable': 'x14ac x16r2 xr',
                    'xmlns': 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
                    'xmlns:mc': 'http://schemas.openxmlformats.org/markup-compatibility/2006',
                    'xmlns:x14ac': 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',
                    'xmlns:x16r2': 'http://schemas.microsoft.com/office/spreadsheetml/2015/02/main',
                    'xmlns:xr': 'http://schemas.microsoft.com/office/spreadsheetml/2014/revision'
                }
            },
            children: [
                numberFormats,
                fonts,
                fills,
                borders,
                cellStylesXfs,
                cellXfs,
                cellStyles,
                {
                    name: 'tableStyles',
                    properties: {
                        rawMap: {
                            count: 0,
                            defaultPivotStyle: 'PivotStyleLight16',
                            defaultTableStyle: 'TableStyleMedium2'
                        }
                    }
                }
            ]
        };
    }
};
const getStyleId = (name, currentSheet) => {
    return stylesMap[getStyleName(name, currentSheet)] || 0;
};
const registerStyles = (styles, _currentSheet) => {
    currentSheet = _currentSheet;
    if (currentSheet === 1) {
        resetStylesheetValues();
    }
    styles.forEach(registerStyle);
};

const sheetFactory = {
    getTemplate(name, idx) {
        const sheetId = (idx + 1).toString();
        return {
            name: "sheet",
            properties: {
                rawMap: {
                    "name": name,
                    "sheetId": sheetId,
                    "r:id": `rId${sheetId}`
                }
            }
        };
    }
};

const sheetsFactory = {
    getTemplate(names) {
        return {
            name: "sheets",
            children: names.map((sheet, idx) => sheetFactory.getTemplate(sheet, idx))
        };
    }
};

const workbookFactory = {
    getTemplate(names) {
        return {
            name: "workbook",
            properties: {
                prefixedAttributes: [{
                        prefix: "xmlns:",
                        map: {
                            r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
                        },
                    }],
                rawMap: {
                    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
                }
            },
            children: [sheetsFactory.getTemplate(names)]
        };
    }
};

// https://docs.microsoft.com/en-us/office/troubleshoot/excel/determine-column-widths
const getExcelCellWidth = (width) => Math.ceil((width - 12) / 7 + 1);
const columnFactory = {
    getTemplate(config) {
        const { min, max, outlineLevel, s, width, hidden, bestFit } = config;
        let excelWidth = 1;
        let customWidth = '0';
        if (width > 1) {
            excelWidth = getExcelCellWidth(width);
            customWidth = '1';
        }
        return {
            name: 'col',
            properties: {
                rawMap: {
                    min: min,
                    max: max,
                    outlineLevel: outlineLevel != null ? outlineLevel : undefined,
                    width: excelWidth,
                    style: s,
                    hidden: hidden ? '1' : '0',
                    bestFit: bestFit ? '1' : '0',
                    customWidth: customWidth
                }
            }
        };
    }
};

const convertLegacyType = (type) => {
    const t = type.charAt(0).toLowerCase();
    return t === 's' ? 'inlineStr' : t;
};
const cellFactory = {
    getTemplate(config, idx, currentSheet) {
        const { ref, data, styleId } = config;
        const { type, value } = data || { type: 'empty', value: null };
        let convertedType = type;
        if (type === 'f') {
            convertedType = 'str';
        }
        else if (type.charAt(0) === type.charAt(0).toUpperCase()) {
            convertedType = convertLegacyType(type);
        }
        const obj = {
            name: 'c',
            properties: {
                rawMap: {
                    r: ref,
                    t: convertedType === 'empty' ? undefined : convertedType,
                    s: styleId ? getStyleId(styleId, currentSheet) : undefined
                }
            }
        };
        if (convertedType === 'empty') {
            return obj;
        }
        let children;
        if (convertedType === 'str' && type === 'f') {
            children = [{
                    name: 'f',
                    textNode: _.escapeString(value)
                }];
        }
        else if (convertedType === 'inlineStr') {
            children = [{
                    name: 'is',
                    children: [{
                            name: 't',
                            textNode: _.escapeString(value)
                        }]
                }];
        }
        else {
            children = [{
                    name: 'v',
                    textNode: value,
                }];
        }
        return Object.assign({}, obj, { children });
    }
};

const addEmptyCells = (cells, rowIdx) => {
    const mergeMap = [];
    let posCounter = 0;
    for (let i = 0; i < cells.length; i++) {
        const cell = cells[i];
        if (cell.mergeAcross) {
            mergeMap.push({
                pos: i,
                excelPos: posCounter
            });
            posCounter += cell.mergeAcross;
        }
        posCounter++;
    }
    if (mergeMap.length) {
        for (let i = mergeMap.length - 1; i >= 0; i--) {
            const mergedCells = [];
            const cell = cells[mergeMap[i].pos];
            for (let j = 1; j <= cell.mergeAcross; j++) {
                mergedCells.push({
                    ref: `${getExcelColumnName(mergeMap[i].excelPos + 1 + j)}${rowIdx + 1}`,
                    styleId: cell.styleId,
                    data: { type: 'empty', value: null }
                });
            }
            if (mergedCells.length) {
                cells.splice(mergeMap[i].pos + 1, 0, ...mergedCells);
            }
        }
    }
};
const shouldDisplayCell = (cell) => { var _a; return ((_a = cell.data) === null || _a === void 0 ? void 0 : _a.value) !== '' || cell.styleId !== undefined; };
const rowFactory = {
    getTemplate(config, idx, currentSheet) {
        const { collapsed, hidden, height, outlineLevel, cells = [] } = config;
        addEmptyCells(cells, idx);
        const children = cells.filter(shouldDisplayCell).map((cell, idx) => cellFactory.getTemplate(cell, idx, currentSheet));
        return {
            name: "row",
            properties: {
                rawMap: {
                    r: idx + 1,
                    collapsed: collapsed ? '1' : '0',
                    hidden: hidden ? '1' : '0',
                    ht: height,
                    customHeight: height != null ? '1' : '0',
                    spans: '1:1',
                    outlineLevel: outlineLevel || undefined
                }
            },
            children
        };
    }
};

const mergeCellFactory = {
    getTemplate(ref) {
        return {
            name: 'mergeCell',
            properties: {
                rawMap: {
                    ref: ref
                }
            }
        };
    }
};

const getMergedCellsAndAddColumnGroups = (rows, cols, suppressColumnOutline) => {
    const mergedCells = [];
    const cellsWithCollapsibleGroups = [];
    rows.forEach((currentRow, rowIdx) => {
        const cells = currentRow.cells;
        let merges = 0;
        let lastCol;
        cells.forEach((currentCell, cellIdx) => {
            const min = cellIdx + merges + 1;
            const start = getExcelColumnName(min);
            const outputRow = rowIdx + 1;
            if (currentCell.mergeAcross) {
                merges += currentCell.mergeAcross;
                const end = getExcelColumnName(cellIdx + merges + 1);
                mergedCells.push(`${start}${outputRow}:${end}${outputRow}`);
            }
            if (!cols[min - 1]) {
                cols[min - 1] = {};
            }
            const { collapsibleRanges } = currentCell;
            if (collapsibleRanges) {
                collapsibleRanges.forEach(range => {
                    cellsWithCollapsibleGroups.push([min + range[0], min + range[1]]);
                });
            }
            lastCol = cols[min - 1];
            lastCol.min = min;
            lastCol.max = min;
            currentCell.ref = `${start}${outputRow}`;
        });
    });
    cellsWithCollapsibleGroups.sort((a, b) => {
        if (a[0] !== b[0]) {
            return a[0] - b[0];
        }
        return b[1] - a[1];
    });
    const rangeMap = new Map();
    const outlineLevel = new Map();
    cellsWithCollapsibleGroups.filter(currentRange => {
        const rangeString = currentRange.toString();
        const inMap = rangeMap.get(rangeString);
        if (inMap) {
            return false;
        }
        rangeMap.set(rangeString, true);
        return true;
    }).forEach(range => {
        const refCol = cols.find(col => col.min == range[0] && col.max == range[1]);
        const currentOutlineLevel = outlineLevel.get(range[0]);
        cols.push({
            min: range[0],
            max: range[1],
            outlineLevel: suppressColumnOutline ? undefined : (currentOutlineLevel || 1),
            width: (refCol || { width: 100 }).width
        });
        outlineLevel.set(range[0], (currentOutlineLevel || 0) + 1);
    });
    return mergedCells;
};
const getPageOrientation = (orientation) => {
    if (!orientation || (orientation !== 'Portrait' && orientation !== 'Landscape')) {
        return 'portrait';
    }
    return orientation.toLocaleLowerCase();
};
const getPageSize = (pageSize) => {
    if (pageSize == null) {
        return 1;
    }
    const positions = ['Letter', 'Letter Small', 'Tabloid', 'Ledger', 'Legal', 'Statement', 'Executive', 'A3', 'A4', 'A4 Small', 'A5', 'A6', 'B4', 'B5', 'Folio', 'Envelope', 'Envelope DL', 'Envelope C5', 'Envelope B5', 'Envelope C3', 'Envelope C4', 'Envelope C6', 'Envelope Monarch', 'Japanese Postcard', 'Japanese Double Postcard'];
    const pos = positions.indexOf(pageSize);
    return pos === -1 ? 1 : (pos + 1);
};
const addColumns = (columns) => {
    return (children) => {
        if (columns.length) {
            children.push({
                name: 'cols',
                children: columns.map(column => columnFactory.getTemplate(column))
            });
        }
        return children;
    };
};
const addSheetData = (rows, sheetNumber) => {
    return (children) => {
        if (rows.length) {
            children.push({
                name: 'sheetData',
                children: rows.map((row, idx) => rowFactory.getTemplate(row, idx, sheetNumber))
            });
        }
        return children;
    };
};
const addMergeCells = (mergeCells) => {
    return (children) => {
        if (mergeCells.length) {
            children.push({
                name: 'mergeCells',
                properties: {
                    rawMap: {
                        count: mergeCells.length
                    }
                },
                children: mergeCells.map(mergedCell => mergeCellFactory.getTemplate(mergedCell))
            });
        }
        return children;
    };
};
const addPageMargins = (margins) => {
    return (children) => {
        const { top = 0.75, right = 0.7, bottom = 0.75, left = 0.7, header = 0.3, footer = 0.3 } = margins;
        children.push({
            name: 'pageMargins',
            properties: {
                rawMap: { bottom, footer, header, left, right, top }
            }
        });
        return children;
    };
};
const addPageSetup = (pageSetup) => {
    return (children) => {
        if (pageSetup) {
            children.push({
                name: 'pageSetup',
                properties: {
                    rawMap: {
                        horizontalDpi: 0,
                        verticalDpi: 0,
                        orientation: getPageOrientation(pageSetup.orientation),
                        paperSize: getPageSize(pageSetup.pageSize)
                    }
                }
            });
        }
        return children;
    };
};
const replaceHeaderFooterTokens = (value) => {
    const map = {
        '&[Page]': '&P',
        '&[Pages]': '&N',
        '&[Date]': '&D',
        '&[Time]': '&T',
        '&[Tab]': '&A',
        '&[Path]': '&Z',
        '&[File]': '&F'
    };
    _.iterateObject(map, (key, val) => {
        value = value.replace(key, val);
    });
    return value;
};
const getHeaderPosition = (position) => {
    if (position === 'Center') {
        return 'C';
    }
    if (position === 'Right') {
        return 'R';
    }
    return 'L';
};
const applyHeaderFontStyle = (headerString, font) => {
    if (!font) {
        return headerString;
    }
    headerString += '&amp;&quot;';
    headerString += font.fontName || 'Calibri';
    if (font.bold !== font.italic) {
        headerString += font.bold ? ',Bold' : ',Italic';
    }
    else if (font.bold) {
        headerString += ',Bold Italic';
    }
    else {
        headerString += ',Regular';
    }
    headerString += '&quot;';
    if (font.size) {
        headerString += `&amp;${font.size}`;
    }
    if (font.strikeThrough) {
        headerString += '&amp;S';
    }
    if (font.underline) {
        headerString += `&amp;${font.underline === 'Double' ? 'E' : 'U'}`;
    }
    if (font.color) {
        headerString += `&amp;K${font.color.replace('#', '').toUpperCase()}`;
    }
    return headerString;
};
const processHeaderFooterContent = (content) => content.reduce((prev, curr) => {
    const pos = getHeaderPosition(curr.position);
    const output = applyHeaderFontStyle(`${prev}&amp;${pos}`, curr.font);
    return `${output}${_.escapeString(replaceHeaderFooterTokens(curr.value))}`;
}, '');
const buildHeaderFooter = (headerFooterConfig) => {
    const rules = ['all', 'first', 'even'];
    const headersAndFooters = [];
    rules.forEach(rule => {
        const headerFooter = headerFooterConfig[rule];
        const namePrefix = rule === 'all' ? 'odd' : rule;
        if (!headerFooter || (!headerFooter.header && !headerFooter.footer)) {
            return;
        }
        _.iterateObject(headerFooter, (key, value) => {
            const nameSuffix = `${key.charAt(0).toUpperCase()}${key.slice(1)}`;
            if (value) {
                headersAndFooters.push({
                    name: `${namePrefix}${nameSuffix}`,
                    properties: {
                        rawMap: {
                            'xml:space': 'preserve'
                        }
                    },
                    textNode: processHeaderFooterContent(value)
                });
            }
        });
    });
    return headersAndFooters;
};
const addHeaderFooter = (headerFooterConfig) => {
    return (children) => {
        if (!headerFooterConfig) {
            return children;
        }
        const differentFirst = headerFooterConfig.first != null ? 1 : 0;
        const differentOddEven = headerFooterConfig.even != null ? 1 : 0;
        children.push({
            name: 'headerFooter',
            properties: {
                rawMap: {
                    differentFirst,
                    differentOddEven
                }
            },
            children: buildHeaderFooter(headerFooterConfig)
        });
        return children;
    };
};
const addDrawingRel = (currentSheet) => {
    return (children) => {
        if (ExcelXlsxFactory.worksheetImages.get(currentSheet)) {
            children.push({
                name: 'drawing',
                properties: {
                    rawMap: {
                        'r:id': 'rId1'
                    }
                }
            });
        }
        return children;
    };
};
const addSheetPr = () => {
    return (children) => {
        children.push({
            name: 'sheetPr',
            children: [{
                    name: 'outlinePr',
                    properties: {
                        rawMap: {
                            summaryBelow: 0
                        }
                    }
                }]
        });
        return children;
    };
};
const addSheetFormatPr = (rows) => {
    return (children) => {
        const maxOutline = rows.reduce((prev, row) => {
            if (row.outlineLevel && row.outlineLevel > prev) {
                return row.outlineLevel;
            }
            return prev;
        }, 0);
        children.push({
            name: 'sheetFormatPr',
            properties: {
                rawMap: {
                    baseColWidth: 10,
                    defaultRowHeight: 16,
                    outlineLevelRow: maxOutline ? maxOutline : undefined
                }
            }
        });
        return children;
    };
};
const worksheetFactory = {
    getTemplate(params) {
        const { worksheet, currentSheet, config } = params;
        const { margins = {}, pageSetup, headerFooterConfig, suppressColumnOutline } = config;
        const { table } = worksheet;
        const { rows, columns } = table;
        const mergedCells = (columns && columns.length) ? getMergedCellsAndAddColumnGroups(rows, columns, !!suppressColumnOutline) : [];
        const createWorksheetChildren = _.compose(addSheetPr(), addSheetFormatPr(rows), addColumns(columns), addSheetData(rows, currentSheet + 1), addMergeCells(mergedCells), addPageMargins(margins), addPageSetup(pageSetup), addHeaderFooter(headerFooterConfig), addDrawingRel(currentSheet));
        const children = createWorksheetChildren([]);
        return {
            name: "worksheet",
            properties: {
                prefixedAttributes: [{
                        prefix: "xmlns:",
                        map: {
                            r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
                        }
                    }],
                rawMap: {
                    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
                }
            },
            children
        };
    }
};

const relationshipFactory = {
    getTemplate(config) {
        const { Id, Type, Target } = config;
        return {
            name: "Relationship",
            properties: {
                rawMap: {
                    Id,
                    Type,
                    Target
                }
            }
        };
    }
};

const relationshipsFactory = {
    getTemplate(c) {
        const children = c.map(relationship => relationshipFactory.getTemplate(relationship));
        return {
            name: "Relationships",
            properties: {
                rawMap: {
                    xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
                }
            },
            children
        };
    }
};

/**
 * See links for more info on the Office Open XML format being used:
 * https://www.ecma-international.org/wp-content/uploads/Office-Open-XML-White-Paper.pdf
 * https://ecma-international.org/publications-and-standards/standards/ecma-376/
 */
class ExcelXlsxFactory {
    static createExcel(styles, worksheet, config) {
        this.addSheetName(worksheet);
        registerStyles(styles, this.sheetNames.length);
        return this.createWorksheet(worksheet, config);
    }
    static buildImageMap(image, rowIndex, col, columnsToExport, rowHeight) {
        const currentSheetIndex = this.sheetNames.length;
        const registeredImage = this.images.get(image.id);
        if (!image.position || !image.position.row || !image.position.column) {
            if (!image.position) {
                image.position = {};
            }
            image.position = Object.assign({}, image.position, {
                row: rowIndex,
                column: columnsToExport.indexOf(col) + 1
            });
        }
        const calculatedImage = image;
        setExcelImageTotalWidth(calculatedImage, columnsToExport);
        setExcelImageTotalHeight(calculatedImage, rowHeight);
        if (registeredImage) {
            const currentSheetImages = registeredImage.find(currentImage => currentImage.sheetId === currentSheetIndex);
            if (currentSheetImages) {
                currentSheetImages.image.push(calculatedImage);
            }
            else {
                registeredImage.push({
                    sheetId: currentSheetIndex,
                    image: [calculatedImage]
                });
            }
        }
        else {
            this.images.set(calculatedImage.id, [{ sheetId: currentSheetIndex, image: [calculatedImage] }]);
            this.workbookImageIds.set(calculatedImage.id, { type: calculatedImage.imageType, index: this.workbookImageIds.size });
        }
        this.buildSheetImageMap(currentSheetIndex, calculatedImage);
    }
    static buildSheetImageMap(sheetIndex, image) {
        let worksheetImageIdMap = this.worksheetImageIds.get(sheetIndex);
        if (!worksheetImageIdMap) {
            worksheetImageIdMap = new Map();
            this.worksheetImageIds.set(sheetIndex, worksheetImageIdMap);
        }
        const sheetImages = this.worksheetImages.get(sheetIndex);
        if (!sheetImages) {
            this.worksheetImages.set(sheetIndex, [image]);
            worksheetImageIdMap.set(image.id, { index: 0, type: image.imageType });
        }
        else {
            sheetImages.push(image);
            if (!worksheetImageIdMap.get(image.id)) {
                worksheetImageIdMap.set(image.id, { index: worksheetImageIdMap.size, type: image.imageType });
            }
        }
    }
    static addSheetName(worksheet) {
        const name = _.escapeString(worksheet.name) || '';
        let append = '';
        while (this.sheetNames.indexOf(`${name}${append}`) !== -1) {
            if (append === '') {
                append = '_1';
            }
            else {
                const curr = parseInt(append.slice(1), 10);
                append = `_${curr + 1}`;
            }
        }
        worksheet.name = `${name}${append}`;
        this.sheetNames.push(worksheet.name);
    }
    static getStringPosition(str) {
        if (this.sharedStrings.has(str)) {
            return this.sharedStrings.get(str);
        }
        this.sharedStrings.set(str, this.sharedStrings.size);
        return this.sharedStrings.size - 1;
    }
    static resetFactory() {
        this.sharedStrings = new Map();
        this.images = new Map();
        this.worksheetImages = new Map();
        this.workbookImageIds = new Map();
        this.worksheetImageIds = new Map();
        this.sheetNames = [];
        this.factoryMode = ExcelFactoryMode.SINGLE_SHEET;
    }
    static createWorkbook() {
        return createXmlPart(workbookFactory.getTemplate(this.sheetNames));
    }
    static createStylesheet(defaultFontSize) {
        return createXmlPart(stylesheetFactory.getTemplate(defaultFontSize));
    }
    static createSharedStrings() {
        return createXmlPart(sharedStrings.getTemplate(this.sharedStrings));
    }
    static createCore(author) {
        return createXmlPart(coreFactory.getTemplate(author));
    }
    static createContentTypes(sheetLen) {
        return createXmlPart(contentTypesFactory.getTemplate(sheetLen));
    }
    static createRels() {
        const rs = relationshipsFactory.getTemplate([{
                Id: 'rId1',
                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
                Target: 'xl/workbook.xml'
            }, {
                Id: 'rId2',
                Type: 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',
                Target: 'docProps/core.xml'
            }]);
        return createXmlPart(rs);
    }
    static createTheme() {
        return createXmlPart(officeTheme.getTemplate());
    }
    static createWorkbookRels(sheetLen) {
        const worksheets = new Array(sheetLen).fill(undefined).map((v, i) => ({
            Id: `rId${i + 1}`,
            Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
            Target: `worksheets/sheet${i + 1}.xml`
        }));
        const rs = relationshipsFactory.getTemplate([
            ...worksheets,
            {
                Id: `rId${sheetLen + 1}`,
                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
                Target: 'theme/theme1.xml'
            }, {
                Id: `rId${sheetLen + 2}`,
                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
                Target: 'styles.xml'
            }, {
                Id: `rId${sheetLen + 3}`,
                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
                Target: 'sharedStrings.xml'
            }
        ]);
        return createXmlPart(rs);
    }
    static createDrawing(sheetIndex) {
        return createXmlPart(drawingFactory.getTemplate({ sheetIndex }));
    }
    static createDrawingRel(sheetIndex) {
        const worksheetImageIds = this.worksheetImageIds.get(sheetIndex);
        const XMLArr = [];
        worksheetImageIds.forEach((value, key) => {
            XMLArr.push({
                Id: `rId${value.index + 1}`,
                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
                Target: `../media/image${this.workbookImageIds.get(key).index + 1}.${value.type}`
            });
        });
        return createXmlPart(relationshipsFactory.getTemplate(XMLArr));
    }
    static createWorksheetDrawingRel(currentRelationIndex) {
        const rs = relationshipsFactory.getTemplate([{
                Id: 'rId1',
                Type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
                Target: `../drawings/drawing${currentRelationIndex + 1}.xml`
            }]);
        return createXmlPart(rs);
    }
    static createWorksheet(worksheet, config) {
        return createXmlPart(worksheetFactory.getTemplate({
            worksheet,
            currentSheet: this.sheetNames.length - 1,
            config
        }));
    }
}
ExcelXlsxFactory.sharedStrings = new Map();
ExcelXlsxFactory.sheetNames = [];
/** Maps images to sheet */
ExcelXlsxFactory.images = new Map();
/** Maps sheets to images */
ExcelXlsxFactory.worksheetImages = new Map();
/** Maps all workbook images to a global Id */
ExcelXlsxFactory.workbookImageIds = new Map();
/** Maps all sheet images to unique Ids */
ExcelXlsxFactory.worksheetImageIds = new Map();
ExcelXlsxFactory.factoryMode = ExcelFactoryMode.SINGLE_SHEET;

class ExcelSerializingSession extends BaseGridSerializingSession {
    constructor(config) {
        super(config);
        this.mixedStyles = {};
        this.mixedStyleCounter = 0;
        this.rows = [];
        this.config = Object.assign({}, config);
        this.stylesByIds = {};
        this.config.baseExcelStyles.forEach(style => {
            this.stylesByIds[style.id] = style;
        });
        this.excelStyles = [...this.config.baseExcelStyles, { id: '_quotePrefix', quotePrefix: 1 }];
    }
    addCustomContent(customContent) {
        customContent.forEach(row => {
            const rowLen = this.rows.length + 1;
            let outlineLevel;
            if (!this.config.suppressRowOutline && row.outlineLevel != null) {
                outlineLevel = row.outlineLevel;
            }
            const rowObj = {
                height: getHeightFromProperty(rowLen, row.height || this.config.rowHeight),
                cells: (row.cells || []).map((cell, idx) => {
                    var _a, _b, _c;
                    const image = this.addImage(rowLen, this.columnsToExport[idx], (_a = cell.data) === null || _a === void 0 ? void 0 : _a.value);
                    let excelStyles = null;
                    if (cell.styleId) {
                        excelStyles = typeof cell.styleId === 'string' ? [cell.styleId] : cell.styleId;
                    }
                    const excelStyleId = this.getStyleId(excelStyles);
                    if (image) {
                        return this.createCell(excelStyleId, this.getDataTypeForValue(image.value), image.value == null ? '' : image.value);
                    }
                    const value = (_c = (_b = cell.data) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : '';
                    const type = this.getDataTypeForValue(value);
                    if (cell.mergeAcross) {
                        return this.createMergedCell(excelStyleId, type, value, cell.mergeAcross);
                    }
                    return this.createCell(excelStyleId, type, value);
                }),
                outlineLevel
            };
            if (row.collapsed != null) {
                rowObj.collapsed = row.collapsed;
            }
            if (row.hidden != null) {
                rowObj.hidden = row.hidden;
            }
            this.rows.push(rowObj);
        });
    }
    onNewHeaderGroupingRow() {
        const currentCells = [];
        this.rows.push({
            cells: currentCells,
            height: getHeightFromProperty(this.rows.length + 1, this.config.headerRowHeight)
        });
        return {
            onColumn: (columnGroup, header, index, span, collapsibleRanges) => {
                const styleIds = this.config.styleLinker({ rowType: RowType.HEADER_GROUPING, rowIndex: 1, value: `grouping-${header}`, columnGroup });
                currentCells.push(Object.assign(Object.assign({}, this.createMergedCell(this.getStyleId(styleIds), this.getDataTypeForValue('string'), header, span)), { collapsibleRanges }));
            }
        };
    }
    onNewHeaderRow() {
        return this.onNewRow(this.onNewHeaderColumn, this.config.headerRowHeight);
    }
    onNewBodyRow(node) {
        const rowAccumulator = this.onNewRow(this.onNewBodyColumn, this.config.rowHeight);
        if (node) {
            this.addRowOutlineIfNecessary(node);
        }
        return rowAccumulator;
    }
    prepare(columnsToExport) {
        super.prepare(columnsToExport);
        this.columnsToExport = [...columnsToExport];
        this.cols = columnsToExport.map((col, i) => this.convertColumnToExcel(col, i));
    }
    parse() {
        // adding custom content might have made some rows wider than the grid, so add new columns
        const longestRow = this.rows.reduce((a, b) => Math.max(a, b.cells.length), 0);
        while (this.cols.length < longestRow) {
            this.cols.push(this.convertColumnToExcel(null, this.cols.length + 1));
        }
        const data = {
            name: this.config.sheetName,
            table: {
                columns: this.cols,
                rows: this.rows
            }
        };
        return this.createExcel(data);
    }
    addRowOutlineIfNecessary(node) {
        const { gridOptionsService, suppressRowOutline, rowGroupExpandState = 'expanded' } = this.config;
        const isGroupHideOpenParents = gridOptionsService.get('groupHideOpenParents');
        if (isGroupHideOpenParents || suppressRowOutline || node.level == null) {
            return;
        }
        const padding = node.footer ? 1 : 0;
        const currentRow = _.last(this.rows);
        currentRow.outlineLevel = node.level + padding;
        if (rowGroupExpandState === 'expanded') {
            return;
        }
        const collapseAll = rowGroupExpandState === 'collapsed';
        if (node.isExpandable()) {
            const isExpanded = !collapseAll && node.expanded;
            currentRow.collapsed = !isExpanded;
        }
        currentRow.hidden =
            // always show the node if there is no parent to be expanded
            !!node.parent &&
                // or if it is a child of the root node
                node.parent.level !== -1 &&
                (collapseAll || this.isAnyParentCollapsed(node.parent));
    }
    isAnyParentCollapsed(node) {
        while (node && node.level !== -1) {
            if (!node.expanded) {
                return true;
            }
            node = node.parent;
        }
        return false;
    }
    convertColumnToExcel(column, index) {
        const columnWidth = this.config.columnWidth;
        if (columnWidth) {
            if (typeof columnWidth === 'number') {
                return { width: columnWidth };
            }
            return { width: columnWidth({ column, index }) };
        }
        if (column) {
            const smallestUsefulWidth = 75;
            return { width: Math.max(column.getActualWidth(), smallestUsefulWidth) };
        }
        return {};
    }
    onNewHeaderColumn(rowIndex, currentCells) {
        return (column, index) => {
            const nameForCol = this.extractHeaderValue(column);
            const styleIds = this.config.styleLinker({ rowType: RowType.HEADER, rowIndex, value: nameForCol, column });
            currentCells.push(this.createCell(this.getStyleId(styleIds), this.getDataTypeForValue('string'), nameForCol));
        };
    }
    onNewBodyColumn(rowIndex, currentCells) {
        let skipCols = 0;
        return (column, index, node) => {
            if (skipCols > 0) {
                skipCols -= 1;
                return;
            }
            const { value: valueForCell, valueFormatted } = this.extractRowCellValue(column, index, rowIndex, 'excel', node);
            const styleIds = this.config.styleLinker({ rowType: RowType.BODY, rowIndex, value: valueForCell, column, node });
            const excelStyleId = this.getStyleId(styleIds);
            const colSpan = column.getColSpan(node);
            const addedImage = this.addImage(rowIndex, column, valueForCell);
            if (addedImage) {
                currentCells.push(this.createCell(excelStyleId, this.getDataTypeForValue(addedImage.value), addedImage.value == null ? '' : addedImage.value));
            }
            else if (colSpan > 1) {
                skipCols = colSpan - 1;
                currentCells.push(this.createMergedCell(excelStyleId, this.getDataTypeForValue(valueForCell), valueForCell, colSpan - 1));
            }
            else {
                currentCells.push(this.createCell(excelStyleId, this.getDataTypeForValue(valueForCell), valueForCell, valueFormatted));
            }
        };
    }
    onNewRow(onNewColumnAccumulator, height) {
        const currentCells = [];
        this.rows.push({
            cells: currentCells,
            height: getHeightFromProperty(this.rows.length + 1, height)
        });
        return {
            onColumn: onNewColumnAccumulator.bind(this, this.rows.length, currentCells)()
        };
    }
    createExcel(data) {
        const { excelStyles, config } = this;
        return ExcelXlsxFactory.createExcel(excelStyles, data, config);
    }
    getDataTypeForValue(valueForCell) {
        if (valueForCell === undefined) {
            return 'empty';
        }
        return this.isNumerical(valueForCell) ? 'n' : 's';
    }
    getTypeFromStyle(style, value) {
        if (this.isFormula(value)) {
            return 'f';
        }
        if (style && style.dataType) {
            switch (style.dataType.toLocaleLowerCase()) {
                case 'formula':
                    return 'f';
                case 'string':
                    return 's';
                case 'number':
                    return 'n';
                case 'datetime':
                    return 'd';
                case 'error':
                    return 'e';
                case 'boolean':
                    return 'b';
                default:
                    console.warn(`AG Grid: Unrecognized data type for excel export [${style.id}.dataType=${style.dataType}]`);
            }
        }
        return null;
    }
    addImage(rowIndex, column, value) {
        if (!this.config.addImageToCell) {
            return;
        }
        const addedImage = this.config.addImageToCell(rowIndex, column, value);
        if (!addedImage) {
            return;
        }
        ExcelXlsxFactory.buildImageMap(addedImage.image, rowIndex, column, this.columnsToExport, this.config.rowHeight);
        return addedImage;
    }
    createCell(styleId, type, value, valueFormatted) {
        const actualStyle = this.getStyleById(styleId);
        if (!(actualStyle === null || actualStyle === void 0 ? void 0 : actualStyle.dataType) && type === 's' && valueFormatted) {
            value = valueFormatted;
        }
        const processedType = this.getTypeFromStyle(actualStyle, value) || type;
        const { value: processedValue, escaped } = this.getCellValue(processedType, value);
        const styles = [];
        if (actualStyle) {
            styles.push(styleId);
        }
        if (escaped) {
            styles.push('_quotePrefix');
        }
        styleId = this.getStyleId(styles) || undefined;
        return {
            styleId,
            data: {
                type: processedType,
                value: processedValue
            }
        };
    }
    createMergedCell(styleId, type, value, numOfCells) {
        const valueToUse = value == null ? '' : value;
        return {
            styleId: !!this.getStyleById(styleId) ? styleId : undefined,
            data: {
                type: type,
                value: type === 's' ? ExcelXlsxFactory.getStringPosition(valueToUse).toString() : value
            },
            mergeAcross: numOfCells
        };
    }
    getCellValue(type, value) {
        let escaped = false;
        if (value == null) {
            type = 's';
            value = '';
        }
        if (type === 's') {
            if (value && value[0] === "'") {
                escaped = true;
                value = value.slice(1);
            }
            value = ExcelXlsxFactory.getStringPosition(value).toString();
        }
        else if (type === 'f') {
            value = value.slice(1);
        }
        else if (type === 'n') {
            value = Number(value).toString();
        }
        return { value, escaped };
    }
    getStyleId(styleIds) {
        if (!styleIds || !styleIds.length) {
            return null;
        }
        if (styleIds.length === 1) {
            return styleIds[0];
        }
        const key = styleIds.join("-");
        if (!this.mixedStyles[key]) {
            this.addNewMixedStyle(styleIds);
        }
        return this.mixedStyles[key].excelID;
    }
    deepCloneObject(object) {
        return JSON.parse(JSON.stringify(object));
    }
    addNewMixedStyle(styleIds) {
        this.mixedStyleCounter += 1;
        const excelId = `mixedStyle${this.mixedStyleCounter}`;
        const resultantStyle = {};
        for (const styleId of styleIds) {
            for (const excelStyle of this.excelStyles) {
                if (excelStyle.id === styleId) {
                    _.mergeDeep(resultantStyle, this.deepCloneObject(excelStyle));
                }
            }
        }
        resultantStyle.id = excelId;
        resultantStyle.name = excelId;
        const key = styleIds.join("-");
        this.mixedStyles[key] = {
            excelID: excelId,
            key: key,
            result: resultantStyle
        };
        this.excelStyles.push(resultantStyle);
        this.stylesByIds[excelId] = resultantStyle;
    }
    isFormula(value) {
        if (value == null) {
            return false;
        }
        return this.config.autoConvertFormulas && value.toString().startsWith('=');
    }
    isNumerical(value) {
        if (typeof value === 'bigint') {
            return true;
        }
        return isFinite(value) && value !== '' && !isNaN(parseFloat(value));
    }
    getStyleById(styleId) {
        if (styleId == null) {
            return null;
        }
        return this.stylesByIds[styleId] || null;
    }
}

var __decorate$1t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const createExcelXMLCoreFolderStructure = () => {
    ZipContainer.addFolders([
        '_rels/',
        'docProps/',
        'xl/',
        'xl/theme/',
        'xl/_rels/',
        'xl/worksheets/'
    ]);
    if (!ExcelXlsxFactory.images.size) {
        return;
    }
    ZipContainer.addFolders([
        'xl/worksheets/_rels',
        'xl/drawings/',
        'xl/drawings/_rels',
        'xl/media/',
    ]);
    let imgCounter = 0;
    ExcelXlsxFactory.images.forEach(value => {
        const firstImage = value[0].image[0];
        const ext = firstImage.imageType;
        ZipContainer.addFile(`xl/media/image${++imgCounter}.${ext}`, firstImage.base64, true);
    });
};
const createExcelXmlWorksheets = (data) => {
    let imageRelationCounter = 0;
    data.forEach((value, idx) => {
        ZipContainer.addFile(`xl/worksheets/sheet${idx + 1}.xml`, value, false);
        if (ExcelXlsxFactory.images.size && ExcelXlsxFactory.worksheetImages.get(idx)) {
            createImageRelationsForSheet(idx, imageRelationCounter++);
        }
    });
};
const createExcelXmlCoreSheets = (fontSize, author, sheetLen) => {
    ZipContainer.addFile('xl/workbook.xml', ExcelXlsxFactory.createWorkbook());
    ZipContainer.addFile('xl/styles.xml', ExcelXlsxFactory.createStylesheet(fontSize));
    ZipContainer.addFile('xl/sharedStrings.xml', ExcelXlsxFactory.createSharedStrings());
    ZipContainer.addFile('xl/theme/theme1.xml', ExcelXlsxFactory.createTheme());
    ZipContainer.addFile('xl/_rels/workbook.xml.rels', ExcelXlsxFactory.createWorkbookRels(sheetLen));
    ZipContainer.addFile('docProps/core.xml', ExcelXlsxFactory.createCore(author));
    ZipContainer.addFile('[Content_Types].xml', ExcelXlsxFactory.createContentTypes(sheetLen));
    ZipContainer.addFile('_rels/.rels', ExcelXlsxFactory.createRels());
};
const createExcelFileForExcel = (data, fontSize = 11, author = 'AG Grid') => {
    if (data && data.length > 0) {
        createExcelXMLCoreFolderStructure();
        createExcelXmlWorksheets(data);
        createExcelXmlCoreSheets(fontSize, author, data.length);
    }
    else {
        console.warn("AG Grid: Invalid params supplied to getMultipleSheetsAsExcel() - `ExcelExportParams.data` is empty.");
    }
    // reset the internal variables of the Excel Factory
    ExcelXlsxFactory.resetFactory();
    if (!data || data.length === 0) {
        return false;
    }
    return true;
};
const getMultipleSheetsAsExcelCompressed = (params) => {
    const { data, fontSize, author } = params;
    const mimeType = params.mimeType || 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    if (!createExcelFileForExcel(data, fontSize, author)) {
        return Promise.resolve(undefined);
    }
    return ZipContainer.getZipFile(mimeType);
};
const getMultipleSheetsAsExcel = (params) => {
    const { data, fontSize, author } = params;
    const mimeType = params.mimeType || 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    if (!createExcelFileForExcel(data, fontSize, author)) {
        return;
    }
    return ZipContainer.getUncompressedZipFile(mimeType);
};
const exportMultipleSheetsAsExcel = (params) => {
    const { fileName = 'export.xlsx' } = params;
    getMultipleSheetsAsExcelCompressed(params).then(contents => {
        if (contents) {
            const downloadFileName = typeof fileName === 'function'
                ? fileName()
                : fileName;
            Downloader.download(downloadFileName, contents);
        }
    });
};
const createImageRelationsForSheet = (sheetIndex, currentRelationIndex) => {
    const drawingFolder = 'xl/drawings';
    const drawingFileName = `${drawingFolder}/drawing${currentRelationIndex + 1}.xml`;
    const relFileName = `${drawingFolder}/_rels/drawing${currentRelationIndex + 1}.xml.rels`;
    const worksheetRelFile = `xl/worksheets/_rels/sheet${sheetIndex + 1}.xml.rels`;
    ZipContainer.addFile(relFileName, ExcelXlsxFactory.createDrawingRel(sheetIndex));
    ZipContainer.addFile(drawingFileName, ExcelXlsxFactory.createDrawing(sheetIndex));
    ZipContainer.addFile(worksheetRelFile, ExcelXlsxFactory.createWorksheetDrawingRel(currentRelationIndex));
};
let ExcelCreator = class ExcelCreator extends BaseCreator {
    postConstruct() {
        this.setBeans({
            gridSerializer: this.gridSerializer,
            gridOptionsService: this.gridOptionsService
        });
    }
    getMergedParams(params) {
        const baseParams = this.gridOptionsService.get('defaultExcelExportParams');
        return Object.assign({}, baseParams, params);
    }
    export(userParams) {
        if (this.isExportSuppressed()) {
            console.warn(`AG Grid: Export cancelled. Export is not allowed as per your configuration.`);
            return;
        }
        const mergedParams = this.getMergedParams(userParams);
        const data = this.getData(mergedParams);
        const exportParams = {
            data: [data],
            fontSize: mergedParams.fontSize,
            author: mergedParams.author,
            mimeType: mergedParams.mimeType
        };
        this.packageCompressedFile(exportParams).then(packageFile => {
            if (packageFile) {
                const { fileName } = mergedParams;
                const providedFileName = typeof fileName === 'function'
                    ? fileName(this.gridOptionsService.getGridCommonParams())
                    : fileName;
                Downloader.download(this.getFileName(providedFileName), packageFile);
            }
        });
    }
    exportDataAsExcel(params) {
        this.export(params);
    }
    getDataAsExcel(params) {
        const mergedParams = this.getMergedParams(params);
        const data = this.getData(mergedParams);
        const exportParams = {
            data: [data],
            fontSize: mergedParams.fontSize,
            author: mergedParams.author,
            mimeType: mergedParams.mimeType
        };
        return this.packageFile(exportParams);
    }
    setFactoryMode(factoryMode) {
        ExcelXlsxFactory.factoryMode = factoryMode;
    }
    getFactoryMode() {
        return ExcelXlsxFactory.factoryMode;
    }
    getSheetDataForExcel(params) {
        const mergedParams = this.getMergedParams(params);
        const data = this.getData(mergedParams);
        return data;
    }
    getMultipleSheetsAsExcel(params) {
        return getMultipleSheetsAsExcel(params);
    }
    exportMultipleSheetsAsExcel(params) {
        exportMultipleSheetsAsExcel(params);
    }
    getDefaultFileExtension() {
        return 'xlsx';
    }
    createSerializingSession(params) {
        const { columnModel, valueService, gridOptionsService, valueFormatterService, valueParserService } = this;
        let sheetName;
        if (params.sheetName != null) {
            const { sheetName: sheetNameParam } = params;
            const sheetNameValue = typeof sheetNameParam === 'function'
                ? sheetNameParam(this.gridOptionsService.getGridCommonParams())
                : sheetNameParam;
            sheetName = String(sheetNameValue).substring(0, 31);
        }
        else {
            sheetName = 'ag-grid';
        }
        const config = Object.assign(Object.assign({}, params), { sheetName,
            columnModel,
            valueService,
            gridOptionsService,
            valueFormatterService,
            valueParserService, suppressRowOutline: params.suppressRowOutline || params.skipRowGroups, headerRowHeight: params.headerRowHeight || params.rowHeight, baseExcelStyles: this.gridOptionsService.get('excelStyles') || [], styleLinker: this.styleLinker.bind(this) });
        return new ExcelSerializingSession(config);
    }
    styleLinker(params) {
        const { rowType, rowIndex, value, column, columnGroup, node } = params;
        const isHeader = rowType === RowType.HEADER;
        const isGroupHeader = rowType === RowType.HEADER_GROUPING;
        const col = (isHeader ? column : columnGroup);
        let headerClasses = [];
        if (isHeader || isGroupHeader) {
            headerClasses.push('header');
            if (isGroupHeader) {
                headerClasses.push('headerGroup');
            }
            if (col) {
                headerClasses = headerClasses.concat(CssClassApplier.getHeaderClassesFromColDef(col.getDefinition(), this.gridOptionsService, column || null, columnGroup || null));
            }
            return headerClasses;
        }
        const styles = this.gridOptionsService.get('excelStyles');
        const applicableStyles = ["cell"];
        if (!styles || !styles.length) {
            return applicableStyles;
        }
        const styleIds = styles.map((it) => {
            return it.id;
        });
        this.stylingService.processAllCellClasses(column.getDefinition(), this.gridOptionsService.addGridCommonParams({
            value,
            data: node.data,
            node: node,
            colDef: column.getDefinition(),
            column: column,
            rowIndex: rowIndex
        }), (className) => {
            if (styleIds.indexOf(className) > -1) {
                applicableStyles.push(className);
            }
        });
        return applicableStyles.sort((left, right) => {
            return (styleIds.indexOf(left) < styleIds.indexOf(right)) ? -1 : 1;
        });
    }
    isExportSuppressed() {
        return this.gridOptionsService.get('suppressExcelExport');
    }
    packageCompressedFile(params) {
        return getMultipleSheetsAsExcelCompressed(params);
    }
    packageFile(params) {
        return getMultipleSheetsAsExcel(params);
    }
};
__decorate$1t([
    Autowired('columnModel')
], ExcelCreator.prototype, "columnModel", void 0);
__decorate$1t([
    Autowired('valueService')
], ExcelCreator.prototype, "valueService", void 0);
__decorate$1t([
    Autowired('stylingService')
], ExcelCreator.prototype, "stylingService", void 0);
__decorate$1t([
    Autowired('gridSerializer')
], ExcelCreator.prototype, "gridSerializer", void 0);
__decorate$1t([
    Autowired('gridOptionsService')
], ExcelCreator.prototype, "gridOptionsService", void 0);
__decorate$1t([
    Autowired('valueFormatterService')
], ExcelCreator.prototype, "valueFormatterService", void 0);
__decorate$1t([
    Autowired('valueParserService')
], ExcelCreator.prototype, "valueParserService", void 0);
__decorate$1t([
    PostConstruct
], ExcelCreator.prototype, "postConstruct", null);
ExcelCreator = __decorate$1t([
    Bean('excelCreator')
], ExcelCreator);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$a = '31.1.1';

const ExcelExportModule = {
    version: VERSION$a,
    moduleName: ModuleNames.ExcelExportModule,
    beans: [
        // beans in this module
        ExcelCreator,
        // these beans are part of CSV Export module
        GridSerializer, CsvCreator
    ],
    dependantModules: [
        CsvExportModule,
        EnterpriseCoreModule
    ]
};

var __decorate$1u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EXPAND_STATE;
(function (EXPAND_STATE) {
    EXPAND_STATE[EXPAND_STATE["EXPANDED"] = 0] = "EXPANDED";
    EXPAND_STATE[EXPAND_STATE["COLLAPSED"] = 1] = "COLLAPSED";
    EXPAND_STATE[EXPAND_STATE["INDETERMINATE"] = 2] = "INDETERMINATE";
})(EXPAND_STATE || (EXPAND_STATE = {}));
class FiltersToolPanelHeaderPanel extends Component {
    preConstruct() {
        this.setTemplate(/* html */ `<div class="ag-filter-toolpanel-search" role="presentation">
                <div ref="eExpand" class="ag-filter-toolpanel-expand"></div>
                <ag-input-text-field ref="eFilterTextField" class="ag-filter-toolpanel-search-input"></ag-input-text-field>
            </div>`);
    }
    postConstruct() {
        const translate = this.localeService.getLocaleTextFunc();
        this.eFilterTextField
            .setAutoComplete(false)
            .setInputAriaLabel(translate('ariaFilterColumnsInput', 'Filter Columns Input'))
            .onValueChange(this.onSearchTextChanged.bind(this));
        this.createExpandIcons();
        this.setExpandState(EXPAND_STATE.EXPANDED);
        this.addManagedListener(this.eExpand, 'click', this.onExpandClicked.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.showOrHideOptions.bind(this));
    }
    init(params) {
        this.params = params;
        if (this.columnModel.isReady()) {
            this.showOrHideOptions();
        }
    }
    createExpandIcons() {
        this.eExpand.appendChild(this.eExpandChecked = _.createIconNoSpan('columnSelectOpen', this.gridOptionsService));
        this.eExpand.appendChild(this.eExpandUnchecked = _.createIconNoSpan('columnSelectClosed', this.gridOptionsService));
        this.eExpand.appendChild(this.eExpandIndeterminate = _.createIconNoSpan('columnSelectIndeterminate', this.gridOptionsService));
    }
    // we only show expand / collapse if we are showing filters
    showOrHideOptions() {
        const showFilterSearch = !this.params.suppressFilterSearch;
        const showExpand = !this.params.suppressExpandAll;
        const translate = this.localeService.getLocaleTextFunc();
        this.eFilterTextField.setInputPlaceholder(translate('searchOoo', 'Search...'));
        const isFilterGroupPresent = (col) => col.getOriginalParent() && col.isFilterAllowed();
        const filterGroupsPresent = this.columnModel.getAllGridColumns().some(isFilterGroupPresent);
        _.setDisplayed(this.eFilterTextField.getGui(), showFilterSearch);
        _.setDisplayed(this.eExpand, showExpand && filterGroupsPresent);
    }
    onSearchTextChanged() {
        if (!this.onSearchTextChangedDebounced) {
            this.onSearchTextChangedDebounced = _.debounce(() => {
                this.dispatchEvent({ type: 'searchChanged', searchText: this.eFilterTextField.getValue() });
            }, 300);
        }
        this.onSearchTextChangedDebounced();
    }
    onExpandClicked() {
        const event = this.currentExpandState === EXPAND_STATE.EXPANDED ? { type: 'collapseAll' } : { type: 'expandAll' };
        this.dispatchEvent(event);
    }
    setExpandState(state) {
        this.currentExpandState = state;
        _.setDisplayed(this.eExpandChecked, this.currentExpandState === EXPAND_STATE.EXPANDED);
        _.setDisplayed(this.eExpandUnchecked, this.currentExpandState === EXPAND_STATE.COLLAPSED);
        _.setDisplayed(this.eExpandIndeterminate, this.currentExpandState === EXPAND_STATE.INDETERMINATE);
    }
}
__decorate$1u([
    Autowired('columnModel')
], FiltersToolPanelHeaderPanel.prototype, "columnModel", void 0);
__decorate$1u([
    RefSelector('eExpand')
], FiltersToolPanelHeaderPanel.prototype, "eExpand", void 0);
__decorate$1u([
    RefSelector('eFilterTextField')
], FiltersToolPanelHeaderPanel.prototype, "eFilterTextField", void 0);
__decorate$1u([
    PreConstruct
], FiltersToolPanelHeaderPanel.prototype, "preConstruct", null);
__decorate$1u([
    PostConstruct
], FiltersToolPanelHeaderPanel.prototype, "postConstruct", null);

var __decorate$1v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ToolPanelFilterComp extends Component {
    constructor(hideHeader, expandedCallback) {
        super(ToolPanelFilterComp.TEMPLATE);
        this.expandedCallback = expandedCallback;
        this.expanded = false;
        this.hideHeader = hideHeader;
    }
    postConstruct() {
        this.eExpandChecked = _.createIconNoSpan('columnSelectOpen', this.gridOptionsService);
        this.eExpandUnchecked = _.createIconNoSpan('columnSelectClosed', this.gridOptionsService);
        this.eExpand.appendChild(this.eExpandChecked);
        this.eExpand.appendChild(this.eExpandUnchecked);
    }
    setColumn(column) {
        this.column = column;
        this.eFilterName.innerText = this.columnModel.getDisplayNameForColumn(this.column, 'filterToolPanel', false) || '';
        this.addManagedListener(this.eFilterToolPanelHeader, 'click', this.toggleExpanded.bind(this));
        this.addManagedListener(this.eFilterToolPanelHeader, 'keydown', (e) => {
            if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {
                e.preventDefault();
                this.toggleExpanded();
            }
        });
        this.addManagedListener(this.eventService, Events.EVENT_FILTER_OPENED, this.onFilterOpened.bind(this));
        this.addInIcon('filter', this.eFilterIcon, this.column);
        _.setDisplayed(this.eFilterIcon, this.isFilterActive(), { skipAriaHidden: true });
        _.setDisplayed(this.eExpandChecked, false);
        if (this.hideHeader) {
            _.setDisplayed(this.eFilterToolPanelHeader, false);
            this.eFilterToolPanelHeader.removeAttribute('tabindex');
        }
        else {
            this.eFilterToolPanelHeader.setAttribute('tabindex', '0');
        }
        this.addManagedListener(this.column, Column.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_FILTER_DESTROYED, this.onFilterDestroyed.bind(this));
    }
    getColumn() {
        return this.column;
    }
    getColumnFilterName() {
        return this.columnModel.getDisplayNameForColumn(this.column, 'filterToolPanel', false);
    }
    addCssClassToTitleBar(cssClass) {
        this.eFilterToolPanelHeader.classList.add(cssClass);
    }
    addInIcon(iconName, eParent, column) {
        if (eParent == null) {
            return;
        }
        const eIcon = _.createIconNoSpan(iconName, this.gridOptionsService, column);
        eParent.appendChild(eIcon);
    }
    isFilterActive() {
        return this.filterManager.isFilterActive(this.column);
    }
    onFilterChanged() {
        _.setDisplayed(this.eFilterIcon, this.isFilterActive(), { skipAriaHidden: true });
        this.dispatchEvent({ type: Column.EVENT_FILTER_CHANGED });
    }
    onFilterDestroyed(event) {
        if (this.expanded &&
            (event.source === 'api' || event.source === 'paramsUpdated') &&
            event.column.getId() === this.column.getId() &&
            this.columnModel.getPrimaryColumn(this.column)) {
            // filter was visible and has been destroyed by the API or params changing. If the column still exists, need to recreate UI component
            this.removeFilterElement();
            this.addFilterElement(true);
        }
    }
    toggleExpanded() {
        this.expanded ? this.collapse() : this.expand();
    }
    expand() {
        if (this.expanded) {
            return;
        }
        this.expanded = true;
        _.setAriaExpanded(this.eFilterToolPanelHeader, true);
        _.setDisplayed(this.eExpandChecked, true);
        _.setDisplayed(this.eExpandUnchecked, false);
        this.addFilterElement();
        this.expandedCallback();
    }
    addFilterElement(suppressFocus) {
        const filterPanelWrapper = _.loadTemplate(/* html */ `<div class="ag-filter-toolpanel-instance-filter"></div>`);
        const filterWrapper = this.filterManager.getOrCreateFilterWrapper(this.column, 'TOOLBAR');
        if (!filterWrapper) {
            return;
        }
        const { filterPromise, guiPromise } = filterWrapper;
        filterPromise === null || filterPromise === void 0 ? void 0 : filterPromise.then(filter => {
            this.underlyingFilter = filter;
            if (!filter) {
                return;
            }
            guiPromise.then(filterContainerEl => {
                if (filterContainerEl) {
                    filterPanelWrapper.appendChild(filterContainerEl);
                }
                this.agFilterToolPanelBody.appendChild(filterPanelWrapper);
                if (filter.afterGuiAttached) {
                    filter.afterGuiAttached({ container: 'toolPanel', suppressFocus });
                }
            });
        });
    }
    collapse() {
        var _a, _b;
        if (!this.expanded) {
            return;
        }
        this.expanded = false;
        _.setAriaExpanded(this.eFilterToolPanelHeader, false);
        this.removeFilterElement();
        _.setDisplayed(this.eExpandChecked, false);
        _.setDisplayed(this.eExpandUnchecked, true);
        (_b = (_a = this.underlyingFilter) === null || _a === void 0 ? void 0 : _a.afterGuiDetached) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.expandedCallback();
    }
    removeFilterElement() {
        _.clearElement(this.agFilterToolPanelBody);
    }
    isExpanded() {
        return this.expanded;
    }
    refreshFilter(isDisplayed) {
        var _a;
        if (!this.expanded) {
            return;
        }
        const filter = this.underlyingFilter;
        if (!filter) {
            return;
        }
        if (isDisplayed) {
            // set filters should be updated when the filter has been changed elsewhere, i.e. via api. Note that we can't
            // use 'afterGuiAttached' to refresh the virtual list as it also focuses on the mini filter which changes the
            // scroll position in the filter list panel
            if (typeof filter.refreshVirtualList === 'function') {
                filter.refreshVirtualList();
            }
        }
        else {
            (_a = filter.afterGuiDetached) === null || _a === void 0 ? void 0 : _a.call(filter);
        }
    }
    onFilterOpened(event) {
        if (event.source !== 'COLUMN_MENU') {
            return;
        }
        if (event.column !== this.column) {
            return;
        }
        if (!this.expanded) {
            return;
        }
        this.collapse();
    }
}
ToolPanelFilterComp.TEMPLATE = `
        <div class="ag-filter-toolpanel-instance">
            <div class="ag-filter-toolpanel-header ag-filter-toolpanel-instance-header" ref="eFilterToolPanelHeader" role="button" aria-expanded="false">
                <div ref="eExpand" class="ag-filter-toolpanel-expand"></div>
                <span ref="eFilterName" class="ag-header-cell-text"></span>
                <span ref="eFilterIcon" class="ag-header-icon ag-filter-icon ag-filter-toolpanel-instance-header-icon" aria-hidden="true"></span>
            </div>
            <div class="ag-filter-toolpanel-instance-body ag-filter" ref="agFilterToolPanelBody"></div>
        </div>`;
__decorate$1v([
    RefSelector('eFilterToolPanelHeader')
], ToolPanelFilterComp.prototype, "eFilterToolPanelHeader", void 0);
__decorate$1v([
    RefSelector('eFilterName')
], ToolPanelFilterComp.prototype, "eFilterName", void 0);
__decorate$1v([
    RefSelector('agFilterToolPanelBody')
], ToolPanelFilterComp.prototype, "agFilterToolPanelBody", void 0);
__decorate$1v([
    RefSelector('eFilterIcon')
], ToolPanelFilterComp.prototype, "eFilterIcon", void 0);
__decorate$1v([
    RefSelector('eExpand')
], ToolPanelFilterComp.prototype, "eExpand", void 0);
__decorate$1v([
    Autowired('filterManager')
], ToolPanelFilterComp.prototype, "filterManager", void 0);
__decorate$1v([
    Autowired('columnModel')
], ToolPanelFilterComp.prototype, "columnModel", void 0);
__decorate$1v([
    PostConstruct
], ToolPanelFilterComp.prototype, "postConstruct", null);

var __decorate$1w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class ToolPanelFilterGroupComp extends Component {
    constructor(columnGroup, childFilterComps, expandedCallback, depth, showingColumn) {
        super();
        this.columnGroup = columnGroup;
        this.childFilterComps = childFilterComps;
        this.depth = depth;
        this.expandedCallback = expandedCallback;
        this.showingColumn = showingColumn;
    }
    preConstruct() {
        const groupParams = {
            cssIdentifier: 'filter-toolpanel',
            direction: 'vertical'
        };
        this.setTemplate(ToolPanelFilterGroupComp.TEMPLATE, { filterGroupComp: groupParams });
    }
    init() {
        this.setGroupTitle();
        this.filterGroupComp.setAlignItems('stretch');
        this.filterGroupComp.addCssClass(`ag-filter-toolpanel-group-level-${this.depth}`);
        this.filterGroupComp.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${this.depth}-header`);
        this.childFilterComps.forEach(filterComp => {
            this.filterGroupComp.addItem(filterComp);
            filterComp.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${this.depth + 1}-header`);
        });
        this.refreshFilterClass();
        this.addExpandCollapseListeners();
        this.addFilterChangedListeners();
        this.setupTooltip();
    }
    setupTooltip() {
        // we don't show tooltips for groups, as when the group expands, it's div contains the columns which also
        // have tooltips, so the tooltips would clash. Eg mouse over group, tooltip shows, mouse over column, another
        // tooltip shows but cos we didn't leave the group the group tooltip remains. this should be fixed in the future,
        // maybe the group shouldn't contain the children form a DOM perspective.
        if (!this.showingColumn) {
            return;
        }
        const refresh = () => {
            const newTooltipText = this.columnGroup.getColDef().headerTooltip;
            this.setTooltip(newTooltipText);
        };
        refresh();
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refresh);
    }
    getTooltipParams() {
        const res = super.getTooltipParams();
        res.location = 'filterToolPanelColumnGroup';
        return res;
    }
    addCssClassToTitleBar(cssClass) {
        this.filterGroupComp.addCssClassToTitleBar(cssClass);
    }
    refreshFilters(isDisplayed) {
        this.childFilterComps.forEach(filterComp => {
            if (filterComp instanceof ToolPanelFilterGroupComp) {
                filterComp.refreshFilters(isDisplayed);
            }
            else {
                filterComp.refreshFilter(isDisplayed);
            }
        });
    }
    isColumnGroup() {
        return this.columnGroup instanceof ProvidedColumnGroup;
    }
    isExpanded() {
        return this.filterGroupComp.isExpanded();
    }
    getChildren() {
        return this.childFilterComps;
    }
    getFilterGroupName() {
        return this.filterGroupName ? this.filterGroupName : '';
    }
    getFilterGroupId() {
        return this.columnGroup.getId();
    }
    hideGroupItem(hide, index) {
        this.filterGroupComp.hideItem(hide, index);
    }
    hideGroup(hide) {
        this.setDisplayed(!hide);
    }
    forEachToolPanelFilterChild(action) {
        this.childFilterComps.forEach(filterComp => {
            if (filterComp instanceof ToolPanelFilterComp) {
                action(filterComp);
            }
        });
    }
    addExpandCollapseListeners() {
        const expandListener = this.isColumnGroup() ?
            () => this.expandedCallback() :
            () => this.forEachToolPanelFilterChild(filterComp => filterComp.expand());
        const collapseListener = this.isColumnGroup() ?
            () => this.expandedCallback() :
            () => this.forEachToolPanelFilterChild(filterComp => filterComp.collapse());
        this.addManagedListener(this.filterGroupComp, AgGroupComponent.EVENT_EXPANDED, expandListener);
        this.addManagedListener(this.filterGroupComp, AgGroupComponent.EVENT_COLLAPSED, collapseListener);
    }
    getColumns() {
        if (this.columnGroup instanceof ProvidedColumnGroup) {
            return this.columnGroup.getLeafColumns();
        }
        return [this.columnGroup];
    }
    addFilterChangedListeners() {
        this.getColumns().forEach(column => {
            this.addManagedListener(column, Column.EVENT_FILTER_CHANGED, () => this.refreshFilterClass());
        });
        if (!(this.columnGroup instanceof ProvidedColumnGroup)) {
            this.addManagedListener(this.eventService, Events.EVENT_FILTER_OPENED, this.onFilterOpened.bind(this));
        }
    }
    refreshFilterClass() {
        const columns = this.getColumns();
        const anyChildFiltersActive = () => columns.some(col => col.isFilterActive());
        this.filterGroupComp.addOrRemoveCssClass('ag-has-filter', anyChildFiltersActive());
    }
    onFilterOpened(event) {
        // when a filter is opened elsewhere, i.e. column menu we close the filter comp so we also need to collapse
        // the column group. This approach means we don't need to try and sync filter models on the same column.
        if (event.source !== 'COLUMN_MENU') {
            return;
        }
        if (event.column !== this.columnGroup) {
            return;
        }
        if (!this.isExpanded()) {
            return;
        }
        this.collapse();
    }
    expand() {
        this.filterGroupComp.toggleGroupExpand(true);
    }
    collapse() {
        this.filterGroupComp.toggleGroupExpand(false);
    }
    setGroupTitle() {
        this.filterGroupName = (this.columnGroup instanceof ProvidedColumnGroup) ?
            this.getColumnGroupName(this.columnGroup) : this.getColumnName(this.columnGroup);
        this.filterGroupComp.setTitle(this.filterGroupName || '');
    }
    getColumnGroupName(columnGroup) {
        return this.columnModel.getDisplayNameForProvidedColumnGroup(null, columnGroup, 'filterToolPanel');
    }
    getColumnName(column) {
        return this.columnModel.getDisplayNameForColumn(column, 'filterToolPanel', false);
    }
    destroyFilters() {
        this.childFilterComps = this.destroyBeans(this.childFilterComps);
        _.clearElement(this.getGui());
    }
    destroy() {
        this.destroyFilters();
        super.destroy();
    }
}
ToolPanelFilterGroupComp.TEMPLATE = `<div class="ag-filter-toolpanel-group-wrapper">
            <ag-group-component ref="filterGroupComp"></ag-group-component>
        </div>`;
__decorate$1w([
    RefSelector('filterGroupComp')
], ToolPanelFilterGroupComp.prototype, "filterGroupComp", void 0);
__decorate$1w([
    Autowired('columnModel')
], ToolPanelFilterGroupComp.prototype, "columnModel", void 0);
__decorate$1w([
    PreConstruct
], ToolPanelFilterGroupComp.prototype, "preConstruct", null);
__decorate$1w([
    PostConstruct
], ToolPanelFilterGroupComp.prototype, "init", null);

var __decorate$1x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class FiltersToolPanelListPanel extends Component {
    constructor() {
        super(FiltersToolPanelListPanel.TEMPLATE);
        this.initialised = false;
        this.hasLoadedInitialState = false;
        this.isInitialState = false;
        this.filterGroupComps = [];
        // If a column drag is happening, we suppress handling the event until it has completed
        this.suppressOnColumnsChanged = false;
        this.onColumnsChangedPending = false;
    }
    init(params) {
        this.initialised = true;
        const defaultParams = this.gridOptionsService.addGridCommonParams({
            suppressExpandAll: false,
            suppressFilterSearch: false,
            suppressSyncLayoutWithGrid: false
        });
        _.mergeDeep(defaultParams, params);
        this.params = defaultParams;
        if (!this.params.suppressSyncLayoutWithGrid) {
            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, () => this.onColumnsChanged());
        }
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.onColumnsChanged());
        this.addManagedListener(this.eventService, Events.EVENT_TOOL_PANEL_VISIBLE_CHANGED, (event) => {
            // when re-entering the filters tool panel we need to refresh the virtual lists in the set filters in case
            // filters have been changed elsewhere, i.e. via an api call.
            if (event.key === 'filters') {
                this.refreshFilters(event.visible);
            }
        });
        this.addManagedListener(this.eventService, Events.EVENT_DRAG_STARTED, () => {
            this.suppressOnColumnsChanged = true;
        });
        this.addManagedListener(this.eventService, Events.EVENT_DRAG_STOPPED, () => {
            this.suppressOnColumnsChanged = false;
            if (this.onColumnsChangedPending) {
                this.onColumnsChangedPending = false;
                this.onColumnsChanged();
            }
        });
        if (this.columnModel.isReady()) {
            this.onColumnsChanged();
        }
        const ariaEl = this.getAriaElement();
        _.setAriaLive(ariaEl, 'assertive');
        _.setAriaAtomic(ariaEl, false);
        _.setAriaRelevant(ariaEl, 'text');
    }
    onColumnsChanged() {
        if (this.suppressOnColumnsChanged) {
            this.onColumnsChangedPending = true;
            return;
        }
        const pivotModeActive = this.columnModel.isPivotMode();
        const shouldSyncColumnLayoutWithGrid = !this.params.suppressSyncLayoutWithGrid && !pivotModeActive;
        shouldSyncColumnLayoutWithGrid ? this.syncFilterLayout() : this.buildTreeFromProvidedColumnDefs();
        this.refreshAriaLabel();
    }
    syncFilterLayout() {
        this.toolPanelColDefService.syncLayoutWithGrid(this.setFiltersLayout.bind(this));
        this.refreshAriaLabel();
    }
    buildTreeFromProvidedColumnDefs() {
        const columnTree = this.columnModel.getPrimaryColumnTree();
        this.recreateFilters(columnTree);
    }
    setFiltersLayout(colDefs) {
        const columnTree = this.toolPanelColDefService.createColumnTree(colDefs);
        this.recreateFilters(columnTree);
    }
    recreateFilters(columnTree) {
        // Underlying filter comp/element won't get recreated if the column still exists (the element just gets detached/re-attached).
        // We can therefore restore focus if an element in the filter tool panel was focused.
        const activeElement = this.gridOptionsService.getDocument().activeElement;
        if (!this.hasLoadedInitialState) {
            this.hasLoadedInitialState = true;
            this.isInitialState = !!this.params.initialState;
        }
        // Want to restore the expansion state where possible.
        const expansionState = this.getExpansionState();
        this.destroyFilters();
        this.filterGroupComps = this.recursivelyAddComps(columnTree, 0, expansionState);
        const len = this.filterGroupComps.length;
        if (len) {
            // skip the destroy function because this will be managed
            // by the `destroyFilters` function
            this.filterGroupComps.forEach(comp => this.appendChild(comp));
            this.setFirstAndLastVisible(0, len - 1);
        }
        // perform search if searchFilterText exists
        if (_.exists(this.searchFilterText)) {
            this.searchFilters(this.searchFilterText);
        }
        // notify header of expand
        this.fireExpandedEvent();
        // We only care about restoring focus if the originally focused element was in the filter tool panel.
        if (this.getGui().contains(activeElement)) {
            activeElement.focus();
        }
        this.isInitialState = false;
        this.refreshAriaLabel();
    }
    recursivelyAddComps(tree, depth, expansionState) {
        return _.flatten(tree.map(child => {
            if (child instanceof ProvidedColumnGroup) {
                return _.flatten(this.recursivelyAddFilterGroupComps(child, depth, expansionState));
            }
            const column = child;
            if (!this.shouldDisplayFilter(column)) {
                return [];
            }
            const hideFilterCompHeader = depth === 0;
            const filterComp = new ToolPanelFilterComp(hideFilterCompHeader, () => this.onFilterExpanded());
            this.createBean(filterComp);
            filterComp.setColumn(column);
            if (expansionState.get(column.getId())) {
                // Default state on creation and desired state are both collapsed. Expand if expanded before.
                filterComp.expand();
            }
            if (depth > 0) {
                return filterComp;
            }
            const filterGroupComp = this.createBean(new ToolPanelFilterGroupComp(column, [filterComp], this.onGroupExpanded.bind(this), depth, true));
            filterGroupComp.addCssClassToTitleBar('ag-filter-toolpanel-header');
            if (!expansionState.get(filterGroupComp.getFilterGroupId())) {
                // Default state on creation is expanded. Desired initial state is collapsed. Always collapse unless expanded before.
                filterGroupComp.collapse();
            }
            return filterGroupComp;
        }));
    }
    refreshAriaLabel() {
        const translate = this.localeService.getLocaleTextFunc();
        const filterListName = translate('ariaFilterPanelList', 'Filter List');
        const localeFilters = translate('filters', 'Filters');
        const eGui = this.getGui();
        const groupSelector = '.ag-filter-toolpanel-group-wrapper';
        const itemSelector = '.ag-filter-toolpanel-group-item';
        const hiddenSelector = '.ag-hidden';
        const visibleItems = eGui.querySelectorAll(`${itemSelector}:not(${groupSelector}, ${hiddenSelector})`);
        const totalVisibleItems = visibleItems.length;
        _.setAriaLabel(this.getAriaElement(), `${filterListName} ${totalVisibleItems} ${localeFilters}`);
    }
    recursivelyAddFilterGroupComps(columnGroup, depth, expansionState) {
        if (!this.filtersExistInChildren(columnGroup.getChildren())) {
            return;
        }
        const colGroupDef = columnGroup.getColGroupDef();
        if (colGroupDef && colGroupDef.suppressFiltersToolPanel) {
            return [];
        }
        const newDepth = columnGroup.isPadding() ? depth : depth + 1;
        const childFilterComps = _.flatten(this.recursivelyAddComps(columnGroup.getChildren(), newDepth, expansionState));
        if (columnGroup.isPadding()) {
            return childFilterComps;
        }
        const filterGroupComp = new ToolPanelFilterGroupComp(columnGroup, childFilterComps, this.onGroupExpanded.bind(this), depth, false);
        this.createBean(filterGroupComp);
        filterGroupComp.addCssClassToTitleBar('ag-filter-toolpanel-header');
        const expansionStateValue = expansionState.get(filterGroupComp.getFilterGroupId());
        if ((this.isInitialState && !expansionStateValue) || expansionStateValue === false) {
            // Default state on creation is expanded. Desired initial state is expanded. Only collapse if collapsed before or using initial state.
            filterGroupComp.collapse();
        }
        return [filterGroupComp];
    }
    filtersExistInChildren(tree) {
        return tree.some(child => {
            if (child instanceof ProvidedColumnGroup) {
                return this.filtersExistInChildren(child.getChildren());
            }
            return this.shouldDisplayFilter(child);
        });
    }
    shouldDisplayFilter(column) {
        const suppressFiltersToolPanel = column.getColDef() && column.getColDef().suppressFiltersToolPanel;
        return column.isFilterAllowed() && !suppressFiltersToolPanel;
    }
    getExpansionState() {
        const expansionState = new Map();
        if (this.isInitialState) {
            const { expandedColIds, expandedGroupIds } = this.params.initialState;
            expandedColIds.forEach(id => expansionState.set(id, true));
            expandedGroupIds.forEach(id => expansionState.set(id, true));
            return expansionState;
        }
        const recursiveGetExpansionState = (filterGroupComp) => {
            expansionState.set(filterGroupComp.getFilterGroupId(), filterGroupComp.isExpanded());
            filterGroupComp.getChildren().forEach(child => {
                if (child instanceof ToolPanelFilterGroupComp) {
                    recursiveGetExpansionState(child);
                }
                else {
                    expansionState.set(child.getColumn().getId(), child.isExpanded());
                }
            });
        };
        this.filterGroupComps.forEach(recursiveGetExpansionState);
        return expansionState;
    }
    // we don't support refreshing, but must implement because it's on the tool panel interface
    refresh() { }
    // lazy initialise the panel
    setVisible(visible) {
        super.setDisplayed(visible);
        if (visible && !this.initialised) {
            this.init(this.params);
        }
    }
    expandFilterGroups(expand, groupIds) {
        const updatedGroupIds = [];
        const updateGroupExpandState = (filterGroup) => {
            const groupId = filterGroup.getFilterGroupId();
            const shouldExpandOrCollapse = !groupIds || _.includes(groupIds, groupId);
            if (shouldExpandOrCollapse) {
                // don't expand 'column groups', i.e. top level columns wrapped in a group
                if (expand && filterGroup.isColumnGroup()) {
                    filterGroup.expand();
                }
                else {
                    filterGroup.collapse();
                }
                updatedGroupIds.push(groupId);
            }
            // recursively look for more groups to expand / collapse
            filterGroup.getChildren().forEach(child => {
                if (child instanceof ToolPanelFilterGroupComp) {
                    updateGroupExpandState(child);
                }
            });
        };
        this.filterGroupComps.forEach(updateGroupExpandState);
        // update header expand / collapse icon
        this.onGroupExpanded();
        if (groupIds) {
            const unrecognisedGroupIds = groupIds.filter(groupId => updatedGroupIds.indexOf(groupId) < 0);
            if (unrecognisedGroupIds.length > 0) {
                console.warn('AG Grid: unable to find groups for these supplied groupIds:', unrecognisedGroupIds);
            }
        }
    }
    expandFilters(expand, colIds) {
        const updatedColIds = [];
        const updateGroupExpandState = (filterComp) => {
            if (filterComp instanceof ToolPanelFilterGroupComp) {
                let anyChildrenChanged = false;
                filterComp.getChildren().forEach(child => {
                    const childUpdated = updateGroupExpandState(child);
                    if (childUpdated) {
                        if (expand) {
                            filterComp.expand();
                            anyChildrenChanged = true;
                        }
                        else if (!filterComp.isColumnGroup()) {
                            // we only collapse columns wrapped in groups
                            filterComp.collapse();
                        }
                    }
                });
                return anyChildrenChanged;
            }
            const colId = filterComp.getColumn().getColId();
            const updateFilterExpandState = !colIds || _.includes(colIds, colId);
            if (updateFilterExpandState) {
                expand ? filterComp.expand() : filterComp.collapse();
                updatedColIds.push(colId);
            }
            return updateFilterExpandState;
        };
        this.filterGroupComps.forEach(updateGroupExpandState);
        // update header expand / collapse icon
        this.onGroupExpanded();
        if (colIds) {
            const unrecognisedColIds = colIds.filter(colId => updatedColIds.indexOf(colId) < 0);
            if (unrecognisedColIds.length > 0) {
                console.warn('AG Grid: unable to find columns for these supplied colIds:', unrecognisedColIds);
            }
        }
    }
    onGroupExpanded() {
        this.fireExpandedEvent();
    }
    onFilterExpanded() {
        this.dispatchEvent({ type: 'filterExpanded' });
    }
    fireExpandedEvent() {
        let expandedCount = 0;
        let notExpandedCount = 0;
        const updateExpandCounts = (filterGroup) => {
            if (!filterGroup.isColumnGroup()) {
                return;
            }
            filterGroup.isExpanded() ? expandedCount++ : notExpandedCount++;
            filterGroup.getChildren().forEach(child => {
                if (child instanceof ToolPanelFilterGroupComp) {
                    updateExpandCounts(child);
                }
            });
        };
        this.filterGroupComps.forEach(updateExpandCounts);
        let state;
        if (expandedCount > 0 && notExpandedCount > 0) {
            state = EXPAND_STATE.INDETERMINATE;
        }
        else if (notExpandedCount > 0) {
            state = EXPAND_STATE.COLLAPSED;
        }
        else {
            state = EXPAND_STATE.EXPANDED;
        }
        this.dispatchEvent({ type: 'groupExpanded', state: state });
    }
    performFilterSearch(searchText) {
        this.searchFilterText = _.exists(searchText) ? searchText.toLowerCase() : null;
        this.searchFilters(this.searchFilterText);
    }
    searchFilters(searchFilter) {
        const passesFilter = (groupName) => {
            return !_.exists(searchFilter) || groupName.toLowerCase().indexOf(searchFilter) !== -1;
        };
        const recursivelySearch = (filterItem, parentPasses) => {
            if (!(filterItem instanceof ToolPanelFilterGroupComp)) {
                return passesFilter(filterItem.getColumnFilterName() || '');
            }
            const children = filterItem.getChildren();
            const groupNamePasses = passesFilter(filterItem.getFilterGroupName());
            // if group or parent already passed - ensure this group and all children are visible
            const alreadyPassed = parentPasses || groupNamePasses;
            if (alreadyPassed) {
                // ensure group visible
                filterItem.hideGroup(false);
                // ensure all children are visible
                for (let i = 0; i < children.length; i++) {
                    recursivelySearch(children[i], alreadyPassed);
                    filterItem.hideGroupItem(false, i);
                }
                return true;
            }
            // hide group item filters
            let anyChildPasses = false;
            children.forEach((child, index) => {
                const childPasses = recursivelySearch(child, parentPasses);
                filterItem.hideGroupItem(!childPasses, index);
                if (childPasses) {
                    anyChildPasses = true;
                }
            });
            // hide group if no children pass
            filterItem.hideGroup(!anyChildPasses);
            return anyChildPasses;
        };
        let firstVisible;
        let lastVisible;
        this.filterGroupComps.forEach((filterGroup, idx) => {
            recursivelySearch(filterGroup, false);
            if (firstVisible === undefined) {
                if (!filterGroup.containsCssClass('ag-hidden')) {
                    firstVisible = idx;
                    lastVisible = idx;
                }
            }
            else if (!filterGroup.containsCssClass('ag-hidden') && lastVisible !== idx) {
                lastVisible = idx;
            }
        });
        this.setFirstAndLastVisible(firstVisible, lastVisible);
        this.refreshAriaLabel();
    }
    setFirstAndLastVisible(firstIdx, lastIdx) {
        this.filterGroupComps.forEach((filterGroup, idx) => {
            filterGroup.removeCssClass('ag-first-group-visible');
            filterGroup.removeCssClass('ag-last-group-visible');
            if (idx === firstIdx) {
                filterGroup.addCssClass('ag-first-group-visible');
            }
            if (idx === lastIdx) {
                filterGroup.addCssClass('ag-last-group-visible');
            }
        });
    }
    refreshFilters(isDisplayed) {
        this.filterGroupComps.forEach(filterGroupComp => filterGroupComp.refreshFilters(isDisplayed));
    }
    getExpandedFiltersAndGroups() {
        const expandedGroupIds = [];
        const expandedColIds = new Set();
        const getExpandedFiltersAndGroups = (filterComp) => {
            if (filterComp instanceof ToolPanelFilterGroupComp) {
                filterComp.getChildren().forEach(child => getExpandedFiltersAndGroups(child));
                const groupId = filterComp.getFilterGroupId();
                if (filterComp.isExpanded() && !expandedColIds.has(groupId)) {
                    expandedGroupIds.push(groupId);
                }
            }
            else {
                if (filterComp.isExpanded()) {
                    expandedColIds.add(filterComp.getColumn().getColId());
                }
            }
        };
        this.filterGroupComps.forEach(getExpandedFiltersAndGroups);
        return { expandedGroupIds, expandedColIds: Array.from(expandedColIds) };
    }
    destroyFilters() {
        this.filterGroupComps = this.destroyBeans(this.filterGroupComps);
        _.clearElement(this.getGui());
    }
    destroy() {
        this.destroyFilters();
        super.destroy();
    }
}
FiltersToolPanelListPanel.TEMPLATE = `<div class="ag-filter-list-panel"></div>`;
__decorate$1x([
    Autowired('toolPanelColDefService')
], FiltersToolPanelListPanel.prototype, "toolPanelColDefService", void 0);
__decorate$1x([
    Autowired('columnModel')
], FiltersToolPanelListPanel.prototype, "columnModel", void 0);

var __decorate$1y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class FiltersToolPanel extends Component {
    constructor() {
        super(FiltersToolPanel.TEMPLATE);
        this.initialised = false;
        this.listenerDestroyFuncs = [];
    }
    init(params) {
        // if initialised is true, means this is a refresh
        if (this.initialised) {
            this.listenerDestroyFuncs.forEach(func => func());
            this.listenerDestroyFuncs = [];
        }
        this.initialised = true;
        const defaultParams = this.gridOptionsService.addGridCommonParams({
            suppressExpandAll: false,
            suppressFilterSearch: false,
            suppressSyncLayoutWithGrid: false
        });
        this.params = Object.assign(Object.assign({}, defaultParams), params);
        this.filtersToolPanelHeaderPanel.init(this.params);
        this.filtersToolPanelListPanel.init(this.params);
        const hideExpand = this.params.suppressExpandAll;
        const hideSearch = this.params.suppressFilterSearch;
        if (hideExpand && hideSearch) {
            this.filtersToolPanelHeaderPanel.setDisplayed(false);
        }
        // this is necessary to prevent a memory leak while refreshing the tool panel
        this.listenerDestroyFuncs.push(this.addManagedListener(this.filtersToolPanelHeaderPanel, 'expandAll', this.onExpandAll.bind(this)), this.addManagedListener(this.filtersToolPanelHeaderPanel, 'collapseAll', this.onCollapseAll.bind(this)), this.addManagedListener(this.filtersToolPanelHeaderPanel, 'searchChanged', this.onSearchChanged.bind(this)), this.addManagedListener(this.filtersToolPanelListPanel, 'filterExpanded', this.onFilterExpanded.bind(this)), this.addManagedListener(this.filtersToolPanelListPanel, 'groupExpanded', this.onGroupExpanded.bind(this)));
    }
    // lazy initialise the panel
    setVisible(visible) {
        super.setDisplayed(visible);
        if (visible && !this.initialised) {
            this.init(this.params);
        }
    }
    onExpandAll() {
        this.filtersToolPanelListPanel.expandFilterGroups(true);
    }
    onCollapseAll() {
        this.filtersToolPanelListPanel.expandFilterGroups(false);
    }
    onSearchChanged(event) {
        this.filtersToolPanelListPanel.performFilterSearch(event.searchText);
    }
    setFilterLayout(colDefs) {
        this.filtersToolPanelListPanel.setFiltersLayout(colDefs);
    }
    onFilterExpanded() {
        this.params.onStateUpdated();
    }
    onGroupExpanded(event) {
        this.filtersToolPanelHeaderPanel.setExpandState(event.state);
        this.params.onStateUpdated();
    }
    expandFilterGroups(groupIds) {
        this.filtersToolPanelListPanel.expandFilterGroups(true, groupIds);
    }
    collapseFilterGroups(groupIds) {
        this.filtersToolPanelListPanel.expandFilterGroups(false, groupIds);
    }
    expandFilters(colIds) {
        this.filtersToolPanelListPanel.expandFilters(true, colIds);
    }
    collapseFilters(colIds) {
        this.filtersToolPanelListPanel.expandFilters(false, colIds);
    }
    syncLayoutWithGrid() {
        this.filtersToolPanelListPanel.syncFilterLayout();
    }
    refresh(params) {
        this.init(params);
        return true;
    }
    getState() {
        return this.filtersToolPanelListPanel.getExpandedFiltersAndGroups();
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
}
FiltersToolPanel.TEMPLATE = `<div class="ag-filter-toolpanel">
            <ag-filters-tool-panel-header ref="filtersToolPanelHeaderPanel"></ag-filters-tool-panel-header>
            <ag-filters-tool-panel-list ref="filtersToolPanelListPanel"></ag-filters-tool-panel-list>
         </div>`;
__decorate$1y([
    RefSelector('filtersToolPanelHeaderPanel')
], FiltersToolPanel.prototype, "filtersToolPanelHeaderPanel", void 0);
__decorate$1y([
    RefSelector('filtersToolPanelListPanel')
], FiltersToolPanel.prototype, "filtersToolPanelListPanel", void 0);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$b = '31.1.1';

const FiltersToolPanelModule = {
    version: VERSION$b,
    moduleName: ModuleNames.FiltersToolPanelModule,
    beans: [],
    agStackComponents: [
        { componentName: 'AgFiltersToolPanelHeader', componentClass: FiltersToolPanelHeaderPanel },
        { componentName: 'AgFiltersToolPanelList', componentClass: FiltersToolPanelListPanel }
    ],
    userComponents: [
        { componentName: 'agFiltersToolPanel', componentClass: FiltersToolPanel },
    ],
    dependantModules: [
        SideBarModule,
        EnterpriseCoreModule
    ]
};

var __decorate$1z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class DetailCellRendererCtrl extends BeanStub {
    constructor() {
        super(...arguments);
        this.loadRowDataVersion = 0;
    }
    init(comp, params) {
        this.params = params;
        this.comp = comp;
        const doNothingBecauseInsidePinnedSection = params.pinned != null;
        if (doNothingBecauseInsidePinnedSection) {
            return;
        }
        this.setAutoHeightClasses();
        this.setupRefreshStrategy();
        this.addThemeToDetailGrid();
        this.createDetailGrid();
        this.loadRowData();
        this.addManagedListener(this.eventService, Events.EVENT_FULL_WIDTH_ROW_FOCUSED, this.onFullWidthRowFocused.bind(this));
    }
    onFullWidthRowFocused(e) {
        const params = this.params;
        const row = { rowIndex: params.node.rowIndex, rowPinned: params.node.rowPinned };
        const eventRow = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
        const isSameRow = this.rowPositionUtils.sameRow(row, eventRow);
        if (!isSameRow) {
            return;
        }
        this.focusService.focusInto(this.comp.getGui(), e.fromBelow);
    }
    setAutoHeightClasses() {
        const autoHeight = this.gridOptionsService.get('detailRowAutoHeight');
        const parentClass = autoHeight ? 'ag-details-row-auto-height' : 'ag-details-row-fixed-height';
        const detailClass = autoHeight ? 'ag-details-grid-auto-height' : 'ag-details-grid-fixed-height';
        this.comp.addOrRemoveCssClass(parentClass, true);
        this.comp.addOrRemoveDetailGridCssClass(detailClass, true);
    }
    setupRefreshStrategy() {
        const providedStrategy = this.params.refreshStrategy;
        const validSelection = providedStrategy == 'everything' || providedStrategy == 'nothing' || providedStrategy == 'rows';
        if (validSelection) {
            this.refreshStrategy = providedStrategy;
            return;
        }
        if (providedStrategy != null) {
            console.warn("AG Grid: invalid cellRendererParams.refreshStrategy = '" + providedStrategy +
                "' supplied, defaulting to refreshStrategy = 'rows'.");
        }
        this.refreshStrategy = 'rows';
    }
    addThemeToDetailGrid() {
        // this is needed by environment service of the child grid, the class needs to be on
        // the grid div itself - the browser's CSS on the other hand just inherits from the parent grid theme.
        const { theme } = this.environment.getTheme();
        if (theme) {
            this.comp.addOrRemoveDetailGridCssClass(theme, true);
        }
    }
    createDetailGrid() {
        if (_.missing(this.params.detailGridOptions)) {
            console.warn('AG Grid: could not find detail grid options for master detail, ' +
                'please set gridOptions.detailCellRendererParams.detailGridOptions');
            return;
        }
        const autoHeight = this.gridOptionsService.get('detailRowAutoHeight');
        // we clone the detail grid options, as otherwise it would be shared
        // across many instances, and that would be a problem because we set
        // api and columnApi into gridOptions
        const gridOptions = Object.assign({}, this.params.detailGridOptions);
        if (autoHeight) {
            gridOptions.domLayout = 'autoHeight';
        }
        this.comp.setDetailGrid(gridOptions);
    }
    registerDetailWithMaster(api, columnApi) {
        const rowId = this.params.node.id;
        const masterGridApi = this.params.api;
        const gridInfo = {
            id: rowId,
            api: api,
            columnApi: columnApi
        };
        const rowNode = this.params.node;
        // register with api
        masterGridApi.addDetailGridInfo(rowId, gridInfo);
        // register with node
        rowNode.detailGridInfo = gridInfo;
        this.addDestroyFunc(() => {
            // the gridInfo can be stale if a refresh happens and
            // a new row is created before the old one is destroyed.
            if (rowNode.detailGridInfo !== gridInfo) {
                return;
            }
            masterGridApi.removeDetailGridInfo(rowId); // unregister from api
            rowNode.detailGridInfo = null; // unregister from node
        });
    }
    loadRowData() {
        var _a, _b, _c;
        // in case a refresh happens before the last refresh completes (as we depend on async
        // application logic) we keep track on what the latest call was.
        this.loadRowDataVersion++;
        const versionThisCall = this.loadRowDataVersion;
        if (((_a = this.params.detailGridOptions) === null || _a === void 0 ? void 0 : _a.rowModelType) === 'serverSide') {
            const node = this.params.node;
            (_c = (_b = node.detailGridInfo) === null || _b === void 0 ? void 0 : _b.api) === null || _c === void 0 ? void 0 : _c.refreshServerSide({ purge: true });
            return;
        }
        const userFunc = this.params.getDetailRowData;
        if (!userFunc) {
            console.warn('AG Grid: could not find getDetailRowData for master / detail, ' +
                'please set gridOptions.detailCellRendererParams.getDetailRowData');
            return;
        }
        const successCallback = (rowData) => {
            const mostRecentCall = this.loadRowDataVersion === versionThisCall;
            if (mostRecentCall) {
                this.comp.setRowData(rowData);
            }
        };
        const funcParams = {
            node: this.params.node,
            // we take data from node, rather than params.data
            // as the data could have been updated with new instance
            data: this.params.node.data,
            successCallback: successCallback,
            context: this.gridOptionsService.getGridCommonParams().context
        };
        userFunc(funcParams);
    }
    refresh() {
        const GET_GRID_TO_REFRESH = false;
        const GET_GRID_TO_DO_NOTHING = true;
        switch (this.refreshStrategy) {
            // ignore this refresh, make grid think we've refreshed but do nothing
            case 'nothing': return GET_GRID_TO_DO_NOTHING;
            // grid will destroy and recreate the cell
            case 'everything': return GET_GRID_TO_REFRESH;
        }
        // do the refresh here, and tell the grid to do nothing
        this.loadRowData();
        return GET_GRID_TO_DO_NOTHING;
    }
}
__decorate$1z([
    Autowired('rowPositionUtils')
], DetailCellRendererCtrl.prototype, "rowPositionUtils", void 0);
__decorate$1z([
    Autowired('focusService')
], DetailCellRendererCtrl.prototype, "focusService", void 0);

var __decorate$1A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class DetailCellRenderer extends Component {
    init(params) {
        this.params = params;
        this.selectAndSetTemplate();
        const compProxy = {
            addOrRemoveCssClass: (cssClassName, on) => this.addOrRemoveCssClass(cssClassName, on),
            addOrRemoveDetailGridCssClass: (cssClassName, on) => this.eDetailGrid.classList.toggle(cssClassName, on),
            setDetailGrid: gridOptions => this.setDetailGrid(gridOptions),
            setRowData: rowData => this.setRowData(rowData),
            getGui: () => this.eDetailGrid
        };
        this.ctrl = this.createManagedBean(new DetailCellRendererCtrl());
        this.ctrl.init(compProxy, params);
    }
    refresh() {
        return this.ctrl && this.ctrl.refresh();
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
    selectAndSetTemplate() {
        if (this.params.pinned) {
            this.setTemplate('<div class="ag-details-row"></div>');
            return;
        }
        const setDefaultTemplate = () => {
            this.setTemplate(DetailCellRenderer.TEMPLATE);
        };
        if (_.missing(this.params.template)) {
            // use default template
            setDefaultTemplate();
        }
        else {
            // use user provided template
            if (typeof this.params.template === 'string') {
                this.setTemplate(this.params.template);
            }
            else if (typeof this.params.template === 'function') {
                const templateFunc = this.params.template;
                const template = templateFunc(this.params);
                this.setTemplate(template);
            }
            else {
                console.warn('AG Grid: detailCellRendererParams.template should be function or string');
                setDefaultTemplate();
            }
        }
        if (this.eDetailGrid == null) {
            console.warn('AG Grid: reference to eDetailGrid was missing from the details template. ' +
                'Please add ref="eDetailGrid" to the template.');
        }
    }
    setDetailGrid(gridOptions) {
        if (!this.eDetailGrid) {
            return;
        }
        // AG-1715
        // this is only needed when suppressReactUi=true, once we remove the old way
        // of doing react, and Master / Details is all native React, then we
        // can remove this code.
        const agGridReact = this.context.getBean('agGridReact');
        const agGridReactCloned = agGridReact ? _.cloneObject(agGridReact) : undefined;
        // when we create detail grid, the detail grid needs frameworkComponentWrapper so that
        // it created child components correctly, ie  Angular detail grid can have Angular cell renderer.
        // this is only used by Angular and Vue, as React uses native React AG Grid detail grids
        const frameworkComponentWrapper = this.context.getBean('frameworkComponentWrapper');
        const frameworkOverrides = this.getFrameworkOverrides();
        const api = createGrid(this.eDetailGrid, gridOptions, {
            frameworkOverrides,
            providedBeanInstances: {
                agGridReact: agGridReactCloned,
                frameworkComponentWrapper: frameworkComponentWrapper,
            },
            modules: ModuleRegistry.__getGridRegisteredModules(this.params.api.getGridId()),
        });
        this.detailApi = api;
        this.ctrl.registerDetailWithMaster(api, new ColumnApi(api));
        this.addDestroyFunc(() => {
            api === null || api === void 0 ? void 0 : api.destroy();
        });
    }
    setRowData(rowData) {
        // ensure detail grid api still exists (grid may be destroyed when async call tries to set data)
        this.detailApi && this.detailApi.setGridOption('rowData', rowData);
    }
}
DetailCellRenderer.TEMPLATE = `<div class="ag-details-row" role="gridcell">
            <div ref="eDetailGrid" class="ag-details-grid" role="presentation"></div>
        </div>`;
__decorate$1A([
    RefSelector('eDetailGrid')
], DetailCellRenderer.prototype, "eDetailGrid", void 0);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$c = '31.1.1';

const MasterDetailModule = {
    version: VERSION$c,
    moduleName: ModuleNames.MasterDetailModule,
    beans: [],
    userComponents: [
        { componentName: 'agDetailCellRenderer', componentClass: DetailCellRenderer }
    ],
    controllers: [
        { controllerName: 'detailCellRenderer', controllerClass: DetailCellRendererCtrl }
    ],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

var __decorate$1B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let EnterpriseMenuFactory = class EnterpriseMenuFactory extends BeanStub {
    hideActiveMenu() {
        this.destroyBean(this.activeMenu);
    }
    showMenuAfterMouseEvent(column, mouseEvent, containerType, filtersOnly) {
        const defaultTab = filtersOnly ? 'filterMenuTab' : undefined;
        this.showMenu(column, (menu) => {
            var _a;
            const ePopup = menu.getGui();
            this.popupService.positionPopupUnderMouseEvent({
                type: containerType,
                column,
                mouseEvent,
                ePopup
            });
            if (defaultTab) {
                (_a = menu.showTab) === null || _a === void 0 ? void 0 : _a.call(menu, defaultTab);
            }
            this.dispatchVisibleChangedEvent(true, false, column, defaultTab);
        }, containerType, defaultTab, undefined, mouseEvent.target);
    }
    showMenuAfterButtonClick(column, eventSource, containerType, filtersOnly) {
        let multiplier = -1;
        let alignSide = 'left';
        if (this.gridOptionsService.get('enableRtl')) {
            multiplier = 1;
            alignSide = 'right';
        }
        const defaultTab = filtersOnly ? 'filterMenuTab' : undefined;
        const restrictToTabs = defaultTab ? [defaultTab] : undefined;
        const isLegacyMenuEnabled = this.menuService.isLegacyMenuEnabled();
        let nudgeX = (isLegacyMenuEnabled ? 9 : 4) * multiplier;
        let nudgeY = isLegacyMenuEnabled ? -23 : 4;
        this.showMenu(column, (menu) => {
            var _a;
            const ePopup = menu.getGui();
            this.popupService.positionPopupByComponent({
                type: containerType,
                column,
                eventSource,
                ePopup,
                alignSide,
                nudgeX,
                nudgeY,
                position: 'under',
                keepWithinBounds: true,
            });
            if (defaultTab) {
                (_a = menu.showTab) === null || _a === void 0 ? void 0 : _a.call(menu, defaultTab);
            }
            this.dispatchVisibleChangedEvent(true, false, column, defaultTab);
        }, containerType, defaultTab, restrictToTabs, eventSource);
    }
    showMenu(column, positionCallback, containerType, defaultTab, restrictToTabs, eventSource) {
        var _a;
        const { menu, eMenuGui, anchorToElement, restoreFocusParams } = this.getMenuParams(column, restrictToTabs, eventSource);
        const closedFuncs = [];
        if (column) {
            // if we don't have a column, then the menu wasn't launched via keyboard navigation
            closedFuncs.push((e) => {
                const eComp = menu.getGui();
                this.destroyBean(menu);
                column === null || column === void 0 ? void 0 : column.setMenuVisible(false, 'contextMenu');
                this.menuUtils.restoreFocusOnClose(restoreFocusParams, eComp, e);
            });
        }
        const translate = this.localeService.getLocaleTextFunc();
        // need to show filter before positioning, as only after filter
        // is visible can we find out what the width of it is
        const addPopupRes = this.popupService.addPopup({
            modal: true,
            eChild: eMenuGui,
            closeOnEsc: true,
            closedCallback: (e) => {
                closedFuncs.forEach(f => f(e));
                this.dispatchVisibleChangedEvent(false, false, column, defaultTab);
            },
            afterGuiAttached: params => menu.afterGuiAttached(Object.assign({}, { container: containerType }, params)),
            // if defaultTab is not present, positionCallback will be called
            // after `showTabBasedOnPreviousSelection` is called.
            positionCallback: !!defaultTab ? () => positionCallback(menu) : undefined,
            ariaLabel: translate('ariaLabelColumnMenu', 'Column Menu')
        });
        if (!defaultTab) {
            (_a = menu.showTabBasedOnPreviousSelection) === null || _a === void 0 ? void 0 : _a.call(menu);
            // reposition the menu because the method above could load
            // an element that is bigger than enterpriseMenu header.
            positionCallback(menu);
        }
        if (this.menuService.isColumnMenuAnchoringEnabled()) {
            // if user starts showing / hiding columns, or otherwise move the underlying column
            // for this menu, we want to stop tracking the menu with the column position. otherwise
            // the menu would move as the user is using the columns tab inside the menu.
            const stopAnchoringPromise = this.popupService.setPopupPositionRelatedToElement(eMenuGui, anchorToElement);
            if (stopAnchoringPromise && column) {
                this.addStopAnchoring(stopAnchoringPromise, column, closedFuncs);
            }
        }
        menu.addEventListener(TabbedColumnMenu.EVENT_TAB_SELECTED, (event) => {
            this.dispatchVisibleChangedEvent(false, true, column);
            this.lastSelectedTab = event.key;
            this.dispatchVisibleChangedEvent(true, true, column);
        });
        column === null || column === void 0 ? void 0 : column.setMenuVisible(true, 'contextMenu');
        this.activeMenu = menu;
        menu.addEventListener(BeanStub.EVENT_DESTROYED, () => {
            if (this.activeMenu === menu) {
                this.activeMenu = null;
            }
        });
    }
    addStopAnchoring(stopAnchoringPromise, column, closedFuncsArr) {
        stopAnchoringPromise.then((stopAnchoringFunc) => {
            column.addEventListener('leftChanged', stopAnchoringFunc);
            column.addEventListener('visibleChanged', stopAnchoringFunc);
            closedFuncsArr.push(() => {
                column.removeEventListener('leftChanged', stopAnchoringFunc);
                column.removeEventListener('visibleChanged', stopAnchoringFunc);
            });
        });
    }
    getMenuParams(column, restrictToTabs, eventSource) {
        const restoreFocusParams = {
            column,
            headerPosition: this.focusService.getFocusedHeader(),
            columnIndex: this.columnModel.getAllDisplayedColumns().indexOf(column),
            eventSource
        };
        const menu = this.createMenu(column, restoreFocusParams, restrictToTabs, eventSource);
        return {
            menu,
            eMenuGui: menu.getGui(),
            anchorToElement: eventSource || this.ctrlsService.getGridBodyCtrl().getGui(),
            restoreFocusParams
        };
    }
    createMenu(column, restoreFocusParams, restrictToTabs, eventSource) {
        if (this.menuService.isLegacyMenuEnabled()) {
            return this.createBean(new TabbedColumnMenu(column, restoreFocusParams, this.lastSelectedTab, restrictToTabs, eventSource));
        }
        else {
            return this.createBean(new ColumnContextMenu(column, restoreFocusParams, eventSource));
        }
    }
    dispatchVisibleChangedEvent(visible, switchingTab, column, defaultTab) {
        var _a, _b;
        const event = {
            type: Events.EVENT_COLUMN_MENU_VISIBLE_CHANGED,
            visible,
            switchingTab,
            key: ((_b = (_a = this.lastSelectedTab) !== null && _a !== void 0 ? _a : defaultTab) !== null && _b !== void 0 ? _b : (this.menuService.isLegacyMenuEnabled() ? TabbedColumnMenu.TAB_GENERAL : 'columnMenu')),
            column: column !== null && column !== void 0 ? column : null
        };
        this.eventService.dispatchEvent(event);
    }
    isMenuEnabled(column) {
        var _a;
        if (!this.menuService.isLegacyMenuEnabled()) {
            return true;
        }
        // Determine whether there are any tabs to show in the menu, given that the filter tab may be hidden
        const isFilterDisabled = !this.filterManager.isFilterAllowed(column);
        const tabs = (_a = column.getColDef().menuTabs) !== null && _a !== void 0 ? _a : TabbedColumnMenu.TABS_DEFAULT;
        const numActiveTabs = isFilterDisabled && tabs.includes(TabbedColumnMenu.TAB_FILTER)
            ? tabs.length - 1
            : tabs.length;
        return numActiveTabs > 0;
    }
    showMenuAfterContextMenuEvent(column, mouseEvent, touchEvent) {
        this.menuUtils.onContextMenu(mouseEvent, touchEvent, (eventOrTouch) => {
            this.showMenuAfterMouseEvent(column, eventOrTouch, 'columnMenu');
            return true;
        });
    }
};
__decorate$1B([
    Autowired('popupService')
], EnterpriseMenuFactory.prototype, "popupService", void 0);
__decorate$1B([
    Autowired('focusService')
], EnterpriseMenuFactory.prototype, "focusService", void 0);
__decorate$1B([
    Autowired('ctrlsService')
], EnterpriseMenuFactory.prototype, "ctrlsService", void 0);
__decorate$1B([
    Autowired('columnModel')
], EnterpriseMenuFactory.prototype, "columnModel", void 0);
__decorate$1B([
    Autowired('filterManager')
], EnterpriseMenuFactory.prototype, "filterManager", void 0);
__decorate$1B([
    Autowired('menuUtils')
], EnterpriseMenuFactory.prototype, "menuUtils", void 0);
__decorate$1B([
    Autowired('menuService')
], EnterpriseMenuFactory.prototype, "menuService", void 0);
EnterpriseMenuFactory = __decorate$1B([
    Bean('enterpriseMenuFactory')
], EnterpriseMenuFactory);
class TabbedColumnMenu extends BeanStub {
    constructor(column, restoreFocusParams, initialSelection, restrictTo, sourceElement) {
        super();
        this.column = column;
        this.restoreFocusParams = restoreFocusParams;
        this.initialSelection = initialSelection;
        this.restrictTo = restrictTo;
        this.sourceElement = sourceElement;
        this.tabFactories = {};
        this.includeChecks = {};
        this.tabFactories[TabbedColumnMenu.TAB_GENERAL] = this.createMainPanel.bind(this);
        this.tabFactories[TabbedColumnMenu.TAB_FILTER] = this.createFilterPanel.bind(this);
        this.tabFactories[TabbedColumnMenu.TAB_COLUMNS] = this.createColumnsPanel.bind(this);
        this.includeChecks[TabbedColumnMenu.TAB_GENERAL] = () => true;
        this.includeChecks[TabbedColumnMenu.TAB_FILTER] = () => column ? this.filterManager.isFilterAllowed(column) : false;
        this.includeChecks[TabbedColumnMenu.TAB_COLUMNS] = () => true;
    }
    init() {
        const tabs = this.getTabsToCreate().map(name => this.createTab(name));
        this.tabbedLayout = new TabbedLayout({
            items: tabs,
            cssClass: 'ag-menu',
            onActiveItemClicked: this.onHidePopup.bind(this),
            onItemClicked: this.onTabItemClicked.bind(this)
        });
        this.createBean(this.tabbedLayout);
        if (this.mainMenuList) {
            this.mainMenuList.setParentComponent(this.tabbedLayout);
        }
        this.addDestroyFunc(() => this.destroyBean(this.tabbedLayout));
    }
    getTabsToCreate() {
        var _a, _b;
        if (this.restrictTo) {
            return this.restrictTo;
        }
        return ((_b = (_a = this.column) === null || _a === void 0 ? void 0 : _a.getColDef().menuTabs) !== null && _b !== void 0 ? _b : TabbedColumnMenu.TABS_DEFAULT)
            .filter(tabName => this.isValidMenuTabItem(tabName))
            .filter(tabName => this.isNotSuppressed(tabName))
            .filter(tabName => this.isModuleLoaded(tabName));
    }
    isModuleLoaded(menuTabName) {
        if (menuTabName === TabbedColumnMenu.TAB_COLUMNS) {
            return ModuleRegistry.__isRegistered(ModuleNames.ColumnsToolPanelModule, this.context.getGridId());
        }
        return true;
    }
    isValidMenuTabItem(menuTabName) {
        let isValid = true;
        let itemsToConsider = TabbedColumnMenu.TABS_DEFAULT;
        if (this.restrictTo != null) {
            isValid = this.restrictTo.indexOf(menuTabName) > -1;
            itemsToConsider = this.restrictTo;
        }
        isValid = isValid && TabbedColumnMenu.TABS_DEFAULT.indexOf(menuTabName) > -1;
        if (!isValid) {
            console.warn(`AG Grid: Trying to render an invalid menu item '${menuTabName}'. Check that your 'menuTabs' contains one of [${itemsToConsider}]`);
        }
        return isValid;
    }
    isNotSuppressed(menuTabName) {
        return this.includeChecks[menuTabName]();
    }
    createTab(name) {
        return this.tabFactories[name]();
    }
    showTabBasedOnPreviousSelection() {
        // show the tab the user was on last time they had a menu open
        this.showTab(this.initialSelection);
    }
    showTab(toShow) {
        if (this.tabItemColumns && toShow === TabbedColumnMenu.TAB_COLUMNS) {
            this.tabbedLayout.showItem(this.tabItemColumns);
        }
        else if (this.tabItemFilter && toShow === TabbedColumnMenu.TAB_FILTER) {
            this.tabbedLayout.showItem(this.tabItemFilter);
        }
        else if (this.tabItemGeneral && toShow === TabbedColumnMenu.TAB_GENERAL) {
            this.tabbedLayout.showItem(this.tabItemGeneral);
        }
        else {
            this.tabbedLayout.showFirstItem();
        }
    }
    onTabItemClicked(event) {
        let key = null;
        switch (event.item) {
            case this.tabItemColumns:
                key = TabbedColumnMenu.TAB_COLUMNS;
                break;
            case this.tabItemFilter:
                key = TabbedColumnMenu.TAB_FILTER;
                break;
            case this.tabItemGeneral:
                key = TabbedColumnMenu.TAB_GENERAL;
                break;
        }
        if (key) {
            this.activateTab(key);
        }
    }
    activateTab(tab) {
        const ev = {
            type: TabbedColumnMenu.EVENT_TAB_SELECTED,
            key: tab
        };
        this.dispatchEvent(ev);
    }
    createMainPanel() {
        this.mainMenuList = this.columnMenuFactory.createMenu(this, this.column, () => { var _a; return (_a = this.sourceElement) !== null && _a !== void 0 ? _a : this.getGui(); });
        this.mainMenuList.addEventListener(AgMenuItemComponent.EVENT_CLOSE_MENU, this.onHidePopup.bind(this));
        this.tabItemGeneral = {
            title: _.createIconNoSpan('menu', this.gridOptionsService, this.column),
            titleLabel: TabbedColumnMenu.TAB_GENERAL.replace('MenuTab', ''),
            bodyPromise: AgPromise.resolve(this.mainMenuList.getGui()),
            name: TabbedColumnMenu.TAB_GENERAL
        };
        return this.tabItemGeneral;
    }
    onHidePopup(event) {
        this.menuUtils.closePopupAndRestoreFocusOnSelect(this.hidePopupFunc, this.restoreFocusParams, event);
    }
    createFilterPanel() {
        const filterWrapper = this.column ? this.filterManager.getOrCreateFilterWrapper(this.column, 'COLUMN_MENU') : null;
        if (!filterWrapper) {
            throw new Error('AG Grid - Unable to instantiate filter');
        }
        const afterFilterAttachedCallback = (params) => {
            if (!(filterWrapper === null || filterWrapper === void 0 ? void 0 : filterWrapper.filterPromise)) {
                return;
            }
            // slightly odd block this - this promise will always have been resolved by the time it gets here, so won't be
            // async (_unless_ in react or similar, but if so why not encountered before now?).
            // I'd suggest a future improvement would be to remove/replace this promise as this block just wont work if it is
            // async and is confusing if you don't have this context
            filterWrapper.filterPromise.then(filter => {
                if (filter && filter.afterGuiAttached) {
                    filter.afterGuiAttached(params);
                }
            });
        };
        // see comment above
        const afterDetachedCallback = () => { var _a; return (_a = filterWrapper === null || filterWrapper === void 0 ? void 0 : filterWrapper.filterPromise) === null || _a === void 0 ? void 0 : _a.then(filter => { var _a; return (_a = filter === null || filter === void 0 ? void 0 : filter.afterGuiDetached) === null || _a === void 0 ? void 0 : _a.call(filter); }); };
        this.tabItemFilter = {
            title: _.createIconNoSpan('filter', this.gridOptionsService, this.column),
            titleLabel: TabbedColumnMenu.TAB_FILTER.replace('MenuTab', ''),
            bodyPromise: filterWrapper === null || filterWrapper === void 0 ? void 0 : filterWrapper.guiPromise,
            afterAttachedCallback: afterFilterAttachedCallback,
            afterDetachedCallback,
            name: TabbedColumnMenu.TAB_FILTER
        };
        return this.tabItemFilter;
    }
    createColumnsPanel() {
        const eWrapperDiv = document.createElement('div');
        eWrapperDiv.classList.add('ag-menu-column-select-wrapper');
        const columnSelectPanel = this.columnChooserFactory.createColumnSelectPanel(this, this.column);
        const columnSelectPanelGui = columnSelectPanel.getGui();
        columnSelectPanelGui.classList.add('ag-menu-column-select');
        eWrapperDiv.appendChild(columnSelectPanelGui);
        this.tabItemColumns = {
            title: _.createIconNoSpan('columns', this.gridOptionsService, this.column),
            titleLabel: TabbedColumnMenu.TAB_COLUMNS.replace('MenuTab', ''),
            bodyPromise: AgPromise.resolve(eWrapperDiv),
            name: TabbedColumnMenu.TAB_COLUMNS
        };
        return this.tabItemColumns;
    }
    afterGuiAttached(params) {
        const { container, hidePopup } = params;
        this.tabbedLayout.setAfterAttachedParams({ container, hidePopup });
        if (hidePopup) {
            this.hidePopupFunc = hidePopup;
            this.addDestroyFunc(hidePopup);
        }
    }
    getGui() {
        return this.tabbedLayout.getGui();
    }
}
TabbedColumnMenu.EVENT_TAB_SELECTED = 'tabSelected';
TabbedColumnMenu.TAB_FILTER = 'filterMenuTab';
TabbedColumnMenu.TAB_GENERAL = 'generalMenuTab';
TabbedColumnMenu.TAB_COLUMNS = 'columnsMenuTab';
TabbedColumnMenu.TABS_DEFAULT = [TabbedColumnMenu.TAB_GENERAL, TabbedColumnMenu.TAB_FILTER, TabbedColumnMenu.TAB_COLUMNS];
__decorate$1B([
    Autowired('filterManager')
], TabbedColumnMenu.prototype, "filterManager", void 0);
__decorate$1B([
    Autowired('columnChooserFactory')
], TabbedColumnMenu.prototype, "columnChooserFactory", void 0);
__decorate$1B([
    Autowired('columnMenuFactory')
], TabbedColumnMenu.prototype, "columnMenuFactory", void 0);
__decorate$1B([
    Autowired('menuUtils')
], TabbedColumnMenu.prototype, "menuUtils", void 0);
__decorate$1B([
    PostConstruct
], TabbedColumnMenu.prototype, "init", null);
class ColumnContextMenu extends Component {
    constructor(column, restoreFocusParams, sourceElement) {
        super(/* html */ `
            <div ref="eColumnMenu" role="presentation" class="ag-menu ag-column-menu"></div>
        `);
        this.column = column;
        this.restoreFocusParams = restoreFocusParams;
        this.sourceElement = sourceElement;
    }
    init() {
        this.mainMenuList = this.columnMenuFactory.createMenu(this, this.column, () => { var _a; return (_a = this.sourceElement) !== null && _a !== void 0 ? _a : this.getGui(); });
        this.mainMenuList.addEventListener(AgMenuItemComponent.EVENT_CLOSE_MENU, this.onHidePopup.bind(this));
        this.eColumnMenu.appendChild(this.mainMenuList.getGui());
    }
    onHidePopup(event) {
        this.menuUtils.closePopupAndRestoreFocusOnSelect(this.hidePopupFunc, this.restoreFocusParams, event);
    }
    afterGuiAttached({ hidePopup }) {
        if (hidePopup) {
            this.hidePopupFunc = hidePopup;
            this.addDestroyFunc(hidePopup);
        }
        this.focusService.focusInto(this.mainMenuList.getGui());
    }
}
__decorate$1B([
    Autowired('columnMenuFactory')
], ColumnContextMenu.prototype, "columnMenuFactory", void 0);
__decorate$1B([
    Autowired('menuUtils')
], ColumnContextMenu.prototype, "menuUtils", void 0);
__decorate$1B([
    Autowired('focusService')
], ColumnContextMenu.prototype, "focusService", void 0);
__decorate$1B([
    RefSelector('eColumnMenu')
], ColumnContextMenu.prototype, "eColumnMenu", void 0);
__decorate$1B([
    PostConstruct
], ColumnContextMenu.prototype, "init", null);

var __decorate$1C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const CSS_MENU = 'ag-menu';
const CSS_CONTEXT_MENU_OPEN = 'ag-context-menu-open';
let ContextMenuFactory = class ContextMenuFactory extends BeanStub {
    hideActiveMenu() {
        this.destroyBean(this.activeMenu);
    }
    getMenuItems(node, column, value) {
        const defaultMenuOptions = [];
        if (_.exists(node) && ModuleRegistry.__isRegistered(ModuleNames.ClipboardModule, this.context.getGridId())) {
            if (column) {
                // only makes sense if column exists, could have originated from a row
                if (!this.gridOptionsService.get('suppressCutToClipboard')) {
                    defaultMenuOptions.push('cut');
                }
                defaultMenuOptions.push('copy', 'copyWithHeaders', 'copyWithGroupHeaders', 'paste', 'separator');
            }
        }
        if (this.gridOptionsService.get('enableCharts') && ModuleRegistry.__isRegistered(ModuleNames.GridChartsModule, this.context.getGridId())) {
            if (this.columnModel.isPivotMode()) {
                defaultMenuOptions.push('pivotChart');
            }
            if (this.rangeService && !this.rangeService.isEmpty()) {
                defaultMenuOptions.push('chartRange');
            }
        }
        if (_.exists(node)) {
            // if user clicks a cell
            const csvModuleMissing = !ModuleRegistry.__isRegistered(ModuleNames.CsvExportModule, this.context.getGridId());
            const excelModuleMissing = !ModuleRegistry.__isRegistered(ModuleNames.ExcelExportModule, this.context.getGridId());
            const suppressExcel = this.gridOptionsService.get('suppressExcelExport') || excelModuleMissing;
            const suppressCsv = this.gridOptionsService.get('suppressCsvExport') || csvModuleMissing;
            const onIPad = _.isIOSUserAgent();
            const anyExport = !onIPad && (!suppressExcel || !suppressCsv);
            if (anyExport) {
                defaultMenuOptions.push('export');
            }
        }
        const defaultItems = defaultMenuOptions.length ? defaultMenuOptions : undefined;
        const columnContextMenuItems = column === null || column === void 0 ? void 0 : column.getColDef().contextMenuItems;
        if (Array.isArray(columnContextMenuItems)) {
            return columnContextMenuItems;
        }
        else if (typeof columnContextMenuItems === 'function') {
            return columnContextMenuItems(this.gridOptionsService.addGridCommonParams({
                column, node, value, defaultItems
            }));
        }
        else {
            const userFunc = this.gridOptionsService.getCallback('getContextMenuItems');
            if (userFunc) {
                return userFunc({ column, node, value, defaultItems });
            }
            else {
                return defaultMenuOptions;
            }
        }
    }
    onContextMenu(mouseEvent, touchEvent, rowNode, column, value, anchorToElement) {
        this.menuUtils.onContextMenu(mouseEvent, touchEvent, (eventOrTouch) => this.showMenu(rowNode, column, value, eventOrTouch, anchorToElement));
    }
    showMenu(node, column, value, mouseEvent, anchorToElement) {
        const menuItems = this.getMenuItems(node, column, value);
        const eGridBodyGui = this.ctrlsService.getGridBodyCtrl().getGui();
        if (menuItems === undefined || _.missingOrEmpty(menuItems)) {
            return false;
        }
        const menu = new ContextMenu$1(menuItems, column, node, value);
        this.createBean(menu);
        const eMenuGui = menu.getGui();
        const positionParams = {
            column: column,
            rowNode: node,
            type: 'contextMenu',
            mouseEvent: mouseEvent,
            ePopup: eMenuGui,
            // move one pixel away so that accidentally double clicking
            // won't show the browser's contextmenu
            nudgeY: 1
        };
        const translate = this.localeService.getLocaleTextFunc();
        const addPopupRes = this.popupService.addPopup({
            modal: true,
            eChild: eMenuGui,
            closeOnEsc: true,
            closedCallback: () => {
                eGridBodyGui.classList.remove(CSS_CONTEXT_MENU_OPEN);
                this.destroyBean(menu);
            },
            click: mouseEvent,
            positionCallback: () => {
                const isRtl = this.gridOptionsService.get('enableRtl');
                this.popupService.positionPopupUnderMouseEvent(Object.assign(Object.assign({}, positionParams), { nudgeX: isRtl ? (eMenuGui.offsetWidth + 1) * -1 : 1 }));
            },
            // so when browser is scrolled down, or grid is scrolled, context menu stays with cell
            anchorToElement: anchorToElement,
            ariaLabel: translate('ariaLabelContextMenu', 'Context Menu')
        });
        if (addPopupRes) {
            eGridBodyGui.classList.add(CSS_CONTEXT_MENU_OPEN);
            menu.afterGuiAttached({ container: 'contextMenu', hidePopup: addPopupRes.hideFunc });
        }
        // there should never be an active menu at this point, however it was found
        // that you could right click a second time just 1 or 2 pixels from the first
        // click, and another menu would pop up. so somehow the logic for closing the
        // first menu (clicking outside should close it) was glitchy somehow. an easy
        // way to avoid this is just remove the old context menu here if it exists.
        if (this.activeMenu) {
            this.hideActiveMenu();
        }
        this.activeMenu = menu;
        menu.addEventListener(BeanStub.EVENT_DESTROYED, () => {
            if (this.activeMenu === menu) {
                this.activeMenu = null;
            }
        });
        // hide the popup if something gets selected
        if (addPopupRes) {
            menu.addEventListener(AgMenuItemComponent.EVENT_CLOSE_MENU, addPopupRes.hideFunc);
        }
        return true;
    }
};
__decorate$1C([
    Autowired('popupService')
], ContextMenuFactory.prototype, "popupService", void 0);
__decorate$1C([
    Optional('rangeService')
], ContextMenuFactory.prototype, "rangeService", void 0);
__decorate$1C([
    Autowired('ctrlsService')
], ContextMenuFactory.prototype, "ctrlsService", void 0);
__decorate$1C([
    Autowired('columnModel')
], ContextMenuFactory.prototype, "columnModel", void 0);
__decorate$1C([
    Autowired('menuUtils')
], ContextMenuFactory.prototype, "menuUtils", void 0);
ContextMenuFactory = __decorate$1C([
    Bean('contextMenuFactory')
], ContextMenuFactory);
class ContextMenu$1 extends Component {
    constructor(menuItems, column, node, value) {
        super(/* html */ `<div class="${CSS_MENU}" role="presentation"></div>`);
        this.menuItems = menuItems;
        this.column = column;
        this.node = node;
        this.value = value;
        this.menuList = null;
        this.focusedCell = null;
    }
    addMenuItems() {
        const menuList = this.createManagedBean(new AgMenuList(0, {
            column: this.column,
            node: this.node,
            value: this.value
        }));
        const menuItemsMapped = this.menuItemMapper.mapWithStockItems(this.menuItems, null, () => this.getGui());
        menuList.addMenuItems(menuItemsMapped);
        this.appendChild(menuList);
        this.menuList = menuList;
        menuList.addEventListener(AgMenuItemComponent.EVENT_CLOSE_MENU, (e) => this.dispatchEvent(e));
    }
    afterGuiAttached(params) {
        if (params.hidePopup) {
            this.addDestroyFunc(params.hidePopup);
        }
        this.focusedCell = this.focusService.getFocusedCell();
        if (this.menuList) {
            this.focusService.focusInto(this.menuList.getGui());
        }
    }
    restoreFocusedCell() {
        const currentFocusedCell = this.focusService.getFocusedCell();
        if (currentFocusedCell && this.focusedCell && this.cellPositionUtils.equals(currentFocusedCell, this.focusedCell)) {
            const { rowIndex, rowPinned, column } = this.focusedCell;
            const doc = this.gridOptionsService.getDocument();
            if (doc.activeElement === doc.body) {
                this.focusService.setFocusedCell({ rowIndex, column, rowPinned, forceBrowserFocus: true });
            }
        }
    }
    destroy() {
        this.restoreFocusedCell();
        super.destroy();
    }
}
__decorate$1C([
    Autowired('menuItemMapper')
], ContextMenu$1.prototype, "menuItemMapper", void 0);
__decorate$1C([
    Autowired('focusService')
], ContextMenu$1.prototype, "focusService", void 0);
__decorate$1C([
    Autowired('cellPositionUtils')
], ContextMenu$1.prototype, "cellPositionUtils", void 0);
__decorate$1C([
    PostConstruct
], ContextMenu$1.prototype, "addMenuItems", null);

var __decorate$1D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let MenuItemMapper = class MenuItemMapper extends BeanStub {
    mapWithStockItems(originalList, column, sourceElement) {
        if (!originalList) {
            return [];
        }
        const resultList = [];
        originalList.forEach(menuItemOrString => {
            let result;
            if (typeof menuItemOrString === 'string') {
                result = this.getStockMenuItem(menuItemOrString, column, sourceElement);
            }
            else {
                // Spread to prevent leaking mapped subMenus back into the original menuItem
                result = Object.assign({}, menuItemOrString);
            }
            // if no mapping, can happen when module is not loaded but user tries to use module anyway
            if (!result) {
                return;
            }
            const resultDef = result;
            const { subMenu } = resultDef;
            if (subMenu && subMenu instanceof Array) {
                resultDef.subMenu = this.mapWithStockItems(subMenu, column, sourceElement);
            }
            if (result != null) {
                resultList.push(result);
            }
        });
        return resultList;
    }
    getStockMenuItem(key, column, sourceElement) {
        var _a;
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const skipHeaderOnAutoSize = this.gridOptionsService.get('skipHeaderOnAutoSize');
        switch (key) {
            case 'pinSubMenu':
                return {
                    name: localeTextFunc('pinColumn', 'Pin Column'),
                    icon: _.createIconNoSpan('menuPin', this.gridOptionsService, null),
                    subMenu: ['clearPinned', 'pinLeft', 'pinRight']
                };
            case 'pinLeft':
                return {
                    name: localeTextFunc('pinLeft', 'Pin Left'),
                    action: () => this.columnModel.setColumnsPinned([column], 'left', "contextMenu"),
                    checked: !!column && column.isPinnedLeft()
                };
            case 'pinRight':
                return {
                    name: localeTextFunc('pinRight', 'Pin Right'),
                    action: () => this.columnModel.setColumnsPinned([column], 'right', "contextMenu"),
                    checked: !!column && column.isPinnedRight()
                };
            case 'clearPinned':
                return {
                    name: localeTextFunc('noPin', 'No Pin'),
                    action: () => this.columnModel.setColumnsPinned([column], null, "contextMenu"),
                    checked: !!column && !column.isPinned()
                };
            case 'valueAggSubMenu':
                if (ModuleRegistry.__assertRegistered(ModuleNames.RowGroupingModule, 'Aggregation from Menu', this.context.getGridId())) {
                    if (!(column === null || column === void 0 ? void 0 : column.isPrimary()) && !(column === null || column === void 0 ? void 0 : column.getColDef().pivotValueColumn)) {
                        return null;
                    }
                    return {
                        name: localeTextFunc('valueAggregation', 'Value Aggregation'),
                        icon: _.createIconNoSpan('menuValue', this.gridOptionsService, null),
                        subMenu: this.createAggregationSubMenu(column)
                    };
                }
                else {
                    return null;
                }
            case 'autoSizeThis':
                return {
                    name: localeTextFunc('autosizeThiscolumn', 'Autosize This Column'),
                    action: () => this.columnModel.autoSizeColumn(column, "contextMenu", skipHeaderOnAutoSize)
                };
            case 'autoSizeAll':
                return {
                    name: localeTextFunc('autosizeAllColumns', 'Autosize All Columns'),
                    action: () => this.columnModel.autoSizeAllColumns("contextMenu", skipHeaderOnAutoSize)
                };
            case 'rowGroup':
                return {
                    name: localeTextFunc('groupBy', 'Group by') + ' ' + _.escapeString(this.columnModel.getDisplayNameForColumn(column, 'header')),
                    disabled: (column === null || column === void 0 ? void 0 : column.isRowGroupActive()) || !(column === null || column === void 0 ? void 0 : column.getColDef().enableRowGroup),
                    action: () => this.columnModel.addRowGroupColumns([column], "contextMenu"),
                    icon: _.createIconNoSpan('menuAddRowGroup', this.gridOptionsService, null)
                };
            case 'rowUnGroup':
                const icon = _.createIconNoSpan('menuRemoveRowGroup', this.gridOptionsService, null);
                const showRowGroup = column === null || column === void 0 ? void 0 : column.getColDef().showRowGroup;
                const lockedGroups = this.gridOptionsService.get('groupLockGroupColumns');
                // Handle single auto group column
                if (showRowGroup === true) {
                    return {
                        name: localeTextFunc('ungroupAll', 'Un-Group All'),
                        disabled: lockedGroups === -1 || lockedGroups >= this.columnModel.getRowGroupColumns().length,
                        action: () => this.columnModel.setRowGroupColumns(this.columnModel.getRowGroupColumns().slice(0, lockedGroups), "contextMenu"),
                        icon: icon
                    };
                }
                // Handle multiple auto group columns
                if (typeof showRowGroup === 'string') {
                    const underlyingColumn = this.columnModel.getPrimaryColumn(showRowGroup);
                    const ungroupByName = (underlyingColumn != null) ? _.escapeString(this.columnModel.getDisplayNameForColumn(underlyingColumn, 'header')) : showRowGroup;
                    return {
                        name: localeTextFunc('ungroupBy', 'Un-Group by') + ' ' + ungroupByName,
                        disabled: underlyingColumn != null && this.columnModel.isColumnGroupingLocked(underlyingColumn),
                        action: () => this.columnModel.removeRowGroupColumns([showRowGroup], "contextMenu"),
                        icon: icon
                    };
                }
                // Handle primary column
                return {
                    name: localeTextFunc('ungroupBy', 'Un-Group by') + ' ' + _.escapeString(this.columnModel.getDisplayNameForColumn(column, 'header')),
                    disabled: !(column === null || column === void 0 ? void 0 : column.isRowGroupActive()) || !(column === null || column === void 0 ? void 0 : column.getColDef().enableRowGroup) || this.columnModel.isColumnGroupingLocked(column),
                    action: () => this.columnModel.removeRowGroupColumns([column], "contextMenu"),
                    icon: icon
                };
            case 'resetColumns':
                return {
                    name: localeTextFunc('resetColumns', 'Reset Columns'),
                    action: () => this.columnModel.resetColumnState("contextMenu")
                };
            case 'expandAll':
                return {
                    name: localeTextFunc('expandAll', 'Expand All Row Groups'),
                    action: () => this.gridApi.expandAll()
                };
            case 'contractAll':
                return {
                    name: localeTextFunc('collapseAll', 'Collapse All Row Groups'),
                    action: () => this.gridApi.collapseAll()
                };
            case 'copy':
                if (ModuleRegistry.__assertRegistered(ModuleNames.ClipboardModule, 'Copy from Menu', this.context.getGridId())) {
                    return {
                        name: localeTextFunc('copy', 'Copy'),
                        shortcut: localeTextFunc('ctrlC', 'Ctrl+C'),
                        icon: _.createIconNoSpan('clipboardCopy', this.gridOptionsService, null),
                        action: () => this.clipboardService.copyToClipboard()
                    };
                }
                else {
                    return null;
                }
            case 'copyWithHeaders':
                if (ModuleRegistry.__assertRegistered(ModuleNames.ClipboardModule, 'Copy with Headers from Menu', this.context.getGridId())) {
                    return {
                        name: localeTextFunc('copyWithHeaders', 'Copy with Headers'),
                        // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
                        icon: _.createIconNoSpan('clipboardCopy', this.gridOptionsService, null),
                        action: () => this.clipboardService.copyToClipboard({ includeHeaders: true })
                    };
                }
                else {
                    return null;
                }
            case 'copyWithGroupHeaders':
                if (ModuleRegistry.__assertRegistered(ModuleNames.ClipboardModule, 'Copy with Group Headers from Menu', this.context.getGridId())) {
                    return {
                        name: localeTextFunc('copyWithGroupHeaders', 'Copy with Group Headers'),
                        // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
                        icon: _.createIconNoSpan('clipboardCopy', this.gridOptionsService, null),
                        action: () => this.clipboardService.copyToClipboard({ includeHeaders: true, includeGroupHeaders: true })
                    };
                }
                else {
                    return null;
                }
            case 'cut':
                if (ModuleRegistry.__assertRegistered(ModuleNames.ClipboardModule, 'Cut from Menu', this.context.getGridId())) {
                    const focusedCell = this.focusService.getFocusedCell();
                    const rowNode = focusedCell ? this.rowPositionUtils.getRowNode(focusedCell) : null;
                    const isEditable = rowNode ? focusedCell === null || focusedCell === void 0 ? void 0 : focusedCell.column.isCellEditable(rowNode) : false;
                    return {
                        name: localeTextFunc('cut', 'Cut'),
                        shortcut: localeTextFunc('ctrlX', 'Ctrl+X'),
                        icon: _.createIconNoSpan('clipboardCut', this.gridOptionsService, null),
                        disabled: !isEditable || this.gridOptionsService.get('suppressCutToClipboard'),
                        action: () => this.clipboardService.cutToClipboard(undefined, 'contextMenu')
                    };
                }
                else {
                    return null;
                }
            case 'paste':
                if (ModuleRegistry.__assertRegistered(ModuleNames.ClipboardModule, 'Paste from Clipboard', this.context.getGridId())) {
                    return {
                        name: localeTextFunc('paste', 'Paste'),
                        shortcut: localeTextFunc('ctrlV', 'Ctrl+V'),
                        disabled: true,
                        icon: _.createIconNoSpan('clipboardPaste', this.gridOptionsService, null),
                        action: () => this.clipboardService.pasteFromClipboard()
                    };
                }
                else {
                    return null;
                }
            case 'export':
                const exportSubMenuItems = [];
                const csvModuleLoaded = ModuleRegistry.__isRegistered(ModuleNames.CsvExportModule, this.context.getGridId());
                const excelModuleLoaded = ModuleRegistry.__isRegistered(ModuleNames.ExcelExportModule, this.context.getGridId());
                if (!this.gridOptionsService.get('suppressCsvExport') && csvModuleLoaded) {
                    exportSubMenuItems.push('csvExport');
                }
                if (!this.gridOptionsService.get('suppressExcelExport') && excelModuleLoaded) {
                    exportSubMenuItems.push('excelExport');
                }
                return {
                    name: localeTextFunc('export', 'Export'),
                    subMenu: exportSubMenuItems,
                    icon: _.createIconNoSpan('save', this.gridOptionsService, null),
                };
            case 'csvExport':
                return {
                    name: localeTextFunc('csvExport', 'CSV Export'),
                    icon: _.createIconNoSpan('csvExport', this.gridOptionsService, null),
                    action: () => this.gridApi.exportDataAsCsv({})
                };
            case 'excelExport':
                return {
                    name: localeTextFunc('excelExport', 'Excel Export'),
                    icon: _.createIconNoSpan('excelExport', this.gridOptionsService, null),
                    action: () => this.gridApi.exportDataAsExcel()
                };
            case 'separator':
                return 'separator';
            case 'pivotChart':
            case 'chartRange':
                return (_a = this.chartMenuItemMapper.getChartItems(key)) !== null && _a !== void 0 ? _a : null;
            case 'columnFilter':
                if (column) {
                    return {
                        name: localeTextFunc('columnFilter', 'Column Filter'),
                        icon: _.createIconNoSpan('filter', this.gridOptionsService, null),
                        action: () => this.menuService.showFilterMenu({
                            column, buttonElement: sourceElement(), containerType: 'columnFilter', positionBy: 'button'
                        })
                    };
                }
                else {
                    return null;
                }
            case 'columnChooser':
                if (ModuleRegistry.__isRegistered(ModuleNames.ColumnsToolPanelModule, this.context.getGridId())) {
                    return {
                        name: localeTextFunc('columnChooser', 'Choose Columns'),
                        icon: _.createIconNoSpan('columns', this.gridOptionsService, null),
                        action: () => this.menuService.showColumnChooser({ column, eventSource: sourceElement() })
                    };
                }
                else {
                    return null;
                }
            case 'sortAscending':
                return {
                    name: localeTextFunc('sortAscending', 'Sort Ascending'),
                    icon: _.createIconNoSpan('sortAscending', this.gridOptionsService, null),
                    action: () => this.sortController.setSortForColumn(column, 'asc', false, 'columnMenu')
                };
            case 'sortDescending':
                return {
                    name: localeTextFunc('sortDescending', 'Sort Descending'),
                    icon: _.createIconNoSpan('sortDescending', this.gridOptionsService, null),
                    action: () => this.sortController.setSortForColumn(column, 'desc', false, 'columnMenu')
                };
            case 'sortUnSort':
                return {
                    name: localeTextFunc('sortUnSort', 'Clear Sort'),
                    icon: _.createIconNoSpan('sortUnSort', this.gridOptionsService, null),
                    action: () => this.sortController.setSortForColumn(column, null, false, 'columnMenu')
                };
            default: {
                console.warn(`AG Grid: unknown menu item type ${key}`);
                return null;
            }
        }
    }
    createAggregationSubMenu(column) {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        let columnToUse;
        if (column.isPrimary()) {
            columnToUse = column;
        }
        else {
            const pivotValueColumn = column.getColDef().pivotValueColumn;
            columnToUse = _.exists(pivotValueColumn) ? pivotValueColumn : undefined;
        }
        const result = [];
        if (columnToUse) {
            const columnIsAlreadyAggValue = columnToUse.isValueActive();
            const funcNames = this.aggFuncService.getFuncNames(columnToUse);
            result.push({
                name: localeTextFunc('noAggregation', 'None'),
                action: () => {
                    this.columnModel.removeValueColumns([columnToUse], "contextMenu");
                    this.columnModel.setColumnAggFunc(columnToUse, undefined, "contextMenu");
                },
                checked: !columnIsAlreadyAggValue
            });
            funcNames.forEach(funcName => {
                result.push({
                    name: localeTextFunc(funcName, this.aggFuncService.getDefaultFuncLabel(funcName)),
                    action: () => {
                        this.columnModel.setColumnAggFunc(columnToUse, funcName, "contextMenu");
                        this.columnModel.addValueColumns([columnToUse], "contextMenu");
                    },
                    checked: columnIsAlreadyAggValue && columnToUse.getAggFunc() === funcName
                });
            });
        }
        return result;
    }
};
__decorate$1D([
    Autowired('columnModel')
], MenuItemMapper.prototype, "columnModel", void 0);
__decorate$1D([
    Autowired('gridApi')
], MenuItemMapper.prototype, "gridApi", void 0);
__decorate$1D([
    Optional('clipboardService')
], MenuItemMapper.prototype, "clipboardService", void 0);
__decorate$1D([
    Optional('aggFuncService')
], MenuItemMapper.prototype, "aggFuncService", void 0);
__decorate$1D([
    Autowired('focusService')
], MenuItemMapper.prototype, "focusService", void 0);
__decorate$1D([
    Autowired('rowPositionUtils')
], MenuItemMapper.prototype, "rowPositionUtils", void 0);
__decorate$1D([
    Autowired('chartMenuItemMapper')
], MenuItemMapper.prototype, "chartMenuItemMapper", void 0);
__decorate$1D([
    Autowired('menuService')
], MenuItemMapper.prototype, "menuService", void 0);
__decorate$1D([
    Autowired('sortController')
], MenuItemMapper.prototype, "sortController", void 0);
MenuItemMapper = __decorate$1D([
    Bean('menuItemMapper')
], MenuItemMapper);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$d = '31.1.1';

var __decorate$1E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ChartMenuItemMapper_1;
let ChartMenuItemMapper = ChartMenuItemMapper_1 = class ChartMenuItemMapper extends BeanStub {
    getChartItems(key) {
        var _a, _b;
        if (!this.chartService) {
            ModuleRegistry.__assertRegistered(ModuleNames.GridChartsModule, `the Context Menu key "${key}"`, this.context.getGridId());
            return undefined;
        }
        const builder = key === 'pivotChart'
            ? new PivotMenuItemMapper(this.gridOptionsService, this.chartService, this.localeService)
            : new RangeMenuItemMapper(this.gridOptionsService, this.chartService, this.localeService);
        const isEnterprise = this.chartService.isEnterprise();
        let topLevelMenuItem = builder.getMenuItem();
        if (topLevelMenuItem && topLevelMenuItem.subMenu && !isEnterprise) {
            // Filter out enterprise-only menu items if 'Community Integrated'
            const filterEnterpriseItems = (m) => {
                var _a;
                return (Object.assign(Object.assign({}, m), { subMenu: (_a = m.subMenu) === null || _a === void 0 ? void 0 : _a.filter((menu) => !menu._enterprise).map((menu) => filterEnterpriseItems(menu)) }));
            };
            topLevelMenuItem = filterEnterpriseItems(topLevelMenuItem);
        }
        const chartGroupsDef = (_b = (_a = this.gridOptionsService.get('chartToolPanelsDef')) === null || _a === void 0 ? void 0 : _a.settingsPanel) === null || _b === void 0 ? void 0 : _b.chartGroupsDef;
        if (chartGroupsDef) {
            topLevelMenuItem = ChartMenuItemMapper_1.filterAndOrderChartMenu(topLevelMenuItem, chartGroupsDef, builder.getConfigLookup());
        }
        return this.cleanInternals(topLevelMenuItem);
    }
    // Remove our internal _key and _enterprise properties so this does not leak out of the class on the menu items.
    cleanInternals(menuItem) {
        if (!menuItem) {
            return menuItem;
        }
        const removeKeys = (m) => {
            var _a;
            m === null || m === void 0 ? true : delete m._key;
            m === null || m === void 0 ? true : delete m._enterprise;
            (_a = m === null || m === void 0 ? void 0 : m.subMenu) === null || _a === void 0 ? void 0 : _a.forEach(s => removeKeys(s));
            return m;
        };
        return removeKeys(menuItem);
    }
    static buildLookup(menuItem) {
        let itemLookup = {};
        const addItem = (item) => {
            itemLookup[item._key] = item;
            if (item.subMenu) {
                item.subMenu.forEach(s => addItem(s));
            }
        };
        addItem(menuItem);
        return itemLookup;
    }
    /**
     * Make the MenuItem match the charts provided and their ordering on the ChartGroupsDef config object as provided by the user.
     */
    static filterAndOrderChartMenu(topLevelMenuItem, chartGroupsDef, configLookup) {
        var _a;
        const menuItemLookup = this.buildLookup(topLevelMenuItem);
        let orderedAndFiltered = Object.assign(Object.assign({}, topLevelMenuItem), { subMenu: [] });
        Object.entries(chartGroupsDef).forEach(([group, chartTypes]) => {
            var _a, _b;
            const chartConfigGroup = configLookup[group];
            // Skip any context panels that are not enabled for the current chart type
            if (chartConfigGroup === null)
                return;
            if (chartConfigGroup == undefined) {
                _.warnOnce(`invalid chartGroupsDef config '${group}'`);
                return undefined;
            }
            const menuItem = menuItemLookup[chartConfigGroup._key];
            if (menuItem) {
                if (menuItem.subMenu) {
                    const subMenus = chartTypes.map(chartType => {
                        const itemKey = chartConfigGroup[chartType];
                        if (itemKey == undefined) {
                            _.warnOnce(`invalid chartGroupsDef config '${group}.${chartType}'`);
                            return undefined;
                        }
                        return menuItemLookup[itemKey];
                    }).filter(s => s !== undefined);
                    if (subMenus.length > 0) {
                        menuItem.subMenu = subMenus;
                        (_a = orderedAndFiltered.subMenu) === null || _a === void 0 ? void 0 : _a.push(menuItem);
                    }
                }
                else {
                    // Handles line case which is not actually a sub subMenu
                    (_b = orderedAndFiltered.subMenu) === null || _b === void 0 ? void 0 : _b.push(menuItem);
                }
            }
        });
        if (((_a = orderedAndFiltered.subMenu) === null || _a === void 0 ? void 0 : _a.length) == 0) {
            return undefined;
        }
        return orderedAndFiltered;
    }
};
__decorate$1E([
    Optional('chartService')
], ChartMenuItemMapper.prototype, "chartService", void 0);
ChartMenuItemMapper = ChartMenuItemMapper_1 = __decorate$1E([
    Bean('chartMenuItemMapper')
], ChartMenuItemMapper);
class PivotMenuItemMapper {
    constructor(gridOptionsService, chartService, localeService) {
        this.gridOptionsService = gridOptionsService;
        this.chartService = chartService;
        this.localeService = localeService;
    }
    getMenuItem() {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const getMenuItem = (localeKey, defaultText, chartType, key, enterprise = false) => {
            return {
                name: localeTextFunc(localeKey, defaultText),
                action: () => this.chartService.createPivotChart({ chartType }),
                _key: key,
                _enterprise: enterprise
            };
        };
        return {
            name: localeTextFunc('pivotChart', 'Pivot Chart'),
            _key: 'pivotChart',
            subMenu: [
                {
                    _key: 'pivotColumnChart',
                    name: localeTextFunc('columnChart', 'Column'),
                    subMenu: [
                        getMenuItem('groupedColumn', 'Grouped&lrm;', 'groupedColumn', 'pivotGroupedColumn'),
                        getMenuItem('stackedColumn', 'Stacked&lrm;', 'stackedColumn', 'pivotStackedColumn'),
                        getMenuItem('normalizedColumn', '100% Stacked&lrm;', 'normalizedColumn', 'pivotNormalizedColumn')
                    ]
                },
                {
                    _key: 'pivotBarChart',
                    name: localeTextFunc('barChart', 'Bar'),
                    subMenu: [
                        getMenuItem('groupedBar', 'Grouped&lrm;', 'groupedBar', 'pivotGroupedBar'),
                        getMenuItem('stackedBar', 'Stacked&lrm;', 'stackedBar', 'pivotStackedBar'),
                        getMenuItem('normalizedBar', '100% Stacked&lrm;', 'normalizedBar', 'pivotNormalizedBar')
                    ]
                },
                {
                    _key: 'pivotPieChart',
                    name: localeTextFunc('pieChart', 'Pie'),
                    subMenu: [
                        getMenuItem('pie', 'Pie&lrm;', 'pie', 'pivotPie'),
                        getMenuItem('donut', 'Donut&lrm;', 'donut', 'pivotDonut')
                    ]
                },
                getMenuItem('line', 'Line&lrm;', 'line', 'pivotLineChart'),
                {
                    _key: 'pivotXYChart',
                    name: localeTextFunc('xyChart', 'X Y (Scatter)'),
                    subMenu: [
                        getMenuItem('scatter', 'Scatter&lrm;', 'scatter', 'pivotScatter'),
                        getMenuItem('bubble', 'Bubble&lrm;', 'bubble', 'pivotBubble')
                    ]
                },
                {
                    _key: 'pivotAreaChart',
                    name: localeTextFunc('areaChart', 'Area'),
                    subMenu: [
                        getMenuItem('area', 'Area&lrm;', 'area', 'pivotArea'),
                        getMenuItem('stackedArea', 'Stacked&lrm;', 'stackedArea', 'pivotStackedArea'),
                        getMenuItem('normalizedArea', '100% Stacked&lrm;', 'normalizedArea', 'pivotNormalizedArea')
                    ]
                },
                {
                    _key: 'pivotStatisticalChart',
                    _enterprise: false,
                    name: localeTextFunc('statisticalChart', 'Statistical'),
                    subMenu: [
                        getMenuItem('histogramChart', 'Histogram&lrm;', 'histogram', 'pivotHistogram', false),
                    ],
                },
                {
                    _key: 'pivotHierarchicalChart',
                    _enterprise: true,
                    name: localeTextFunc('hierarchicalChart', 'Hierarchical'),
                    subMenu: [
                        getMenuItem('treemapChart', 'Treemap&lrm;', 'treemap', 'pivotTreemap', true),
                        getMenuItem('sunburstChart', 'Sunburst&lrm;', 'sunburst', 'pivotSunburst', true),
                    ],
                },
                {
                    _key: 'pivotCombinationChart',
                    name: localeTextFunc('combinationChart', 'Combination'),
                    subMenu: [
                        getMenuItem('columnLineCombo', 'Column & Line&lrm;', 'columnLineCombo', 'pivotColumnLineCombo'),
                        getMenuItem('AreaColumnCombo', 'Area & Column&lrm;', 'areaColumnCombo', 'pivotAreaColumnCombo')
                    ]
                }
            ],
            icon: _.createIconNoSpan('chart', this.gridOptionsService, undefined),
        };
    }
    getConfigLookup() {
        return {
            columnGroup: {
                _key: 'pivotColumnChart',
                column: 'pivotGroupedColumn',
                stackedColumn: 'pivotStackedColumn',
                normalizedColumn: 'pivotNormalizedColumn',
            },
            barGroup: {
                _key: 'pivotBarChart',
                bar: 'pivotGroupedBar',
                stackedBar: 'pivotStackedBar',
                normalizedBar: 'pivotNormalizedBar',
            },
            pieGroup: {
                _key: 'pivotPieChart',
                pie: 'pivotPie',
                donut: 'pivotDonut',
                doughnut: 'pivotDonut',
            },
            lineGroup: {
                _key: 'pivotLineChart',
                line: 'pivotLineChart',
            },
            scatterGroup: {
                _key: 'pivotXYChart',
                bubble: 'pivotBubble',
                scatter: 'pivotScatter',
            },
            areaGroup: {
                _key: 'pivotAreaChart',
                area: 'pivotArea',
                stackedArea: 'pivotStackedArea',
                normalizedArea: 'pivotNormalizedArea',
            },
            combinationGroup: {
                _key: 'pivotCombinationChart',
                columnLineCombo: 'pivotColumnLineCombo',
                areaColumnCombo: 'pivotAreaColumnCombo',
                customCombo: null, // Not currently supported
            },
            hierarchicalGroup: {
                _key: 'pivotHierarchicalChart',
                treemap: 'pivotTreemap',
                sunburst: 'pivotSunburst',
            },
            statisticalGroup: {
                _key: 'pivotStatisticalChart',
                histogram: 'pivotHistogram',
                // Some statistical charts do not currently support pivot mode
                rangeBar: null,
                rangeArea: null,
                boxPlot: null,
            },
            // Polar charts do not support pivot mode
            polarGroup: null,
            // Specialized charts do not currently support pivot mode
            specializedGroup: null,
        };
    }
}
class RangeMenuItemMapper {
    constructor(gridOptionsService, chartService, localeService) {
        this.gridOptionsService = gridOptionsService;
        this.chartService = chartService;
        this.localeService = localeService;
    }
    getMenuItem() {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const getMenuItem = (localeKey, defaultText, chartType, key, enterprise = false) => {
            return {
                name: localeTextFunc(localeKey, defaultText),
                action: () => this.chartService.createChartFromCurrentRange(chartType),
                _key: key,
                _enterprise: enterprise
            };
        };
        return {
            name: localeTextFunc('chartRange', 'Chart Range'),
            _key: 'chartRange',
            subMenu: [
                {
                    name: localeTextFunc('columnChart', 'Column'),
                    subMenu: [
                        getMenuItem('groupedColumn', 'Grouped&lrm;', 'groupedColumn', 'rangeGroupedColumn'),
                        getMenuItem('stackedColumn', 'Stacked&lrm;', 'stackedColumn', 'rangeStackedColumn'),
                        getMenuItem('normalizedColumn', '100% Stacked&lrm;', 'normalizedColumn', 'rangeNormalizedColumn')
                    ],
                    _key: 'rangeColumnChart'
                },
                {
                    name: localeTextFunc('barChart', 'Bar'),
                    subMenu: [
                        getMenuItem('groupedBar', 'Grouped&lrm;', 'groupedBar', 'rangeGroupedBar'),
                        getMenuItem('stackedBar', 'Stacked&lrm;', 'stackedBar', 'rangeStackedBar'),
                        getMenuItem('normalizedBar', '100% Stacked&lrm;', 'normalizedBar', 'rangeNormalizedBar')
                    ],
                    _key: 'rangeBarChart'
                },
                {
                    name: localeTextFunc('pieChart', 'Pie'),
                    subMenu: [
                        getMenuItem('pie', 'Pie&lrm;', 'pie', 'rangePie'),
                        getMenuItem('donut', 'Donut&lrm;', 'donut', 'rangeDonut')
                    ],
                    _key: 'rangePieChart'
                },
                getMenuItem('line', 'Line&lrm;', 'line', 'rangeLineChart'),
                {
                    name: localeTextFunc('xyChart', 'X Y (Scatter)'),
                    subMenu: [
                        getMenuItem('scatter', 'Scatter&lrm;', 'scatter', 'rangeScatter'),
                        getMenuItem('bubble', 'Bubble&lrm;', 'bubble', 'rangeBubble')
                    ],
                    _key: 'rangeXYChart'
                },
                {
                    name: localeTextFunc('areaChart', 'Area'),
                    subMenu: [
                        getMenuItem('area', 'Area&lrm;', 'area', 'rangeArea'),
                        getMenuItem('stackedArea', 'Stacked&lrm;', 'stackedArea', 'rangeStackedArea'),
                        getMenuItem('normalizedArea', '100% Stacked&lrm;', 'normalizedArea', 'rangeNormalizedArea')
                    ],
                    _key: 'rangeAreaChart'
                },
                {
                    name: localeTextFunc('polarChart', 'Polar'),
                    subMenu: [
                        getMenuItem('radarLine', 'Radar Line&lrm;', 'radarLine', 'rangeRadarLine'),
                        getMenuItem('radarArea', 'Radar Area&lrm;', 'radarArea', 'rangeRadarArea'),
                        getMenuItem('nightingale', 'Nightingale&lrm;', 'nightingale', 'rangeNightingale'),
                        getMenuItem('radialColumn', 'Radial Column&lrm;', 'radialColumn', 'rangeRadialColumn'),
                        getMenuItem('radialBar', 'Radial Bar&lrm;', 'radialBar', 'rangeRadialBar'),
                    ],
                    _key: 'rangePolarChart',
                    _enterprise: true,
                },
                {
                    name: localeTextFunc('statisticalChart', 'Statistical'),
                    subMenu: [
                        getMenuItem('boxPlot', 'Box Plot&lrm;', 'boxPlot', 'rangeBoxPlot', true),
                        getMenuItem('histogramChart', 'Histogram&lrm;', 'histogram', 'rangeHistogram', false),
                        getMenuItem('rangeBar', 'Range Bar&lrm;', 'rangeBar', 'rangeRangeBar', true),
                        getMenuItem('rangeArea', 'Range Area&lrm;', 'rangeArea', 'rangeRangeArea', true),
                    ],
                    _key: 'rangeStatisticalChart',
                    _enterprise: false, // histogram chart is available in both community and enterprise distributions
                },
                {
                    name: localeTextFunc('hierarchicalChart', 'Hierarchical'),
                    subMenu: [
                        getMenuItem('treemap', 'Treemap&lrm;', 'treemap', 'rangeTreemap'),
                        getMenuItem('sunburst', 'Sunburst&lrm;', 'sunburst', 'rangeSunburst'),
                    ],
                    _key: 'rangeHierarchicalChart',
                    _enterprise: true,
                },
                {
                    name: localeTextFunc('specializedChart', 'Specialized'),
                    subMenu: [
                        getMenuItem('heatmap', 'Heatmap&lrm;', 'heatmap', 'rangeHeatmap'),
                        getMenuItem('waterfall', 'Waterfall&lrm;', 'waterfall', 'rangeWaterfall'),
                    ],
                    _key: 'rangeSpecializedChart',
                    _enterprise: true,
                },
                {
                    name: localeTextFunc('combinationChart', 'Combination'),
                    subMenu: [
                        getMenuItem('columnLineCombo', 'Column & Line&lrm;', 'columnLineCombo', 'rangeColumnLineCombo'),
                        getMenuItem('AreaColumnCombo', 'Area & Column&lrm;', 'areaColumnCombo', 'rangeAreaColumnCombo')
                    ],
                    _key: 'rangeCombinationChart'
                }
            ],
            icon: _.createIconNoSpan('chart', this.gridOptionsService, undefined),
        };
    }
    getConfigLookup() {
        return {
            columnGroup: {
                _key: 'rangeColumnChart',
                column: 'rangeGroupedColumn',
                stackedColumn: 'rangeStackedColumn',
                normalizedColumn: 'rangeNormalizedColumn',
            },
            barGroup: {
                _key: 'rangeBarChart',
                bar: 'rangeGroupedBar',
                stackedBar: 'rangeStackedBar',
                normalizedBar: 'rangeNormalizedBar',
            },
            pieGroup: {
                _key: 'rangePieChart',
                pie: 'rangePie',
                donut: 'rangeDonut',
                doughnut: 'rangeDonut',
            },
            lineGroup: {
                _key: 'rangeLineChart',
                line: 'rangeLineChart',
            },
            scatterGroup: {
                _key: 'rangeXYChart',
                bubble: 'rangeBubble',
                scatter: 'rangeScatter',
            },
            areaGroup: {
                _key: 'rangeAreaChart',
                area: 'rangeArea',
                stackedArea: 'rangeStackedArea',
                normalizedArea: 'rangeNormalizedArea',
            },
            polarGroup: {
                _key: 'rangePolarChart',
                radarLine: 'rangeRadarLine',
                radarArea: 'rangeRadarArea',
                nightingale: 'rangeNightingale',
                radialColumn: 'rangeRadialColumn',
                radialBar: 'rangeRadialBar',
            },
            statisticalGroup: {
                _key: 'rangeStatisticalChart',
                boxPlot: 'rangeBoxPlot',
                histogram: 'rangeHistogram',
                rangeBar: 'rangeRangeBar',
                rangeArea: 'rangeRangeArea',
            },
            hierarchicalGroup: {
                _key: 'rangeHierarchicalChart',
                treemap: 'rangeTreemap',
                sunburst: 'rangeSunburst',
            },
            specializedGroup: {
                _key: 'rangeSpecializedChart',
                heatmap: 'rangeHeatmap',
                waterfall: 'rangeWaterfall',
            },
            combinationGroup: {
                _key: 'rangeCombinationChart',
                columnLineCombo: 'rangeColumnLineCombo',
                areaColumnCombo: 'rangeAreaColumnCombo',
                customCombo: null // Not currently supported
            }
        };
    }
}

var __decorate$1F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ColumnChooserFactory = class ColumnChooserFactory extends BeanStub {
    createColumnSelectPanel(parent, column, draggable, params) {
        var _a, _b;
        const columnSelectPanel = parent.createManagedBean(new PrimaryColsPanel());
        const columnChooserParams = (_b = (_a = params !== null && params !== void 0 ? params : column === null || column === void 0 ? void 0 : column.getColDef().columnChooserParams) !== null && _a !== void 0 ? _a : column === null || column === void 0 ? void 0 : column.getColDef().columnsMenuParams) !== null && _b !== void 0 ? _b : {};
        const { contractColumnSelection, suppressColumnExpandAll, suppressColumnFilter, suppressColumnSelectAll, suppressSyncLayoutWithGrid, columnLayout } = columnChooserParams;
        columnSelectPanel.init(!!draggable, this.gridOptionsService.addGridCommonParams({
            suppressColumnMove: false,
            suppressValues: false,
            suppressPivots: false,
            suppressRowGroups: false,
            suppressPivotMode: false,
            contractColumnSelection: !!contractColumnSelection,
            suppressColumnExpandAll: !!suppressColumnExpandAll,
            suppressColumnFilter: !!suppressColumnFilter,
            suppressColumnSelectAll: !!suppressColumnSelectAll,
            suppressSyncLayoutWithGrid: !!columnLayout || !!suppressSyncLayoutWithGrid,
            onStateUpdated: () => { }
        }), 'columnMenu');
        if (columnLayout) {
            columnSelectPanel.setColumnLayout(columnLayout);
        }
        return columnSelectPanel;
    }
    showColumnChooser({ column, chooserParams, eventSource }) {
        this.hideActiveColumnChooser();
        const columnSelectPanel = this.createColumnSelectPanel(this, column, true, chooserParams);
        const translate = this.localeService.getLocaleTextFunc();
        const columnIndex = this.columnModel.getAllDisplayedColumns().indexOf(column);
        const headerPosition = column ? this.focusService.getFocusedHeader() : null;
        this.activeColumnChooserDialog = this.createBean(new AgDialog({
            title: translate('chooseColumns', 'Choose Columns'),
            component: columnSelectPanel,
            width: 300,
            height: 300,
            resizable: true,
            movable: true,
            centered: true,
            closable: true,
            afterGuiAttached: () => {
                var _a;
                (_a = this.focusService.findNextFocusableElement(columnSelectPanel.getGui())) === null || _a === void 0 ? void 0 : _a.focus();
                this.dispatchVisibleChangedEvent(true, column);
            },
            closedCallback: (event) => {
                const eComp = this.activeColumnChooser.getGui();
                this.destroyBean(this.activeColumnChooser);
                this.activeColumnChooser = undefined;
                this.activeColumnChooserDialog = undefined;
                this.dispatchVisibleChangedEvent(false, column);
                if (column) {
                    this.menuUtils.restoreFocusOnClose({ column, headerPosition, columnIndex, eventSource }, eComp, event, true);
                }
            }
        }));
        this.activeColumnChooser = columnSelectPanel;
    }
    hideActiveColumnChooser() {
        if (this.activeColumnChooserDialog) {
            this.destroyBean(this.activeColumnChooserDialog);
        }
    }
    dispatchVisibleChangedEvent(visible, column) {
        const event = {
            type: Events.EVENT_COLUMN_MENU_VISIBLE_CHANGED,
            visible,
            switchingTab: false,
            key: 'columnChooser',
            column: column !== null && column !== void 0 ? column : null
        };
        this.eventService.dispatchEvent(event);
    }
};
__decorate$1F([
    Autowired('focusService')
], ColumnChooserFactory.prototype, "focusService", void 0);
__decorate$1F([
    Autowired('menuUtils')
], ColumnChooserFactory.prototype, "menuUtils", void 0);
__decorate$1F([
    Autowired('columnModel')
], ColumnChooserFactory.prototype, "columnModel", void 0);
ColumnChooserFactory = __decorate$1F([
    Bean('columnChooserFactory')
], ColumnChooserFactory);

var __decorate$1G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ColumnMenuFactory_1;
let ColumnMenuFactory = ColumnMenuFactory_1 = class ColumnMenuFactory extends BeanStub {
    createMenu(parent, column, sourceElement) {
        const menuList = parent.createManagedBean(new AgMenuList(0, {
            column: column !== null && column !== void 0 ? column : null,
            node: null,
            value: null
        }));
        const menuItems = this.getMenuItems(column);
        const menuItemsMapped = this.menuItemMapper.mapWithStockItems(menuItems, column !== null && column !== void 0 ? column : null, sourceElement);
        menuList.addMenuItems(menuItemsMapped);
        return menuList;
    }
    getMenuItems(column) {
        const defaultItems = this.getDefaultMenuOptions(column);
        let result;
        const columnMainMenuItems = column === null || column === void 0 ? void 0 : column.getColDef().mainMenuItems;
        if (Array.isArray(columnMainMenuItems)) {
            result = columnMainMenuItems;
        }
        else if (typeof columnMainMenuItems === 'function') {
            result = columnMainMenuItems(this.gridOptionsService.addGridCommonParams({
                column: column,
                defaultItems
            }));
        }
        else {
            const userFunc = this.gridOptionsService.getCallback('getMainMenuItems');
            if (userFunc && column) {
                result = userFunc({
                    column,
                    defaultItems
                });
            }
            else {
                result = defaultItems;
            }
        }
        // GUI looks weird when two separators are side by side. this can happen accidentally
        // if we remove items from the menu then two separators can edit up adjacent.
        _.removeRepeatsFromArray(result, ColumnMenuFactory_1.MENU_ITEM_SEPARATOR);
        return result;
    }
    getDefaultMenuOptions(column) {
        const result = [];
        const isLegacyMenuEnabled = this.menuService.isLegacyMenuEnabled();
        if (!column) {
            if (!isLegacyMenuEnabled) {
                result.push('columnChooser');
            }
            result.push('resetColumns');
            return result;
        }
        const allowPinning = !column.getColDef().lockPinned;
        const rowGroupCount = this.columnModel.getRowGroupColumns().length;
        const doingGrouping = rowGroupCount > 0;
        const allowValue = column.isAllowValue();
        const allowRowGroup = column.isAllowRowGroup();
        const isPrimary = column.isPrimary();
        const pivotModeOn = this.columnModel.isPivotMode();
        const isInMemoryRowModel = this.rowModel.getType() === 'clientSide';
        const usingTreeData = this.gridOptionsService.get('treeData');
        const allowValueAgg = 
        // if primary, then only allow aggValue if grouping and it's a value columns
        (isPrimary && doingGrouping && allowValue)
            // secondary columns can always have aggValue, as it means it's a pivot value column
            || !isPrimary;
        if (!isLegacyMenuEnabled && column.isSortable()) {
            const sort = column.getSort();
            if (sort !== 'asc') {
                result.push('sortAscending');
            }
            if (sort !== 'desc') {
                result.push('sortDescending');
            }
            if (sort) {
                result.push('sortUnSort');
            }
            result.push(ColumnMenuFactory_1.MENU_ITEM_SEPARATOR);
        }
        if (this.menuService.isFilterMenuItemEnabled(column)) {
            result.push('columnFilter');
            result.push(ColumnMenuFactory_1.MENU_ITEM_SEPARATOR);
        }
        if (allowPinning) {
            result.push('pinSubMenu');
        }
        if (allowValueAgg) {
            result.push('valueAggSubMenu');
        }
        if (allowPinning || allowValueAgg) {
            result.push(ColumnMenuFactory_1.MENU_ITEM_SEPARATOR);
        }
        result.push('autoSizeThis');
        result.push('autoSizeAll');
        result.push(ColumnMenuFactory_1.MENU_ITEM_SEPARATOR);
        const showRowGroup = column.getColDef().showRowGroup;
        if (showRowGroup) {
            result.push('rowUnGroup');
        }
        else if (allowRowGroup && column.isPrimary()) {
            if (column.isRowGroupActive()) {
                const groupLocked = this.columnModel.isColumnGroupingLocked(column);
                if (!groupLocked) {
                    result.push('rowUnGroup');
                }
            }
            else {
                result.push('rowGroup');
            }
        }
        result.push(ColumnMenuFactory_1.MENU_ITEM_SEPARATOR);
        if (!isLegacyMenuEnabled) {
            result.push('columnChooser');
        }
        result.push('resetColumns');
        // only add grouping expand/collapse if grouping in the InMemoryRowModel
        // if pivoting, we only have expandable groups if grouping by 2 or more columns
        // as the lowest level group is not expandable while pivoting.
        // if not pivoting, then any active row group can be expanded.
        const allowExpandAndContract = isInMemoryRowModel && (usingTreeData || rowGroupCount > (pivotModeOn ? 1 : 0));
        if (allowExpandAndContract) {
            result.push('expandAll');
            result.push('contractAll');
        }
        return result;
    }
};
ColumnMenuFactory.MENU_ITEM_SEPARATOR = 'separator';
__decorate$1G([
    Autowired('menuItemMapper')
], ColumnMenuFactory.prototype, "menuItemMapper", void 0);
__decorate$1G([
    Autowired('columnModel')
], ColumnMenuFactory.prototype, "columnModel", void 0);
__decorate$1G([
    Autowired('rowModel')
], ColumnMenuFactory.prototype, "rowModel", void 0);
__decorate$1G([
    Autowired('filterManager')
], ColumnMenuFactory.prototype, "filterManager", void 0);
__decorate$1G([
    Autowired('menuService')
], ColumnMenuFactory.prototype, "menuService", void 0);
ColumnMenuFactory = ColumnMenuFactory_1 = __decorate$1G([
    Bean('columnMenuFactory')
], ColumnMenuFactory);

var __decorate$1H = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let MenuUtils = class MenuUtils extends BeanStub {
    restoreFocusOnClose(restoreFocusParams, eComp, e, restoreIfMouseEvent) {
        const { eventSource } = restoreFocusParams;
        const isKeyboardEvent = e instanceof KeyboardEvent;
        if ((!restoreIfMouseEvent && !isKeyboardEvent) || !eventSource) {
            return;
        }
        const eDocument = this.gridOptionsService.getDocument();
        if (!eComp.contains(eDocument.activeElement) && eDocument.activeElement !== eDocument.body) {
            // something else has focus, so don't return focus to the header
            return;
        }
        this.focusHeaderCell(restoreFocusParams);
    }
    closePopupAndRestoreFocusOnSelect(hidePopupFunc, restoreFocusParams, event) {
        let keyboardEvent;
        if (event && event.event && event.event instanceof KeyboardEvent) {
            keyboardEvent = event.event;
        }
        hidePopupFunc(keyboardEvent && { keyboardEvent });
        // this method only gets called when the menu was closed by selecting an option
        // in this case we focus the cell that was previously focused, otherwise the header
        const focusedCell = this.focusService.getFocusedCell();
        const eDocument = this.gridOptionsService.getDocument();
        if (eDocument.activeElement === eDocument.body) {
            if (focusedCell) {
                const { rowIndex, rowPinned, column } = focusedCell;
                this.focusService.setFocusedCell({ rowIndex, column, rowPinned, forceBrowserFocus: true, preventScrollOnBrowserFocus: true });
            }
            else {
                this.focusHeaderCell(restoreFocusParams);
            }
        }
    }
    onContextMenu(mouseEvent, touchEvent, showMenuCallback) {
        // to allow us to debug in chrome, we ignore the event if ctrl is pressed.
        // not everyone wants this, so first 'if' below allows to turn this hack off.
        if (!this.gridOptionsService.get('allowContextMenuWithControlKey')) {
            // then do the check
            if (mouseEvent && (mouseEvent.ctrlKey || mouseEvent.metaKey)) {
                return;
            }
        }
        // need to do this regardless of context menu showing or not, so doing
        // before the isSuppressContextMenu() check
        if (mouseEvent) {
            this.blockMiddleClickScrollsIfNeeded(mouseEvent);
        }
        if (this.gridOptionsService.get('suppressContextMenu')) {
            return;
        }
        const eventOrTouch = mouseEvent !== null && mouseEvent !== void 0 ? mouseEvent : touchEvent.touches[0];
        if (showMenuCallback(eventOrTouch)) {
            const event = mouseEvent !== null && mouseEvent !== void 0 ? mouseEvent : touchEvent;
            event.preventDefault();
        }
    }
    focusHeaderCell(restoreFocusParams) {
        const { column, columnIndex, headerPosition, eventSource } = restoreFocusParams;
        const isColumnStillVisible = this.columnModel.getAllDisplayedColumns().some(col => col === column);
        if (isColumnStillVisible && eventSource && _.isVisible(eventSource)) {
            const focusableEl = this.focusService.findTabbableParent(eventSource);
            if (focusableEl) {
                if (column) {
                    this.headerNavigationService.scrollToColumn(column);
                }
                focusableEl.focus();
            }
        }
        // if the focusEl is no longer in the DOM, we try to focus
        // the header that is closest to the previous header position
        else if (headerPosition && columnIndex !== -1) {
            const allColumns = this.columnModel.getAllDisplayedColumns();
            const columnToFocus = allColumns[columnIndex] || _.last(allColumns);
            if (columnToFocus) {
                this.focusService.focusHeaderPosition({
                    headerPosition: {
                        headerRowIndex: headerPosition.headerRowIndex,
                        column: columnToFocus
                    }
                });
            }
        }
    }
    blockMiddleClickScrollsIfNeeded(mouseEvent) {
        // if we don't do this, then middle click will never result in a 'click' event, as 'mousedown'
        // will be consumed by the browser to mean 'scroll' (as you can scroll with the middle mouse
        // button in the browser). so this property allows the user to receive middle button clicks if
        // they want.
        const { gridOptionsService } = this;
        const { which } = mouseEvent;
        if (gridOptionsService.get('suppressMiddleClickScrolls') && which === 2) {
            mouseEvent.preventDefault();
        }
    }
};
__decorate$1H([
    Autowired('focusService')
], MenuUtils.prototype, "focusService", void 0);
__decorate$1H([
    Autowired('headerNavigationService')
], MenuUtils.prototype, "headerNavigationService", void 0);
__decorate$1H([
    Autowired('columnModel')
], MenuUtils.prototype, "columnModel", void 0);
MenuUtils = __decorate$1H([
    Bean('menuUtils')
], MenuUtils);

const MenuModule = {
    version: VERSION$d,
    moduleName: ModuleNames.MenuModule,
    beans: [EnterpriseMenuFactory, ContextMenuFactory, MenuItemMapper, ChartMenuItemMapper, ColumnChooserFactory, ColumnMenuFactory, MenuUtils],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

var __decorate$1I = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class MultiFilter extends TabGuardComp {
    constructor() {
        super(/* html */ `<div class="ag-multi-filter ag-menu-list-compact"></div>`);
        this.filterDefs = [];
        this.filters = [];
        this.guiDestroyFuncs = [];
        // this could be the accordion/sub menu element depending on the display type
        this.filterGuis = [];
        this.activeFilterIndices = [];
        this.lastActivatedMenuItem = null;
        this.afterFiltersReadyFuncs = [];
    }
    postConstruct() {
        this.initialiseTabGuard({
            onFocusIn: e => this.onFocusIn(e)
        });
    }
    static getFilterDefs(params) {
        const { filters } = params;
        return filters && filters.length > 0 ?
            filters :
            [{ filter: 'agTextColumnFilter' }, { filter: 'agSetColumnFilter' }];
    }
    init(params) {
        this.params = params;
        this.filterDefs = MultiFilter.getFilterDefs(params);
        const { column, filterChangedCallback } = params;
        this.column = column;
        this.filterChangedCallback = filterChangedCallback;
        const filterPromises = [];
        this.filterDefs.forEach((filterDef, index) => {
            const filterPromise = this.createFilter(filterDef, index);
            if (filterPromise != null) {
                filterPromises.push(filterPromise);
            }
        });
        // we have to refresh the GUI here to ensure that Angular components are not rendered in odd places
        return new AgPromise(resolve => {
            AgPromise.all(filterPromises).then(filters => {
                this.filters = filters;
                this.refreshGui('columnMenu').then(() => {
                    resolve();
                });
            });
        }).then(() => {
            this.afterFiltersReadyFuncs.forEach(f => f());
            this.afterFiltersReadyFuncs.length = 0;
        });
    }
    refreshGui(container) {
        if (container === this.lastOpenedInContainer) {
            return AgPromise.resolve();
        }
        this.removeAllChildrenExceptTabGuards();
        this.destroyChildren();
        return AgPromise.all(this.filters.map((filter, index) => {
            const filterDef = this.filterDefs[index];
            const filterTitle = this.getFilterTitle(filter, filterDef);
            let filterGuiPromise;
            if (filterDef.display === 'subMenu' && container !== 'toolPanel') {
                // prevent sub-menu being used in tool panel
                filterGuiPromise = this.insertFilterMenu(filter, filterTitle).then(menuItem => menuItem.getGui());
            }
            else if (filterDef.display === 'subMenu' || filterDef.display === 'accordion') {
                // sub-menus should appear as groups in the tool panel
                const group = this.insertFilterGroup(filter, filterTitle);
                filterGuiPromise = AgPromise.resolve(group.getGui());
            }
            else {
                // display inline
                filterGuiPromise = AgPromise.resolve(filter.getGui());
            }
            return filterGuiPromise;
        })).then((filterGuis) => {
            filterGuis.forEach((filterGui, index) => {
                if (index > 0) {
                    this.appendChild(_.loadTemplate(/* html */ `<div class="ag-filter-separator"></div>`));
                }
                this.appendChild(filterGui);
            });
            this.filterGuis = filterGuis;
            this.lastOpenedInContainer = container;
        });
    }
    getFilterTitle(filter, filterDef) {
        if (filterDef.title != null) {
            return filterDef.title;
        }
        return filter instanceof ProvidedFilter ? filter.getFilterTitle() : 'Filter';
    }
    destroyChildren() {
        this.guiDestroyFuncs.forEach(func => func());
        this.guiDestroyFuncs.length = 0;
        this.filterGuis.length = 0;
    }
    insertFilterMenu(filter, name) {
        const menuItem = this.createBean(new AgMenuItemComponent());
        return menuItem.init({
            menuItemDef: {
                name,
                subMenu: [],
                cssClasses: ['ag-multi-filter-menu-item'],
                menuItem: AgMenuItemRenderer,
                menuItemParams: {
                    cssClassPrefix: 'ag-compact-menu-option',
                    isCompact: true,
                }
            },
            level: 0,
            isAnotherSubMenuOpen: () => false,
            childComponent: filter,
            contextParams: {
                column: null,
                node: null,
                value: null
            }
        }).then(() => {
            menuItem.setParentComponent(this);
            this.guiDestroyFuncs.push(() => this.destroyBean(menuItem));
            this.addManagedListener(menuItem, AgMenuItemComponent.EVENT_MENU_ITEM_ACTIVATED, (event) => {
                if (this.lastActivatedMenuItem && this.lastActivatedMenuItem !== event.menuItem) {
                    this.lastActivatedMenuItem.deactivate();
                }
                this.lastActivatedMenuItem = event.menuItem;
            });
            const menuItemGui = menuItem.getGui();
            // `AgMenuList` normally handles keyboard navigation, so need to do here
            menuItem.addManagedListener(menuItemGui, 'keydown', (e) => {
                const { key } = e;
                switch (key) {
                    case KeyCode.UP:
                    case KeyCode.RIGHT:
                    case KeyCode.DOWN:
                    case KeyCode.LEFT:
                        e.preventDefault();
                        if (key === KeyCode.RIGHT) {
                            menuItem.openSubMenu(true);
                        }
                        break;
                }
            });
            menuItem.addManagedListener(menuItemGui, 'focusin', () => menuItem.activate());
            menuItem.addManagedListener(menuItemGui, 'focusout', () => {
                if (!menuItem.isSubMenuOpen() && !menuItem.isSubMenuOpening()) {
                    menuItem.deactivate();
                }
            });
            return menuItem;
        });
    }
    insertFilterGroup(filter, title) {
        const group = this.createBean(new AgGroupComponent({
            title,
            cssIdentifier: 'multi-filter',
        }));
        this.guiDestroyFuncs.push(() => this.destroyBean(group));
        group.addItem(filter.getGui());
        group.toggleGroupExpand(false);
        if (filter.afterGuiAttached) {
            group.addManagedListener(group, AgGroupComponent.EVENT_EXPANDED, () => filter.afterGuiAttached({
                container: this.lastOpenedInContainer,
                suppressFocus: true,
                hidePopup: this.hidePopup
            }));
        }
        return group;
    }
    isFilterActive() {
        return this.filters.some(filter => filter.isFilterActive());
    }
    getLastActiveFilterIndex() {
        return this.activeFilterIndices.length > 0 ? this.activeFilterIndices[this.activeFilterIndices.length - 1] : null;
    }
    doesFilterPass(params, filterToSkip) {
        let rowPasses = true;
        this.filters.forEach(filter => {
            if (!rowPasses || filter === filterToSkip || !filter.isFilterActive()) {
                return;
            }
            rowPasses = filter.doesFilterPass(params);
        });
        return rowPasses;
    }
    getFilterType() {
        return 'multi';
    }
    getModelFromUi() {
        const model = {
            filterType: this.getFilterType(),
            filterModels: this.filters.map(filter => {
                const providedFilter = filter;
                if (typeof providedFilter.getModelFromUi === 'function') {
                    return providedFilter.getModelFromUi();
                }
                return null;
            })
        };
        return model;
    }
    getModel() {
        if (!this.isFilterActive()) {
            return null;
        }
        const model = {
            filterType: this.getFilterType(),
            filterModels: this.filters.map(filter => {
                if (filter.isFilterActive()) {
                    return filter.getModel();
                }
                return null;
            })
        };
        return model;
    }
    setModel(model) {
        const setFilterModel = (filter, filterModel) => {
            return new AgPromise(resolve => {
                const promise = filter.setModel(filterModel);
                promise ? promise.then(() => resolve()) : resolve();
            });
        };
        let promises = [];
        if (model == null) {
            promises = this.filters.map((filter, index) => {
                const res = setFilterModel(filter, null).then(() => {
                    this.updateActiveList(index);
                });
                return res;
            });
        }
        else {
            this.filters.forEach((filter, index) => {
                const filterModel = model.filterModels.length > index ? model.filterModels[index] : null;
                const res = setFilterModel(filter, filterModel).then(() => {
                    this.updateActiveList(index);
                });
                promises.push(res);
            });
        }
        return AgPromise.all(promises).then(() => { });
    }
    applyModel(source = 'api') {
        let result = false;
        this.filters.forEach((filter) => {
            if (filter instanceof ProvidedFilter) {
                result = filter.applyModel(source) || result;
            }
        });
        return result;
    }
    getChildFilterInstance(index) {
        return this.filters[index];
    }
    afterGuiAttached(params) {
        let refreshPromise;
        if (params) {
            this.hidePopup = params.hidePopup;
            refreshPromise = this.refreshGui(params.container);
        }
        else {
            this.hidePopup = undefined;
            refreshPromise = AgPromise.resolve();
        }
        refreshPromise.then(() => {
            const { filterDefs } = this;
            let hasFocused = false;
            if (filterDefs) {
                _.forEachReverse(filterDefs, (filterDef, index) => {
                    var _a;
                    const isFirst = index === 0;
                    const suppressFocus = !isFirst || filterDef.display !== 'inline';
                    const afterGuiAttachedParams = Object.assign(Object.assign({}, params !== null && params !== void 0 ? params : {}), { suppressFocus });
                    const filter = (_a = this.filters) === null || _a === void 0 ? void 0 : _a[index];
                    if (filter) {
                        this.executeFunctionIfExistsOnFilter(filter, 'afterGuiAttached', afterGuiAttachedParams);
                        if (isFirst) {
                            hasFocused = true;
                        }
                    }
                    if (isFirst && suppressFocus) {
                        // focus the first filter container instead (accordion/sub menu)
                        const filterGui = this.filterGuis[index];
                        if (filterGui) {
                            filterGui.focus();
                            hasFocused = true;
                        }
                    }
                });
            }
            const eDocument = this.gridOptionsService.getDocument();
            const activeEl = eDocument.activeElement;
            // if we haven't focused the first item in the filter, we might run into two scenarios:
            // 1 - we are loading the filter for the first time and the component isn't ready,
            //     which means the document will have focus.
            // 2 - The focus will be somewhere inside the component due to auto focus
            // In both cases we need to force the focus somewhere valid but outside the filter.
            if (!hasFocused && (activeEl === eDocument.body || this.getGui().contains(activeEl))) {
                // reset focus to the top of the container, and blur
                this.forceFocusOutOfContainer(true);
            }
        });
    }
    afterGuiDetached() {
        this.executeFunctionIfExists('afterGuiDetached');
    }
    onAnyFilterChanged() {
        this.executeFunctionIfExists('onAnyFilterChanged');
    }
    onNewRowsLoaded() {
        this.executeFunctionIfExists('onNewRowsLoaded');
    }
    destroy() {
        this.filters.forEach(filter => {
            filter.setModel(null);
            this.destroyBean(filter);
        });
        this.filters.length = 0;
        this.destroyChildren();
        this.hidePopup = undefined;
        super.destroy();
    }
    executeFunctionIfExists(name, ...params) {
        // The first filter is always the "dominant" one. By iterating in reverse order we ensure the first filter
        // always gets the last say
        _.forEachReverse(this.filters, filter => {
            this.executeFunctionIfExistsOnFilter(filter, name, params);
        });
    }
    executeFunctionIfExistsOnFilter(filter, name, ...params) {
        const func = filter[name];
        if (typeof func === 'function') {
            func.apply(filter, params);
        }
    }
    createFilter(filterDef, index) {
        const { filterModifiedCallback, doesRowPassOtherFilter } = this.params;
        let filterInstance;
        const filterParams = Object.assign(Object.assign({}, this.filterManager.createFilterParams(this.column, this.column.getColDef())), { filterModifiedCallback, filterChangedCallback: additionalEventAttributes => {
                this.executeWhenAllFiltersReady(() => this.filterChanged(index, additionalEventAttributes));
            }, doesRowPassOtherFilter: (node) => doesRowPassOtherFilter(node) && this.doesFilterPass({ node, data: node.data }, filterInstance) });
        const compDetails = this.userComponentFactory.getFilterDetails(filterDef, filterParams, 'agTextColumnFilter');
        if (!compDetails) {
            return null;
        }
        const filterPromise = compDetails.newAgStackInstance();
        if (filterPromise) {
            filterPromise.then(filter => filterInstance = filter);
        }
        return filterPromise;
    }
    executeWhenAllFiltersReady(action) {
        if (this.filters && this.filters.length > 0) {
            action();
        }
        else {
            this.afterFiltersReadyFuncs.push(action);
        }
    }
    updateActiveList(index) {
        const changedFilter = this.filters[index];
        _.removeFromArray(this.activeFilterIndices, index);
        if (changedFilter.isFilterActive()) {
            this.activeFilterIndices.push(index);
        }
    }
    filterChanged(index, additionalEventAttributes) {
        this.updateActiveList(index);
        this.filterChangedCallback(additionalEventAttributes);
        const changedFilter = this.filters[index];
        this.filters.forEach(filter => {
            if (filter === changedFilter) {
                return;
            }
            if (typeof filter.onAnyFilterChanged === 'function') {
                filter.onAnyFilterChanged();
            }
        });
    }
    onFocusIn(e) {
        if (this.lastActivatedMenuItem != null && !this.lastActivatedMenuItem.getGui().contains(e.target)) {
            this.lastActivatedMenuItem.deactivate();
            this.lastActivatedMenuItem = null;
        }
    }
    getModelAsString(model) {
        var _a, _b, _c, _d;
        if (!this.filters || !((_a = model === null || model === void 0 ? void 0 : model.filterModels) === null || _a === void 0 ? void 0 : _a.length)) {
            return '';
        }
        const lastActiveIndex = (_b = this.getLastActiveFilterIndex()) !== null && _b !== void 0 ? _b : 0;
        const activeFilter = this.filters[lastActiveIndex];
        return (_d = (_c = activeFilter.getModelAsString) === null || _c === void 0 ? void 0 : _c.call(activeFilter, model.filterModels[lastActiveIndex])) !== null && _d !== void 0 ? _d : '';
    }
}
__decorate$1I([
    Autowired('filterManager')
], MultiFilter.prototype, "filterManager", void 0);
__decorate$1I([
    Autowired('userComponentFactory')
], MultiFilter.prototype, "userComponentFactory", void 0);
__decorate$1I([
    PostConstruct
], MultiFilter.prototype, "postConstruct", null);

var __decorate$1J = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class MultiFloatingFilterComp extends Component {
    constructor() {
        super(/* html */ `<div class="ag-multi-floating-filter ag-floating-filter-input"></div>`);
        this.floatingFilters = [];
        this.compDetailsList = [];
    }
    init(params) {
        this.params = params;
        const { compDetailsList } = this.getCompDetailsList(params);
        return this.setParams(compDetailsList);
    }
    setParams(compDetailsList) {
        const floatingFilterPromises = [];
        compDetailsList.forEach(compDetails => {
            const floatingFilterPromise = compDetails === null || compDetails === void 0 ? void 0 : compDetails.newAgStackInstance();
            if (floatingFilterPromise != null) {
                this.compDetailsList.push(compDetails);
                floatingFilterPromises.push(floatingFilterPromise);
            }
        });
        return AgPromise.all(floatingFilterPromises).then(floatingFilters => {
            floatingFilters.forEach((floatingFilter, index) => {
                this.floatingFilters.push(floatingFilter);
                const gui = floatingFilter.getGui();
                this.appendChild(gui);
                if (index > 0) {
                    _.setDisplayed(gui, false);
                }
            });
        });
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        this.params = params;
        const { compDetailsList: newCompDetailsList, floatingFilterParamsList } = this.getCompDetailsList(params);
        const allFloatingFilterCompsUnchanged = newCompDetailsList.length === this.compDetailsList.length
            && newCompDetailsList.every((newCompDetails, index) => !this.filterManager.areFilterCompsDifferent(this.compDetailsList[index], newCompDetails));
        if (allFloatingFilterCompsUnchanged) {
            floatingFilterParamsList.forEach((floatingFilterParams, index) => {
                var _a;
                const floatingFilter = this.floatingFilters[index];
                let hasRefreshed = false;
                if (floatingFilter.refresh) {
                    const result = floatingFilter.refresh(floatingFilterParams);
                    // framework wrapper always implements optional methods, but returns null if no underlying method
                    if (result !== null) {
                        hasRefreshed = true;
                    }
                }
                if (!hasRefreshed) {
                    (_a = floatingFilter.onParamsUpdated) === null || _a === void 0 ? void 0 : _a.call(floatingFilter, floatingFilterParams);
                }
            });
        }
        else {
            _.clearElement(this.getGui());
            this.destroyBeans(this.floatingFilters);
            this.floatingFilters = [];
            this.compDetailsList = [];
            this.setParams(newCompDetailsList);
        }
    }
    getCompDetailsList(params) {
        const compDetailsList = [];
        const floatingFilterParamsList = [];
        const filterParams = params.filterParams;
        MultiFilter.getFilterDefs(filterParams).forEach((filterDef, index) => {
            const floatingFilterParams = Object.assign(Object.assign({}, params), { 
                // set the parent filter instance for each floating filter to the relevant child filter instance
                parentFilterInstance: (callback) => {
                    this.parentMultiFilterInstance((parent) => {
                        const child = parent.getChildFilterInstance(index);
                        if (child == null) {
                            return;
                        }
                        callback(child);
                    });
                } });
            _.mergeDeep(floatingFilterParams.filterParams, filterDef.filterParams);
            const compDetails = this.getCompDetails(filterDef, floatingFilterParams);
            if (compDetails) {
                compDetailsList.push(compDetails);
                floatingFilterParamsList.push(floatingFilterParams);
            }
        });
        return { compDetailsList, floatingFilterParamsList };
    }
    onParentModelChanged(model, event) {
        // We don't want to update the floating filter if the floating filter caused the change,
        // because the UI is already in sync. if we didn't do this, the UI would behave strangely
        // as it would be updating as the user is typing
        if (event && event.afterFloatingFilter) {
            return;
        }
        this.parentMultiFilterInstance((parent) => {
            if (model == null) {
                this.floatingFilters.forEach((filter, i) => {
                    filter.onParentModelChanged(null, event);
                    _.setDisplayed(filter.getGui(), i === 0);
                });
            }
            else {
                const lastActiveFloatingFilterIndex = parent.getLastActiveFilterIndex();
                this.floatingFilters.forEach((filter, i) => {
                    const filterModel = model.filterModels.length > i ? model.filterModels[i] : null;
                    filter.onParentModelChanged(filterModel, event);
                    const shouldShow = lastActiveFloatingFilterIndex == null ? i === 0 : i === lastActiveFloatingFilterIndex;
                    _.setDisplayed(filter.getGui(), shouldShow);
                });
            }
        });
    }
    destroy() {
        this.destroyBeans(this.floatingFilters);
        this.floatingFilters.length = 0;
        super.destroy();
    }
    getCompDetails(filterDef, params) {
        var _a;
        let defaultComponentName = (_a = this.userComponentFactory.getDefaultFloatingFilterType(filterDef, () => this.filterManager.getDefaultFloatingFilter(this.params.column))) !== null && _a !== void 0 ? _a : 'agReadOnlyFloatingFilter';
        return this.userComponentFactory.getFloatingFilterCompDetails(filterDef, params, defaultComponentName);
    }
    parentMultiFilterInstance(cb) {
        this.params.parentFilterInstance((parent) => {
            if (!(parent instanceof MultiFilter)) {
                throw new Error('AG Grid - MultiFloatingFilterComp expects MultiFilter as its parent');
            }
            cb(parent);
        });
    }
}
__decorate$1J([
    Autowired('userComponentFactory')
], MultiFloatingFilterComp.prototype, "userComponentFactory", void 0);
__decorate$1J([
    Autowired('filterManager')
], MultiFloatingFilterComp.prototype, "filterManager", void 0);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$e = '31.1.1';

const MultiFilterModule = {
    version: VERSION$e,
    moduleName: ModuleNames.MultiFilterModule,
    beans: [],
    userComponents: [
        { componentName: 'agMultiColumnFilter', componentClass: MultiFilter },
        { componentName: 'agMultiColumnFloatingFilter', componentClass: MultiFloatingFilterComp },
    ],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

class RichSelectCellEditor extends PopupComponent {
    constructor() {
        super(/* html */ `<div class="ag-cell-edit-wrapper"></div>`);
    }
    init(params) {
        this.params = params;
        const { cellStartedEdit, cellHeight, values } = params;
        if (_.missing(values)) {
            console.warn('AG Grid: agRichSelectCellEditor requires cellEditorParams.values to be set');
        }
        const { params: richSelectParams, valuesPromise } = this.buildRichSelectParams();
        this.richSelect = this.createManagedBean(new AgRichSelect(richSelectParams));
        this.richSelect.addCssClass('ag-cell-editor');
        this.appendChild(this.richSelect);
        if (valuesPromise) {
            valuesPromise.then((values) => {
                this.richSelect.setValueList({ valueList: values, refresh: true });
                const searchStringCallback = this.getSearchStringCallback(values);
                if (searchStringCallback) {
                    this.richSelect.setSearchStringCreator(searchStringCallback);
                }
            });
        }
        this.addManagedListener(this.richSelect, Events.EVENT_FIELD_PICKER_VALUE_SELECTED, this.onEditorPickerValueSelected.bind(this));
        this.addManagedListener(this.richSelect.getGui(), 'focusout', this.onEditorFocusOut.bind(this));
        this.focusAfterAttached = cellStartedEdit;
        if (_.exists(cellHeight)) {
            this.richSelect.setRowHeight(cellHeight);
        }
    }
    onEditorPickerValueSelected(e) {
        this.params.stopEditing(!e.fromEnterKey);
    }
    onEditorFocusOut(e) {
        if (this.richSelect.getGui().contains(e.relatedTarget)) {
            return;
        }
        this.params.stopEditing(true);
    }
    buildRichSelectParams() {
        const { cellRenderer, value, values, formatValue, searchDebounceDelay, valueListGap, valueListMaxHeight, valueListMaxWidth, allowTyping, filterList, searchType, highlightMatch, valuePlaceholder, eventKey } = this.params;
        const ret = {
            value: value,
            cellRenderer,
            searchDebounceDelay,
            valueFormatter: formatValue,
            pickerAriaLabelKey: 'ariaLabelRichSelectField',
            pickerAriaLabelValue: 'Rich Select Field',
            pickerType: 'virtual-list',
            pickerGap: valueListGap,
            allowTyping,
            filterList,
            searchType,
            highlightMatch,
            maxPickerHeight: valueListMaxHeight,
            maxPickerWidth: valueListMaxWidth,
            placeholder: valuePlaceholder,
            initialInputValue: (eventKey === null || eventKey === void 0 ? void 0 : eventKey.length) === 1 ? eventKey : undefined
        };
        let valuesResult;
        let valuesPromise;
        if (typeof values === 'function') {
            valuesResult = values(this.params);
        }
        else {
            valuesResult = values !== null && values !== void 0 ? values : [];
        }
        if (Array.isArray(valuesResult)) {
            ret.valueList = valuesResult;
            ret.searchStringCreator = this.getSearchStringCallback(valuesResult);
        }
        else {
            valuesPromise = valuesResult;
        }
        return { params: ret, valuesPromise };
    }
    getSearchStringCallback(values) {
        const { colDef } = this.params;
        if (typeof values[0] !== 'object' || !colDef.keyCreator) {
            return;
        }
        return (values) => values.map((value) => {
            const keyParams = this.gridOptionsService.addGridCommonParams({
                value: value,
                colDef: this.params.colDef,
                column: this.params.column,
                node: this.params.node,
                data: this.params.data
            });
            return colDef.keyCreator(keyParams);
        });
    }
    // we need to have the gui attached before we can draw the virtual rows, as the
    // virtual row logic needs info about the gui state
    afterGuiAttached() {
        const { focusAfterAttached, params } = this;
        setTimeout(() => {
            if (!this.isAlive()) {
                return;
            }
            if (focusAfterAttached) {
                const focusableEl = this.richSelect.getFocusableElement();
                focusableEl.focus();
                const { allowTyping, eventKey } = this.params;
                if (allowTyping && (!eventKey || eventKey.length !== 1)) {
                    focusableEl.select();
                }
            }
            this.richSelect.showPicker();
            const { eventKey } = params;
            if (eventKey) {
                if ((eventKey === null || eventKey === void 0 ? void 0 : eventKey.length) === 1) {
                    this.richSelect.searchTextFromString(eventKey);
                }
            }
        });
    }
    getValue() {
        return this.richSelect.getValue();
    }
    isPopup() {
        return false;
    }
}

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$f = '31.1.1';

const RichSelectModule = {
    version: VERSION$f,
    moduleName: ModuleNames.RichSelectModule,
    beans: [],
    userComponents: [
        { componentName: 'agRichSelect', componentClass: RichSelectCellEditor },
        { componentName: 'agRichSelectCellEditor', componentClass: RichSelectCellEditor }
    ],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

var __decorate$1K = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class FullStore extends RowNodeBlock {
    constructor(ssrmParams, storeParams, parentRowNode) {
        // finite block represents a cache with just one block, thus 0 is the id, it's the first block
        super(0);
        this.nodeIdSequence = new NumberSequence();
        this.info = {};
        this.ssrmParams = ssrmParams;
        this.parentRowNode = parentRowNode;
        this.level = parentRowNode.level + 1;
        this.groupLevel = ssrmParams.rowGroupCols ? this.level < ssrmParams.rowGroupCols.length : undefined;
        this.leafGroup = ssrmParams.rowGroupCols ? this.level === ssrmParams.rowGroupCols.length - 1 : false;
    }
    postConstruct() {
        this.usingTreeData = this.gridOptionsService.get('treeData');
        this.nodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.parentRowNode);
        if (!this.usingTreeData && this.groupLevel) {
            const groupColVo = this.ssrmParams.rowGroupCols[this.level];
            this.groupField = groupColVo.field;
            this.rowGroupColumn = this.columnModel.getRowGroupColumns()[this.level];
        }
        let initialRowCount = 1;
        const isRootStore = this.parentRowNode.level === -1;
        const userInitialRowCount = this.storeUtils.getServerSideInitialRowCount();
        if (isRootStore && userInitialRowCount != null) {
            initialRowCount = userInitialRowCount;
        }
        this.initialiseRowNodes(initialRowCount);
        this.rowNodeBlockLoader.addBlock(this);
        this.addDestroyFunc(() => this.rowNodeBlockLoader.removeBlock(this));
        this.postSortFunc = this.gridOptionsService.getCallback('postSortRows');
        if (userInitialRowCount != null) {
            this.eventService.dispatchEventOnce({
                type: Events.EVENT_ROW_COUNT_READY
            });
        }
    }
    destroyRowNodes() {
        this.blockUtils.destroyRowNodes(this.allRowNodes);
        this.allRowNodes = [];
        this.nodesAfterSort = [];
        this.nodesAfterFilter = [];
        this.allNodesMap = {};
    }
    initialiseRowNodes(loadingRowsCount, failedLoad = false) {
        this.destroyRowNodes();
        for (let i = 0; i < loadingRowsCount; i++) {
            const loadingRowNode = this.blockUtils.createRowNode({
                field: this.groupField, group: this.groupLevel, leafGroup: this.leafGroup,
                level: this.level, parent: this.parentRowNode, rowGroupColumn: this.rowGroupColumn
            });
            if (failedLoad) {
                loadingRowNode.failedLoad = true;
            }
            this.allRowNodes.push(loadingRowNode);
            this.nodesAfterFilter.push(loadingRowNode);
            this.nodesAfterSort.push(loadingRowNode);
        }
    }
    getBlockStateJson() {
        return {
            id: this.nodeIdPrefix ? this.nodeIdPrefix : '',
            state: this.getState()
        };
    }
    loadFromDatasource() {
        this.storeUtils.loadFromDatasource({
            startRow: undefined,
            endRow: undefined,
            parentBlock: this,
            parentNode: this.parentRowNode,
            storeParams: this.ssrmParams,
            success: this.success.bind(this, this.getVersion()),
            fail: this.pageLoadFailed.bind(this, this.getVersion())
        });
    }
    getStartRow() {
        return 0; // always zero as not in a cache
    }
    getEndRow() {
        return this.nodesAfterSort.length;
    }
    createDataNode(data, index) {
        const rowNode = this.blockUtils.createRowNode({
            field: this.groupField, group: this.groupLevel, leafGroup: this.leafGroup,
            level: this.level, parent: this.parentRowNode, rowGroupColumn: this.rowGroupColumn
        });
        if (index != null) {
            _.insertIntoArray(this.allRowNodes, rowNode, index);
        }
        else {
            this.allRowNodes.push(rowNode);
        }
        const defaultId = this.prefixId(this.nodeIdSequence.next());
        this.blockUtils.setDataIntoRowNode(rowNode, data, defaultId, undefined);
        this.nodeManager.addRowNode(rowNode);
        this.blockUtils.checkOpenByDefault(rowNode);
        this.allNodesMap[rowNode.id] = rowNode;
        return rowNode;
    }
    prefixId(id) {
        if (this.nodeIdPrefix) {
            return this.nodeIdPrefix + '-' + id;
        }
        else {
            return id.toString();
        }
    }
    processServerFail() {
        this.initialiseRowNodes(1, true);
        this.fireStoreUpdatedEvent();
        this.flushAsyncTransactions();
    }
    processServerResult(params) {
        if (!this.isAlive()) {
            return;
        }
        const info = params.groupLevelInfo;
        if (info) {
            Object.assign(this.info, info);
        }
        if (params.pivotResultFields) {
            this.serverSideRowModel.generateSecondaryColumns(params.pivotResultFields);
        }
        const nodesToRecycle = this.allRowNodes.length > 0 ? this.allNodesMap : undefined;
        this.allRowNodes = [];
        this.nodesAfterSort = [];
        this.nodesAfterFilter = [];
        this.allNodesMap = {};
        if (!params.rowData) {
            _.warnOnce('"params.data" is missing from Server-Side Row Model success() callback. Please use the "data" attribute. If no data is returned, set an empty list.');
        }
        this.createOrRecycleNodes(nodesToRecycle, params.rowData);
        if (nodesToRecycle) {
            this.blockUtils.destroyRowNodes(_.getAllValuesInObject(nodesToRecycle));
        }
        if (this.level === 0) {
            this.eventService.dispatchEventOnce({
                type: Events.EVENT_ROW_COUNT_READY
            });
        }
        this.filterAndSortNodes();
        this.fireStoreUpdatedEvent();
        this.flushAsyncTransactions();
    }
    createOrRecycleNodes(nodesToRecycle, rowData) {
        if (!rowData) {
            return;
        }
        const lookupNodeToRecycle = (data) => {
            if (!nodesToRecycle) {
                return undefined;
            }
            const getRowIdFunc = this.gridOptionsService.getCallback('getRowId');
            if (!getRowIdFunc) {
                return undefined;
            }
            const parentKeys = this.parentRowNode.getGroupKeys();
            const level = this.level;
            const id = getRowIdFunc({
                data,
                parentKeys: parentKeys.length > 0 ? parentKeys : undefined,
                level,
            });
            const foundNode = nodesToRecycle[id];
            if (!foundNode) {
                return undefined;
            }
            delete nodesToRecycle[id];
            return foundNode;
        };
        const recycleNode = (rowNode, dataItem) => {
            this.allNodesMap[rowNode.id] = rowNode;
            this.blockUtils.updateDataIntoRowNode(rowNode, dataItem);
            this.allRowNodes.push(rowNode);
        };
        rowData.forEach(dataItem => {
            const nodeToRecycle = lookupNodeToRecycle(dataItem);
            if (nodeToRecycle) {
                recycleNode(nodeToRecycle, dataItem);
            }
            else {
                this.createDataNode(dataItem);
            }
        });
    }
    flushAsyncTransactions() {
        // we want to update the store with any outstanding transactions straight away,
        // as otherwise if waitTimeMillis is large (eg 5s), then the user could be looking
        // at old data for a few seconds before the transactions is applied, which isn't what
        // you would expect when we advertise 'transaction is applied when data is loaded'.
        // we do this in a timeout as flushAsyncTransactions expects the grid to be in a settled
        // state, not in the middle of loading rows! keeps the VM Turns more simple and deterministic.
        window.setTimeout(() => this.transactionManager.flushAsyncTransactions(), 0);
    }
    filterAndSortNodes() {
        this.filterRowNodes();
        this.sortRowNodes();
    }
    sortRowNodes() {
        const serverIsSorting = this.storeUtils.isServerSideSortAllLevels() || this.storeUtils.isServerSideSortOnServer();
        const sortOptions = this.sortController.getSortOptions();
        const noSortApplied = !sortOptions || sortOptions.length == 0;
        if (serverIsSorting || noSortApplied) {
            this.nodesAfterSort = this.nodesAfterFilter;
            return;
        }
        this.nodesAfterSort = this.rowNodeSorter.doFullSort(this.nodesAfterFilter, sortOptions);
        if (this.postSortFunc) {
            const params = { nodes: this.nodesAfterSort };
            this.postSortFunc(params);
        }
    }
    filterRowNodes() {
        const serverIsFiltering = !this.storeUtils.isServerSideOnlyRefreshFilteredGroups() || this.storeUtils.isServerSideFilterOnServer();
        // filtering for InFullStore only works at lowest level details.
        // reason is the logic for group filtering was to difficult to work out how it should work at time of writing.
        const groupLevel = this.groupLevel;
        if (serverIsFiltering || groupLevel) {
            this.nodesAfterFilter = this.allRowNodes;
            return;
        }
        this.nodesAfterFilter = this.allRowNodes.filter(rowNode => this.filterManager.doesRowPassFilter({ rowNode: rowNode }));
    }
    clearDisplayIndexes() {
        this.displayIndexStart = undefined;
        this.displayIndexEnd = undefined;
        this.allRowNodes.forEach(rowNode => this.blockUtils.clearDisplayIndex(rowNode));
    }
    getDisplayIndexEnd() {
        return this.displayIndexEnd;
    }
    isDisplayIndexInStore(displayIndex) {
        if (this.getRowCount() === 0) {
            return false;
        }
        return displayIndex >= this.displayIndexStart && displayIndex < this.displayIndexEnd;
    }
    setDisplayIndexes(displayIndexSeq, nextRowTop) {
        this.displayIndexStart = displayIndexSeq.peek();
        this.topPx = nextRowTop.value;
        const visibleNodeIds = {};
        // set on all visible nodes
        this.nodesAfterSort.forEach(rowNode => {
            this.blockUtils.setDisplayIndex(rowNode, displayIndexSeq, nextRowTop);
            visibleNodeIds[rowNode.id] = true;
        });
        // and clear on all non-visible nodes
        this.allRowNodes.forEach(rowNode => {
            if (!visibleNodeIds[rowNode.id]) {
                this.blockUtils.clearDisplayIndex(rowNode);
            }
        });
        this.displayIndexEnd = displayIndexSeq.peek();
        this.heightPx = nextRowTop.value - this.topPx;
    }
    forEachStoreDeep(callback, sequence = new NumberSequence()) {
        callback(this, sequence.next());
        this.allRowNodes.forEach(rowNode => {
            const childCache = rowNode.childStore;
            if (childCache) {
                childCache.forEachStoreDeep(callback, sequence);
            }
        });
    }
    forEachNodeDeep(callback, sequence = new NumberSequence()) {
        this.allRowNodes.forEach(rowNode => {
            callback(rowNode, sequence.next());
            const childCache = rowNode.childStore;
            if (childCache) {
                childCache.forEachNodeDeep(callback, sequence);
            }
        });
    }
    forEachNodeDeepAfterFilterAndSort(callback, sequence = new NumberSequence(), includeFooterNodes = false) {
        this.nodesAfterSort.forEach(rowNode => {
            callback(rowNode, sequence.next());
            const childCache = rowNode.childStore;
            if (childCache) {
                childCache.forEachNodeDeepAfterFilterAndSort(callback, sequence, includeFooterNodes);
            }
        });
        if (includeFooterNodes && this.parentRowNode.sibling) {
            callback(this.parentRowNode.sibling, sequence.next());
        }
    }
    getRowUsingDisplayIndex(displayRowIndex) {
        // this can happen if asking for a row that doesn't exist in the model,
        // eg if a cell range is selected, and the user filters so rows no longer exists
        if (!this.isDisplayIndexInStore(displayRowIndex)) {
            return undefined;
        }
        const res = this.blockUtils.binarySearchForDisplayIndex(displayRowIndex, this.nodesAfterSort);
        return res;
    }
    getRowBounds(index) {
        for (let i = 0; i < this.nodesAfterSort.length; i++) {
            const rowNode = this.nodesAfterSort[i];
            const res = this.blockUtils.extractRowBounds(rowNode, index);
            if (res) {
                return res;
            }
        }
        return null;
    }
    isPixelInRange(pixel) {
        return pixel >= this.topPx && pixel < (this.topPx + this.heightPx);
    }
    getRowIndexAtPixel(pixel) {
        // if pixel before block, return first row
        const pixelBeforeThisStore = pixel <= this.topPx;
        if (pixelBeforeThisStore) {
            const firstNode = this.nodesAfterSort[0];
            return firstNode.rowIndex;
        }
        // if pixel after store, return last row, however the last
        // row could be a child store
        const pixelAfterThisStore = pixel >= (this.topPx + this.heightPx);
        if (pixelAfterThisStore) {
            const lastRowNode = this.nodesAfterSort[this.nodesAfterSort.length - 1];
            const lastRowNodeBottomPx = lastRowNode.rowTop + lastRowNode.rowHeight;
            if (pixel >= lastRowNodeBottomPx && lastRowNode.expanded) {
                if (lastRowNode.childStore && lastRowNode.childStore.getRowCount() > 0) {
                    return lastRowNode.childStore.getRowIndexAtPixel(pixel);
                }
                if (lastRowNode.detailNode) {
                    return lastRowNode.detailNode.rowIndex;
                }
            }
            return lastRowNode.rowIndex;
        }
        let res = null;
        this.nodesAfterSort.forEach(rowNode => {
            const res2 = this.blockUtils.getIndexAtPixel(rowNode, pixel);
            if (res2 != null) {
                res = res2;
            }
        });
        const pixelIsPastLastRow = res == null;
        if (pixelIsPastLastRow) {
            return this.displayIndexEnd - 1;
        }
        return res;
    }
    getChildStore(keys) {
        return this.storeUtils.getChildStore(keys, this, (key) => {
            const rowNode = this.allRowNodes.find(currentRowNode => {
                return currentRowNode.key == key;
            });
            return rowNode;
        });
    }
    forEachChildStoreShallow(callback) {
        this.allRowNodes.forEach(rowNode => {
            const childStore = rowNode.childStore;
            if (childStore) {
                callback(childStore);
            }
        });
    }
    refreshAfterFilter(params) {
        const serverIsFiltering = this.storeUtils.isServerSideFilterOnServer();
        const storeIsImpacted = this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params);
        const serverIsFilteringAllLevels = !this.storeUtils.isServerSideOnlyRefreshFilteredGroups();
        if (serverIsFilteringAllLevels || (serverIsFiltering && storeIsImpacted)) {
            this.refreshStore(true);
            this.sortRowNodes();
            return;
        }
        this.filterRowNodes();
        this.sortRowNodes();
        this.forEachChildStoreShallow(store => store.refreshAfterFilter(params));
    }
    refreshAfterSort(params) {
        const serverIsSorting = this.storeUtils.isServerSideSortOnServer();
        const storeIsImpacted = this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params);
        const serverIsSortingAllLevels = this.storeUtils.isServerSideSortAllLevels();
        if (serverIsSortingAllLevels || (serverIsSorting && storeIsImpacted)) {
            this.refreshStore(true);
            this.filterRowNodes();
            return;
        }
        this.filterRowNodes();
        this.sortRowNodes();
        this.forEachChildStoreShallow(store => store.refreshAfterSort(params));
    }
    applyTransaction(transaction) {
        // we only apply transactions to loaded state
        switch (this.getState()) {
            case RowNodeBlock.STATE_FAILED:
                return { status: ServerSideTransactionResultStatus.StoreLoadingFailed };
            case RowNodeBlock.STATE_LOADING:
                return { status: ServerSideTransactionResultStatus.StoreLoading };
            case RowNodeBlock.STATE_WAITING_TO_LOAD:
                return { status: ServerSideTransactionResultStatus.StoreWaitingToLoad };
        }
        const applyCallback = this.gridOptionsService.getCallback('isApplyServerSideTransaction');
        if (applyCallback) {
            const params = {
                transaction: transaction,
                parentNode: this.parentRowNode,
                groupLevelInfo: this.info
            };
            const apply = applyCallback(params);
            if (!apply) {
                return { status: ServerSideTransactionResultStatus.Cancelled };
            }
        }
        const res = {
            status: ServerSideTransactionResultStatus.Applied,
            remove: [],
            update: [],
            add: []
        };
        const nodesToUnselect = [];
        this.executeAdd(transaction, res);
        this.executeRemove(transaction, res, nodesToUnselect);
        this.executeUpdate(transaction, res, nodesToUnselect);
        this.filterAndSortNodes();
        this.updateSelection(nodesToUnselect);
        return res;
    }
    updateSelection(nodesToUnselect) {
        const selectionChanged = nodesToUnselect.length > 0;
        if (selectionChanged) {
            this.selectionService.setNodesSelected({
                newValue: false,
                nodes: nodesToUnselect,
                suppressFinishActions: true,
                clearSelection: false,
                source: 'rowDataChanged',
            });
            const event = {
                type: Events.EVENT_SELECTION_CHANGED,
                source: 'rowDataChanged'
            };
            this.eventService.dispatchEvent(event);
        }
    }
    executeAdd(rowDataTran, rowNodeTransaction) {
        const { add, addIndex } = rowDataTran;
        if (_.missingOrEmpty(add)) {
            return;
        }
        const useIndex = typeof addIndex === 'number' && addIndex >= 0;
        if (useIndex) {
            // items get inserted in reverse order for index insertion
            add.reverse().forEach(item => {
                const newRowNode = this.createDataNode(item, addIndex);
                rowNodeTransaction.add.push(newRowNode);
            });
        }
        else {
            add.forEach(item => {
                const newRowNode = this.createDataNode(item);
                rowNodeTransaction.add.push(newRowNode);
            });
        }
    }
    executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect) {
        const { remove } = rowDataTran;
        if (remove == null) {
            return;
        }
        const rowIdsRemoved = {};
        remove.forEach(item => {
            const rowNode = this.lookupRowNode(item);
            if (!rowNode) {
                return;
            }
            // do delete - setting 'suppressFinishActions = true' to ensure EVENT_SELECTION_CHANGED is not raised for
            // each row node updated, instead it is raised once by the calling code if any selected nodes exist.
            if (rowNode.isSelected()) {
                nodesToUnselect.push(rowNode);
            }
            // so row renderer knows to fade row out (and not reposition it)
            rowNode.clearRowTopAndRowIndex();
            // NOTE: were we could remove from allLeaveChildren, however _.removeFromArray() is expensive, especially
            // if called multiple times (eg deleting lots of rows) and if allLeafChildren is a large list
            rowIdsRemoved[rowNode.id] = true;
            // _.removeFromArray(this.rootNode.allLeafChildren, rowNode);
            delete this.allNodesMap[rowNode.id];
            rowNodeTransaction.remove.push(rowNode);
            this.nodeManager.removeNode(rowNode);
        });
        this.allRowNodes = this.allRowNodes.filter(rowNode => !rowIdsRemoved[rowNode.id]);
    }
    executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect) {
        const { update } = rowDataTran;
        if (update == null) {
            return;
        }
        update.forEach(item => {
            const rowNode = this.lookupRowNode(item);
            if (!rowNode) {
                return;
            }
            this.blockUtils.updateDataIntoRowNode(rowNode, item);
            if (!rowNode.selectable && rowNode.isSelected()) {
                nodesToUnselect.push(rowNode);
            }
            rowNodeTransaction.update.push(rowNode);
        });
    }
    lookupRowNode(data) {
        const getRowIdFunc = this.gridOptionsService.getCallback('getRowId');
        let rowNode;
        if (getRowIdFunc != null) {
            // find rowNode using id
            const level = this.level;
            const parentKeys = this.parentRowNode.getGroupKeys();
            const id = getRowIdFunc({
                data,
                parentKeys: parentKeys.length > 0 ? parentKeys : undefined,
                level,
            });
            rowNode = this.allNodesMap[id];
            if (!rowNode) {
                console.error(`AG Grid: could not find row id=${id}, data item was not found for this id`);
                return null;
            }
        }
        else {
            // find rowNode using object references
            rowNode = this.allRowNodes.find(currentRowNode => currentRowNode.data === data);
            if (!rowNode) {
                console.error(`AG Grid: could not find data item as object was not found`, data);
                return null;
            }
        }
        return rowNode;
    }
    addStoreStates(result) {
        result.push({
            suppressInfiniteScroll: true,
            route: this.parentRowNode.getGroupKeys(),
            rowCount: this.allRowNodes.length,
            info: this.info
        });
        this.forEachChildStoreShallow(childStore => childStore.addStoreStates(result));
    }
    refreshStore(purge) {
        if (purge) {
            const loadingRowsToShow = this.nodesAfterSort ? this.nodesAfterSort.length : 1;
            this.initialiseRowNodes(loadingRowsToShow);
        }
        this.scheduleLoad();
        this.fireStoreUpdatedEvent();
    }
    retryLoads() {
        if (this.getState() === RowNodeBlock.STATE_FAILED) {
            this.initialiseRowNodes(1);
            this.scheduleLoad();
        }
        this.forEachChildStoreShallow(store => store.retryLoads());
    }
    scheduleLoad() {
        this.setStateWaitingToLoad();
        this.rowNodeBlockLoader.checkBlockToLoad();
    }
    // gets called 1) row count changed 2) cache purged 3) items inserted
    fireStoreUpdatedEvent() {
        // this results in row model firing ModelUpdated.
        // server side row model also updates the row indexes first
        const event = {
            type: Events.EVENT_STORE_UPDATED
        };
        this.eventService.dispatchEvent(event);
    }
    getRowCount() {
        return this.nodesAfterSort.length;
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        const rowNode = this.nodesAfterSort[topLevelIndex];
        return rowNode.rowIndex;
    }
    isLastRowIndexKnown() {
        return this.getState() == RowNodeBlock.STATE_LOADED;
    }
    getRowNodesInRange(firstInRange, lastInRange) {
        const result = [];
        let inActiveRange = false;
        // if only one node passed, we start the selection at the top
        if (_.missing(firstInRange)) {
            inActiveRange = true;
        }
        this.nodesAfterSort.forEach(rowNode => {
            const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;
            if (inActiveRange || hitFirstOrLast) {
                result.push(rowNode);
            }
            if (hitFirstOrLast) {
                inActiveRange = !inActiveRange;
            }
        });
        // inActiveRange will be still true if we never hit the second rowNode
        const invalidRange = inActiveRange;
        return invalidRange ? [] : result;
    }
    getStoreBounds() {
        return {
            topPx: this.topPx,
            heightPx: this.heightPx,
        };
    }
}
__decorate$1K([
    Autowired('ssrmStoreUtils')
], FullStore.prototype, "storeUtils", void 0);
__decorate$1K([
    Autowired('ssrmBlockUtils')
], FullStore.prototype, "blockUtils", void 0);
__decorate$1K([
    Autowired('columnModel')
], FullStore.prototype, "columnModel", void 0);
__decorate$1K([
    Autowired('rowNodeBlockLoader')
], FullStore.prototype, "rowNodeBlockLoader", void 0);
__decorate$1K([
    Autowired('rowNodeSorter')
], FullStore.prototype, "rowNodeSorter", void 0);
__decorate$1K([
    Autowired('sortController')
], FullStore.prototype, "sortController", void 0);
__decorate$1K([
    Autowired('selectionService')
], FullStore.prototype, "selectionService", void 0);
__decorate$1K([
    Autowired('ssrmNodeManager')
], FullStore.prototype, "nodeManager", void 0);
__decorate$1K([
    Autowired('filterManager')
], FullStore.prototype, "filterManager", void 0);
__decorate$1K([
    Autowired('ssrmTransactionManager')
], FullStore.prototype, "transactionManager", void 0);
__decorate$1K([
    Autowired('rowModel')
], FullStore.prototype, "serverSideRowModel", void 0);
__decorate$1K([
    PostConstruct
], FullStore.prototype, "postConstruct", null);
__decorate$1K([
    PreDestroy
], FullStore.prototype, "destroyRowNodes", null);

var __decorate$1L = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class LazyBlockLoader extends BeanStub {
    constructor(cache, parentNode, storeParams) {
        super();
        this.loadingNodes = new Set();
        this.checkForLoadQueued = false;
        this.loaderTimeout = undefined;
        this.nextBlockToLoad = undefined;
        this.parentNode = parentNode;
        this.cache = cache;
        this.storeParams = storeParams;
    }
    init() {
        this.addManagedListener(this.rowNodeBlockLoader, RowNodeBlockLoader.BLOCK_LOADED_EVENT, () => this.queueLoadAction());
    }
    isRowLoading(index) {
        return this.loadingNodes.has(index);
    }
    getBlockToLoad() {
        var _a;
        const firstRowInViewport = this.api.getFirstDisplayedRowIndex();
        const lastRowInViewport = this.api.getLastDisplayedRowIndex();
        // quick look-up for priority rows needing loading in viewport.
        for (let i = firstRowInViewport; i <= lastRowInViewport; i++) {
            const node = this.cache.getNodeCachedByDisplayIndex(i);
            if (!node) {
                // if no row details, ignore, as row hasn't been created
                // and it's too expensive to work out its location here
                continue;
            }
            const lazyNode = this.cache.getNodes().getBy('node', node);
            if (!lazyNode) {
                continue;
            }
            if (this.isRowLoading(lazyNode.index)) {
                continue;
            }
            if (node.__needsRefreshWhenVisible || (node.stub && !node.failedLoad)) {
                return this.getBlockStartIndexForIndex(lazyNode.index);
            }
        }
        const nodesToRefresh = this.cache.getNodesToRefresh();
        let nodeToRefresh = null;
        let nodeToRefreshDist = Number.MAX_SAFE_INTEGER;
        nodesToRefresh.forEach(node => {
            if (node.rowIndex == null) {
                nodeToRefresh = node;
                return;
            }
            if (this.isRowLoading(node.rowIndex)) {
                return;
            }
            const distToViewportTop = Math.abs(firstRowInViewport - node.rowIndex);
            const distToViewportBottom = Math.abs(node.rowIndex - lastRowInViewport);
            if (distToViewportTop < nodeToRefreshDist) {
                nodeToRefresh = node;
                nodeToRefreshDist = distToViewportTop;
            }
            if (distToViewportBottom < nodeToRefreshDist) {
                nodeToRefresh = node;
                nodeToRefreshDist = distToViewportBottom;
            }
        });
        const lazyIndex = (_a = this.cache.getNodes().getBy('node', nodeToRefresh)) === null || _a === void 0 ? void 0 : _a.index;
        return lazyIndex == null ? undefined : this.getBlockStartIndexForIndex(lazyIndex);
    }
    reset() {
        this.loadingNodes.clear();
        clearTimeout(this.loaderTimeout);
        this.loaderTimeout = undefined;
    }
    executeLoad(startRow, endRow) {
        var _a;
        const ssrmParams = this.cache.getSsrmParams();
        const request = {
            startRow,
            endRow,
            rowGroupCols: ssrmParams.rowGroupCols,
            valueCols: ssrmParams.valueCols,
            pivotCols: ssrmParams.pivotCols,
            pivotMode: ssrmParams.pivotMode,
            groupKeys: this.parentNode.getGroupKeys(),
            filterModel: ssrmParams.filterModel,
            sortModel: ssrmParams.sortModel,
        };
        const removeNodesFromLoadingMap = () => {
            for (let i = 0; i < endRow - startRow; i++) {
                this.loadingNodes.delete(startRow + i);
            }
        };
        const addNodesToLoadingMap = () => {
            for (let i = 0; i < endRow - startRow; i++) {
                this.loadingNodes.add(startRow + i);
            }
        };
        const success = (params) => {
            this.rowNodeBlockLoader.loadComplete();
            this.cache.onLoadSuccess(startRow, endRow - startRow, params);
            removeNodesFromLoadingMap();
            this.queueLoadAction();
        };
        const fail = () => {
            this.rowNodeBlockLoader.loadComplete();
            this.cache.onLoadFailed(startRow, endRow - startRow);
            removeNodesFromLoadingMap();
            this.queueLoadAction();
        };
        const params = this.gridOptionsService.addGridCommonParams({
            request,
            success,
            fail,
            parentNode: this.parentNode
        });
        addNodesToLoadingMap();
        (_a = this.cache.getSsrmParams().datasource) === null || _a === void 0 ? void 0 : _a.getRows(params);
    }
    getNextBlockToLoad() {
        const result = this.getBlockToLoad();
        if (result != null) {
            return [String(result), result + this.getBlockSize()];
        }
        return null;
    }
    queueLoadCheck() {
        // already going to check next cycle, ignore.
        if (this.checkForLoadQueued) {
            return;
        }
        this.checkForLoadQueued = true;
        window.queueMicrotask(() => {
            this.checkForLoadQueued = false;
            this.queueLoadAction();
        });
    }
    queueLoadAction() {
        const nextBlockToLoad = this.getNextBlockToLoad();
        if (!nextBlockToLoad) {
            // there's no block we should be loading right now, clear the timeouts
            window.clearTimeout(this.loaderTimeout);
            this.loaderTimeout = undefined;
            this.nextBlockToLoad = undefined;
            return;
        }
        // if the next required block has changed, reset the loading timeout
        if (!this.nextBlockToLoad || (this.nextBlockToLoad[0] !== nextBlockToLoad[0] && this.nextBlockToLoad[1] !== nextBlockToLoad[1])) {
            this.nextBlockToLoad = nextBlockToLoad;
            window.clearTimeout(this.loaderTimeout);
            const [startRowString, endRow] = this.nextBlockToLoad;
            const startRow = Number(startRowString);
            this.loaderTimeout = window.setTimeout(() => {
                if (!this.cache.isAlive()) {
                    return;
                }
                this.loaderTimeout = undefined;
                this.attemptLoad(startRow, endRow);
                this.nextBlockToLoad = undefined;
            }, this.gridOptionsService.get('blockLoadDebounceMillis'));
        }
    }
    attemptLoad(start, end) {
        const availableLoadingCount = this.rowNodeBlockLoader.getAvailableLoadingCount();
        // too many loads already, ignore the request as a successful request will requeue itself anyway
        if (availableLoadingCount != null && availableLoadingCount === 0) {
            return;
        }
        this.rowNodeBlockLoader.registerLoads(1);
        this.executeLoad(start, end);
        this.queueLoadAction();
    }
    getBlockSize() {
        return this.storeParams.cacheBlockSize || LazyBlockLoader.DEFAULT_BLOCK_SIZE;
    }
    getBlockStartIndexForIndex(storeIndex) {
        const blockSize = this.getBlockSize();
        return storeIndex - (storeIndex % blockSize);
    }
    getBlockBoundsForIndex(storeIndex) {
        const startOfBlock = this.getBlockStartIndexForIndex(storeIndex);
        const blockSize = this.getBlockSize();
        return [startOfBlock, startOfBlock + blockSize];
    }
}
LazyBlockLoader.DEFAULT_BLOCK_SIZE = 100;
__decorate$1L([
    Autowired('gridApi')
], LazyBlockLoader.prototype, "api", void 0);
__decorate$1L([
    Autowired('rowNodeBlockLoader')
], LazyBlockLoader.prototype, "rowNodeBlockLoader", void 0);
__decorate$1L([
    PostConstruct
], LazyBlockLoader.prototype, "init", null);

class MultiIndexMap {
    constructor(...indexes) {
        if (indexes.length < 1) {
            throw new Error('AG Grid: At least one index must be provided.');
        }
        this.indexes = indexes;
        this.maps = new Map(this.indexes.map(index => [index, new Map()]));
    }
    getSize() {
        return this.maps.get(this.indexes[0]).size;
    }
    getBy(index, key) {
        const map = this.maps.get(index);
        if (!map) {
            throw new Error(`AG Grid: ${String(index)} not found`);
        }
        return map.get(key);
    }
    set(item) {
        this.indexes.forEach(index => {
            const map = this.maps.get(index);
            if (!map) {
                throw new Error(`AG Grid: ${String(index)} not found`);
            }
            map.set(item[index], item);
        });
    }
    delete(item) {
        this.indexes.forEach(index => {
            const map = this.maps.get(index);
            if (!map) {
                throw new Error(`AG Grid: ${String(index)} not found`);
            }
            map.delete(item[index]);
        });
    }
    clear() {
        this.maps.forEach(map => map.clear());
    }
    getIterator(index) {
        const map = this.maps.get(index);
        if (!map) {
            throw new Error(`AG Grid: ${String(index)} not found`);
        }
        return map.values();
    }
    forEach(callback) {
        const iterator = this.getIterator(this.indexes[0]);
        let pointer;
        while (pointer = iterator.next()) {
            if (pointer.done)
                break;
            callback(pointer.value);
        }
    }
    find(callback) {
        const iterator = this.getIterator(this.indexes[0]);
        let pointer;
        while (pointer = iterator.next()) {
            if (pointer.done)
                break;
            if (callback(pointer.value)) {
                return pointer.value;
            }
        }
    }
    filter(predicate) {
        const iterator = this.getIterator(this.indexes[0]);
        let pointer;
        const result = [];
        while (pointer = iterator.next()) {
            if (pointer.done)
                break;
            if (predicate(pointer.value)) {
                result.push(pointer.value);
            }
        }
        return result;
    }
}

var __decorate$1M = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class LazyCache extends BeanStub {
    constructor(store, numberOfRows, storeParams) {
        super();
        /**
         * Indicates whether this is still the live dataset for this store (used for ignoring old requests after purge)
         */
        this.live = true;
        /**
         * A cache of removed group nodes, this is retained for preserving group
         * state when the node moves in and out of the cache. Generally caused by
         * rows moving blocks.
         */
        this.removedNodeCache = new Map();
        this.store = store;
        this.numberOfRows = numberOfRows;
        this.isLastRowKnown = false;
        this.storeParams = storeParams;
    }
    init() {
        // initiate the node map to be indexed at 'index', 'id' and 'node' for quick look-up.
        // it's important id isn't first, as stub nodes overwrite each-other, and the first index is
        // used for iteration.
        this.nodeMap = new MultiIndexMap('index', 'id', 'node');
        this.nodeDisplayIndexMap = new Map();
        this.nodesToRefresh = new Set();
        this.defaultNodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.store.getParentNode());
        this.rowLoader = this.createManagedBean(new LazyBlockLoader(this, this.store.getParentNode(), this.storeParams));
        this.getRowIdFunc = this.gridOptionsService.getCallback('getRowId');
        this.isMasterDetail = this.gridOptionsService.get('masterDetail');
    }
    destroyRowNodes() {
        this.numberOfRows = 0;
        this.nodeMap.forEach(node => this.blockUtils.destroyRowNode(node.node));
        this.nodeMap.clear();
        this.nodeDisplayIndexMap.clear();
        this.nodesToRefresh.clear();
        this.live = false;
    }
    /**
     * Get the row node for a specific display index from this store
     * @param displayIndex the display index of the node to find
     * @returns undefined if the node is not in the store bounds, otherwise will always return a node
     */
    getRowByDisplayIndex(displayIndex) {
        var _a, _b, _c, _d;
        // if index isn't in store, nothing to return
        if (!this.store.isDisplayIndexInStore(displayIndex)) {
            return undefined;
        }
        // first try to directly look this node up in the display index map
        const node = this.nodeDisplayIndexMap.get(displayIndex);
        if (node) {
            // if we have the node, check if it needs refreshed when rendered
            if (node.stub || node.__needsRefreshWhenVisible) {
                this.rowLoader.queueLoadCheck();
            }
            return node;
        }
        // next check if this is the first row, if so return a stub node
        // this is a performance optimisation, as it is the most common scenario
        // and enables the node - 1 check to kick in more often.
        if (displayIndex === this.store.getDisplayIndexStart()) {
            return this.createStubNode(0, displayIndex);
        }
        // check if the row immediately prior is available in the store
        const contiguouslyPreviousNode = this.nodeDisplayIndexMap.get(displayIndex - 1);
        if (contiguouslyPreviousNode) {
            // if previous row is master detail, and expanded, this node must be detail
            if (this.isMasterDetail && contiguouslyPreviousNode.master && contiguouslyPreviousNode.expanded) {
                return contiguouslyPreviousNode.detailNode;
            }
            // if previous row is expanded group, this node will belong to that group.
            if (contiguouslyPreviousNode.expanded && ((_a = contiguouslyPreviousNode.childStore) === null || _a === void 0 ? void 0 : _a.isDisplayIndexInStore(displayIndex))) {
                return (_b = contiguouslyPreviousNode.childStore) === null || _b === void 0 ? void 0 : _b.getRowUsingDisplayIndex(displayIndex);
            }
            // otherwise, row must be a stub node
            const lazyCacheNode = this.nodeMap.getBy('node', contiguouslyPreviousNode);
            return this.createStubNode(lazyCacheNode.index + 1, displayIndex);
        }
        const adjacentNodes = this.getSurroundingNodesByDisplayIndex(displayIndex);
        // if no bounds skipped includes this, calculate from end index
        if (adjacentNodes == null) {
            const storeIndexFromEndIndex = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - displayIndex);
            return this.createStubNode(storeIndexFromEndIndex, displayIndex);
        }
        const { previousNode, nextNode } = adjacentNodes;
        // if the node before this node is expanded, this node might be a child of that node
        if (previousNode && previousNode.node.expanded && ((_c = previousNode.node.childStore) === null || _c === void 0 ? void 0 : _c.isDisplayIndexInStore(displayIndex))) {
            return (_d = previousNode.node.childStore) === null || _d === void 0 ? void 0 : _d.getRowUsingDisplayIndex(displayIndex);
        }
        // if we have the node after this node, we can calculate the store index of this node by the difference
        // in display indexes between the two nodes.
        if (nextNode) {
            const displayIndexDiff = nextNode.node.rowIndex - displayIndex;
            const newStoreIndex = nextNode.index - displayIndexDiff;
            return this.createStubNode(newStoreIndex, displayIndex);
        }
        // if no next node, calculate from end index of this store
        const storeIndexFromEndIndex = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - displayIndex);
        return this.createStubNode(storeIndexFromEndIndex, displayIndex);
    }
    /**
     * Used for creating and positioning a stub node without firing a store updated event
     */
    createStubNode(storeIndex, displayIndex) {
        // bounds are acquired before creating the node, as otherwise it'll use it's own empty self to calculate
        const rowBounds = this.store.getRowBounds(displayIndex);
        const newNode = this.createRowAtIndex(storeIndex, null, node => {
            node.setRowIndex(displayIndex);
            node.setRowTop(rowBounds.rowTop);
            this.nodeDisplayIndexMap.set(displayIndex, node);
        });
        this.rowLoader.queueLoadCheck();
        return newNode;
    }
    /**
     * @param index The row index relative to this store
     * @returns A rowNode at the given store index
     */
    getRowByStoreIndex(index) {
        var _a;
        return (_a = this.nodeMap.getBy('index', index)) === null || _a === void 0 ? void 0 : _a.node;
    }
    /**
     * Given a number of rows, skips through the given sequence & row top reference (using default row height)
     * @param numberOfRowsToSkip number of rows to skip over in the given sequence
     * @param displayIndexSeq the sequence in which to skip
     * @param nextRowTop the row top reference in which to skip
     */
    skipDisplayIndexes(numberOfRowsToSkip, displayIndexSeq, nextRowTop) {
        if (numberOfRowsToSkip === 0) {
            return;
        }
        const defaultRowHeight = this.gridOptionsService.getRowHeightAsNumber();
        displayIndexSeq.skip(numberOfRowsToSkip);
        nextRowTop.value += numberOfRowsToSkip * defaultRowHeight;
    }
    /**
     * @param displayIndexSeq the number sequence for generating the display index of each row
     * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
     */
    setDisplayIndexes(displayIndexSeq, nextRowTop) {
        // Create a map of display index nodes for access speed
        this.nodeDisplayIndexMap.clear();
        // create an object indexed by store index, as this will sort all of the nodes when we iterate
        // the object
        const orderedMap = {};
        this.nodeMap.forEach(lazyNode => {
            orderedMap[lazyNode.index] = lazyNode.node;
        });
        let lastIndex = -1;
        // iterate over the nodes in order, setting the display index on each node.
        for (const stringIndex in orderedMap) {
            const node = orderedMap[stringIndex];
            const numericIndex = Number(stringIndex);
            // if any nodes aren't currently in the store, skip the display indexes too
            const numberOfRowsToSkip = (numericIndex - 1) - lastIndex;
            this.skipDisplayIndexes(numberOfRowsToSkip, displayIndexSeq, nextRowTop);
            // set this nodes index and row top
            this.blockUtils.setDisplayIndex(node, displayIndexSeq, nextRowTop);
            this.nodeDisplayIndexMap.set(node.rowIndex, node);
            // store this index for skipping after this
            lastIndex = numericIndex;
        }
        // need to skip rows until the end of this store
        const numberOfRowsToSkip = (this.numberOfRows - 1) - lastIndex;
        this.skipDisplayIndexes(numberOfRowsToSkip, displayIndexSeq, nextRowTop);
        // this is not terribly efficient, and could probs be improved
        this.purgeExcessRows();
    }
    getRowCount() {
        return this.numberOfRows;
    }
    setRowCount(rowCount, isLastRowIndexKnown) {
        if (rowCount < 0) {
            throw new Error('AG Grid: setRowCount can only accept a positive row count.');
        }
        this.numberOfRows = rowCount;
        if (isLastRowIndexKnown != null) {
            this.isLastRowKnown = isLastRowIndexKnown;
            if (isLastRowIndexKnown === false) {
                this.numberOfRows += 1;
            }
        }
        this.fireStoreUpdatedEvent();
    }
    getNodes() {
        return this.nodeMap;
    }
    getNodeCachedByDisplayIndex(displayIndex) {
        var _a;
        return (_a = this.nodeDisplayIndexMap.get(displayIndex)) !== null && _a !== void 0 ? _a : null;
    }
    getNodesToRefresh() {
        return this.nodesToRefresh;
    }
    /**
     * @returns the previous and next loaded row nodes surrounding the given display index
     */
    getSurroundingNodesByDisplayIndex(displayIndex) {
        let nextNode;
        let previousNode;
        this.nodeMap.forEach(lazyNode => {
            // previous node
            if (displayIndex > lazyNode.node.rowIndex) {
                // get the largest previous node
                if (previousNode == null || previousNode.node.rowIndex < lazyNode.node.rowIndex) {
                    previousNode = lazyNode;
                }
                return;
            }
            // next node
            // get the smallest next node
            if (nextNode == null || nextNode.node.rowIndex > lazyNode.node.rowIndex) {
                nextNode = lazyNode;
                return;
            }
        });
        if (!previousNode && !nextNode)
            return null;
        return { previousNode, nextNode };
    }
    /**
     * Get or calculate the display index for a given store index
     * @param storeIndex the rows index within this store
     * @returns the rows visible display index relative to the grid
     */
    getDisplayIndexFromStoreIndex(storeIndex) {
        var _a, _b;
        const nodeAtIndex = this.nodeMap.getBy('index', storeIndex);
        if (nodeAtIndex) {
            return nodeAtIndex.node.rowIndex;
        }
        let nextNode;
        let previousNode;
        this.nodeMap.forEach(lazyNode => {
            // previous node
            if (storeIndex > lazyNode.index) {
                // get the largest previous node
                if (previousNode == null || previousNode.index < lazyNode.index) {
                    previousNode = lazyNode;
                }
                return;
            }
            // next node
            // get the smallest next node
            if (nextNode == null || nextNode.index > lazyNode.index) {
                nextNode = lazyNode;
                return;
            }
        });
        if (!nextNode) {
            return this.store.getDisplayIndexEnd() - (this.numberOfRows - storeIndex);
        }
        if (!previousNode) {
            return this.store.getDisplayIndexStart() + storeIndex;
        }
        const storeIndexDiff = storeIndex - previousNode.index;
        const previousDisplayIndex = ((_b = (_a = previousNode.node.childStore) === null || _a === void 0 ? void 0 : _a.getDisplayIndexEnd()) !== null && _b !== void 0 ? _b : previousNode.node.rowIndex);
        return previousDisplayIndex + storeIndexDiff;
    }
    /**
     * Creates a new row and inserts it at the given index
     * @param atStoreIndex the node index relative to this store
     * @param data the data object to populate the node with
     * @returns the new row node
     */
    createRowAtIndex(atStoreIndex, data, createNodeCallback) {
        var _a, _b;
        // make sure an existing node isn't being overwritten
        const lazyNode = this.nodeMap.getBy('index', atStoreIndex);
        // if node already exists, update it or destroy it
        if (lazyNode) {
            const { node } = lazyNode;
            node.__needsRefreshWhenVisible = false;
            // if the node is the same, just update the content
            if (this.doesNodeMatch(data, node)) {
                this.blockUtils.updateDataIntoRowNode(node, data);
                this.nodesToRefresh.delete(node);
                return node;
            }
            // if there's no id and this is an open group, protect this node from changes
            // hasChildren also checks for tree data and master detail
            if (this.getRowIdFunc == null && node.hasChildren() && node.expanded) {
                this.nodesToRefresh.delete(node);
                return node;
            }
            // destroy the old node, might be worth caching state here
            this.destroyRowAtIndex(atStoreIndex);
        }
        // if the node already exists elsewhere, update it and move it to the new location
        if (data && this.getRowIdFunc != null) {
            const id = this.getRowId(data);
            // the node was deleted at some point, but as we're refreshing
            // it's been cached and we can retrieve it for reuse.
            const deletedNode = id && ((_a = this.removedNodeCache) === null || _a === void 0 ? void 0 : _a.get(id));
            if (deletedNode) {
                (_b = this.removedNodeCache) === null || _b === void 0 ? void 0 : _b.delete(id);
                this.blockUtils.updateDataIntoRowNode(deletedNode, data);
                this.nodeMap.set({
                    id: deletedNode.id,
                    node: deletedNode,
                    index: atStoreIndex
                });
                return deletedNode;
            }
            const lazyNode = this.nodeMap.getBy('id', id);
            if (lazyNode) {
                // delete old lazy node so we can insert it at different location
                this.nodeMap.delete(lazyNode);
                const { node, index } = lazyNode;
                this.blockUtils.updateDataIntoRowNode(node, data);
                this.nodeMap.set({
                    id: node.id,
                    node,
                    index: atStoreIndex
                });
                this.nodesToRefresh.delete(node);
                if (this.rowLoader.getBlockStartIndexForIndex(index) === this.rowLoader.getBlockStartIndexForIndex(atStoreIndex)) {
                    // if the block hasn't changed and we have a nodes map, we don't need to refresh the original block, as this block
                    // has just been refreshed.
                    return node;
                }
                // mark all of the old block as needsVerify to trigger it for a refresh, as nodes
                // should not be out of place
                this.markBlockForVerify(index);
                return node;
            }
        }
        // node doesn't exist, create a new one
        const newNode = this.blockUtils.createRowNode(this.store.getRowDetails());
        if (data != null) {
            const defaultId = this.getPrefixedId(this.store.getIdSequence().next());
            this.blockUtils.setDataIntoRowNode(newNode, data, defaultId, undefined);
            this.blockUtils.checkOpenByDefault(newNode);
            this.nodeManager.addRowNode(newNode);
        }
        // add the new node to the store, has to be done after the display index is calculated so it doesn't take itself into account
        this.nodeMap.set({
            id: newNode.id,
            node: newNode,
            index: atStoreIndex,
        });
        if (createNodeCallback) {
            createNodeCallback(newNode);
        }
        return newNode;
    }
    getBlockStates() {
        const blockCounts = {};
        const blockStates = {};
        this.nodeMap.forEach(({ node, index }) => {
            var _a;
            const blockStart = this.rowLoader.getBlockStartIndexForIndex(index);
            if (!node.stub && !node.failedLoad) {
                blockCounts[blockStart] = ((_a = blockCounts[blockStart]) !== null && _a !== void 0 ? _a : 0) + 1;
            }
            let rowState = 'loaded';
            if (node.failedLoad) {
                rowState = 'failed';
            }
            else if (this.rowLoader.isRowLoading(blockStart)) {
                rowState = 'loading';
            }
            else if (this.nodesToRefresh.has(node) || node.stub) {
                rowState = 'needsLoading';
            }
            if (!blockStates[blockStart]) {
                blockStates[blockStart] = new Set();
            }
            blockStates[blockStart].add(rowState);
        });
        const statePriorityMap = {
            loading: 4,
            failed: 3,
            needsLoading: 2,
            loaded: 1,
        };
        const blockPrefix = this.blockUtils.createNodeIdPrefix(this.store.getParentNode());
        const results = {};
        Object.entries(blockStates).forEach(([blockStart, uniqueStates]) => {
            var _a;
            const sortedStates = [...uniqueStates].sort((a, b) => { var _a, _b; return ((_a = statePriorityMap[a]) !== null && _a !== void 0 ? _a : 0) - ((_b = statePriorityMap[b]) !== null && _b !== void 0 ? _b : 0); });
            const priorityState = sortedStates[0];
            const blockNumber = Number(blockStart) / this.rowLoader.getBlockSize();
            const blockId = blockPrefix ? `${blockPrefix}-${blockNumber}` : String(blockNumber);
            results[blockId] = {
                blockNumber,
                startRow: Number(blockStart),
                endRow: Number(blockStart) + this.rowLoader.getBlockSize(),
                pageStatus: priorityState,
                loadedRowCount: (_a = blockCounts[blockStart]) !== null && _a !== void 0 ? _a : 0,
            };
        });
        return results;
    }
    destroyRowAtIndex(atStoreIndex) {
        const lazyNode = this.nodeMap.getBy('index', atStoreIndex);
        if (!lazyNode) {
            return;
        }
        this.nodeMap.delete(lazyNode);
        this.nodeDisplayIndexMap.delete(lazyNode.node.rowIndex);
        if (this.nodesToRefresh.size > 0) {
            // while refreshing, we retain the group nodes so they can be moved
            // without losing state
            this.removedNodeCache.set(lazyNode.node.id, lazyNode.node);
        }
        else {
            this.blockUtils.destroyRowNode(lazyNode.node);
        }
        this.nodesToRefresh.delete(lazyNode.node);
    }
    getSsrmParams() {
        return this.store.getSsrmParams();
    }
    /**
     * @param id the base id to be prefixed
     * @returns a node id with prefix if required
     */
    getPrefixedId(id) {
        if (this.defaultNodeIdPrefix) {
            return this.defaultNodeIdPrefix + '-' + id;
        }
        else {
            return id.toString();
        }
    }
    markBlockForVerify(rowIndex) {
        const [start, end] = this.rowLoader.getBlockBoundsForIndex(rowIndex);
        const lazyNodesInRange = this.nodeMap.filter((lazyNode) => lazyNode.index >= start && lazyNode.index < end);
        lazyNodesInRange.forEach(({ node }) => {
            node.__needsRefreshWhenVisible = true;
        });
    }
    doesNodeMatch(data, node) {
        if (node.stub) {
            return false;
        }
        if (this.getRowIdFunc != null) {
            const id = this.getRowId(data);
            return node.id === id;
        }
        return node.data === data;
    }
    /**
     * Deletes any stub nodes not within the given range
     */
    purgeStubsOutsideOfViewport() {
        const firstRow = this.api.getFirstDisplayedRowIndex();
        const lastRow = this.api.getLastDisplayedRowIndex();
        const firstRowBlockStart = this.rowLoader.getBlockStartIndexForIndex(firstRow);
        const [_, lastRowBlockEnd] = this.rowLoader.getBlockBoundsForIndex(lastRow);
        this.nodeMap.forEach(lazyNode => {
            // failed loads are still useful, so we don't purge them
            if (this.rowLoader.isRowLoading(lazyNode.index) || lazyNode.node.failedLoad) {
                return;
            }
            if (lazyNode.node.stub && (lazyNode.index < firstRowBlockStart || lazyNode.index > lastRowBlockEnd)) {
                this.destroyRowAtIndex(lazyNode.index);
            }
        });
    }
    getBlocksDistanceFromRow(nodes, otherDisplayIndex) {
        const blockDistanceToMiddle = {};
        nodes.forEach(({ node, index }) => {
            const [blockStart, blockEnd] = this.rowLoader.getBlockBoundsForIndex(index);
            if (blockStart in blockDistanceToMiddle) {
                return;
            }
            const distStart = Math.abs(node.rowIndex - otherDisplayIndex);
            let distEnd;
            // may not have an end node if the block came back small 
            const lastLazyNode = this.nodeMap.getBy('index', [blockEnd - 1]);
            if (lastLazyNode)
                distEnd = Math.abs(lastLazyNode.node.rowIndex - otherDisplayIndex);
            const farthest = distEnd == null || distStart < distEnd ? distStart : distEnd;
            blockDistanceToMiddle[blockStart] = farthest;
        });
        return Object.entries(blockDistanceToMiddle);
    }
    purgeExcessRows() {
        var _a;
        // Delete all stub nodes which aren't in the viewport or already loading
        this.purgeStubsOutsideOfViewport();
        if (this.store.getDisplayIndexEnd() == null || this.storeParams.maxBlocksInCache == null) {
            // if group is collapsed, or max blocks missing, ignore the event
            return;
        }
        const firstRowInViewport = this.api.getFirstDisplayedRowIndex();
        const lastRowInViewport = this.api.getLastDisplayedRowIndex();
        // the start storeIndex of every block in this store
        const allLoadedBlocks = new Set();
        // the start storeIndex of every displayed block in this store
        const blocksInViewport = new Set();
        this.nodeMap.forEach(({ index, node }) => {
            const blockStart = this.rowLoader.getBlockStartIndexForIndex(index);
            allLoadedBlocks.add(blockStart);
            const isInViewport = node.rowIndex >= firstRowInViewport && node.rowIndex <= lastRowInViewport;
            if (isInViewport) {
                blocksInViewport.add(blockStart);
            }
        });
        // if the viewport is larger than the max blocks, then the viewport size is minimum cache size
        const numberOfBlocksToRetain = Math.max(blocksInViewport.size, (_a = this.storeParams.maxBlocksInCache) !== null && _a !== void 0 ? _a : 0);
        // ensure there is blocks that can be removed
        const loadedBlockCount = allLoadedBlocks.size;
        const blocksToRemove = loadedBlockCount - numberOfBlocksToRetain;
        if (blocksToRemove <= 0) {
            return;
        }
        // the first and last block in the viewport
        let firstRowBlockStart = Number.MAX_SAFE_INTEGER;
        let lastRowBlockStart = Number.MIN_SAFE_INTEGER;
        blocksInViewport.forEach(blockStart => {
            if (firstRowBlockStart > blockStart) {
                firstRowBlockStart = blockStart;
            }
            if (lastRowBlockStart < blockStart) {
                lastRowBlockStart = blockStart;
            }
        });
        // all nodes which aren't cached or in the viewport, and so can be removed
        const disposableNodes = this.nodeMap.filter(({ node, index }) => {
            const rowBlockStart = this.rowLoader.getBlockStartIndexForIndex(index);
            const rowBlockInViewport = rowBlockStart >= firstRowBlockStart && rowBlockStart <= lastRowBlockStart;
            return !rowBlockInViewport && !this.isNodeCached(node);
        });
        if (disposableNodes.length === 0) {
            return;
        }
        const midViewportRow = firstRowInViewport + ((lastRowInViewport - firstRowInViewport) / 2);
        const blockDistanceArray = this.getBlocksDistanceFromRow(disposableNodes, midViewportRow);
        const blockSize = this.rowLoader.getBlockSize();
        // sort the blocks by distance from middle of viewport
        blockDistanceArray.sort((a, b) => Math.sign(b[1] - a[1]));
        // remove excess blocks, starting from furthest from viewport
        for (let i = 0; i < Math.min(blocksToRemove, blockDistanceArray.length); i++) {
            const blockStart = Number(blockDistanceArray[i][0]);
            for (let x = blockStart; x < blockStart + blockSize; x++) {
                const lazyNode = this.nodeMap.getBy('index', x);
                if (!lazyNode || this.isNodeCached(lazyNode.node)) {
                    continue;
                }
                this.destroyRowAtIndex(x);
            }
        }
    }
    isNodeFocused(node) {
        const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();
        if (!focusedCell) {
            return false;
        }
        if (focusedCell.rowPinned != null) {
            return false;
        }
        const hasFocus = focusedCell.rowIndex === node.rowIndex;
        return hasFocus;
    }
    isNodeCached(node) {
        return (node.isExpandable() && node.expanded) || this.isNodeFocused(node);
    }
    extractDuplicateIds(rows) {
        if (this.getRowIdFunc == null) {
            return [];
        }
        const newIds = new Set();
        const duplicates = new Set();
        rows.forEach(data => {
            const id = this.getRowId(data);
            if (newIds.has(id)) {
                duplicates.add(id);
                return;
            }
            newIds.add(id);
        });
        return [...duplicates];
    }
    onLoadSuccess(firstRowIndex, numberOfRowsExpected, response) {
        if (!this.live)
            return;
        const info = response.groupLevelInfo;
        this.store.setStoreInfo(info);
        if (this.getRowIdFunc != null) {
            const duplicates = this.extractDuplicateIds(response.rowData);
            if (duplicates.length > 0) {
                const duplicateIdText = duplicates.join(', ');
                console.warn(`AG Grid: Unable to display rows as duplicate row ids (${duplicateIdText}) were returned by the getRowId callback. Please modify the getRowId callback to provide unique ids.`);
                this.onLoadFailed(firstRowIndex, numberOfRowsExpected);
                return;
            }
        }
        if (response.pivotResultFields) {
            this.serverSideRowModel.generateSecondaryColumns(response.pivotResultFields);
        }
        const wasRefreshing = this.nodesToRefresh.size > 0;
        response.rowData.forEach((data, responseRowIndex) => {
            var _a;
            const rowIndex = firstRowIndex + responseRowIndex;
            const nodeFromCache = this.nodeMap.getBy('index', rowIndex);
            // if stub, overwrite
            if ((_a = nodeFromCache === null || nodeFromCache === void 0 ? void 0 : nodeFromCache.node) === null || _a === void 0 ? void 0 : _a.stub) {
                this.createRowAtIndex(rowIndex, data);
                return;
            }
            // node already exists, and same as node at designated position, update data
            if (nodeFromCache && this.doesNodeMatch(data, nodeFromCache.node)) {
                this.blockUtils.updateDataIntoRowNode(nodeFromCache.node, data);
                this.nodesToRefresh.delete(nodeFromCache.node);
                nodeFromCache.node.__needsRefreshWhenVisible = false;
                return;
            }
            // create row will handle deleting the overwritten row
            this.createRowAtIndex(rowIndex, data);
        });
        if (response.rowCount != undefined && response.rowCount !== -1) {
            // if the rowCount has been provided, set the row count
            this.numberOfRows = response.rowCount;
            this.isLastRowKnown = true;
        }
        else if (numberOfRowsExpected > response.rowData.length) {
            // infer the last row as the response came back short
            this.numberOfRows = firstRowIndex + response.rowData.length;
            this.isLastRowKnown = true;
        }
        else if (!this.isLastRowKnown) {
            // add 1 for loading row, as we don't know the last row
            const lastInferredRow = firstRowIndex + response.rowData.length + 1;
            if (lastInferredRow > this.numberOfRows) {
                this.numberOfRows = lastInferredRow;
            }
        }
        if (this.isLastRowKnown) {
            // delete any rows after the last index
            const lazyNodesAfterStoreEnd = this.nodeMap.filter(lazyNode => lazyNode.index >= this.numberOfRows);
            lazyNodesAfterStoreEnd.forEach(lazyNode => this.destroyRowAtIndex(lazyNode.index));
        }
        this.fireStoreUpdatedEvent();
        // Happens after store updated, as store updating can clear our excess rows.
        const finishedRefreshing = this.nodesToRefresh.size === 0;
        if (wasRefreshing && finishedRefreshing) {
            this.fireRefreshFinishedEvent();
        }
    }
    fireRefreshFinishedEvent() {
        const finishedRefreshing = this.nodesToRefresh.size === 0;
        // if anything refreshing currently, skip.
        if (!finishedRefreshing) {
            return;
        }
        // any nodes left in the map need to be cleaned up, this prevents us preserving nodes
        // indefinitely
        this.removedNodeCache.forEach(node => {
            this.blockUtils.destroyRowNode(node);
        });
        this.removedNodeCache = new Map();
        this.store.fireRefreshFinishedEvent();
    }
    /**
     * @returns true if all rows are loaded
     */
    isStoreFullyLoaded() {
        const knowsSize = this.isLastRowKnown;
        const hasCorrectRowCount = this.nodeMap.getSize() === this.numberOfRows;
        if (!knowsSize || !hasCorrectRowCount) {
            return;
        }
        if (this.nodesToRefresh.size > 0) {
            return;
        }
        // nodeMap find cancels early when it finds a matching record.
        // better to use this than forEach
        let index = -1;
        const firstOutOfPlaceNode = this.nodeMap.find(lazyNode => {
            index += 1;
            // node not contiguous, nodes must be missing
            if (lazyNode.index !== index) {
                return true;
            }
            // node data is out of date
            if (lazyNode.node.__needsRefreshWhenVisible) {
                return true;
            }
            // node not yet loaded
            if (lazyNode.node.stub) {
                return true;
            }
            return false;
        });
        return firstOutOfPlaceNode == null;
    }
    isLastRowIndexKnown() {
        return this.isLastRowKnown;
    }
    onLoadFailed(firstRowIndex, numberOfRowsExpected) {
        var _a;
        if (!this.live)
            return;
        const wasRefreshing = this.nodesToRefresh.size > 0;
        for (let i = firstRowIndex; i < firstRowIndex + numberOfRowsExpected && i < this.getRowCount(); i++) {
            let { node } = (_a = this.nodeMap.getBy('index', i)) !== null && _a !== void 0 ? _a : {};
            if (node) {
                this.nodesToRefresh.delete(node);
            }
            if (!node || !node.stub) {
                if (node && !node.stub) {
                    // if node is not a stub, we destroy it and recreate as nodes can't go from data to stub
                    this.destroyRowAtIndex(i);
                }
                node = this.createRowAtIndex(i);
            }
            // this node has been refreshed, even if it wasn't successful
            node.__needsRefreshWhenVisible = false;
            node.failedLoad = true;
        }
        const finishedRefreshing = this.nodesToRefresh.size === 0;
        if (wasRefreshing && finishedRefreshing) {
            this.fireRefreshFinishedEvent();
        }
        this.fireStoreUpdatedEvent();
    }
    markNodesForRefresh() {
        this.nodeMap.forEach(lazyNode => {
            if (lazyNode.node.stub && !lazyNode.node.failedLoad) {
                return;
            }
            this.nodesToRefresh.add(lazyNode.node);
        });
        this.rowLoader.queueLoadCheck();
        if (this.isLastRowKnown && this.numberOfRows === 0) {
            this.numberOfRows = 1;
            this.isLastRowKnown = false;
            this.fireStoreUpdatedEvent();
        }
    }
    isNodeInCache(id) {
        return !!this.nodeMap.getBy('id', id);
    }
    // gets called 1) row count changed 2) cache purged 3) items inserted
    fireStoreUpdatedEvent() {
        if (!this.live) {
            return;
        }
        this.store.fireStoreUpdatedEvent();
    }
    getRowId(data) {
        if (this.getRowIdFunc == null) {
            return null;
        }
        // find rowNode using id
        const { level } = this.store.getRowDetails();
        const parentKeys = this.store.getParentNode().getGroupKeys();
        const id = this.getRowIdFunc({
            data,
            parentKeys: parentKeys.length > 0 ? parentKeys : undefined,
            level,
        });
        return String(id);
    }
    getOrderedNodeMap() {
        const obj = {};
        this.nodeMap.forEach(node => obj[node.index] = node);
        return obj;
    }
    clearDisplayIndexes() {
        this.nodeDisplayIndexMap.clear();
    }
    /**
     * Client side sorting
     */
    clientSideSortRows() {
        const sortOptions = this.sortController.getSortOptions();
        const isAnySort = sortOptions.some(opt => opt.sort != null);
        if (!isAnySort) {
            return;
        }
        // the node map does not need entirely recreated, only the indexes need updated.
        const allNodes = new Array(this.nodeMap.getSize());
        this.nodeMap.forEach(lazyNode => allNodes[lazyNode.index] = lazyNode.node);
        this.nodeMap.clear();
        const sortedNodes = this.rowNodeSorter.doFullSort(allNodes, sortOptions);
        sortedNodes.forEach((node, index) => {
            this.nodeMap.set({
                id: node.id,
                node,
                index,
            });
        });
    }
    /**
     * Transaction Support here
     */
    updateRowNodes(updates) {
        if (this.getRowIdFunc == null) {
            // throw error, as this is type checked in the store. User likely abusing internal apis if here.
            throw new Error('AG Grid: Transactions can only be applied when row ids are supplied.');
        }
        const updatedNodes = [];
        updates.forEach(data => {
            const id = this.getRowId(data);
            const lazyNode = this.nodeMap.getBy('id', id);
            if (lazyNode) {
                this.blockUtils.updateDataIntoRowNode(lazyNode.node, data);
                updatedNodes.push(lazyNode.node);
            }
        });
        return updatedNodes;
    }
    insertRowNodes(inserts, indexToAdd) {
        // adjust row count to allow for footer row
        const realRowCount = this.store.getRowCount() - (this.store.getParentNode().sibling ? 1 : 0);
        // if missing and we know the last row, we're inserting at the end
        const addIndex = indexToAdd == null && this.isLastRowKnown ? realRowCount : indexToAdd;
        // can't insert nodes past the end of the store
        if (addIndex == null || realRowCount < addIndex) {
            return [];
        }
        if (this.getRowIdFunc == null) {
            // throw error, as this is type checked in the store. User likely abusing internal apis if here.
            throw new Error('AG Grid: Transactions can only be applied when row ids are supplied.');
        }
        const uniqueInsertsMap = {};
        inserts.forEach(data => {
            const dataId = this.getRowId(data);
            if (dataId && this.isNodeInCache(dataId)) {
                return;
            }
            uniqueInsertsMap[dataId] = data;
        });
        const uniqueInserts = Object.values(uniqueInsertsMap);
        let numberOfInserts = uniqueInserts.length;
        if (numberOfInserts === 0) {
            return [];
        }
        const nodesToMove = this.nodeMap.filter(node => node.index >= addIndex);
        // delete all nodes which need moved first, so they don't get overwritten
        nodesToMove.forEach(lazyNode => this.nodeMap.delete(lazyNode));
        // then move the nodes to their new locations
        nodesToMove.forEach(lazyNode => {
            this.nodeMap.set({
                node: lazyNode.node,
                index: lazyNode.index + numberOfInserts,
                id: lazyNode.id,
            });
        });
        // increase the store size to accommodate
        this.numberOfRows += numberOfInserts;
        // finally insert the new rows
        return uniqueInserts.map((data, uniqueInsertOffset) => this.createRowAtIndex(addIndex + uniqueInsertOffset, data));
    }
    removeRowNodes(idsToRemove) {
        if (this.getRowIdFunc == null) {
            // throw error, as this is type checked in the store. User likely abusing internal apis if here.
            throw new Error('AG Grid: Transactions can only be applied when row ids are supplied.');
        }
        const removedNodes = [];
        const nodesToVerify = [];
        // track how many nodes have been deleted, as when we pass other nodes we need to shift them up
        let deletedNodeCount = 0;
        const remainingIdsToRemove = [...idsToRemove];
        const allNodes = this.getOrderedNodeMap();
        let contiguousIndex = -1;
        for (let stringIndex in allNodes) {
            contiguousIndex += 1;
            const node = allNodes[stringIndex];
            // finding the index allows the use of splice which should be slightly faster than both a check and filter
            const matchIndex = remainingIdsToRemove.findIndex(idToRemove => idToRemove === node.id);
            if (matchIndex !== -1) {
                // found node, remove it from nodes to remove
                remainingIdsToRemove.splice(matchIndex, 1);
                this.destroyRowAtIndex(Number(stringIndex));
                removedNodes.push(node.node);
                deletedNodeCount += 1;
                continue;
            }
            // no nodes removed and this node doesn't match, so no need to shift
            if (deletedNodeCount === 0) {
                continue;
            }
            const numericStoreIndex = Number(stringIndex);
            if (contiguousIndex !== numericStoreIndex) {
                nodesToVerify.push(node.node);
            }
            // shift normal node up by number of deleted prior to this point
            this.nodeMap.delete(allNodes[stringIndex]);
            this.nodeMap.set({
                id: node.id,
                node: node.node,
                index: numericStoreIndex - deletedNodeCount,
            });
        }
        this.numberOfRows -= this.isLastRowIndexKnown() ? idsToRemove.length : deletedNodeCount;
        if (remainingIdsToRemove.length > 0 && nodesToVerify.length > 0) {
            nodesToVerify.forEach(node => node.__needsRefreshWhenVisible = true);
            this.rowLoader.queueLoadCheck();
        }
        return removedNodes;
    }
}
__decorate$1M([
    Autowired('gridApi')
], LazyCache.prototype, "api", void 0);
__decorate$1M([
    Autowired('ssrmBlockUtils')
], LazyCache.prototype, "blockUtils", void 0);
__decorate$1M([
    Autowired('focusService')
], LazyCache.prototype, "focusService", void 0);
__decorate$1M([
    Autowired('ssrmNodeManager')
], LazyCache.prototype, "nodeManager", void 0);
__decorate$1M([
    Autowired('rowModel')
], LazyCache.prototype, "serverSideRowModel", void 0);
__decorate$1M([
    Autowired('rowNodeSorter')
], LazyCache.prototype, "rowNodeSorter", void 0);
__decorate$1M([
    Autowired('sortController')
], LazyCache.prototype, "sortController", void 0);
__decorate$1M([
    PostConstruct
], LazyCache.prototype, "init", null);
__decorate$1M([
    PreDestroy
], LazyCache.prototype, "destroyRowNodes", null);

var __decorate$1N = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class LazyStore extends BeanStub {
    constructor(ssrmParams, storeParams, parentRowNode) {
        super();
        this.idSequence = new NumberSequence();
        this.ssrmParams = ssrmParams;
        this.parentRowNode = parentRowNode;
        this.storeParams = storeParams;
        this.level = parentRowNode.level + 1;
        this.group = ssrmParams.rowGroupCols ? this.level < ssrmParams.rowGroupCols.length : false;
        this.leafGroup = ssrmParams.rowGroupCols ? this.level === ssrmParams.rowGroupCols.length - 1 : false;
        this.info = {};
    }
    init() {
        var _a;
        let numberOfRows = 1;
        if (this.level === 0) {
            numberOfRows = (_a = this.storeUtils.getServerSideInitialRowCount()) !== null && _a !== void 0 ? _a : 1;
            this.eventService.dispatchEventOnce({
                type: Events.EVENT_ROW_COUNT_READY
            });
        }
        this.cache = this.createManagedBean(new LazyCache(this, numberOfRows, this.storeParams));
        const usingTreeData = this.gridOptionsService.get('treeData');
        if (!usingTreeData && this.group) {
            const groupColVo = this.ssrmParams.rowGroupCols[this.level];
            this.groupField = groupColVo.field;
            this.rowGroupColumn = this.columnModel.getRowGroupColumns()[this.level];
        }
    }
    destroyRowNodes() {
        this.displayIndexStart = undefined;
        this.displayIndexEnd = undefined;
        this.destroyBean(this.cache);
    }
    /**
     * Given a server response, ingest the rows outside of the data source lifecycle.
     *
     * @param rowDataParams the server response containing the rows to ingest
     * @param startRow the index to start ingesting rows
     * @param expectedRows the expected number of rows in the response (used to determine if the last row index is known)
     */
    applyRowData(rowDataParams, startRow, expectedRows) {
        this.cache.onLoadSuccess(startRow, expectedRows, rowDataParams);
    }
    /**
     * Applies a given transaction to the data set within this store
     *
     * @param transaction an object containing delta instructions determining the changes to apply to this store
     * @returns an object determining the status of this transaction and effected nodes
     */
    applyTransaction(transaction) {
        var _a, _b, _c;
        const idFunc = this.gridOptionsService.getCallback('getRowId');
        if (!idFunc) {
            console.warn('AG Grid: getRowId callback must be implemented for transactions to work. Transaction was ignored.');
            return {
                status: ServerSideTransactionResultStatus.Cancelled,
            };
        }
        const applyCallback = this.gridOptionsService.getCallback('isApplyServerSideTransaction');
        if (applyCallback) {
            const params = {
                transaction: transaction,
                parentNode: this.parentRowNode,
                groupLevelInfo: this.info
            };
            const apply = applyCallback(params);
            if (!apply) {
                return { status: ServerSideTransactionResultStatus.Cancelled };
            }
        }
        // needs checked before transactions are applied, as rows won't be contiguous immediately
        // after
        const allRowsLoaded = this.cache.isStoreFullyLoaded();
        let updatedNodes = undefined;
        if ((_a = transaction.update) === null || _a === void 0 ? void 0 : _a.length) {
            updatedNodes = this.cache.updateRowNodes(transaction.update);
        }
        let insertedNodes = undefined;
        if ((_b = transaction.add) === null || _b === void 0 ? void 0 : _b.length) {
            let addIndex = transaction.addIndex;
            if (addIndex != null && addIndex < 0) {
                addIndex = undefined;
            }
            insertedNodes = this.cache.insertRowNodes(transaction.add, addIndex);
        }
        let removedNodes = undefined;
        if ((_c = transaction.remove) === null || _c === void 0 ? void 0 : _c.length) {
            const allIdsToRemove = transaction.remove.map(data => (idFunc({ level: this.level, parentKeys: this.parentRowNode.getGroupKeys(), data })));
            const allUniqueIdsToRemove = [...new Set(allIdsToRemove)];
            removedNodes = this.cache.removeRowNodes(allUniqueIdsToRemove);
        }
        const isClientSideSortingEnabled = this.gridOptionsService.get('serverSideEnableClientSideSort');
        const isUpdateOrAdd = (updatedNodes === null || updatedNodes === void 0 ? void 0 : updatedNodes.length) || (insertedNodes === null || insertedNodes === void 0 ? void 0 : insertedNodes.length);
        const isClientSideSort = allRowsLoaded && isClientSideSortingEnabled;
        if (isClientSideSort && isUpdateOrAdd) {
            // if client side sorting, we need to sort the rows after the transaction
            this.cache.clientSideSortRows();
        }
        this.updateSelectionAfterTransaction(updatedNodes, removedNodes);
        return {
            status: ServerSideTransactionResultStatus.Applied,
            update: updatedNodes,
            add: insertedNodes,
            remove: removedNodes,
        };
    }
    updateSelectionAfterTransaction(updatedNodes, removedNodes) {
        const nodesToDeselect = [];
        updatedNodes === null || updatedNodes === void 0 ? void 0 : updatedNodes.forEach(node => {
            if (node.isSelected() && !node.selectable) {
                nodesToDeselect.push(node);
            }
        });
        removedNodes === null || removedNodes === void 0 ? void 0 : removedNodes.forEach(node => {
            if (node.isSelected()) {
                nodesToDeselect.push(node);
            }
        });
        if (nodesToDeselect.length) {
            this.selectionService.setNodesSelected({
                newValue: false,
                clearSelection: false,
                nodes: nodesToDeselect,
                source: 'rowDataChanged',
            });
        }
    }
    /**
     * Clear the display indexes, used for fading rows out when stores are not being destroyed
     */
    clearDisplayIndexes() {
        this.displayIndexStart = undefined;
        this.displayIndexEnd = undefined;
        this.cache.getNodes().forEach(lazyNode => this.blockUtils.clearDisplayIndex(lazyNode.node));
        if (this.parentRowNode.sibling) {
            this.blockUtils.clearDisplayIndex(this.parentRowNode.sibling);
        }
        this.cache.clearDisplayIndexes();
    }
    /**
     * @returns an index representing the last sequentially displayed row in the grid for this store
     */
    getDisplayIndexStart() {
        return this.displayIndexStart;
    }
    /**
     * @returns the index representing one after the last sequentially displayed row in the grid for this store
     */
    getDisplayIndexEnd() {
        return this.displayIndexEnd;
    }
    /**
     * @returns the virtual size of this store
     */
    getRowCount() {
        if (this.parentRowNode.sibling) {
            return this.cache.getRowCount() + 1;
        }
        return this.cache.getRowCount();
    }
    /**
     * Sets the current row count of the store, and whether the last row index is known
     */
    setRowCount(rowCount, isLastRowIndexKnown) {
        this.cache.setRowCount(rowCount, isLastRowIndexKnown);
    }
    /**
     * Given a display index, returns whether that row is within this store or a child store of this store
     *
     * @param displayIndex the visible index of a row
     * @returns whether or not the row exists within this store
     */
    isDisplayIndexInStore(displayIndex) {
        if (this.cache.getRowCount() === 0)
            return false;
        return this.displayIndexStart <= displayIndex && displayIndex < this.getDisplayIndexEnd();
    }
    /**
     * Recursively sets up the display indexes and top position of every node belonging to this store.
     *
     * Called after a row height changes, or a store updated event.
     *
     * @param displayIndexSeq the number sequence for generating the display index of each row
     * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
     */
    setDisplayIndexes(displayIndexSeq, nextRowTop) {
        this.displayIndexStart = displayIndexSeq.peek();
        this.topPx = nextRowTop.value;
        // delegate to the store to set the row display indexes
        this.cache.setDisplayIndexes(displayIndexSeq, nextRowTop);
        if (this.parentRowNode.sibling) {
            this.blockUtils.setDisplayIndex(this.parentRowNode.sibling, displayIndexSeq, nextRowTop);
        }
        this.displayIndexEnd = displayIndexSeq.peek();
        this.heightPx = nextRowTop.value - this.topPx;
    }
    /**
     * Recursively applies a provided function to every node
     *
     * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
     */
    forEachStoreDeep(callback, sequence = new NumberSequence()) {
        callback(this, sequence.next());
        this.cache.getNodes().forEach(lazyNode => {
            const childCache = lazyNode.node.childStore;
            if (childCache) {
                childCache.forEachStoreDeep(callback, sequence);
            }
        });
    }
    /**
     * Recursively applies a provided function to every node
     *
     * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
     */
    forEachNodeDeep(callback, sequence = new NumberSequence()) {
        this.cache.getNodes().forEach(lazyNode => {
            callback(lazyNode.node, sequence.next());
            const childCache = lazyNode.node.childStore;
            if (childCache) {
                childCache.forEachNodeDeep(callback, sequence);
            }
        });
    }
    /**
     * Recursively applies a provided function to every node
     *
     * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeep
     */
    forEachNodeDeepAfterFilterAndSort(callback, sequence = new NumberSequence(), includeFooterNodes = false) {
        const orderedNodes = this.cache.getOrderedNodeMap();
        for (let key in orderedNodes) {
            const lazyNode = orderedNodes[key];
            callback(lazyNode.node, sequence.next());
            const childCache = lazyNode.node.childStore;
            if (childCache) {
                childCache.forEachNodeDeepAfterFilterAndSort(callback, sequence, includeFooterNodes);
            }
        }
        if (includeFooterNodes && this.parentRowNode.sibling) {
            callback(this.parentRowNode.sibling, sequence.next());
        }
    }
    /**
     * Removes the failed status from all nodes, and marks them as stub to encourage reloading
     */
    retryLoads() {
        this.cache.getNodes().forEach(({ node }) => {
            if (node.failedLoad) {
                node.failedLoad = false;
                node.__needsRefreshWhenVisible = true;
                node.stub = true;
            }
        });
        this.forEachChildStoreShallow(store => store.retryLoads());
        this.fireStoreUpdatedEvent();
    }
    /**
     * Given a display index, returns the row at that location.
     *
     * @param displayRowIndex the displayed index within the grid to search for
     * @returns the row node if the display index falls within the store, if it didn't exist this will create a new stub to return
     */
    getRowUsingDisplayIndex(displayRowIndex) {
        if (this.parentRowNode.sibling && displayRowIndex === this.parentRowNode.sibling.rowIndex) {
            return this.parentRowNode.sibling;
        }
        return this.cache.getRowByDisplayIndex(displayRowIndex);
    }
    /**
     * Given a display index, returns the row top and height for the row at that index.
     *
     * @param displayIndex the display index of the node
     * @returns an object containing the rowTop and rowHeight of the node at the given displayIndex
     */
    getRowBounds(displayIndex) {
        var _a;
        if (!this.isDisplayIndexInStore(displayIndex)) {
            return null;
        }
        const thisNode = this.cache.getNodeCachedByDisplayIndex(displayIndex);
        if (thisNode) {
            const boundsFromRow = this.blockUtils.extractRowBounds(thisNode, displayIndex);
            if (boundsFromRow) {
                return boundsFromRow;
            }
        }
        const { previousNode, nextNode } = (_a = this.cache.getSurroundingNodesByDisplayIndex(displayIndex)) !== null && _a !== void 0 ? _a : {};
        // previous node may equal, or catch via detail node or child of group
        if (previousNode) {
            const boundsFromRow = this.blockUtils.extractRowBounds(previousNode.node, displayIndex);
            if (boundsFromRow != null) {
                return boundsFromRow;
            }
        }
        const defaultRowHeight = this.gridOptionsService.getRowHeightAsNumber();
        // if node after this, can calculate backwards (and ignore detail/grouping)
        if (nextNode) {
            const numberOfRowDiff = (nextNode.node.rowIndex - displayIndex) * defaultRowHeight;
            return {
                rowTop: nextNode.node.rowTop - numberOfRowDiff,
                rowHeight: defaultRowHeight,
            };
        }
        // otherwise calculate from end of store
        const lastTop = this.topPx + this.heightPx;
        const numberOfRowDiff = (this.getDisplayIndexEnd() - displayIndex) * defaultRowHeight;
        return {
            rowTop: lastTop - numberOfRowDiff,
            rowHeight: defaultRowHeight,
        };
    }
    /**
     * Given a vertical pixel, determines whether this store contains a row at that pixel
     *
     * @param pixel a vertical pixel position from the grid
     * @returns whether that pixel points to a virtual space belonging to this store
     */
    isPixelInRange(pixel) {
        return pixel >= this.topPx && pixel < (this.topPx + this.heightPx);
    }
    /**
     * Given a vertical pixel, returns the row existing at that pixel location
     *
     * @param pixel a vertical pixel position from the grid
     * @returns the display index at the given pixel location
     */
    getRowIndexAtPixel(pixel) {
        if (pixel < this.topPx) {
            return this.getDisplayIndexStart();
        }
        if (pixel >= this.topPx + this.heightPx) {
            return this.getDisplayIndexEnd() - 1;
        }
        let distToPreviousNodeTop = Number.MAX_SAFE_INTEGER;
        let previousNode = null;
        let distToNextNodeTop = Number.MAX_SAFE_INTEGER;
        let nextNode = null;
        this.cache.getNodes().forEach(({ node }) => {
            const distBetween = Math.abs(pixel - node.rowTop);
            // previous node
            if (node.rowTop < pixel) {
                if (distBetween < distToPreviousNodeTop) {
                    distToPreviousNodeTop = distBetween;
                    previousNode = node;
                }
                return;
            }
            // next node
            if (distBetween < distToNextNodeTop) {
                distToNextNodeTop = distBetween;
                nextNode = node;
            }
        });
        // cast these back as typescript doesn't understand the forEach above
        previousNode = previousNode;
        nextNode = nextNode;
        // previous node may equal, or catch via detail node or child of group
        if (previousNode) {
            const indexOfRow = this.blockUtils.getIndexAtPixel(previousNode, pixel);
            if (indexOfRow != null) {
                return indexOfRow;
            }
        }
        const defaultRowHeight = this.gridOptionsService.getRowHeightAsNumber();
        // if node after this, can calculate backwards (and ignore detail/grouping)
        if (nextNode) {
            const nextTop = nextNode.rowTop;
            const numberOfRowDiff = Math.ceil((nextTop - pixel) / defaultRowHeight);
            return nextNode.rowIndex - numberOfRowDiff;
        }
        // otherwise calculate from end of store
        const nextTop = this.topPx + this.heightPx;
        const numberOfRowDiff = Math.floor((nextTop - pixel) / defaultRowHeight);
        return this.getDisplayIndexEnd() - numberOfRowDiff;
    }
    /**
     * Given a path of group keys, returns the child store for that group.
     *
     * @param keys the grouping path to the desired store
     * @returns the child store for the given keys, or null if not found
     */
    getChildStore(keys) {
        return this.storeUtils.getChildStore(keys, this, (key) => {
            const lazyNode = this.cache.getNodes().find(lazyNode => lazyNode.node.key == key);
            if (!lazyNode) {
                return null;
            }
            return lazyNode.node;
        });
    }
    /**
     * Executes a provided callback on each child store belonging to this store
     *
     * @param cb the callback to execute
     */
    forEachChildStoreShallow(cb) {
        this.cache.getNodes().forEach(({ node }) => {
            if (node.childStore) {
                cb(node.childStore);
            }
        });
    }
    /**
     * Executes after a change to sorting, determines recursively whether this store or a child requires refreshed.
     *
     * If a purge refresh occurs, the row count is preserved.
     *
     * @param params a set of properties pertaining to the sort changes
     */
    refreshAfterSort(params) {
        const serverSortsAllLevels = this.storeUtils.isServerSideSortAllLevels();
        if (serverSortsAllLevels || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params)) {
            const allRowsLoaded = this.cache.isStoreFullyLoaded();
            const isClientSideSortingEnabled = this.gridOptionsService.get('serverSideEnableClientSideSort');
            const isClientSideSort = allRowsLoaded && isClientSideSortingEnabled;
            if (!isClientSideSort) {
                const oldCount = this.cache.getRowCount();
                this.destroyBean(this.cache);
                this.cache = this.createManagedBean(new LazyCache(this, oldCount, this.storeParams));
                return;
            }
            // client side sorting only handles one level, so allow it to pass through
            // to recursive sort.
            this.cache.clientSideSortRows();
        }
        // call refreshAfterSort on children, as we did not purge.
        // if we did purge, no need to do this as all children were destroyed
        this.forEachChildStoreShallow(store => store.refreshAfterSort(params));
    }
    /**
     * Executes after a change to filtering, determines recursively whether this store or a child requires refreshed.
     *
     * If a refresh occurs, the row count is reset.
     *
     * @param params a set of properties pertaining to the filter changes
     */
    refreshAfterFilter(params) {
        const serverFiltersAllLevels = !this.storeUtils.isServerSideOnlyRefreshFilteredGroups();
        if (serverFiltersAllLevels || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params)) {
            this.refreshStore(true);
            return;
        }
        // call refreshAfterFilter on children, as we did not purge.
        // if we did purge, no need to do this as all children were destroyed
        this.forEachChildStoreShallow(store => store.refreshAfterFilter(params));
    }
    /**
     * Marks all existing nodes as requiring reloaded, and triggers a load check
     *
     * @param purge whether to remove all nodes and data in favour of stub nodes
     */
    refreshStore(purge) {
        if (purge) {
            this.destroyBean(this.cache);
            this.cache = this.createManagedBean(new LazyCache(this, 1, this.storeParams));
            this.fireStoreUpdatedEvent();
            return;
        }
        this.cache.markNodesForRefresh();
    }
    /**
     * Used for pagination, given a local/store index, returns the display index of that row
     *
     * @param topLevelIndex the store index of a row
     * @returns the display index for the given store index
     */
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        const displayIndex = this.cache.getDisplayIndexFromStoreIndex(topLevelIndex);
        return displayIndex !== null && displayIndex !== void 0 ? displayIndex : topLevelIndex;
    }
    /**
     * Used for pagination to determine if the last page is known, and for aria to determine if the last grid row is known
     *
     * @returns whether the last index of this store is known, or if lazy loading still required
     */
    isLastRowIndexKnown() {
        return this.cache.isLastRowIndexKnown();
    }
    /**
     * Used by the selection service to select a range of nodes
     *
     * @param firstInRange the first node in the range to find
     * @param lastInRange the last node in the range to find
     * @returns a range of nodes between firstInRange and lastInRange inclusive
     */
    getRowNodesInRange(firstInRange, lastInRange) {
        // if only one node passed, we start the selection at the top
        if (_.missing(firstInRange)) ;
        return this.cache.getNodes().filter(({ node }) => {
            return node.rowIndex >= firstInRange.rowIndex && node.rowIndex <= lastInRange.rowIndex;
        }).map(({ node }) => node);
    }
    /**
     * Mutates a given array to add this stores state, and recursively add all the children store states.
     *
     * @param result a mutable results array
     */
    addStoreStates(result) {
        result.push({
            suppressInfiniteScroll: false,
            route: this.parentRowNode.getGroupKeys(),
            rowCount: this.getRowCount(),
            lastRowIndexKnown: this.isLastRowIndexKnown(),
            info: this.info,
            maxBlocksInCache: this.storeParams.maxBlocksInCache,
            cacheBlockSize: this.storeParams.cacheBlockSize,
        });
        this.forEachChildStoreShallow(childStore => childStore.addStoreStates(result));
    }
    getIdSequence() {
        return this.idSequence;
    }
    getParentNode() {
        return this.parentRowNode;
    }
    getRowDetails() {
        return {
            field: this.groupField,
            group: this.group,
            leafGroup: this.leafGroup,
            level: this.level,
            parent: this.parentRowNode,
            rowGroupColumn: this.rowGroupColumn,
        };
    }
    getSsrmParams() {
        return this.ssrmParams;
    }
    setStoreInfo(info) {
        if (info) {
            Object.assign(this.info, info);
        }
    }
    // gets called 1) row count changed 2) cache purged
    fireStoreUpdatedEvent() {
        // this results in row model firing ModelUpdated.
        // server side row model also updates the row indexes first
        const event = {
            type: Events.EVENT_STORE_UPDATED
        };
        this.eventService.dispatchEvent(event);
    }
    // gets called when row data updated, and no more refreshing needed
    fireRefreshFinishedEvent() {
        const event = {
            type: Events.EVENT_STORE_REFRESHED,
            route: this.parentRowNode.getRoute(),
        };
        this.eventService.dispatchEvent(event);
    }
    getBlockStates() {
        return this.cache.getBlockStates();
    }
    getStoreBounds() {
        return {
            topPx: this.topPx,
            heightPx: this.heightPx,
        };
    }
}
__decorate$1N([
    Autowired('ssrmBlockUtils')
], LazyStore.prototype, "blockUtils", void 0);
__decorate$1N([
    Autowired('ssrmStoreUtils')
], LazyStore.prototype, "storeUtils", void 0);
__decorate$1N([
    Autowired('columnModel')
], LazyStore.prototype, "columnModel", void 0);
__decorate$1N([
    Autowired('selectionService')
], LazyStore.prototype, "selectionService", void 0);
__decorate$1N([
    PostConstruct
], LazyStore.prototype, "init", null);
__decorate$1N([
    PreDestroy
], LazyStore.prototype, "destroyRowNodes", null);

var __decorate$1O = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ServerSideRowModel = class ServerSideRowModel extends BeanStub {
    constructor() {
        super(...arguments);
        this.onRowHeightChanged_debounced = _.debounce(this.onRowHeightChanged.bind(this), 100);
        this.pauseStoreUpdateListening = false;
        this.started = false;
        this.managingPivotResultColumns = false;
    }
    // we don't implement as lazy row heights is not supported in this row model
    ensureRowHeightsValid() { return false; }
    start() {
        this.started = true;
        this.updateDatasource();
    }
    destroyDatasource() {
        if (!this.datasource) {
            return;
        }
        if (this.datasource.destroy) {
            this.datasource.destroy();
        }
        this.rowRenderer.datasourceChanged();
        this.datasource = undefined;
    }
    addEventListeners() {
        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_STORE_UPDATED, this.onStoreUpdated.bind(this));
        const resetListener = this.resetRootStore.bind(this);
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, resetListener);
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, resetListener);
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, resetListener);
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, resetListener);
        this.addManagedPropertyListeners([
            /**
             * Following properties omitted as they are likely to come with undesired  side effects.
             * 'getRowId', 'isRowMaster', 'getRowHeight', 'isServerSideGroup', 'getServerSideGroupKey',
             * */
            'masterDetail', 'treeData', 'removePivotHeaderRowWhenSingleValueColumn',
            'suppressServerSideInfiniteScroll', 'cacheBlockSize',
        ], resetListener);
        this.addManagedPropertyListener('rowHeight', () => this.resetRowHeights());
        this.verifyProps();
        this.addManagedPropertyListener('serverSideDatasource', () => this.updateDatasource());
    }
    updateDatasource() {
        const datasource = this.gridOptionsService.get('serverSideDatasource');
        if (datasource) {
            this.setDatasource(datasource);
        }
    }
    verifyProps() {
        if (this.gridOptionsService.exists('initialGroupOrderComparator')) {
            _.warnOnce(`initialGroupOrderComparator cannot be used with Server Side Row Model.`);
        }
        if (this.gridOptionsService.isRowSelection() && !this.gridOptionsService.exists('getRowId')) {
            _.warnOnce(`getRowId callback must be provided for Server Side Row Model selection to work correctly.`);
        }
    }
    setDatasource(datasource) {
        // sometimes React, due to async, can call gridApi.setDatasource() before we have started.
        // this happens when React app does this:
        //      useEffect(() => setDatasource(ds), []);
        // thus if we set the datasource before the grid UI has finished initialising, we do not set it,
        // and the ssrm.start() method will set the datasoure when the grid is ready.
        if (!this.started) {
            return;
        }
        this.destroyDatasource();
        this.datasource = datasource;
        this.resetRootStore();
    }
    applyRowData(rowDataParams, startRow, route) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        const storeToExecuteOn = rootStore.getChildStore(route);
        if (!storeToExecuteOn) {
            return;
        }
        if (storeToExecuteOn instanceof LazyStore) {
            storeToExecuteOn.applyRowData(rowDataParams, startRow, rowDataParams.rowData.length);
        }
        else if (storeToExecuteOn instanceof FullStore) {
            storeToExecuteOn.processServerResult(rowDataParams);
        }
    }
    isLastRowIndexKnown() {
        const cache = this.getRootStore();
        if (!cache) {
            return false;
        }
        return cache.isLastRowIndexKnown();
    }
    onColumnEverything() {
        // if first time, always reset
        if (!this.storeParams) {
            this.resetRootStore();
            return;
        }
        // check if anything pertaining to fetching data has changed, and if it has, reset, but if
        // it has not, don't reset
        const rowGroupColumnVos = this.columnsToValueObjects(this.columnModel.getRowGroupColumns());
        const valueColumnVos = this.columnsToValueObjects(this.columnModel.getValueColumns());
        const pivotColumnVos = this.columnsToValueObjects(this.columnModel.getPivotColumns());
        // compares two sets of columns, ensuring no columns have been added or removed (unless specified via allowRemovedColumns)
        // if the columns are found, also ensures the field and aggFunc properties have not been changed.
        const areColsSame = (params) => {
            const oldColsMap = {};
            params.oldCols.forEach(col => oldColsMap[col.id] = col);
            const allColsUnchanged = params.newCols.every(col => {
                const equivalentCol = oldColsMap[col.id];
                if (equivalentCol) {
                    delete oldColsMap[col.id];
                }
                return equivalentCol && equivalentCol.field === col.field && equivalentCol.aggFunc === col.aggFunc;
            });
            const missingCols = !params.allowRemovedColumns && !!Object.values(oldColsMap).length;
            return allColsUnchanged && !missingCols;
        };
        const sortModelDifferent = !_.jsonEquals(this.storeParams.sortModel, this.sortController.getSortModel());
        const rowGroupDifferent = !areColsSame({
            oldCols: this.storeParams.rowGroupCols,
            newCols: rowGroupColumnVos,
        });
        const pivotDifferent = !areColsSame({
            oldCols: this.storeParams.pivotCols,
            newCols: pivotColumnVos,
        });
        const valuesDifferent = !!(rowGroupColumnVos === null || rowGroupColumnVos === void 0 ? void 0 : rowGroupColumnVos.length) && !areColsSame({
            oldCols: this.storeParams.valueCols,
            newCols: valueColumnVos,
            allowRemovedColumns: true,
        });
        const resetRequired = sortModelDifferent || rowGroupDifferent || pivotDifferent || valuesDifferent;
        if (resetRequired) {
            this.resetRootStore();
        }
        else {
            // cols may have changed even if we didn't do a reset. storeParams ref will be provided when getRows
            // is called, so it's important to keep it up to date.
            const newParams = this.createStoreParams();
            this.storeParams.rowGroupCols = newParams.rowGroupCols;
            this.storeParams.pivotCols = newParams.pivotCols;
            this.storeParams.valueCols = newParams.valueCols;
        }
    }
    destroyRootStore() {
        if (!this.rootNode || !this.rootNode.childStore) {
            return;
        }
        this.rootNode.childStore = this.destroyBean(this.rootNode.childStore);
        this.nodeManager.clear();
    }
    refreshAfterSort(newSortModel, params) {
        if (this.storeParams) {
            this.storeParams.sortModel = newSortModel;
        }
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.refreshAfterSort(params);
        this.onStoreUpdated();
    }
    generateSecondaryColumns(pivotFields) {
        const pivotColumnGroupDefs = this.pivotColDefService.createColDefsFromFields(pivotFields);
        this.managingPivotResultColumns = true;
        this.columnModel.setSecondaryColumns(pivotColumnGroupDefs, "rowModelUpdated");
    }
    ;
    resetRowHeights() {
        const atLeastOne = this.resetRowHeightsForAllRowNodes();
        const rootNodeHeight = this.gridOptionsService.getRowHeightForNode(this.rootNode);
        this.rootNode.setRowHeight(rootNodeHeight.height, rootNodeHeight.estimated);
        if (this.rootNode.sibling) {
            const rootNodeSibling = this.gridOptionsService.getRowHeightForNode(this.rootNode.sibling);
            this.rootNode.sibling.setRowHeight(rootNodeSibling.height, rootNodeSibling.estimated);
        }
        // when pivotMode but pivot not active, root node is displayed on its own
        // because it's only ever displayed alone, refreshing the model (onRowHeightChanged) is not required
        if (atLeastOne) {
            this.onRowHeightChanged();
        }
    }
    resetRowHeightsForAllRowNodes() {
        let atLeastOne = false;
        this.forEachNode(rowNode => {
            const rowHeightForNode = this.gridOptionsService.getRowHeightForNode(rowNode);
            rowNode.setRowHeight(rowHeightForNode.height, rowHeightForNode.estimated);
            // we keep the height each row is at, however we set estimated=true rather than clear the height.
            // this means the grid will not reset the row heights back to defaults, rather it will re-calc
            // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.
            const detailNode = rowNode.detailNode;
            if (detailNode) {
                const detailRowHeight = this.gridOptionsService.getRowHeightForNode(detailNode);
                detailNode.setRowHeight(detailRowHeight.height, detailRowHeight.estimated);
            }
            if (rowNode.sibling) {
                const siblingRowHeight = this.gridOptionsService.getRowHeightForNode(rowNode.sibling);
                detailNode.setRowHeight(siblingRowHeight.height, siblingRowHeight.estimated);
            }
            atLeastOne = true;
        });
        return atLeastOne;
    }
    resetRootStore() {
        this.destroyRootStore();
        this.rootNode = new RowNode(this.beans);
        this.rootNode.group = true;
        this.rootNode.level = -1;
        if (this.datasource) {
            this.storeParams = this.createStoreParams();
            this.rootNode.childStore = this.createBean(this.storeFactory.createStore(this.storeParams, this.rootNode));
            this.updateRowIndexesAndBounds();
        }
        if (this.managingPivotResultColumns) {
            // if managing pivot columns, also reset secondary columns.
            this.columnModel.setSecondaryColumns(null, 'api');
            this.managingPivotResultColumns = false;
        }
        // this gets the row to render rows (or remove the previously rendered rows, as it's blank to start).
        // important to NOT pass in an event with keepRenderedRows or animate, as we want the renderer
        // to treat the rows as new rows, as it's all new data
        this.dispatchModelUpdated(true);
    }
    columnsToValueObjects(columns) {
        return columns.map(col => ({
            id: col.getId(),
            aggFunc: col.getAggFunc(),
            displayName: this.columnModel.getDisplayNameForColumn(col, 'model'),
            field: col.getColDef().field
        }));
    }
    createStoreParams() {
        const rowGroupColumnVos = this.columnsToValueObjects(this.columnModel.getRowGroupColumns());
        const valueColumnVos = this.columnsToValueObjects(this.columnModel.getValueColumns());
        const pivotColumnVos = this.columnsToValueObjects(this.columnModel.getPivotColumns());
        const dynamicRowHeight = this.gridOptionsService.isGetRowHeightFunction();
        const params = {
            // the columns the user has grouped and aggregated by
            valueCols: valueColumnVos,
            rowGroupCols: rowGroupColumnVos,
            pivotCols: pivotColumnVos,
            pivotMode: this.columnModel.isPivotMode(),
            // sort and filter model
            filterModel: this.filterManager.isAdvancedFilterEnabled()
                ? this.filterManager.getAdvancedFilterModel()
                : this.filterManager.getFilterModel(),
            sortModel: this.sortController.getSortModel(),
            datasource: this.datasource,
            lastAccessedSequence: new NumberSequence(),
            // blockSize: blockSize == null ? 100 : blockSize,
            dynamicRowHeight: dynamicRowHeight
        };
        return params;
    }
    getParams() {
        return this.storeParams;
    }
    dispatchModelUpdated(reset = false) {
        const modelUpdatedEvent = {
            type: Events.EVENT_MODEL_UPDATED,
            animate: !reset,
            keepRenderedRows: !reset,
            newPage: false,
            newData: false
        };
        this.eventService.dispatchEvent(modelUpdatedEvent);
    }
    onStoreUpdated() {
        // sometimes if doing a batch update, we do the batch first,
        // then call onStoreUpdated manually. eg expandAll() method.
        if (this.pauseStoreUpdateListening) {
            return;
        }
        this.updateRowIndexesAndBounds();
        this.dispatchModelUpdated();
    }
    /** This method is debounced. It is used for row auto-height. If we don't debounce,
     * then the Row Models will end up recalculating each row position
     * for each row height change and result in the Row Renderer laying out rows.
     * This is particularly bad if using print layout, and showing eg 1,000 rows,
     * each row will change it's height, causing Row Model to update 1,000 times.
     */
    onRowHeightChangedDebounced() {
        this.onRowHeightChanged_debounced();
    }
    onRowHeightChanged() {
        this.updateRowIndexesAndBounds();
        this.dispatchModelUpdated();
    }
    updateRowIndexesAndBounds() {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.setDisplayIndexes(new NumberSequence(), { value: 0 });
    }
    retryLoads() {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.retryLoads();
        this.onStoreUpdated();
    }
    getRow(index) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return undefined;
        }
        return rootStore.getRowUsingDisplayIndex(index);
    }
    expandAll(value) {
        // if we don't pause store updating, we are needlessly
        // recalculating row-indexes etc, and also getting rendering
        // engine to re-render (listens on ModelUpdated event)
        this.pauseStoreUpdateListening = true;
        this.forEachNode(node => {
            if (node.stub) {
                return;
            }
            if (node.hasChildren()) {
                node.setExpanded(value);
            }
        });
        this.pauseStoreUpdateListening = false;
        this.onStoreUpdated();
    }
    refreshAfterFilter(newFilterModel, params) {
        if (this.storeParams) {
            this.storeParams.filterModel = newFilterModel;
        }
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.refreshAfterFilter(params);
        this.onStoreUpdated();
    }
    getRootStore() {
        if (this.rootNode && this.rootNode.childStore) {
            return this.rootNode.childStore;
        }
    }
    getRowCount() {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return 0;
        }
        return rootStore.getDisplayIndexEnd();
    }
    getTopLevelRowCount() {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return 1;
        }
        return rootStore.getRowCount();
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return topLevelIndex;
        }
        return rootStore.getTopLevelRowDisplayedIndex(topLevelIndex);
    }
    getRowBounds(index) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            const rowHeight = this.gridOptionsService.getRowHeightAsNumber();
            return {
                rowTop: 0,
                rowHeight: rowHeight
            };
        }
        return rootStore.getRowBounds(index);
    }
    getBlockStates() {
        const root = this.getRootStore();
        if (!root) {
            return undefined;
        }
        const states = {};
        root.forEachStoreDeep(store => {
            if (store instanceof FullStore) {
                const { id, state } = store.getBlockStateJson();
                states[id] = state;
            }
            else if (store instanceof LazyStore) {
                Object.entries(store.getBlockStates()).forEach(([block, state]) => {
                    states[block] = state;
                });
            }
            else {
                throw new Error('AG Grid: Unsupported store type');
            }
        });
        return states;
    }
    getRowIndexAtPixel(pixel) {
        const rootStore = this.getRootStore();
        if (pixel <= 0 || !rootStore) {
            return 0;
        }
        return rootStore.getRowIndexAtPixel(pixel);
    }
    isEmpty() {
        return false;
    }
    isRowsToRender() {
        return this.getRootStore() != null && this.getRowCount() > 0;
    }
    getType() {
        return 'serverSide';
    }
    forEachNode(callback) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.forEachNodeDeep(callback);
    }
    forEachNodeAfterFilterAndSort(callback, includeFooterNodes = false) {
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return;
        }
        rootStore.forEachNodeDeepAfterFilterAndSort(callback, undefined, includeFooterNodes);
    }
    /** @return false if store hasn't started */
    executeOnStore(route, callback) {
        if (!this.started) {
            return false;
        }
        const rootStore = this.getRootStore();
        if (!rootStore) {
            return true;
        }
        const storeToExecuteOn = rootStore.getChildStore(route);
        if (storeToExecuteOn) {
            callback(storeToExecuteOn);
        }
        return true;
    }
    refreshStore(params = {}) {
        const route = params.route ? params.route : [];
        this.executeOnStore(route, store => store.refreshStore(params.purge == true));
    }
    getStoreState() {
        const res = [];
        const rootStore = this.getRootStore();
        if (rootStore) {
            rootStore.addStoreStates(res);
        }
        return res;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
        if (!_.exists(firstInRange)) {
            return [];
        }
        if (!lastInRange) {
            return [firstInRange];
        }
        const startIndex = firstInRange.rowIndex;
        const endIndex = lastInRange.rowIndex;
        if (startIndex === null || endIndex === null) {
            return [firstInRange];
        }
        const nodeRange = [];
        const [firstIndex, lastIndex] = [startIndex, endIndex].sort((a, b) => a - b);
        this.forEachNode((node) => {
            const thisRowIndex = node.rowIndex;
            if (thisRowIndex == null || node.stub) {
                return;
            }
            if (thisRowIndex >= firstIndex && thisRowIndex <= lastIndex) {
                nodeRange.push(node);
            }
        });
        // don't allow range selection if we don't have the full range of rows
        if (nodeRange.length !== (lastIndex - firstIndex + 1)) {
            return [firstInRange];
        }
        return nodeRange;
    }
    getRowNode(id) {
        let result;
        this.forEachNode(rowNode => {
            if (rowNode.id === id) {
                result = rowNode;
            }
            if (rowNode.detailNode && rowNode.detailNode.id === id) {
                result = rowNode.detailNode;
            }
        });
        return result;
    }
    isRowPresent(rowNode) {
        const foundRowNode = this.getRowNode(rowNode.id);
        return !!foundRowNode;
    }
    setRowCount(rowCount, lastRowIndexKnown) {
        const rootStore = this.getRootStore();
        if (rootStore) {
            if (rootStore instanceof LazyStore) {
                rootStore.setRowCount(rowCount, lastRowIndexKnown);
                return;
            }
            console.error('AG Grid: Infinite scrolling must be enabled in order to set the row count.');
        }
    }
};
__decorate$1O([
    Autowired('columnModel')
], ServerSideRowModel.prototype, "columnModel", void 0);
__decorate$1O([
    Autowired('filterManager')
], ServerSideRowModel.prototype, "filterManager", void 0);
__decorate$1O([
    Autowired('sortController')
], ServerSideRowModel.prototype, "sortController", void 0);
__decorate$1O([
    Autowired('rowRenderer')
], ServerSideRowModel.prototype, "rowRenderer", void 0);
__decorate$1O([
    Autowired('ssrmSortService')
], ServerSideRowModel.prototype, "sortListener", void 0);
__decorate$1O([
    Autowired('ssrmNodeManager')
], ServerSideRowModel.prototype, "nodeManager", void 0);
__decorate$1O([
    Autowired('ssrmStoreFactory')
], ServerSideRowModel.prototype, "storeFactory", void 0);
__decorate$1O([
    Autowired('beans')
], ServerSideRowModel.prototype, "beans", void 0);
__decorate$1O([
    Optional('pivotColDefService')
], ServerSideRowModel.prototype, "pivotColDefService", void 0);
__decorate$1O([
    PreDestroy
], ServerSideRowModel.prototype, "destroyDatasource", null);
__decorate$1O([
    PostConstruct
], ServerSideRowModel.prototype, "addEventListeners", null);
__decorate$1O([
    PreDestroy
], ServerSideRowModel.prototype, "destroyRootStore", null);
ServerSideRowModel = __decorate$1O([
    Bean('rowModel')
], ServerSideRowModel);

var __decorate$1P = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let StoreUtils = class StoreUtils extends BeanStub {
    loadFromDatasource(p) {
        const { storeParams, parentBlock, parentNode } = p;
        const groupKeys = parentNode.getGroupKeys();
        if (!storeParams.datasource) {
            return;
        }
        const request = {
            startRow: p.startRow,
            endRow: p.endRow,
            rowGroupCols: storeParams.rowGroupCols,
            valueCols: storeParams.valueCols,
            pivotCols: storeParams.pivotCols,
            pivotMode: storeParams.pivotMode,
            groupKeys: groupKeys,
            filterModel: storeParams.filterModel,
            sortModel: storeParams.sortModel
        };
        const getRowsParams = this.gridOptionsService.addGridCommonParams({
            success: p.success,
            fail: p.fail,
            request: request,
            parentNode: p.parentNode
        });
        window.setTimeout(() => {
            if (!storeParams.datasource || !parentBlock.isAlive()) {
                // failCallback() is important, to reduce the 'RowNodeBlockLoader.activeBlockLoadsCount' count
                p.fail();
                return;
            }
            storeParams.datasource.getRows(getRowsParams);
        }, 0);
    }
    getChildStore(keys, currentCache, findNodeFunc) {
        if (_.missingOrEmpty(keys)) {
            return currentCache;
        }
        const nextKey = keys[0];
        const nextNode = findNodeFunc(nextKey);
        if (nextNode) {
            // if we have the final node, but not the final store, we create it to allow
            // early population of data
            if (keys.length === 1 && !nextNode.childStore) {
                const storeParams = this.serverSideRowModel.getParams();
                nextNode.childStore = this.createBean(this.storeFactory.createStore(storeParams, nextNode));
            }
            const keyListForNextLevel = keys.slice(1, keys.length);
            const nextStore = nextNode.childStore;
            return nextStore ? nextStore.getChildStore(keyListForNextLevel) : null;
        }
        return null;
    }
    isServerRefreshNeeded(parentRowNode, rowGroupCols, params) {
        if (params.valueColChanged || params.secondaryColChanged) {
            return true;
        }
        const level = parentRowNode.level + 1;
        const grouping = level < rowGroupCols.length;
        const leafNodes = !grouping;
        if (leafNodes) {
            return true;
        }
        const colIdThisGroup = rowGroupCols[level].id;
        const actionOnThisGroup = params.changedColumns.indexOf(colIdThisGroup) > -1;
        if (actionOnThisGroup) {
            return true;
        }
        const allCols = this.columnModel.getAllGridColumns();
        const affectedGroupCols = allCols
            // find all impacted cols which also a group display column
            .filter(col => col.getColDef().showRowGroup && params.changedColumns.includes(col.getId()))
            .map(col => col.getColDef().showRowGroup)
            // if displaying all groups, or displaying the effected col for this group, refresh
            .some(group => group === true || group === colIdThisGroup);
        return affectedGroupCols;
    }
    getServerSideInitialRowCount() {
        return this.gridOptionsService.get('serverSideInitialRowCount');
    }
    assertRowModelIsServerSide(key) {
        if (!this.gridOptionsService.isRowModelType('serverSide')) {
            _.warnOnce(`The '${key}' property can only be used with the Server Side Row Model.`);
            return false;
        }
        return true;
    }
    assertNotTreeData(key) {
        if (this.gridOptionsService.get('treeData')) {
            _.warnOnce(`The '${key}' property cannot be used while using tree data.`);
            return false;
        }
        return true;
    }
    isServerSideSortAllLevels() {
        return this.gridOptionsService.get('serverSideSortAllLevels') && this.assertRowModelIsServerSide('serverSideSortAllLevels');
    }
    isServerSideOnlyRefreshFilteredGroups() {
        return this.gridOptionsService.get('serverSideOnlyRefreshFilteredGroups') && this.assertRowModelIsServerSide('serverSideOnlyRefreshFilteredGroups');
    }
    isServerSideSortOnServer() {
        return this.gridOptionsService.get('serverSideSortOnServer') && this.assertRowModelIsServerSide('serverSideSortOnServer') && this.assertNotTreeData('serverSideSortOnServer');
    }
    isServerSideFilterOnServer() {
        return this.gridOptionsService.get('serverSideFilterOnServer') && this.assertRowModelIsServerSide('serverSideFilterOnServer') && this.assertNotTreeData('serverSideFilterOnServer');
    }
};
__decorate$1P([
    Autowired('columnModel')
], StoreUtils.prototype, "columnModel", void 0);
__decorate$1P([
    Autowired('rowModel')
], StoreUtils.prototype, "serverSideRowModel", void 0);
__decorate$1P([
    Autowired('ssrmStoreFactory')
], StoreUtils.prototype, "storeFactory", void 0);
StoreUtils = __decorate$1P([
    Bean('ssrmStoreUtils')
], StoreUtils);

var __decorate$1Q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const GROUP_MISSING_KEY_ID = 'ag-Grid-MissingKey';
let BlockUtils = class BlockUtils extends BeanStub {
    createRowNode(params) {
        const rowNode = new RowNode(this.beans);
        const rowHeight = params.rowHeight != null ? params.rowHeight : this.gridOptionsService.getRowHeightAsNumber();
        rowNode.setRowHeight(rowHeight);
        rowNode.group = params.group;
        rowNode.leafGroup = params.leafGroup;
        rowNode.level = params.level;
        rowNode.uiLevel = params.level;
        rowNode.parent = params.parent;
        // stub gets set to true here, and then false when this rowNode gets it's data
        rowNode.stub = true;
        rowNode.__needsRefreshWhenVisible = false;
        if (rowNode.group) {
            rowNode.expanded = false;
            rowNode.field = params.field;
            rowNode.rowGroupColumn = params.rowGroupColumn;
        }
        return rowNode;
    }
    destroyRowNodes(rowNodes) {
        if (rowNodes) {
            rowNodes.forEach((row) => this.destroyRowNode(row));
        }
    }
    destroyRowNode(rowNode, preserveStore = false) {
        if (rowNode.childStore && !preserveStore) {
            this.destroyBean(rowNode.childStore);
            rowNode.childStore = null;
        }
        // if this has a footer, destroy that too
        if (rowNode.sibling && !rowNode.footer) {
            this.destroyRowNode(rowNode.sibling, false);
        }
        // this is needed, so row render knows to fade out the row, otherwise it
        // sees row top is present, and thinks the row should be shown. maybe
        // rowNode should have a flag on whether it is visible???
        rowNode.clearRowTopAndRowIndex();
        if (rowNode.id != null) {
            this.nodeManager.removeNode(rowNode);
        }
    }
    setTreeGroupInfo(rowNode) {
        rowNode.updateHasChildren();
        const getKeyFunc = this.gridOptionsService.get('getServerSideGroupKey');
        if (rowNode.hasChildren() && getKeyFunc != null) {
            rowNode.key = getKeyFunc(rowNode.data);
        }
        if (!rowNode.hasChildren() && rowNode.childStore != null) {
            this.destroyBean(rowNode.childStore);
            rowNode.childStore = null;
            rowNode.expanded = false;
        }
    }
    setRowGroupInfo(rowNode) {
        rowNode.key = this.valueService.getValue(rowNode.rowGroupColumn, rowNode);
        if (rowNode.key === null || rowNode.key === undefined) {
            _.doOnce(() => {
                console.warn(`AG Grid: null and undefined values are not allowed for server side row model keys`);
                if (rowNode.rowGroupColumn) {
                    console.warn(`column = ${rowNode.rowGroupColumn.getId()}`);
                }
                console.warn(`data is `, rowNode.data);
            }, 'ServerSideBlock-CannotHaveNullOrUndefinedForKey');
        }
        const getGroupIncludeFooter = this.beans.gridOptionsService.getGroupIncludeFooter();
        const doesRowShowFooter = getGroupIncludeFooter({ node: rowNode });
        if (doesRowShowFooter) {
            rowNode.createFooter();
            if (rowNode.sibling) {
                rowNode.sibling.uiLevel = rowNode.uiLevel + 1;
            }
        }
    }
    setMasterDetailInfo(rowNode) {
        const isMasterFunc = this.gridOptionsService.get('isRowMaster');
        if (isMasterFunc != null) {
            rowNode.master = isMasterFunc(rowNode.data);
        }
        else {
            rowNode.master = true;
        }
    }
    updateDataIntoRowNode(rowNode, data) {
        rowNode.updateData(data);
        if (this.gridOptionsService.get('treeData')) {
            this.setTreeGroupInfo(rowNode);
            this.setChildCountIntoRowNode(rowNode);
        }
        else if (rowNode.group) {
            this.setChildCountIntoRowNode(rowNode);
            if (!rowNode.footer) {
                const getGroupIncludeFooter = this.beans.gridOptionsService.getGroupIncludeFooter();
                const doesRowShowFooter = getGroupIncludeFooter({ node: rowNode });
                if (doesRowShowFooter) {
                    if (rowNode.sibling) {
                        rowNode.sibling.updateData(data);
                    }
                    else {
                        rowNode.createFooter();
                    }
                }
                else if (rowNode.sibling) {
                    rowNode.destroyFooter();
                }
            }
            // it's not possible for a node to change whether it's a group or not
            // when doing row grouping (as only rows at certain levels are groups),
            // so nothing to do here
        }
        else if (this.gridOptionsService.get('masterDetail')) ;
    }
    setDataIntoRowNode(rowNode, data, defaultId, cachedRowHeight) {
        var _a;
        rowNode.stub = false;
        const treeData = this.gridOptionsService.get('treeData');
        if (_.exists(data)) {
            rowNode.setDataAndId(data, defaultId);
            if (treeData) {
                this.setTreeGroupInfo(rowNode);
            }
            else if (rowNode.group) {
                this.setRowGroupInfo(rowNode);
            }
            else if (this.gridOptionsService.get('masterDetail')) {
                this.setMasterDetailInfo(rowNode);
            }
        }
        else {
            rowNode.setDataAndId(undefined, undefined);
            rowNode.key = null;
        }
        if (treeData || rowNode.group) {
            this.setGroupDataIntoRowNode(rowNode);
            this.setChildCountIntoRowNode(rowNode);
        }
        // this needs to be done AFTER setGroupDataIntoRowNode(), as the height can depend on the group data
        // getting set, if it's a group node and colDef.autoHeight=true
        if (_.exists(data)) {
            rowNode.setRowHeight(this.gridOptionsService.getRowHeightForNode(rowNode, false, cachedRowHeight).height);
            (_a = rowNode.sibling) === null || _a === void 0 ? void 0 : _a.setRowHeight(this.gridOptionsService.getRowHeightForNode(rowNode.sibling, false, cachedRowHeight).height);
        }
    }
    setChildCountIntoRowNode(rowNode) {
        const getChildCount = this.gridOptionsService.get('getChildCount');
        if (getChildCount) {
            rowNode.setAllChildrenCount(getChildCount(rowNode.data));
        }
    }
    setGroupDataIntoRowNode(rowNode) {
        const groupDisplayCols = this.columnModel.getGroupDisplayColumns();
        const usingTreeData = this.gridOptionsService.get('treeData');
        groupDisplayCols.forEach(col => {
            if (rowNode.groupData == null) {
                rowNode.groupData = {};
            }
            if (usingTreeData) {
                rowNode.groupData[col.getColId()] = rowNode.key;
            }
            else if (col.isRowGroupDisplayed(rowNode.rowGroupColumn.getId())) {
                const groupValue = this.valueService.getValue(rowNode.rowGroupColumn, rowNode);
                rowNode.groupData[col.getColId()] = groupValue;
            }
        });
    }
    clearDisplayIndex(rowNode) {
        rowNode.clearRowTopAndRowIndex();
        const hasChildStore = rowNode.hasChildren() && _.exists(rowNode.childStore);
        if (hasChildStore) {
            const childStore = rowNode.childStore;
            childStore.clearDisplayIndexes();
        }
        const hasDetailNode = rowNode.master && rowNode.detailNode;
        if (hasDetailNode) {
            rowNode.detailNode.clearRowTopAndRowIndex();
        }
    }
    setDisplayIndex(rowNode, displayIndexSeq, nextRowTop) {
        // set this row
        rowNode.setRowIndex(displayIndexSeq.next());
        rowNode.setRowTop(nextRowTop.value);
        nextRowTop.value += rowNode.rowHeight;
        if (rowNode.footer) {
            return;
        }
        // set child for master / detail
        const hasDetailRow = rowNode.master;
        if (hasDetailRow) {
            if (rowNode.expanded && rowNode.detailNode) {
                rowNode.detailNode.setRowIndex(displayIndexSeq.next());
                rowNode.detailNode.setRowTop(nextRowTop.value);
                nextRowTop.value += rowNode.detailNode.rowHeight;
            }
            else if (rowNode.detailNode) {
                rowNode.detailNode.clearRowTopAndRowIndex();
            }
        }
        // set children for SSRM child rows
        const hasChildStore = rowNode.hasChildren() && _.exists(rowNode.childStore);
        if (hasChildStore) {
            const childStore = rowNode.childStore;
            if (rowNode.expanded) {
                childStore.setDisplayIndexes(displayIndexSeq, nextRowTop);
            }
            else {
                // we need to clear the row tops, as the row renderer depends on
                // this to know if the row should be faded out
                childStore.clearDisplayIndexes();
            }
        }
    }
    binarySearchForDisplayIndex(displayRowIndex, rowNodes) {
        let bottomPointer = 0;
        let topPointer = rowNodes.length - 1;
        if (_.missing(topPointer) || _.missing(bottomPointer)) {
            console.warn(`AG Grid: error: topPointer = ${topPointer}, bottomPointer = ${bottomPointer}`);
            return undefined;
        }
        while (true) {
            const midPointer = Math.floor((bottomPointer + topPointer) / 2);
            const currentRowNode = rowNodes[midPointer];
            // first check current row for index
            if (currentRowNode.rowIndex === displayRowIndex) {
                return currentRowNode;
            }
            // then check if current row contains a detail row with the index
            const expandedMasterRow = currentRowNode.master && currentRowNode.expanded;
            const detailNode = currentRowNode.detailNode;
            if (expandedMasterRow && detailNode && detailNode.rowIndex === displayRowIndex) {
                return currentRowNode.detailNode;
            }
            // then check if child cache contains index
            const childStore = currentRowNode.childStore;
            if (currentRowNode.expanded && childStore && childStore.isDisplayIndexInStore(displayRowIndex)) {
                return childStore.getRowUsingDisplayIndex(displayRowIndex);
            }
            // otherwise adjust pointers to continue searching for index
            if (currentRowNode.rowIndex < displayRowIndex) {
                bottomPointer = midPointer + 1;
            }
            else if (currentRowNode.rowIndex > displayRowIndex) {
                topPointer = midPointer - 1;
            }
            else {
                console.warn(`AG Grid: error: unable to locate rowIndex = ${displayRowIndex} in cache`);
                return undefined;
            }
        }
    }
    extractRowBounds(rowNode, index) {
        const extractRowBounds = (currentRowNode) => ({
            rowHeight: currentRowNode.rowHeight,
            rowTop: currentRowNode.rowTop
        });
        if (rowNode.rowIndex === index) {
            return extractRowBounds(rowNode);
        }
        if (rowNode.hasChildren() && rowNode.expanded && _.exists(rowNode.childStore)) {
            const childStore = rowNode.childStore;
            if (childStore.isDisplayIndexInStore(index)) {
                return childStore.getRowBounds(index);
            }
        }
        else if (rowNode.master && rowNode.expanded && _.exists(rowNode.detailNode)) {
            if (rowNode.detailNode.rowIndex === index) {
                return extractRowBounds(rowNode.detailNode);
            }
        }
    }
    getIndexAtPixel(rowNode, pixel) {
        // first check if pixel is in range of current row
        if (rowNode.isPixelInRange(pixel)) {
            return rowNode.rowIndex;
        }
        // then check if current row contains a detail row with pixel in range
        const expandedMasterRow = rowNode.master && rowNode.expanded;
        const detailNode = rowNode.detailNode;
        if (expandedMasterRow && detailNode && detailNode.isPixelInRange(pixel)) {
            return rowNode.detailNode.rowIndex;
        }
        // then check if it's a group row with a child cache with pixel in range
        if (rowNode.hasChildren() && rowNode.expanded && _.exists(rowNode.childStore)) {
            const childStore = rowNode.childStore;
            if (childStore.isPixelInRange(pixel)) {
                return childStore.getRowIndexAtPixel(pixel);
            }
        }
        return null;
        // pixel is not within this row node or it's children / detail, so return undefined
    }
    createNodeIdPrefix(parentRowNode) {
        const parts = [];
        let rowNode = parentRowNode;
        // pull keys from all parent nodes, but do not include the root node
        while (rowNode && rowNode.level >= 0) {
            if (rowNode.key === '') {
                parts.push(GROUP_MISSING_KEY_ID);
            }
            else {
                parts.push(rowNode.key);
            }
            rowNode = rowNode.parent;
        }
        if (parts.length > 0) {
            return parts.reverse().join('-');
        }
        // no prefix, so node id's are left as they are
        return undefined;
    }
    checkOpenByDefault(rowNode) {
        return this.expansionService.checkOpenByDefault(rowNode);
    }
};
__decorate$1Q([
    Autowired('valueService')
], BlockUtils.prototype, "valueService", void 0);
__decorate$1Q([
    Autowired('columnModel')
], BlockUtils.prototype, "columnModel", void 0);
__decorate$1Q([
    Autowired('ssrmNodeManager')
], BlockUtils.prototype, "nodeManager", void 0);
__decorate$1Q([
    Autowired('beans')
], BlockUtils.prototype, "beans", void 0);
__decorate$1Q([
    Autowired('expansionService')
], BlockUtils.prototype, "expansionService", void 0);
BlockUtils = __decorate$1Q([
    Bean('ssrmBlockUtils')
], BlockUtils);

var __decorate$1R = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NodeManager = class NodeManager {
    constructor() {
        this.rowNodes = {};
    }
    addRowNode(rowNode) {
        const id = rowNode.id;
        if (this.rowNodes[id]) {
            console.warn(`AG Grid: Duplicate node id ${rowNode.id}. Row ID's are provided via the getRowId() callback. Please modify the getRowId() callback code to provide unique row id values.`);
            console.warn('first instance', this.rowNodes[id].data);
            console.warn('second instance', rowNode.data);
        }
        this.rowNodes[id] = rowNode;
    }
    removeNode(rowNode) {
        const id = rowNode.id;
        if (this.rowNodes[id]) {
            this.rowNodes[id] = undefined;
        }
    }
    clear() {
        this.rowNodes = {};
    }
};
__decorate$1R([
    PreDestroy
], NodeManager.prototype, "clear", null);
NodeManager = __decorate$1R([
    Bean('ssrmNodeManager')
], NodeManager);

var __decorate$1S = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TransactionManager = class TransactionManager extends BeanStub {
    constructor() {
        super(...arguments);
        this.asyncTransactions = [];
    }
    postConstruct() {
        // only want to be active if SSRM active, otherwise would be interfering with other row models
        if (!this.gridOptionsService.isRowModelType('serverSide')) {
            return;
        }
    }
    applyTransactionAsync(transaction, callback) {
        if (this.asyncTransactionsTimeout == null) {
            this.scheduleExecuteAsync();
        }
        this.asyncTransactions.push({ transaction: transaction, callback: callback });
    }
    scheduleExecuteAsync() {
        const waitMillis = this.gridOptionsService.getAsyncTransactionWaitMillis();
        this.asyncTransactionsTimeout = window.setTimeout(() => {
            this.executeAsyncTransactions();
        }, waitMillis);
    }
    executeAsyncTransactions() {
        if (!this.asyncTransactions) {
            return;
        }
        const resultFuncs = [];
        const resultsForEvent = [];
        const transactionsToRetry = [];
        let atLeastOneTransactionApplied = false;
        this.asyncTransactions.forEach(txWrapper => {
            let result;
            const hasStarted = this.serverSideRowModel.executeOnStore(txWrapper.transaction.route, cache => {
                result = cache.applyTransaction(txWrapper.transaction);
            });
            if (!hasStarted) {
                result = { status: ServerSideTransactionResultStatus.StoreNotStarted };
            }
            else if (result == undefined) {
                result = { status: ServerSideTransactionResultStatus.StoreNotFound };
            }
            resultsForEvent.push(result);
            const retryTransaction = result.status == ServerSideTransactionResultStatus.StoreLoading;
            if (retryTransaction) {
                transactionsToRetry.push(txWrapper);
                return;
            }
            if (txWrapper.callback) {
                resultFuncs.push(() => txWrapper.callback(result));
            }
            if (result.status === ServerSideTransactionResultStatus.Applied) {
                atLeastOneTransactionApplied = true;
            }
        });
        // do callbacks in next VM turn so it's async
        if (resultFuncs.length > 0) {
            window.setTimeout(() => {
                resultFuncs.forEach(func => func());
            }, 0);
        }
        this.asyncTransactionsTimeout = undefined;
        // this will be empty list if nothing to retry
        this.asyncTransactions = transactionsToRetry;
        if (atLeastOneTransactionApplied) {
            this.valueCache.onDataChanged();
            this.eventService.dispatchEvent({ type: Events.EVENT_STORE_UPDATED });
        }
        if (resultsForEvent.length > 0) {
            const event = {
                type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,
                results: resultsForEvent
            };
            this.eventService.dispatchEvent(event);
        }
    }
    flushAsyncTransactions() {
        // the timeout could be missing, if we are flushing due to row data loaded
        if (this.asyncTransactionsTimeout != null) {
            clearTimeout(this.asyncTransactionsTimeout);
        }
        this.executeAsyncTransactions();
    }
    applyTransaction(transaction) {
        let res;
        const hasStarted = this.serverSideRowModel.executeOnStore(transaction.route, store => {
            res = store.applyTransaction(transaction);
        });
        if (!hasStarted) {
            return { status: ServerSideTransactionResultStatus.StoreNotStarted };
        }
        else if (res) {
            this.valueCache.onDataChanged();
            if (res.remove) {
                const removedRowIds = res.remove.map(row => row.id);
                this.selectionService.deleteSelectionStateFromParent(transaction.route || [], removedRowIds);
            }
            this.eventService.dispatchEvent({ type: Events.EVENT_STORE_UPDATED });
            return res;
        }
        else {
            return { status: ServerSideTransactionResultStatus.StoreNotFound };
        }
    }
};
__decorate$1S([
    Autowired('rowNodeBlockLoader')
], TransactionManager.prototype, "rowNodeBlockLoader", void 0);
__decorate$1S([
    Autowired('valueCache')
], TransactionManager.prototype, "valueCache", void 0);
__decorate$1S([
    Autowired('rowModel')
], TransactionManager.prototype, "serverSideRowModel", void 0);
__decorate$1S([
    Autowired('rowRenderer')
], TransactionManager.prototype, "rowRenderer", void 0);
__decorate$1S([
    Autowired('selectionService')
], TransactionManager.prototype, "selectionService", void 0);
__decorate$1S([
    PostConstruct
], TransactionManager.prototype, "postConstruct", null);
TransactionManager = __decorate$1S([
    Bean('ssrmTransactionManager')
], TransactionManager);

var __decorate$1T = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ExpandListener = class ExpandListener extends BeanStub {
    postConstruct() {
        // only want to be active if SSRM active, otherwise would be interfering with other row models
        if (!this.gridOptionsService.isRowModelType('serverSide')) {
            return;
        }
        this.addManagedListener(this.eventService, Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));
    }
    onRowGroupOpened(event) {
        const rowNode = event.node;
        if (rowNode.expanded) {
            if (rowNode.master) {
                this.createDetailNode(rowNode);
            }
            else if (_.missing(rowNode.childStore)) {
                const storeParams = this.serverSideRowModel.getParams();
                rowNode.childStore = this.createBean(this.storeFactory.createStore(storeParams, rowNode));
            }
        }
        else if (this.gridOptionsService.get('purgeClosedRowNodes') && _.exists(rowNode.childStore)) {
            rowNode.childStore = this.destroyBean(rowNode.childStore);
        }
        const storeUpdatedEvent = { type: Events.EVENT_STORE_UPDATED };
        this.eventService.dispatchEvent(storeUpdatedEvent);
    }
    createDetailNode(masterNode) {
        if (_.exists(masterNode.detailNode)) {
            return masterNode.detailNode;
        }
        const detailNode = new RowNode(this.beans);
        detailNode.detail = true;
        detailNode.selectable = false;
        detailNode.parent = masterNode;
        if (_.exists(masterNode.id)) {
            detailNode.id = 'detail_' + masterNode.id;
        }
        detailNode.data = masterNode.data;
        detailNode.level = masterNode.level + 1;
        const defaultDetailRowHeight = 200;
        const rowHeight = this.gridOptionsService.getRowHeightForNode(detailNode).height;
        detailNode.rowHeight = rowHeight ? rowHeight : defaultDetailRowHeight;
        masterNode.detailNode = detailNode;
        return detailNode;
    }
};
__decorate$1T([
    Autowired('rowModel')
], ExpandListener.prototype, "serverSideRowModel", void 0);
__decorate$1T([
    Autowired('ssrmStoreFactory')
], ExpandListener.prototype, "storeFactory", void 0);
__decorate$1T([
    Autowired('beans')
], ExpandListener.prototype, "beans", void 0);
__decorate$1T([
    PostConstruct
], ExpandListener.prototype, "postConstruct", null);
ExpandListener = __decorate$1T([
    Bean('ssrmExpandListener')
], ExpandListener);

var __decorate$1U = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let SortListener = class SortListener extends BeanStub {
    postConstruct() {
        // only want to be active if SSRM active, otherwise would be interfering with other row models
        if (!this.gridOptionsService.isRowModelType('serverSide')) {
            return;
        }
        this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));
    }
    onSortChanged() {
        const storeParams = this.serverSideRowModel.getParams();
        if (!storeParams) {
            return;
        } // params is undefined if no datasource set
        const newSortModel = this.sortController.getSortModel();
        const oldSortModel = storeParams.sortModel;
        const changedColumns = this.findChangedColumnsInSort(newSortModel, oldSortModel);
        const valueColChanged = this.listenerUtils.isSortingWithValueColumn(changedColumns);
        const secondaryColChanged = this.listenerUtils.isSortingWithSecondaryColumn(changedColumns);
        const params = {
            valueColChanged,
            secondaryColChanged,
            changedColumns
        };
        this.serverSideRowModel.refreshAfterSort(newSortModel, params);
    }
    // returns back all the cols that were effected by the sorting. eg if we were sorting by col A,
    // and now we are sorting by col B, the list of impacted cols should be A and B. so if a cache
    // is impacted by sorting on A or B then it needs to be refreshed. this includes where the cache
    // was previously sorted by A and then the A sort now needs to be cleared.
    findChangedColumnsInSort(newSortModel, oldSortModel) {
        let allColsInBothSorts = [];
        [newSortModel, oldSortModel].forEach(sortModel => {
            if (sortModel) {
                const ids = sortModel.map(sm => sm.colId);
                allColsInBothSorts = allColsInBothSorts.concat(ids);
            }
        });
        const differentSorts = (oldSortItem, newSortItem) => {
            const oldSort = oldSortItem ? oldSortItem.sort : null;
            const newSort = newSortItem ? newSortItem.sort : null;
            return oldSort !== newSort;
        };
        const differentIndexes = (oldSortItem, newSortItem) => {
            const oldIndex = oldSortItem ? oldSortModel.indexOf(oldSortItem) : -1;
            const newIndex = newSortItem ? newSortModel.indexOf(newSortItem) : -1;
            return oldIndex !== newIndex;
        };
        return allColsInBothSorts.filter(colId => {
            const oldSortItem = oldSortModel.find(sm => sm.colId === colId);
            const newSortItem = newSortModel.find(sm => sm.colId === colId);
            return differentSorts(oldSortItem, newSortItem) || differentIndexes(oldSortItem, newSortItem);
        });
    }
};
__decorate$1U([
    Autowired('sortController')
], SortListener.prototype, "sortController", void 0);
__decorate$1U([
    Autowired('rowModel')
], SortListener.prototype, "serverSideRowModel", void 0);
__decorate$1U([
    Autowired('ssrmListenerUtils')
], SortListener.prototype, "listenerUtils", void 0);
__decorate$1U([
    PostConstruct
], SortListener.prototype, "postConstruct", null);
SortListener = __decorate$1U([
    Bean('ssrmSortService')
], SortListener);

var __decorate$1V = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let FilterListener = class FilterListener extends BeanStub {
    postConstruct() {
        // only want to be active if SSRM active, otherwise would be interfering with other row models
        if (!this.gridOptionsService.isRowModelType('serverSide')) {
            return;
        }
        this.addManagedListener(this.eventService, Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, () => this.onFilterChanged(true));
        this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, () => this.onFilterChanged());
    }
    onFilterChanged(advancedFilterEnabledChanged) {
        const storeParams = this.serverSideRowModel.getParams();
        if (!storeParams) {
            return;
        } // params is undefined if no datasource set
        const oldModel = storeParams.filterModel;
        let newModel;
        let changedColumns;
        if (this.filterManager.isAdvancedFilterEnabled()) {
            newModel = this.filterManager.getAdvancedFilterModel();
            // if advancedFilterEnabledChanged, old model is of type `FilterModel`
            const oldColumns = advancedFilterEnabledChanged ? Object.keys(oldModel !== null && oldModel !== void 0 ? oldModel : {}) : this.getAdvancedFilterColumns(oldModel);
            const newColumns = this.getAdvancedFilterColumns(newModel);
            oldColumns.forEach(column => newColumns.add(column));
            changedColumns = Array.from(newColumns);
        }
        else {
            newModel = this.filterManager.getFilterModel();
            if (advancedFilterEnabledChanged) {
                // old model is of type `AdvancedFilterModel | null`
                const oldColumns = this.getAdvancedFilterColumns(oldModel);
                Object.keys(newModel).forEach(column => oldColumns.add(column));
                changedColumns = Array.from(oldColumns);
            }
            else {
                changedColumns = this.findChangedColumns(oldModel, newModel);
            }
        }
        const valueColChanged = this.listenerUtils.isSortingWithValueColumn(changedColumns);
        const secondaryColChanged = this.listenerUtils.isSortingWithSecondaryColumn(changedColumns);
        const params = {
            valueColChanged,
            secondaryColChanged,
            changedColumns
        };
        this.serverSideRowModel.refreshAfterFilter(newModel, params);
    }
    findChangedColumns(oldModel, newModel) {
        const allColKeysMap = {};
        Object.keys(oldModel).forEach(key => allColKeysMap[key] = true);
        Object.keys(newModel).forEach(key => allColKeysMap[key] = true);
        const res = [];
        Object.keys(allColKeysMap).forEach(key => {
            const oldJson = JSON.stringify(oldModel[key]);
            const newJson = JSON.stringify(newModel[key]);
            const filterChanged = oldJson != newJson;
            if (filterChanged) {
                res.push(key);
            }
        });
        return res;
    }
    getAdvancedFilterColumns(model) {
        const columns = new Set();
        if (!model) {
            return columns;
        }
        const processAdvancedFilterModel = (filterModel) => {
            if (filterModel.filterType === 'join') {
                filterModel.conditions.forEach(condition => processAdvancedFilterModel(condition));
            }
            else {
                columns.add(filterModel.colId);
            }
        };
        processAdvancedFilterModel(model);
        return columns;
    }
};
__decorate$1V([
    Autowired('rowModel')
], FilterListener.prototype, "serverSideRowModel", void 0);
__decorate$1V([
    Autowired('filterManager')
], FilterListener.prototype, "filterManager", void 0);
__decorate$1V([
    Autowired('ssrmListenerUtils')
], FilterListener.prototype, "listenerUtils", void 0);
__decorate$1V([
    PostConstruct
], FilterListener.prototype, "postConstruct", null);
FilterListener = __decorate$1V([
    Bean('ssrmFilterListener')
], FilterListener);

var __decorate$1W = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let StoreFactory = class StoreFactory {
    createStore(ssrmParams, parentNode) {
        const storeParams = this.getStoreParams(ssrmParams, parentNode);
        const CacheClass = storeParams.suppressInfiniteScroll ? FullStore : LazyStore;
        return new CacheClass(ssrmParams, storeParams, parentNode);
    }
    getStoreParams(ssrmParams, parentNode) {
        const userStoreParams = this.getLevelSpecificParams(parentNode);
        // if user provided overrideParams, we take infiniteScroll from there if it exists
        const infiniteScroll = this.isInfiniteScroll(userStoreParams);
        const cacheBlockSize = this.getBlockSize(infiniteScroll, userStoreParams);
        const maxBlocksInCache = this.getMaxBlocksInCache(infiniteScroll, ssrmParams, userStoreParams);
        const storeParams = {
            suppressInfiniteScroll: !infiniteScroll,
            cacheBlockSize,
            maxBlocksInCache
        };
        return storeParams;
    }
    getMaxBlocksInCache(infiniteScroll, ssrmParams, userStoreParams) {
        if (!infiniteScroll) {
            return undefined;
        }
        const maxBlocksInCache = (userStoreParams && userStoreParams.maxBlocksInCache != null)
            ? userStoreParams.maxBlocksInCache
            : this.gridOptionsService.get('maxBlocksInCache');
        const maxBlocksActive = maxBlocksInCache != null && maxBlocksInCache >= 0;
        if (!maxBlocksActive) {
            return undefined;
        }
        if (ssrmParams.dynamicRowHeight) {
            const message = 'Server Side Row Model does not support Dynamic Row Height and Cache Purging. ' +
                'Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.';
            _.warnOnce(message);
            return undefined;
        }
        if (this.columnModel.isAutoRowHeightActive()) {
            const message = 'Server Side Row Model does not support Auto Row Height and Cache Purging. ' +
                'Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.';
            _.warnOnce(message);
            return undefined;
        }
        return maxBlocksInCache;
    }
    getBlockSize(infiniteScroll, userStoreParams) {
        if (!infiniteScroll) {
            return undefined;
        }
        const blockSize = (userStoreParams && userStoreParams.cacheBlockSize != null)
            ? userStoreParams.cacheBlockSize
            : this.gridOptionsService.get('cacheBlockSize');
        if (blockSize != null && blockSize > 0) {
            return blockSize;
        }
        else {
            return 100;
        }
    }
    getLevelSpecificParams(parentNode) {
        const callback = this.gridOptionsService.getCallback('getServerSideGroupLevelParams');
        if (!callback) {
            return undefined;
        }
        const params = {
            level: parentNode.level + 1,
            parentRowNode: parentNode.level >= 0 ? parentNode : undefined,
            rowGroupColumns: this.columnModel.getRowGroupColumns(),
            pivotColumns: this.columnModel.getPivotColumns(),
            pivotMode: this.columnModel.isPivotMode()
        };
        const res = callback(params);
        return res;
    }
    isInfiniteScroll(storeParams) {
        const res = (storeParams && storeParams.suppressInfiniteScroll != null)
            ? storeParams.suppressInfiniteScroll
            : this.isSuppressServerSideInfiniteScroll();
        return !res;
    }
    isSuppressServerSideInfiniteScroll() {
        return this.gridOptionsService.get('suppressServerSideInfiniteScroll');
    }
};
__decorate$1W([
    Autowired('gridOptionsService')
], StoreFactory.prototype, "gridOptionsService", void 0);
__decorate$1W([
    Autowired('columnModel')
], StoreFactory.prototype, "columnModel", void 0);
StoreFactory = __decorate$1W([
    Bean('ssrmStoreFactory')
], StoreFactory);

var __decorate$1X = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ListenerUtils = class ListenerUtils {
    isSortingWithValueColumn(changedColumnsInSort) {
        const valueColIds = this.columnModel.getValueColumns().map(col => col.getColId());
        for (let i = 0; i < changedColumnsInSort.length; i++) {
            if (valueColIds.indexOf(changedColumnsInSort[i]) > -1) {
                return true;
            }
        }
        return false;
    }
    isSortingWithSecondaryColumn(changedColumnsInSort) {
        if (!this.columnModel.getSecondaryColumns()) {
            return false;
        }
        const secondaryColIds = this.columnModel.getSecondaryColumns().map(col => col.getColId());
        for (let i = 0; i < changedColumnsInSort.length; i++) {
            if (secondaryColIds.indexOf(changedColumnsInSort[i]) > -1) {
                return true;
            }
        }
        return false;
    }
};
__decorate$1X([
    Autowired('columnModel')
], ListenerUtils.prototype, "columnModel", void 0);
ListenerUtils = __decorate$1X([
    Bean('ssrmListenerUtils')
], ListenerUtils);

var __decorate$1Y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class DefaultStrategy extends BeanStub {
    constructor() {
        super(...arguments);
        this.selectedState = { selectAll: false, toggledNodes: new Set() };
        this.lastSelected = null;
        this.selectAllUsed = false;
        // this is to prevent regressions, default selectionService retains reference of clicked nodes.
        this.selectedNodes = {};
    }
    init() {
        this.rowSelection = this.gridOptionsService.get('rowSelection');
        this.addManagedPropertyListener('rowSelection', (propChange) => {
            this.rowSelection = propChange.currentValue;
        });
    }
    getSelectedState() {
        return {
            selectAll: this.selectedState.selectAll,
            toggledNodes: [...this.selectedState.toggledNodes],
        };
    }
    setSelectedState(state) {
        // fire selection changed event
        const newState = {
            selectAll: false,
            toggledNodes: new Set(),
        };
        if (typeof state !== 'object') {
            console.error('AG Grid: The provided selection state should be an object.');
            return;
        }
        if ('selectAll' in state && typeof state.selectAll === 'boolean') {
            newState.selectAll = state.selectAll;
        }
        else {
            console.error('AG Grid: Select all status should be of boolean type.');
            return;
        }
        if ('toggledNodes' in state && Array.isArray(state.toggledNodes)) {
            state.toggledNodes.forEach((key) => {
                if (typeof key === 'string') {
                    newState.toggledNodes.add(key);
                }
                else {
                    console.warn(`AG Grid: Provided ids must be of string type. Invalid id provided: ${key}`);
                }
            });
        }
        else {
            console.error('AG Grid: `toggledNodes` must be an array of string ids.');
            return;
        }
        this.selectedState = newState;
    }
    deleteSelectionStateFromParent(parentPath, removedNodeIds) {
        if (this.selectedState.toggledNodes.size === 0) {
            return false;
        }
        let anyNodesToggled = false;
        removedNodeIds.forEach(id => {
            if (this.selectedState.toggledNodes.delete(id)) {
                anyNodesToggled = true;
            }
        });
        return anyNodesToggled;
    }
    setNodesSelected(params) {
        if (params.nodes.length === 0)
            return 0;
        const onlyThisNode = params.clearSelection && params.newValue && !params.rangeSelect;
        if (this.rowSelection !== 'multiple' || onlyThisNode) {
            if (params.nodes.length > 1) {
                throw new Error('AG Grid: cannot select multiple rows when rowSelection is set to \'single\'');
            }
            const node = params.nodes[0];
            if (params.newValue) {
                this.selectedNodes = { [node.id]: node };
                this.selectedState = {
                    selectAll: false,
                    toggledNodes: new Set([node.id]),
                };
            }
            else {
                this.selectedNodes = {};
                this.selectedState = {
                    selectAll: false,
                    toggledNodes: new Set(),
                };
            }
            this.lastSelected = node.id;
            return 1;
        }
        const updateNodeState = (node) => {
            if (params.newValue) {
                this.selectedNodes[node.id] = node;
            }
            else {
                delete this.selectedNodes[node.id];
            }
            const isNodeSelectable = node.selectable;
            const doesNodeConform = params.newValue === this.selectedState.selectAll;
            if (doesNodeConform || !isNodeSelectable) {
                this.selectedState.toggledNodes.delete(node.id);
                return;
            }
            this.selectedState.toggledNodes.add(node.id);
        };
        if (params.rangeSelect && this.lastSelected) {
            if (params.nodes.length > 1) {
                throw new Error('AG Grid: cannot select multiple rows when using rangeSelect');
            }
            const node = params.nodes[0];
            const lastSelectedNode = this.rowModel.getRowNode(this.lastSelected);
            this.rowModel.getNodesInRangeForSelection(node, lastSelectedNode !== null && lastSelectedNode !== void 0 ? lastSelectedNode : null).forEach(updateNodeState);
            this.lastSelected = node.id;
            return 1;
        }
        params.nodes.forEach(updateNodeState);
        this.lastSelected = params.nodes[params.nodes.length - 1].id;
        return 1;
    }
    processNewRow(node) {
        if (this.selectedNodes[node.id]) {
            this.selectedNodes[node.id] = node;
        }
    }
    isNodeSelected(node) {
        const isToggled = this.selectedState.toggledNodes.has(node.id);
        return this.selectedState.selectAll ? !isToggled : isToggled;
    }
    getSelectedNodes() {
        if (this.selectAllUsed) {
            console.warn(`AG Grid: getSelectedNodes and getSelectedRows functions cannot be used with select all functionality with the server-side row model.
                Use \`api.getServerSideSelectionState()\` instead.`);
        }
        return Object.values(this.selectedNodes);
    }
    getSelectedRows() {
        return this.getSelectedNodes().map(node => node.data);
    }
    getSelectionCount() {
        if (this.selectedState.selectAll) {
            return -1;
        }
        return this.selectedState.toggledNodes.size;
    }
    clearOtherNodes(rowNodeToKeepSelected, source) {
        const clearedRows = this.selectedState.selectAll ? 1 : this.selectedState.toggledNodes.size - 1;
        this.selectedState = {
            selectAll: false,
            toggledNodes: new Set([rowNodeToKeepSelected.id]),
        };
        this.rowModel.forEachNode(node => {
            if (node !== rowNodeToKeepSelected) {
                node.selectThisNode(false, undefined, source);
            }
        });
        const event = {
            type: Events.EVENT_SELECTION_CHANGED,
            source,
        };
        this.eventService.dispatchEvent(event);
        return clearedRows;
    }
    isEmpty() {
        var _a;
        return !this.selectedState.selectAll && !((_a = this.selectedState.toggledNodes) === null || _a === void 0 ? void 0 : _a.size);
    }
    selectAllRowNodes(params) {
        this.selectedState = { selectAll: true, toggledNodes: new Set() };
        this.selectedNodes = {};
        this.selectAllUsed = true;
    }
    deselectAllRowNodes(params) {
        this.selectedState = { selectAll: false, toggledNodes: new Set() };
        this.selectedNodes = {};
    }
    getSelectAllState(justFiltered, justCurrentPage) {
        if (this.selectedState.selectAll) {
            if (this.selectedState.toggledNodes.size > 0) {
                return null;
            }
            return true;
        }
        if (this.selectedState.toggledNodes.size > 0) {
            return null;
        }
        return false;
    }
}
__decorate$1Y([
    Autowired('rowModel')
], DefaultStrategy.prototype, "rowModel", void 0);
__decorate$1Y([
    PostConstruct
], DefaultStrategy.prototype, "init", null);

var __decorate$1Z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$1 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
class GroupSelectsChildrenStrategy extends BeanStub {
    constructor() {
        super(...arguments);
        this.selectedState = { selectAllChildren: false, toggledNodes: new Map() };
        this.lastSelected = null;
    }
    init() {
        // if model has updated, a store may now be fully loaded to clean up indeterminate states
        this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, () => this.removeRedundantState());
        // when the grouping changes, the state no longer makes sense, so reset the state.
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.selectionService.reset('rowGroupChanged'));
    }
    getSelectedState() {
        const treeData = this.gridOptionsService.get('treeData');
        const recursivelySerializeState = (state, level, nodeId) => {
            const normalisedState = {
                nodeId,
            };
            if (treeData || level <= this.columnModel.getRowGroupColumns().length) {
                normalisedState.selectAllChildren = state.selectAllChildren;
            }
            // omit toggledNodes if empty
            if (state.toggledNodes.size) {
                const toggledNodes = [];
                state.toggledNodes.forEach((value, key) => {
                    const newState = recursivelySerializeState(value, level + 1, key);
                    toggledNodes.push(newState);
                });
                normalisedState.toggledNodes = toggledNodes;
            }
            return normalisedState;
        };
        return recursivelySerializeState(this.selectedState, 0);
    }
    setSelectedState(state) {
        const recursivelyDeserializeState = (normalisedState, parentSelected) => {
            var _a, _b;
            if (typeof normalisedState !== 'object') {
                throw new Error('AG Grid: Each provided state object must be an object.');
            }
            if ('selectAllChildren' in normalisedState && typeof normalisedState.selectAllChildren !== 'boolean') {
                throw new Error('AG Grid: `selectAllChildren` must be a boolean value or undefined.');
            }
            if ('toggledNodes' in normalisedState) {
                if (!Array.isArray(normalisedState.toggledNodes)) {
                    throw new Error('AG Grid: `toggledNodes` must be an array.');
                }
                const allHaveIds = normalisedState.toggledNodes.every(innerState => (typeof innerState === 'object' && 'nodeId' in innerState && typeof innerState.nodeId === 'string'));
                if (!allHaveIds) {
                    throw new Error('AG Grid: Every `toggledNode` requires an associated string id.');
                }
            }
            const isThisNodeSelected = (_a = normalisedState.selectAllChildren) !== null && _a !== void 0 ? _a : !parentSelected;
            const convertedChildren = (_b = normalisedState.toggledNodes) === null || _b === void 0 ? void 0 : _b.map(innerState => ([innerState.nodeId, recursivelyDeserializeState(innerState, isThisNodeSelected)]));
            const doesRedundantStateExist = convertedChildren === null || convertedChildren === void 0 ? void 0 : convertedChildren.some(([_, innerState]) => isThisNodeSelected === innerState.selectAllChildren && innerState.toggledNodes.size === 0);
            if (doesRedundantStateExist) {
                throw new Error(`
                    AG Grid: AG Grid: Row selection state could not be parsed due to invalid data. Ensure all child state has toggledNodes or does not conform with the parent rule.
                    Please rebuild the selection state and reapply it.
                `);
            }
            return {
                selectAllChildren: isThisNodeSelected,
                toggledNodes: new Map(convertedChildren),
            };
        };
        try {
            this.selectedState = recursivelyDeserializeState(state, !!state.selectAllChildren);
        }
        catch (e) {
            console.error(e.message);
        }
    }
    deleteSelectionStateFromParent(parentRoute, removedNodeIds) {
        let parentState = this.selectedState;
        const remainingRoute = [...parentRoute];
        while (parentState && remainingRoute.length) {
            parentState = parentState.toggledNodes.get(remainingRoute.pop());
        }
        // parent has no explicit state, nothing to remove
        if (!parentState) {
            return false;
        }
        let anyStateChanged = false;
        removedNodeIds.forEach(id => {
            if (parentState === null || parentState === void 0 ? void 0 : parentState.toggledNodes.delete(id)) {
                anyStateChanged = true;
            }
        });
        if (anyStateChanged) {
            this.removeRedundantState();
        }
        return anyStateChanged;
    }
    setNodesSelected(params) {
        const { nodes } = params, other = __rest$1(params, ["nodes"]);
        if (nodes.length === 0)
            return 0;
        if (params.rangeSelect) {
            if (nodes.length > 1) {
                throw new Error('AG Grid: cannot select multiple rows when using rangeSelect');
            }
            const node = nodes[0];
            const rangeOfNodes = this.rowModel.getNodesInRangeForSelection(node, this.lastSelected);
            // sort the routes by route length, high to low, this means we can do the lowest level children first
            const routes = rangeOfNodes.map(this.getRouteToNode).sort((a, b) => b.length - a.length);
            // skip routes if we've already done a descendent
            const completedRoutes = new Set();
            routes.forEach(route => {
                // skip routes if we've already selected a descendent
                if (completedRoutes.has(route[route.length - 1])) {
                    return;
                }
                route.forEach(part => completedRoutes.add(part));
                this.recursivelySelectNode(route, this.selectedState, Object.assign({ node }, other));
            });
            this.removeRedundantState();
            this.lastSelected = node;
            return 1;
        }
        params.nodes.forEach(node => {
            const idPathToNode = this.getRouteToNode(node);
            this.recursivelySelectNode(idPathToNode, this.selectedState, Object.assign(Object.assign({}, other), { node }));
        });
        this.removeRedundantState();
        this.lastSelected = params.nodes[params.nodes.length - 1];
        return 1;
    }
    isNodeSelected(node) {
        const path = this.getRouteToNode(node);
        return this.isNodePathSelected(path, this.selectedState);
    }
    isNodePathSelected([nextNode, ...nodes], state) {
        if (nodes.length === 0) {
            const isToggled = state.toggledNodes.has(nextNode.id);
            if (nextNode.hasChildren()) {
                const groupState = state.toggledNodes.get(nextNode.id);
                if (groupState && groupState.toggledNodes.size) {
                    return undefined;
                }
            }
            return state.selectAllChildren ? !isToggled : isToggled;
        }
        // if there's a deeper level, check recursively
        if (state.toggledNodes.has(nextNode.id)) {
            const nextState = state.toggledNodes.get(nextNode.id);
            if (nextState) {
                return this.isNodePathSelected(nodes, nextState);
            }
        }
        // no deeper custom state, respect the closest default
        return !!state.selectAllChildren;
    }
    getRouteToNode(node) {
        const pathToNode = [];
        let tempNode = node;
        while (tempNode.parent) {
            pathToNode.push(tempNode);
            tempNode = tempNode.parent;
        }
        return pathToNode.reverse();
    }
    removeRedundantState() {
        if (this.filterManager.isAnyFilterPresent()) {
            return;
        }
        const forEachNodeStateDepthFirst = (state = this.selectedState, thisKey, parentState) => {
            // clean up lowest level state first in order to calculate this levels state
            // from updated child state
            state.toggledNodes.forEach((value, key) => {
                forEachNodeStateDepthFirst(value, key, state);
            });
            if (thisKey) {
                const thisRow = this.rowModel.getRowNode(thisKey);
                const thisRowStore = thisRow === null || thisRow === void 0 ? void 0 : thisRow.childStore;
                const isStoreSizeKnown = thisRowStore === null || thisRowStore === void 0 ? void 0 : thisRowStore.isLastRowIndexKnown();
                if (isStoreSizeKnown) {
                    // have to check greater than, as we may have stale state still, if so all visible rows may not be
                    // toggled
                    const possibleAllNodesToggled = state.toggledNodes.size >= thisRowStore.getRowCount();
                    if (possibleAllNodesToggled) {
                        // more complex checks nested for performance
                        for (const childState of state.toggledNodes.entries()) {
                            const [key, value] = childState;
                            // if any child has toggled rows, then this row is indeterminate
                            // and the state is relevant.
                            if (value.toggledNodes.size > 0) {
                                return;
                            }
                            const rowDoesNotExist = !this.rowModel.getRowNode(key);
                            if (rowDoesNotExist) {
                                // if row doesn't exist, it's not toggled.
                                return;
                            }
                        }
                        // no indeterminate rows, and all rows are toggled, flip this row state
                        // and clear child states.
                        state.selectAllChildren = !state.selectAllChildren;
                        state.toggledNodes.clear();
                    }
                }
            }
            // if this has no toggled rows, and is identical to parent state, it's redundant and can be removed.
            const hasNoToggledRows = state.toggledNodes.size === 0;
            const isIdenticalToParent = (parentState === null || parentState === void 0 ? void 0 : parentState.selectAllChildren) === state.selectAllChildren;
            if (hasNoToggledRows && isIdenticalToParent) {
                parentState === null || parentState === void 0 ? void 0 : parentState.toggledNodes.delete(thisKey);
            }
        };
        forEachNodeStateDepthFirst();
    }
    recursivelySelectNode([nextNode, ...nodes], selectedState, params) {
        if (!nextNode) {
            return;
        }
        // if this is the last node, hard add/remove based on its selectAllChildren state
        const isLastNode = !nodes.length;
        if (isLastNode) {
            // if the node is not selectable, we should never have it in selection state
            const isNodeSelectable = nextNode.selectable;
            const doesNodeConform = selectedState.selectAllChildren === params.newValue;
            if (doesNodeConform || !isNodeSelectable) {
                selectedState.toggledNodes.delete(nextNode.id);
                return;
            }
            const newState = {
                selectAllChildren: params.newValue,
                toggledNodes: new Map(),
            };
            selectedState.toggledNodes.set(nextNode.id, newState);
            return;
        }
        const doesStateAlreadyExist = selectedState.toggledNodes.has(nextNode.id);
        const childState = doesStateAlreadyExist ? (selectedState.toggledNodes.get(nextNode.id)) : {
            selectAllChildren: selectedState.selectAllChildren,
            toggledNodes: new Map(),
        };
        if (!doesStateAlreadyExist) {
            selectedState.toggledNodes.set(nextNode.id, childState);
        }
        this.recursivelySelectNode(nodes, childState, params);
        // cleans out groups which have no toggled nodes and an equivalent default to its parent
        if (selectedState.selectAllChildren === childState.selectAllChildren && childState.toggledNodes.size === 0) {
            selectedState.toggledNodes.delete(nextNode.id);
        }
    }
    getSelectedNodes() {
        console.warn(`AG Grid: \`getSelectedNodes\` and \`getSelectedRows\` functions cannot be used with \`groupSelectsChildren\` and the server-side row model.
            Use \`api.getServerSideSelectionState()\` instead.`);
        const selectedNodes = [];
        this.rowModel.forEachNode(node => {
            if (node.isSelected()) {
                selectedNodes.push(node);
            }
        });
        return selectedNodes;
    }
    processNewRow(node) {
        // This is used for updating outdated node refs, as this model entirely uses ids it's irrelevant
    }
    getSelectedRows() {
        return this.getSelectedNodes().map(node => node.data);
    }
    getSelectionCount() {
        return -1;
    }
    isEmpty() {
        var _a;
        return !this.selectedState.selectAllChildren && !((_a = this.selectedState.toggledNodes) === null || _a === void 0 ? void 0 : _a.size);
    }
    selectAllRowNodes(params) {
        this.selectedState = { selectAllChildren: true, toggledNodes: new Map() };
    }
    deselectAllRowNodes(params) {
        this.selectedState = { selectAllChildren: false, toggledNodes: new Map() };
    }
    getSelectAllState(justFiltered, justCurrentPage) {
        if (this.selectedState.selectAllChildren) {
            if (this.selectedState.toggledNodes.size > 0) {
                return null;
            }
            return true;
        }
        if (this.selectedState.toggledNodes.size > 0) {
            return null;
        }
        return false;
    }
}
__decorate$1Z([
    Autowired('rowModel')
], GroupSelectsChildrenStrategy.prototype, "rowModel", void 0);
__decorate$1Z([
    Autowired('columnModel')
], GroupSelectsChildrenStrategy.prototype, "columnModel", void 0);
__decorate$1Z([
    Autowired('filterManager')
], GroupSelectsChildrenStrategy.prototype, "filterManager", void 0);
__decorate$1Z([
    Autowired('rowModel')
], GroupSelectsChildrenStrategy.prototype, "serverSideRowModel", void 0);
__decorate$1Z([
    Autowired('selectionService')
], GroupSelectsChildrenStrategy.prototype, "selectionService", void 0);
__decorate$1Z([
    PostConstruct
], GroupSelectsChildrenStrategy.prototype, "init", null);

var __decorate$1_ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest$2 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
let ServerSideSelectionService = class ServerSideSelectionService extends BeanStub {
    init() {
        const groupSelectsChildren = this.gridOptionsService.get('groupSelectsChildren');
        this.addManagedPropertyListener('groupSelectsChildren', (propChange) => {
            this.destroyBean(this.selectionStrategy);
            const StrategyClazz = !propChange.currentValue ? DefaultStrategy : GroupSelectsChildrenStrategy;
            this.selectionStrategy = this.createManagedBean(new StrategyClazz());
            this.shotgunResetNodeSelectionState();
            const event = {
                type: Events.EVENT_SELECTION_CHANGED,
                source: 'api',
            };
            this.eventService.dispatchEvent(event);
        });
        this.addManagedPropertyListener('rowSelection', () => this.deselectAllRowNodes({ source: 'api' }));
        const StrategyClazz = !groupSelectsChildren ? DefaultStrategy : GroupSelectsChildrenStrategy;
        this.selectionStrategy = this.createManagedBean(new StrategyClazz());
    }
    getSelectionState() {
        return this.selectionStrategy.getSelectedState();
    }
    setSelectionState(state, source) {
        if (Array.isArray(state)) {
            return;
        }
        this.selectionStrategy.setSelectedState(state);
        this.shotgunResetNodeSelectionState();
        const event = {
            type: Events.EVENT_SELECTION_CHANGED,
            source,
        };
        this.eventService.dispatchEvent(event);
    }
    setNodesSelected(params) {
        const { nodes } = params, otherParams = __rest$2(params, ["nodes"]);
        const rowSelection = this.gridOptionsService.get('rowSelection');
        if (nodes.length > 1 && rowSelection !== 'multiple') {
            console.warn(`AG Grid: cannot multi select while rowSelection='single'`);
            return 0;
        }
        if (nodes.length > 1 && params.rangeSelect) {
            console.warn(`AG Grid: cannot use range selection when multi selecting rows`);
            return 0;
        }
        const adjustedParams = Object.assign({ nodes: nodes.filter(node => node.selectable) }, otherParams);
        // if no selectable nodes, then return 0
        if (!adjustedParams.nodes.length) {
            return 0;
        }
        const changedNodes = this.selectionStrategy.setNodesSelected(adjustedParams);
        this.shotgunResetNodeSelectionState(adjustedParams.source);
        const event = {
            type: Events.EVENT_SELECTION_CHANGED,
            source: adjustedParams.source,
        };
        this.eventService.dispatchEvent(event);
        return changedNodes;
    }
    /**
     * Deletes the selection state for a set of nodes, for use after deleting nodes via
     * transaction. As this is designed for transactions, all nodes should belong to the same group.
     */
    deleteSelectionStateFromParent(storeRoute, removedNodeIds) {
        const stateChanged = this.selectionStrategy.deleteSelectionStateFromParent(storeRoute, removedNodeIds);
        if (!stateChanged) {
            return;
        }
        this.shotgunResetNodeSelectionState();
        const event = {
            type: Events.EVENT_SELECTION_CHANGED,
            source: 'api',
        };
        this.eventService.dispatchEvent(event);
    }
    shotgunResetNodeSelectionState(source) {
        this.rowModel.forEachNode(node => {
            if (node.stub) {
                return;
            }
            const isNodeSelected = this.selectionStrategy.isNodeSelected(node);
            if (isNodeSelected !== node.isSelected()) {
                node.selectThisNode(isNodeSelected, undefined, source);
            }
        });
    }
    getSelectedNodes() {
        return this.selectionStrategy.getSelectedNodes();
    }
    getSelectedRows() {
        return this.selectionStrategy.getSelectedRows();
    }
    getSelectionCount() {
        return this.selectionStrategy.getSelectionCount();
    }
    syncInRowNode(rowNode, oldNode) {
        // update any refs being held in the strategies
        this.selectionStrategy.processNewRow(rowNode);
        const isNodeSelected = this.selectionStrategy.isNodeSelected(rowNode);
        // if the node was selected but node is not selectable, we deselect the node.
        // (could be due to user applying selected state directly, or a change in selectable)
        if (isNodeSelected != false && !rowNode.selectable) {
            this.selectionStrategy.setNodesSelected({
                nodes: [rowNode],
                newValue: false,
                source: 'api',
            });
            // we need to shotgun reset here as if this was hierarchical, some group nodes
            // may be changing from indeterminate to unchecked.
            this.shotgunResetNodeSelectionState();
            const event = {
                type: Events.EVENT_SELECTION_CHANGED,
                source: 'api',
            };
            this.eventService.dispatchEvent(event);
            return;
        }
        rowNode.setSelectedInitialValue(isNodeSelected);
    }
    reset() {
        this.selectionStrategy.deselectAllRowNodes({ source: 'api' });
    }
    isEmpty() {
        return this.selectionStrategy.isEmpty();
    }
    hasNodesToSelect(justFiltered = false, justCurrentPage = false) {
        return true;
    }
    selectAllRowNodes(params) {
        if (params.justCurrentPage || params.justFiltered) {
            console.warn("AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'");
        }
        this.selectionStrategy.selectAllRowNodes(params);
        this.rowModel.forEachNode(node => {
            if (node.stub) {
                return;
            }
            node.selectThisNode(true, undefined, params.source);
        });
        const event = {
            type: Events.EVENT_SELECTION_CHANGED,
            source: params.source,
        };
        this.eventService.dispatchEvent(event);
    }
    deselectAllRowNodes(params) {
        if (params.justCurrentPage || params.justFiltered) {
            console.warn("AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'");
        }
        this.selectionStrategy.deselectAllRowNodes(params);
        this.rowModel.forEachNode(node => {
            if (node.stub) {
                return;
            }
            node.selectThisNode(false, undefined, params.source);
        });
        const event = {
            type: Events.EVENT_SELECTION_CHANGED,
            source: params.source,
        };
        this.eventService.dispatchEvent(event);
    }
    getSelectAllState(justFiltered, justCurrentPage) {
        return this.selectionStrategy.getSelectAllState(justFiltered, justCurrentPage);
    }
    // used by CSRM
    updateGroupsFromChildrenSelections(source, changedPath) {
        return false;
    }
    // used by CSRM
    getBestCostNodeSelection() {
        console.warn('AG Grid: calling gridApi.getBestCostNodeSelection() is only possible when using rowModelType=`clientSide`.');
        return undefined;
    }
    // used by CSRM
    filterFromSelection() {
        return;
    }
};
__decorate$1_([
    Autowired('rowModel')
], ServerSideSelectionService.prototype, "rowModel", void 0);
__decorate$1_([
    PostConstruct
], ServerSideSelectionService.prototype, "init", null);
ServerSideSelectionService = __decorate$1_([
    Bean('selectionService')
], ServerSideSelectionService);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$g = '31.1.1';

var __decorate$1$ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ServerSideExpansionService = class ServerSideExpansionService extends ExpansionService {
    constructor() {
        super(...arguments);
        this.queuedRowIds = new Set();
    }
    postConstruct() {
        super.postConstruct();
        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => {
            this.queuedRowIds.clear();
        });
    }
    checkOpenByDefault(rowNode) {
        if (!rowNode.isExpandable()) {
            return;
        }
        const expandRowNode = () => {
            // we do this in a timeout, so that we don't expand a row node while in the middle
            // of setting up rows, setting up rows is complex enough without another chunk of work
            // getting added to the call stack. this is also helpful as openByDefault may or may
            // not happen (so makes setting up rows more deterministic by expands never happening)
            // and also checkOpenByDefault is shard with both store types, so easier control how it
            // impacts things by keeping it in new VM turn.
            window.setTimeout(() => rowNode.setExpanded(true), 0);
        };
        if (this.queuedRowIds.has(rowNode.id)) {
            this.queuedRowIds.delete(rowNode.id);
            expandRowNode();
            return;
        }
        const userFunc = this.gridOptionsService.getCallback('isServerSideGroupOpenByDefault');
        if (!userFunc) {
            return;
        }
        const params = {
            data: rowNode.data,
            rowNode
        };
        const userFuncRes = userFunc(params);
        if (userFuncRes) {
            expandRowNode();
        }
    }
    expandRows(rowIds) {
        rowIds.forEach(rowId => {
            const rowNode = this.serverSideRowModel.getRowNode(rowId);
            if (rowNode) {
                rowNode.setExpanded(true);
            }
            else {
                this.queuedRowIds.add(rowId);
            }
        });
    }
    expandAll(value) {
        this.serverSideRowModel.expandAll(value);
    }
    onGroupExpandedOrCollapsed() {
        // do nothing
    }
};
__decorate$1$([
    Autowired('rowModel')
], ServerSideExpansionService.prototype, "serverSideRowModel", void 0);
ServerSideExpansionService = __decorate$1$([
    Bean('expansionService')
], ServerSideExpansionService);

const ServerSideRowModelModule = {
    version: VERSION$g,
    moduleName: ModuleNames.ServerSideRowModelModule,
    rowModel: 'serverSide',
    beans: [ServerSideRowModel, ExpandListener, SortListener, StoreUtils, BlockUtils, NodeManager, TransactionManager,
        FilterListener, StoreFactory, ListenerUtils, ServerSideSelectionService, ServerSideExpansionService],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

/** @param V type of value in the Set Filter */
class ClientSideValuesExtractor {
    constructor(rowModel, filterParams, createKey, caseFormat, columnModel, valueService, treeDataOrGrouping, treeData, getDataPath, groupAllowUnbalanced, addManagedListener) {
        this.rowModel = rowModel;
        this.filterParams = filterParams;
        this.createKey = createKey;
        this.caseFormat = caseFormat;
        this.columnModel = columnModel;
        this.valueService = valueService;
        this.treeDataOrGrouping = treeDataOrGrouping;
        this.treeData = treeData;
        this.getDataPath = getDataPath;
        this.groupAllowUnbalanced = groupAllowUnbalanced;
        this.addManagedListener = addManagedListener;
    }
    extractUniqueValuesAsync(predicate, existingValues) {
        return new AgPromise(resolve => {
            if (this.rowModel.isRowDataLoaded()) {
                resolve(this.extractUniqueValues(predicate, existingValues));
            }
            else {
                const destroyFunc = this.addManagedListener(Events.EVENT_ROW_COUNT_READY, () => {
                    destroyFunc === null || destroyFunc === void 0 ? void 0 : destroyFunc();
                    resolve(this.extractUniqueValues(predicate, existingValues));
                });
            }
        });
    }
    extractUniqueValues(predicate, existingValues) {
        const values = new Map();
        const existingFormattedKeys = this.extractExistingFormattedKeys(existingValues);
        const formattedKeys = new Set();
        const treeData = this.treeData && !!this.getDataPath;
        const groupedCols = this.columnModel.getRowGroupColumns();
        const addValue = (unformattedKey, value) => {
            const formattedKey = this.caseFormat(unformattedKey);
            if (!formattedKeys.has(formattedKey)) {
                formattedKeys.add(formattedKey);
                let keyToAdd = unformattedKey;
                let valueToAdd = _.makeNull(value);
                // when case insensitive, we pick the first value to use. if this is later filtered out,
                // we still want to use the original value and not one with a different case
                const existingUnformattedKey = existingFormattedKeys === null || existingFormattedKeys === void 0 ? void 0 : existingFormattedKeys.get(formattedKey);
                if (existingUnformattedKey != null) {
                    keyToAdd = existingUnformattedKey;
                    valueToAdd = existingValues.get(existingUnformattedKey);
                }
                values.set(keyToAdd, valueToAdd);
            }
        };
        this.rowModel.forEachLeafNode(node => {
            // only pull values from rows that have data. this means we skip filler group nodes.
            if (!node.data || !predicate(node)) {
                return;
            }
            if (this.treeDataOrGrouping) {
                this.addValueForTreeDataOrGrouping(node, treeData, groupedCols, addValue);
                return;
            }
            let value = this.getValue(node);
            if (this.filterParams.convertValuesToStrings) {
                // for backwards compatibility - keeping separate as it will eventually be removed
                this.addValueForConvertValuesToString(node, value, addValue);
                return;
            }
            if (value != null && Array.isArray(value)) {
                value.forEach(x => {
                    addValue(this.createKey(x, node), x);
                });
                if (value.length === 0) {
                    addValue(null, null);
                }
            }
            else {
                addValue(this.createKey(value, node), value);
            }
        });
        return values;
    }
    addValueForConvertValuesToString(node, value, addValue) {
        const key = this.createKey(value, node);
        if (key != null && Array.isArray(key)) {
            key.forEach(part => {
                const processedPart = _.toStringOrNull(_.makeNull(part));
                addValue(processedPart, processedPart);
            });
            if (key.length === 0) {
                addValue(null, null);
            }
        }
        else {
            addValue(key, key);
        }
    }
    addValueForTreeDataOrGrouping(node, treeData, groupedCols, addValue) {
        var _a;
        let dataPath;
        if (treeData) {
            if ((_a = node.childrenAfterGroup) === null || _a === void 0 ? void 0 : _a.length) {
                return;
            }
            dataPath = this.getDataPath(node.data);
        }
        else {
            dataPath = groupedCols.map(groupCol => this.valueService.getKeyForNode(groupCol, node));
            dataPath.push(this.getValue(node));
        }
        if (dataPath) {
            dataPath = dataPath.map(treeKey => _.toStringOrNull(_.makeNull(treeKey)));
        }
        if (!treeData && this.groupAllowUnbalanced && (dataPath === null || dataPath === void 0 ? void 0 : dataPath.some(treeKey => treeKey == null))) {
            dataPath = dataPath.filter(treeKey => treeKey != null);
        }
        addValue(this.createKey(dataPath), dataPath);
    }
    getValue(node) {
        return this.filterParams.getValue(node);
    }
    extractExistingFormattedKeys(existingValues) {
        if (!existingValues) {
            return null;
        }
        const existingFormattedKeys = new Map();
        existingValues.forEach((_value, key) => {
            existingFormattedKeys.set(this.caseFormat(key), key);
        });
        return existingFormattedKeys;
    }
}

class SetFilterDisplayValue {
}
SetFilterDisplayValue.SELECT_ALL = '__AG_SELECT_ALL__';
SetFilterDisplayValue.ADD_SELECTION_TO_FILTER = '__AG_ADD_SELECTION_TO_FILTER__';

class FlatSetDisplayValueModel {
    constructor(valueFormatterService, valueFormatter, formatter, column) {
        this.valueFormatterService = valueFormatterService;
        this.valueFormatter = valueFormatter;
        this.formatter = formatter;
        this.column = column;
        /** All keys that are currently displayed, after the mini-filter has been applied. */
        this.displayedKeys = [];
    }
    updateDisplayedValuesToAllAvailable(_getValue, _allKeys, availableKeys) {
        this.displayedKeys = Array.from(availableKeys);
    }
    updateDisplayedValuesToMatchMiniFilter(getValue, _allKeys, availableKeys, matchesFilter, nullMatchesFilter) {
        this.displayedKeys = [];
        for (let key of availableKeys) {
            if (key == null) {
                if (nullMatchesFilter) {
                    this.displayedKeys.push(key);
                }
            }
            else {
                const value = getValue(key);
                const valueFormatterValue = this.valueFormatterService.formatValue(this.column, null, value, this.valueFormatter, false);
                const textFormatterValue = this.formatter(valueFormatterValue);
                if (matchesFilter(textFormatterValue)) {
                    this.displayedKeys.push(key);
                }
            }
        }
    }
    getDisplayedValueCount() {
        return this.displayedKeys.length;
    }
    getDisplayedItem(index) {
        return this.displayedKeys[index];
    }
    getSelectAllItem() {
        return SetFilterDisplayValue.SELECT_ALL;
    }
    getAddSelectionToFilterItem() {
        return SetFilterDisplayValue.ADD_SELECTION_TO_FILTER;
    }
    getDisplayedKeys() {
        return this.displayedKeys;
    }
    forEachDisplayedKey(func) {
        this.displayedKeys.forEach(func);
    }
    someDisplayedKey(func) {
        return this.displayedKeys.some(func);
    }
    hasGroups() {
        return false;
    }
    refresh() {
        // not used
    }
}

class TreeSetDisplayValueModel {
    constructor(formatter, treeListPathGetter, treeListFormatter, treeDataOrGrouping) {
        this.formatter = formatter;
        this.treeListPathGetter = treeListPathGetter;
        this.treeListFormatter = treeListFormatter;
        this.treeDataOrGrouping = treeDataOrGrouping;
        /** all displayed items in a tree structure */
        this.allDisplayedItemsTree = [];
        /** all displayed items flattened and filtered */
        this.activeDisplayedItemsFlat = [];
        this.selectAllItem = {
            depth: 0,
            filterPasses: true,
            available: true,
            treeKey: SetFilterDisplayValue.SELECT_ALL,
            children: this.allDisplayedItemsTree,
            expanded: true,
            key: SetFilterDisplayValue.SELECT_ALL,
            parentTreeKeys: []
        };
        this.addSelectionToFilterItem = {
            depth: 0,
            filterPasses: true,
            available: true,
            treeKey: SetFilterDisplayValue.ADD_SELECTION_TO_FILTER,
            expanded: true,
            key: SetFilterDisplayValue.ADD_SELECTION_TO_FILTER,
            parentTreeKeys: []
        };
    }
    ;
    updateDisplayedValuesToAllAvailable(getValue, allKeys, availableKeys, source) {
        if (source === 'reload') {
            this.generateItemTree(getValue, allKeys, availableKeys);
        }
        else if (source === 'otherFilter') {
            this.updateAvailable(availableKeys);
            this.updateExpandAll();
        }
        else if (source === 'miniFilter') {
            this.resetFilter();
            this.updateExpandAll();
        }
        this.flattenItems();
    }
    updateDisplayedValuesToMatchMiniFilter(getValue, allKeys, availableKeys, matchesFilter, nullMatchesFilter, source) {
        if (source === 'reload') {
            this.generateItemTree(getValue, allKeys, availableKeys);
        }
        else if (source === 'otherFilter') {
            this.updateAvailable(availableKeys);
        }
        this.updateFilter(matchesFilter, nullMatchesFilter);
        this.updateExpandAll();
        this.flattenItems();
    }
    generateItemTree(getValue, allKeys, availableKeys) {
        var _a;
        this.allDisplayedItemsTree = [];
        this.groupsExist = false;
        const treeListPathGetter = this.getTreeListPathGetter(getValue, availableKeys);
        for (let key of allKeys) {
            const value = getValue(key);
            const dataPath = (_a = treeListPathGetter(value)) !== null && _a !== void 0 ? _a : [null];
            if (dataPath.length > 1) {
                this.groupsExist = true;
            }
            const available = availableKeys.has(key);
            let children = this.allDisplayedItemsTree;
            let item;
            let parentTreeKeys = [];
            dataPath.forEach((treeKey, depth) => {
                if (!children) {
                    children = [];
                    item.children = children;
                }
                item = children.find(child => { var _a; return ((_a = child.treeKey) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === (treeKey === null || treeKey === void 0 ? void 0 : treeKey.toUpperCase()); });
                if (!item) {
                    item = { treeKey, depth, filterPasses: true, expanded: false, available, parentTreeKeys };
                    if (depth === dataPath.length - 1) {
                        item.key = key;
                    }
                    children.push(item);
                }
                children = item.children;
                parentTreeKeys = [...parentTreeKeys, treeKey];
            });
        }
        // update the parent availability based on the children
        this.updateAvailable(availableKeys);
        this.selectAllItem.children = this.allDisplayedItemsTree;
        this.selectAllItem.expanded = false;
    }
    getTreeListPathGetter(getValue, availableKeys) {
        if (this.treeListPathGetter) {
            return this.treeListPathGetter;
        }
        if (this.treeDataOrGrouping) {
            return value => value;
        }
        // infer from data
        let isDate = false;
        for (const availableKey of availableKeys) {
            // find the first non-null value
            const value = getValue(availableKey);
            if (value instanceof Date) {
                isDate = true;
                break;
            }
            else if (value != null) {
                break;
            }
        }
        if (isDate) {
            return TreeSetDisplayValueModel.DATE_TREE_LIST_PATH_GETTER;
        }
        _.warnOnce('property treeList=true for Set Filter params, but you did not provide a treeListPathGetter or values of type Date.');
        return value => [String(value)];
    }
    flattenItems() {
        this.activeDisplayedItemsFlat = [];
        const recursivelyFlattenDisplayedItems = (items) => {
            items.forEach(item => {
                if (!item.filterPasses || !item.available) {
                    return;
                }
                this.activeDisplayedItemsFlat.push(item);
                if (item.children && item.expanded) {
                    recursivelyFlattenDisplayedItems(item.children);
                }
            });
        };
        recursivelyFlattenDisplayedItems(this.allDisplayedItemsTree);
    }
    resetFilter() {
        const recursiveFilterReset = (item) => {
            if (item.children) {
                item.children.forEach(child => {
                    recursiveFilterReset(child);
                });
            }
            item.filterPasses = true;
        };
        this.allDisplayedItemsTree.forEach(item => recursiveFilterReset(item));
    }
    updateFilter(matchesFilter, nullMatchesFilter) {
        const passesFilter = (item) => {
            if (!item.available) {
                return false;
            }
            if (item.treeKey == null) {
                return nullMatchesFilter;
            }
            return matchesFilter(this.formatter(this.treeListFormatter ? this.treeListFormatter(item.treeKey, item.depth, item.parentTreeKeys) : item.treeKey));
        };
        this.allDisplayedItemsTree.forEach(item => this.recursiveItemCheck(item, false, passesFilter, 'filterPasses'));
    }
    getDisplayedValueCount() {
        return this.activeDisplayedItemsFlat.length;
    }
    getDisplayedItem(index) {
        return this.activeDisplayedItemsFlat[index];
    }
    getSelectAllItem() {
        return this.selectAllItem;
    }
    getAddSelectionToFilterItem() {
        return this.addSelectionToFilterItem;
    }
    getDisplayedKeys() {
        const displayedKeys = [];
        this.forEachDisplayedKey((key) => displayedKeys.push(key));
        return displayedKeys;
    }
    forEachDisplayedKey(func) {
        const recursiveForEachItem = (item, topParentExpanded) => {
            if (item.children) {
                if (!item.expanded || !topParentExpanded) {
                    // if the parent is not expanded, we need to iterate the entire tree
                    item.children.forEach(child => {
                        if (child.filterPasses) {
                            recursiveForEachItem(child, false);
                        }
                    });
                }
            }
            else {
                func(item.key);
            }
        };
        this.activeDisplayedItemsFlat.forEach(item => recursiveForEachItem(item, true));
    }
    someDisplayedKey(func) {
        const recursiveSomeItem = (item, topParentExpanded) => {
            if (item.children) {
                if (!item.expanded || !topParentExpanded) {
                    // if the parent is not expanded, we need to iterate the entire tree
                    return item.children.some(child => {
                        if (child.filterPasses) {
                            return recursiveSomeItem(child, false);
                        }
                        return false;
                    });
                }
            }
            else {
                return func(item.key);
            }
            return false;
        };
        return this.activeDisplayedItemsFlat.some(item => recursiveSomeItem(item, true));
    }
    hasGroups() {
        return this.groupsExist;
    }
    refresh() {
        this.updateExpandAll();
        this.flattenItems();
    }
    updateExpandAll() {
        const recursiveExpansionCheck = (items, someTrue, someFalse) => {
            for (const item of items) {
                if (!item.filterPasses || !item.available || !item.children) {
                    continue;
                }
                // indeterminate state only exists for expand all, so don't need to check for the current item
                someTrue = someTrue || !!item.expanded;
                someFalse = someFalse || !item.expanded;
                if (someTrue && someFalse) {
                    // already indeterminate. No need to check the children
                    return undefined;
                }
                const childExpanded = recursiveExpansionCheck(item.children, someTrue, someFalse);
                if (childExpanded === undefined) {
                    return undefined;
                }
                else if (childExpanded) {
                    someTrue = true;
                }
                else {
                    someFalse = true;
                }
            }
            return someTrue && someFalse ? undefined : someTrue;
        };
        const item = this.getSelectAllItem();
        item.expanded = recursiveExpansionCheck(item.children, false, false);
    }
    recursiveItemCheck(item, parentPasses, checkFunction, itemProp) {
        let atLeastOneChildPassed = false;
        if (item.children) {
            item.children.forEach(child => {
                const childPasses = this.recursiveItemCheck(child, parentPasses || checkFunction(item), checkFunction, itemProp);
                atLeastOneChildPassed = atLeastOneChildPassed || childPasses;
            });
        }
        const itemPasses = parentPasses || atLeastOneChildPassed || checkFunction(item);
        item[itemProp] = itemPasses;
        return itemPasses;
    }
    updateAvailable(availableKeys) {
        const isAvailable = (item) => availableKeys.has(item.key);
        this.allDisplayedItemsTree.forEach(item => this.recursiveItemCheck(item, false, isAvailable, 'available'));
    }
}
TreeSetDisplayValueModel.DATE_TREE_LIST_PATH_GETTER = (date) => date ? [String(date.getFullYear()), String(date.getMonth() + 1), String(date.getDate())] : null;

class SetValueModelFilteringKeys {
    constructor({ caseFormat }) {
        // To make the filtering fast, we store the keys in a Set rather than using the default array.
        this.filteringKeys = null;
        // This attribute contains keys that are actually used for filtering.
        // These keys take into account case sensitivity:
        // - When filtering is case-insensitive, all filtering keys are converted to upper case and stored here.
        // - When filtering is case-sensitive, this is the same as filteringKeys.
        this.filteringKeysCaseFormatted = null;
        this.hasNoAppliedFilteringKeys = false;
        this.caseFormat = caseFormat;
    }
    allFilteringKeys() {
        return this.filteringKeys;
    }
    allFilteringKeysCaseFormatted() {
        return this.filteringKeysCaseFormatted;
    }
    noAppliedFilteringKeys() {
        return this.hasNoAppliedFilteringKeys;
    }
    setFilteringKeys(filteringKeys) {
        this.filteringKeys = new Set(filteringKeys);
        this.hasNoAppliedFilteringKeys = !this.filteringKeys || this.filteringKeys.size === 0;
        this.filteringKeysCaseFormatted = new Set();
        this.filteringKeys.forEach(key => this.filteringKeysCaseFormatted.add(this.caseFormat(key)));
    }
    addFilteringKey(key) {
        if (this.filteringKeys == null) {
            this.filteringKeys = new Set();
            this.filteringKeysCaseFormatted = new Set();
        }
        this.filteringKeys.add(key);
        this.filteringKeysCaseFormatted.add(this.caseFormat(key));
        if (this.hasNoAppliedFilteringKeys) {
            this.hasNoAppliedFilteringKeys = false;
        }
    }
    hasCaseFormattedFilteringKey(key) {
        return this.filteringKeysCaseFormatted.has(this.caseFormat(key));
    }
    hasFilteringKey(key) {
        return this.filteringKeys.has(key);
    }
    reset() {
        this.filteringKeys = null;
        this.filteringKeysCaseFormatted = null;
        this.hasNoAppliedFilteringKeys = false;
    }
}

var SetFilterModelValuesType;
(function (SetFilterModelValuesType) {
    SetFilterModelValuesType[SetFilterModelValuesType["PROVIDED_LIST"] = 0] = "PROVIDED_LIST";
    SetFilterModelValuesType[SetFilterModelValuesType["PROVIDED_CALLBACK"] = 1] = "PROVIDED_CALLBACK";
    SetFilterModelValuesType[SetFilterModelValuesType["TAKEN_FROM_GRID_VALUES"] = 2] = "TAKEN_FROM_GRID_VALUES";
})(SetFilterModelValuesType || (SetFilterModelValuesType = {}));
/** @param V type of value in the Set Filter */
class SetValueModel {
    constructor(params) {
        var _a;
        this.localEventService = new EventService();
        this.miniFilterText = null;
        /** When true, in excelMode = 'windows', it adds previously selected filter items to newly checked filter selection */
        this.addCurrentSelectionToFilter = false;
        /** Values provided to the filter for use. */
        this.providedValues = null;
        /** All possible values for the filter, sorted if required. */
        this.allValues = new Map();
        /** Remaining keys when filters from other columns have been applied. */
        this.availableKeys = new Set();
        /** Keys that have been selected for this filter. */
        this.selectedKeys = new Set();
        this.initialised = false;
        const { usingComplexObjects, columnModel, valueService, treeDataTreeList, groupingTreeList, filterParams, gridOptionsService, valueFormatterService, valueFormatter, addManagedListener } = params;
        const { column, colDef, textFormatter, doesRowPassOtherFilter, suppressSorting, comparator, rowModel, values, caseSensitive, convertValuesToStrings, treeList, treeListPathGetter, treeListFormatter } = filterParams;
        this.filterParams = filterParams;
        this.gridOptionsService = gridOptionsService;
        this.setIsLoading = params.setIsLoading;
        this.translate = params.translate;
        this.caseFormat = params.caseFormat;
        this.createKey = params.createKey;
        this.usingComplexObjects = !!params.usingComplexObjects;
        this.formatter = textFormatter || TextFilter.DEFAULT_FORMATTER;
        this.doesRowPassOtherFilters = doesRowPassOtherFilter;
        this.suppressSorting = suppressSorting || false;
        this.convertValuesToStrings = !!convertValuesToStrings;
        this.filteringKeys = new SetValueModelFilteringKeys({ caseFormat: this.caseFormat });
        const keyComparator = comparator !== null && comparator !== void 0 ? comparator : colDef.comparator;
        const treeDataOrGrouping = !!treeDataTreeList || !!groupingTreeList;
        // If using complex objects and a comparator is provided, sort by values, otherwise need to sort by the string keys.
        // Also if tree data, grouping, or date with tree list, then need to do value sort
        this.compareByValue = !!((usingComplexObjects && keyComparator) || treeDataOrGrouping || (treeList && !treeListPathGetter));
        if (treeDataOrGrouping && !keyComparator) {
            this.entryComparator = this.createTreeDataOrGroupingComparator();
        }
        else if (treeList && !treeListPathGetter && !keyComparator) {
            this.entryComparator = ([_aKey, aValue], [_bKey, bValue]) => _.defaultComparator(aValue, bValue);
        }
        else {
            this.entryComparator = ([_aKey, aValue], [_bKey, bValue]) => keyComparator(aValue, bValue);
        }
        this.keyComparator = (_a = keyComparator) !== null && _a !== void 0 ? _a : _.defaultComparator;
        this.caseSensitive = !!caseSensitive;
        const getDataPath = gridOptionsService.get('getDataPath');
        const groupAllowUnbalanced = gridOptionsService.get('groupAllowUnbalanced');
        if (rowModel.getType() === 'clientSide') {
            this.clientSideValuesExtractor = new ClientSideValuesExtractor(rowModel, this.filterParams, this.createKey, this.caseFormat, columnModel, valueService, treeDataOrGrouping, !!treeDataTreeList, getDataPath, groupAllowUnbalanced, addManagedListener);
        }
        if (values == null) {
            this.valuesType = SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES;
        }
        else {
            this.valuesType = Array.isArray(values) ?
                SetFilterModelValuesType.PROVIDED_LIST :
                SetFilterModelValuesType.PROVIDED_CALLBACK;
            this.providedValues = values;
        }
        this.displayValueModel = treeList ? new TreeSetDisplayValueModel(this.formatter, treeListPathGetter, treeListFormatter, treeDataTreeList || groupingTreeList) : new FlatSetDisplayValueModel(valueFormatterService, valueFormatter, this.formatter, column);
        this.updateAllValues().then(updatedKeys => this.resetSelectionState(updatedKeys || []));
    }
    addEventListener(eventType, listener, async) {
        this.localEventService.addEventListener(eventType, listener, async);
    }
    removeEventListener(eventType, listener, async) {
        this.localEventService.removeEventListener(eventType, listener, async);
    }
    updateOnParamsChange(filterParams) {
        return new AgPromise(resolve => {
            const { values, textFormatter, suppressSorting, } = filterParams;
            const currentProvidedValues = this.providedValues;
            const currentSuppressSorting = this.suppressSorting;
            this.filterParams = filterParams;
            this.formatter = textFormatter || TextFilter.DEFAULT_FORMATTER;
            this.suppressSorting = suppressSorting || false;
            this.providedValues = values !== null && values !== void 0 ? values : null;
            // Rebuild values when values or their sort order changes
            if (this.providedValues !== currentProvidedValues || this.suppressSorting !== currentSuppressSorting) {
                if (!values || values.length === 0) {
                    this.valuesType = SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES;
                    this.providedValues = null;
                }
                else {
                    const isArrayOfCallback = Array.isArray(values) && values.length > 0 && typeof values[0] === 'function';
                    this.valuesType = isArrayOfCallback ?
                        SetFilterModelValuesType.PROVIDED_CALLBACK :
                        SetFilterModelValuesType.PROVIDED_LIST;
                }
                const currentModel = this.getModel();
                this.updateAllValues().then((updatedKeys) => {
                    this.setModel(currentModel).then(() => resolve());
                });
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Re-fetches the values used in the filter from the value source.
     * If keepSelection is false, the filter selection will be reset to everything selected,
     * otherwise the current selection will be preserved.
     */
    refreshValues() {
        return new AgPromise(resolve => {
            // don't get the model until values are resolved, as there could be queued setModel calls
            this.allValuesPromise.then(() => {
                const currentModel = this.getModel();
                this.updateAllValues();
                // ensure model is updated for new values
                this.setModel(currentModel).then(() => resolve());
            });
        });
    }
    /**
     * Overrides the current values being used for the set filter.
     * If keepSelection is false, the filter selection will be reset to everything selected,
     * otherwise the current selection will be preserved.
     */
    overrideValues(valuesToUse) {
        return new AgPromise(resolve => {
            // wait for any existing values to be populated before overriding
            this.allValuesPromise.then(() => {
                this.valuesType = SetFilterModelValuesType.PROVIDED_LIST;
                this.providedValues = valuesToUse;
                this.refreshValues().then(() => resolve());
            });
        });
    }
    /** @return has anything been updated */
    refreshAfterAnyFilterChanged() {
        if (this.showAvailableOnly()) {
            return this.allValuesPromise.then(keys => {
                this.updateAvailableKeys(keys !== null && keys !== void 0 ? keys : [], 'otherFilter');
                return true;
            });
        }
        return AgPromise.resolve(false);
    }
    isInitialised() {
        return this.initialised;
    }
    updateAllValues() {
        this.allValuesPromise = new AgPromise(resolve => {
            switch (this.valuesType) {
                case SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES:
                    this.getValuesFromRowsAsync(false).then(values => resolve(this.processAllValues(values)));
                    break;
                case SetFilterModelValuesType.PROVIDED_LIST: {
                    resolve(this.processAllValues(this.uniqueValues(this.validateProvidedValues(this.providedValues))));
                    break;
                }
                case SetFilterModelValuesType.PROVIDED_CALLBACK: {
                    this.setIsLoading(true);
                    const callback = this.providedValues;
                    const { column, colDef } = this.filterParams;
                    const params = this.gridOptionsService.addGridCommonParams({
                        success: values => {
                            this.setIsLoading(false);
                            resolve(this.processAllValues(this.uniqueValues(this.validateProvidedValues(values))));
                        },
                        colDef,
                        column
                    });
                    window.setTimeout(() => callback(params), 0);
                    break;
                }
                default:
                    throw new Error('Unrecognised valuesType');
            }
        });
        this.allValuesPromise.then(values => this.updateAvailableKeys(values || [], 'reload')).then(() => this.initialised = true);
        return this.allValuesPromise;
    }
    processAllValues(values) {
        const sortedKeys = this.sortKeys(values);
        this.allValues = values !== null && values !== void 0 ? values : new Map();
        return sortedKeys;
    }
    validateProvidedValues(values) {
        if (this.usingComplexObjects && (values === null || values === void 0 ? void 0 : values.length)) {
            const firstValue = values[0];
            if (firstValue && typeof firstValue !== 'object' && typeof firstValue !== 'function') {
                const firstKey = this.createKey(firstValue);
                if (firstKey == null) {
                    _.warnOnce('Set Filter Key Creator is returning null for provided values and provided values are primitives. Please provide complex objects or set convertValuesToStrings=true in the filterParams. See https://www.ag-grid.com/javascript-data-grid/filter-set-filter-list/#filter-value-types');
                }
                else {
                    _.warnOnce('Set Filter has a Key Creator, but provided values are primitives. Did you mean to provide complex objects or enable convertValuesToStrings?');
                }
            }
        }
        return values;
    }
    setValuesType(value) {
        this.valuesType = value;
    }
    getValuesType() {
        return this.valuesType;
    }
    isKeyAvailable(key) {
        return this.availableKeys.has(key);
    }
    showAvailableOnly() {
        return this.valuesType === SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES;
    }
    updateAvailableKeys(allKeys, source) {
        const availableKeys = this.showAvailableOnly() ? this.sortKeys(this.getValuesFromRows(true)) : allKeys;
        this.availableKeys = new Set(availableKeys);
        this.localEventService.dispatchEvent({ type: SetValueModel.EVENT_AVAILABLE_VALUES_CHANGED });
        this.updateDisplayedValues(source, allKeys);
    }
    sortKeys(nullableValues) {
        const values = nullableValues !== null && nullableValues !== void 0 ? nullableValues : new Map();
        if (this.suppressSorting) {
            return Array.from(values.keys());
        }
        let sortedKeys;
        if (this.compareByValue) {
            sortedKeys = Array.from(values.entries()).sort(this.entryComparator).map(([key]) => key);
        }
        else {
            sortedKeys = Array.from(values.keys()).sort(this.keyComparator);
        }
        if (this.filterParams.excelMode && values.has(null)) {
            // ensure the blank value always appears last
            sortedKeys = sortedKeys.filter(v => v != null);
            sortedKeys.push(null);
        }
        return sortedKeys;
    }
    getParamsForValuesFromRows(removeUnavailableValues = false) {
        if (!this.clientSideValuesExtractor) {
            _.doOnce(() => {
                console.error('AG Grid: Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values');
            }, 'setFilterValueNotCSRM');
            return null;
        }
        const predicate = (node) => (!removeUnavailableValues || this.doesRowPassOtherFilters(node));
        const existingValues = removeUnavailableValues && !this.caseSensitive ? this.allValues : undefined;
        return { predicate, existingValues };
    }
    getValuesFromRows(removeUnavailableValues = false) {
        const params = this.getParamsForValuesFromRows(removeUnavailableValues);
        if (!params) {
            return null;
        }
        return this.clientSideValuesExtractor.extractUniqueValues(params.predicate, params.existingValues);
    }
    getValuesFromRowsAsync(removeUnavailableValues = false) {
        const params = this.getParamsForValuesFromRows(removeUnavailableValues);
        if (!params) {
            return AgPromise.resolve(null);
        }
        return this.clientSideValuesExtractor.extractUniqueValuesAsync(params.predicate, params.existingValues);
    }
    /** Sets mini filter value. Returns true if it changed from last value, otherwise false. */
    setMiniFilter(value) {
        value = _.makeNull(value);
        if (this.miniFilterText === value) {
            //do nothing if filter has not changed
            return false;
        }
        if (value === null) {
            // Reset 'Add current selection to filter' checkbox when clearing mini filter
            this.setAddCurrentSelectionToFilter(false);
        }
        this.miniFilterText = value;
        this.updateDisplayedValues('miniFilter');
        return true;
    }
    getMiniFilter() {
        return this.miniFilterText;
    }
    updateDisplayedValues(source, allKeys) {
        if (source === 'expansion') {
            this.displayValueModel.refresh();
            return;
        }
        // if no filter, just display all available values
        if (this.miniFilterText == null) {
            this.displayValueModel.updateDisplayedValuesToAllAvailable((key) => this.getValue(key), allKeys, this.availableKeys, source);
            return;
        }
        // if filter present, we filter down the list
        // to allow for case insensitive searches, upper-case both filter text and value
        const formattedFilterText = this.caseFormat(this.formatter(this.miniFilterText) || '');
        const matchesFilter = (valueToCheck) => valueToCheck != null && this.caseFormat(valueToCheck).indexOf(formattedFilterText) >= 0;
        const nullMatchesFilter = !!this.filterParams.excelMode && matchesFilter(this.translate('blanks'));
        this.displayValueModel.updateDisplayedValuesToMatchMiniFilter((key) => this.getValue(key), allKeys, this.availableKeys, matchesFilter, nullMatchesFilter, source);
    }
    getDisplayedValueCount() {
        return this.displayValueModel.getDisplayedValueCount();
    }
    getDisplayedItem(index) {
        return this.displayValueModel.getDisplayedItem(index);
    }
    getSelectAllItem() {
        return this.displayValueModel.getSelectAllItem();
    }
    getAddSelectionToFilterItem() {
        return this.displayValueModel.getAddSelectionToFilterItem();
    }
    hasSelections() {
        return this.filterParams.defaultToNothingSelected ?
            this.selectedKeys.size > 0 :
            this.allValues.size !== this.selectedKeys.size;
    }
    getKeys() {
        return Array.from(this.allValues.keys());
    }
    getValues() {
        return Array.from(this.allValues.values());
    }
    getValue(key) {
        return this.allValues.get(key);
    }
    setAddCurrentSelectionToFilter(value) {
        this.addCurrentSelectionToFilter = value;
    }
    isInWindowsExcelMode() {
        return this.filterParams.excelMode === 'windows';
    }
    isAddCurrentSelectionToFilterChecked() {
        return this.isInWindowsExcelMode() && this.addCurrentSelectionToFilter;
    }
    showAddCurrentSelectionToFilter() {
        // We only show the 'Add current selection to filter' option
        // when excel mode is enabled with 'windows' mode
        // and when the users types a value in the mini filter.
        return (this.isInWindowsExcelMode()
            && _.exists(this.miniFilterText)
            && this.miniFilterText.length > 0);
    }
    selectAllMatchingMiniFilter(clearExistingSelection = false) {
        if (this.miniFilterText == null) {
            // ensure everything is selected
            this.selectedKeys = new Set(this.allValues.keys());
        }
        else {
            // ensure everything that matches the mini filter is selected
            if (clearExistingSelection) {
                this.selectedKeys.clear();
            }
            this.displayValueModel.forEachDisplayedKey(key => this.selectedKeys.add(key));
        }
    }
    deselectAllMatchingMiniFilter() {
        if (this.miniFilterText == null) {
            // ensure everything is deselected
            this.selectedKeys.clear();
        }
        else {
            // ensure everything that matches the mini filter is deselected
            this.displayValueModel.forEachDisplayedKey(key => this.selectedKeys.delete(key));
        }
    }
    selectKey(key) {
        this.selectedKeys.add(key);
    }
    deselectKey(key) {
        if (this.filterParams.excelMode && this.isEverythingVisibleSelected()) {
            // ensure we're starting from the correct "everything selected" state
            this.resetSelectionState(this.displayValueModel.getDisplayedKeys());
        }
        this.selectedKeys.delete(key);
    }
    isKeySelected(key) {
        return this.selectedKeys.has(key);
    }
    isEverythingVisibleSelected() {
        return !this.displayValueModel.someDisplayedKey(it => !this.isKeySelected(it));
    }
    isNothingVisibleSelected() {
        return !this.displayValueModel.someDisplayedKey(it => this.isKeySelected(it));
    }
    getModel() {
        if (!this.hasSelections()) {
            return null;
        }
        // When excelMode = 'windows' and the user has ticked 'Add current selection to filter'
        // the filtering keys can be different from the selected keys, and they should be included
        // in the model.
        const filteringKeys = this.isAddCurrentSelectionToFilterChecked()
            ? this.filteringKeys.allFilteringKeys()
            : null;
        if (filteringKeys && filteringKeys.size > 0) {
            if (this.selectedKeys) {
                // When existing filtering keys are present along with selected keys,
                // we combine them and return the result.
                // We use a set structure to avoid duplicates
                const modelKeys = new Set([
                    ...Array.from(filteringKeys),
                    ...Array.from(this.selectedKeys).filter(key => !filteringKeys.has(key)),
                ]);
                return Array.from(modelKeys);
            }
            return Array.from(filteringKeys);
        }
        // No extra filtering keys are present - so just return the selected keys
        return Array.from(this.selectedKeys);
    }
    setModel(model) {
        return this.allValuesPromise.then(keys => {
            if (model == null) {
                this.resetSelectionState(keys !== null && keys !== void 0 ? keys : []);
            }
            else {
                // select all values from the model that exist in the filter
                this.selectedKeys.clear();
                const existingFormattedKeys = new Map();
                this.allValues.forEach((_value, key) => {
                    existingFormattedKeys.set(this.caseFormat(key), key);
                });
                model.forEach(unformattedKey => {
                    const formattedKey = this.caseFormat(_.makeNull(unformattedKey));
                    const existingUnformattedKey = existingFormattedKeys.get(formattedKey);
                    if (existingUnformattedKey !== undefined) {
                        this.selectKey(existingUnformattedKey);
                    }
                });
            }
        });
    }
    uniqueValues(values) {
        const uniqueValues = new Map();
        const formattedKeys = new Set();
        (values !== null && values !== void 0 ? values : []).forEach(value => {
            const valueToUse = _.makeNull(value);
            const unformattedKey = this.convertAndGetKey(valueToUse);
            const formattedKey = this.caseFormat(unformattedKey);
            if (!formattedKeys.has(formattedKey)) {
                formattedKeys.add(formattedKey);
                uniqueValues.set(unformattedKey, valueToUse);
            }
        });
        return uniqueValues;
    }
    convertAndGetKey(value) {
        return this.convertValuesToStrings ? value : this.createKey(value);
    }
    resetSelectionState(keys) {
        if (this.filterParams.defaultToNothingSelected) {
            this.selectedKeys.clear();
        }
        else {
            this.selectedKeys = new Set(keys);
        }
    }
    hasGroups() {
        return this.displayValueModel.hasGroups();
    }
    createTreeDataOrGroupingComparator() {
        return ([_aKey, aValue], [_bKey, bValue]) => {
            if (aValue == null) {
                return bValue == null ? 0 : -1;
            }
            else if (bValue == null) {
                return 1;
            }
            for (let i = 0; i < aValue.length; i++) {
                if (i >= bValue.length) {
                    return 1;
                }
                const diff = _.defaultComparator(aValue[i], bValue[i]);
                if (diff !== 0) {
                    return diff;
                }
            }
            return 0;
        };
    }
    setAppliedModelKeys(appliedModelKeys) {
        this.filteringKeys.setFilteringKeys(appliedModelKeys);
    }
    addToAppliedModelKeys(appliedModelKey) {
        this.filteringKeys.addFilteringKey(appliedModelKey);
    }
    getAppliedModelKeys() {
        return this.filteringKeys.allFilteringKeys();
    }
    getCaseFormattedAppliedModelKeys() {
        return this.filteringKeys.allFilteringKeysCaseFormatted();
    }
    hasAppliedModelKey(appliedModelKey) {
        return this.filteringKeys.hasCaseFormattedFilteringKey(appliedModelKey);
    }
    hasAnyAppliedModelKey() {
        return !this.filteringKeys.noAppliedFilteringKeys();
    }
}
SetValueModel.EVENT_AVAILABLE_VALUES_CHANGED = 'availableValuesChanged';

var __decorate$20 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/** @param V type of value in the Set Filter */
class SetFilterListItem extends Component {
    constructor(params) {
        var _a;
        super(params.isGroup ? SetFilterListItem.GROUP_TEMPLATE : SetFilterListItem.TEMPLATE);
        this.focusWrapper = params.focusWrapper;
        this.value = params.value;
        this.params = params.params;
        this.translate = params.translate;
        this.valueFormatter = params.valueFormatter;
        this.item = params.item;
        this.isSelected = params.isSelected;
        this.isTree = params.isTree;
        this.depth = (_a = params.depth) !== null && _a !== void 0 ? _a : 0;
        this.isGroup = params.isGroup;
        this.groupsExist = params.groupsExist;
        this.isExpanded = params.isExpanded;
        this.hasIndeterminateExpandState = params.hasIndeterminateExpandState;
    }
    init() {
        this.addDestroyFunc(() => { var _a; return (_a = this.destroyCellRendererComponent) === null || _a === void 0 ? void 0 : _a.call(this); });
        this.render();
        this.eCheckbox
            .setLabelEllipsis(true)
            .setValue(this.isSelected, true)
            .setDisabled(!!this.params.readOnly)
            .getInputElement().setAttribute('tabindex', '-1');
        this.refreshVariableAriaLabels();
        if (this.isTree) {
            if (this.depth > 0) {
                this.addCssClass('ag-set-filter-indent-' + this.depth);
            }
            if (this.isGroup) {
                this.setupExpansion();
            }
            else {
                if (this.groupsExist) {
                    this.addCssClass('ag-set-filter-add-group-indent');
                }
            }
            _.setAriaLevel(this.getAriaElement(), this.depth + 1);
        }
        this.refreshAriaChecked();
        if (!!this.params.readOnly) {
            // Don't add event listeners if we're read-only.
            return;
        }
        this.eCheckbox.onValueChange((value) => this.onCheckboxChanged(!!value));
    }
    getFocusableElement() {
        return this.focusWrapper;
    }
    setupExpansion() {
        this.eGroupClosedIcon.appendChild(_.createIcon('setFilterGroupClosed', this.gridOptionsService, null));
        this.eGroupOpenedIcon.appendChild(_.createIcon('setFilterGroupOpen', this.gridOptionsService, null));
        this.addManagedListener(this.eGroupClosedIcon, 'click', this.onExpandOrContractClicked.bind(this));
        this.addManagedListener(this.eGroupOpenedIcon, 'click', this.onExpandOrContractClicked.bind(this));
        if (this.hasIndeterminateExpandState) {
            this.eGroupIndeterminateIcon.appendChild(_.createIcon('setFilterGroupIndeterminate', this.gridOptionsService, null));
            this.addManagedListener(this.eGroupIndeterminateIcon, 'click', this.onExpandOrContractClicked.bind(this));
        }
        this.setExpandedIcons();
        this.refreshAriaExpanded();
    }
    onExpandOrContractClicked() {
        this.setExpanded(!this.isExpanded);
    }
    setExpanded(isExpanded, silent) {
        if (this.isGroup && isExpanded !== this.isExpanded) {
            this.isExpanded = isExpanded;
            const event = {
                type: SetFilterListItem.EVENT_EXPANDED_CHANGED,
                isExpanded: !!isExpanded,
                item: this.item
            };
            if (!silent) {
                this.dispatchEvent(event);
            }
            this.setExpandedIcons();
            this.refreshAriaExpanded();
        }
    }
    setExpandedIcons() {
        _.setDisplayed(this.eGroupClosedIcon, this.hasIndeterminateExpandState ? this.isExpanded === false : !this.isExpanded);
        _.setDisplayed(this.eGroupOpenedIcon, this.isExpanded === true);
        if (this.hasIndeterminateExpandState) {
            _.setDisplayed(this.eGroupIndeterminateIcon, this.isExpanded === undefined);
        }
    }
    onCheckboxChanged(isSelected) {
        this.isSelected = isSelected;
        const event = {
            type: SetFilterListItem.EVENT_SELECTION_CHANGED,
            isSelected,
            item: this.item
        };
        this.dispatchEvent(event);
        this.refreshVariableAriaLabels();
        this.refreshAriaChecked();
    }
    toggleSelected() {
        if (!!this.params.readOnly) {
            return;
        }
        this.setSelected(!this.isSelected);
    }
    setSelected(isSelected, silent) {
        this.isSelected = isSelected;
        this.eCheckbox.setValue(isSelected, silent);
        this.refreshAriaChecked();
    }
    refreshVariableAriaLabels() {
        if (!this.isTree) {
            return;
        }
        const translate = this.localeService.getLocaleTextFunc();
        const checkboxValue = this.eCheckbox.getValue();
        const state = checkboxValue === undefined ?
            translate('ariaIndeterminate', 'indeterminate') :
            (checkboxValue ? translate('ariaVisible', 'visible') : translate('ariaHidden', 'hidden'));
        const visibilityLabel = translate('ariaToggleVisibility', 'Press SPACE to toggle visibility');
        _.setAriaLabelledBy(this.eCheckbox.getInputElement(), undefined);
        this.eCheckbox.setInputAriaLabel(`${visibilityLabel} (${state})`);
    }
    setupFixedAriaLabels(value) {
        if (!this.isTree) {
            return;
        }
        const translate = this.localeService.getLocaleTextFunc();
        const itemLabel = translate('ariaFilterValue', 'Filter Value');
        const ariaEl = this.getAriaElement();
        _.setAriaLabel(ariaEl, `${value} ${itemLabel}`);
        _.setAriaDescribedBy(ariaEl, this.eCheckbox.getInputElement().id);
    }
    refreshAriaChecked() {
        const ariaEl = this.getAriaElement();
        _.setAriaChecked(ariaEl, this.eCheckbox.getValue());
    }
    refreshAriaExpanded() {
        _.setAriaExpanded(this.getAriaElement(), !!this.isExpanded);
    }
    refresh(item, isSelected, isExpanded) {
        var _a, _b;
        this.item = item;
        // setExpanded checks if value has changed, setSelected does not
        if (isSelected !== this.isSelected) {
            this.setSelected(isSelected, true);
        }
        this.setExpanded(isExpanded, true);
        if (this.valueFunction) {
            // underlying value might have changed, so call again and re-render
            const value = this.valueFunction();
            this.setTooltipAndCellRendererParams(value, value);
            if (!this.cellRendererComponent) {
                this.renderCellWithoutCellRenderer();
            }
        }
        if (this.cellRendererComponent) {
            const success = (_b = (_a = this.cellRendererComponent).refresh) === null || _b === void 0 ? void 0 : _b.call(_a, this.cellRendererParams);
            if (!success) {
                const oldComponent = this.cellRendererComponent;
                this.renderCell();
                this.destroyBean(oldComponent);
            }
        }
    }
    render() {
        const { params: { column } } = this;
        let { value } = this;
        let formattedValue = null;
        if (typeof value === 'function') {
            this.valueFunction = value;
            formattedValue = this.valueFunction();
            // backwards compatibility for select all in value
            value = formattedValue;
        }
        else if (this.isTree) {
            // tree values are already formatted via treeListFormatter
            formattedValue = _.toStringOrNull(value);
        }
        else {
            formattedValue = this.getFormattedValue(column, value);
        }
        this.setTooltipAndCellRendererParams(value, formattedValue);
        this.renderCell();
    }
    setTooltipAndCellRendererParams(value, formattedValue) {
        if (this.params.showTooltips) {
            const tooltipValue = formattedValue != null ? formattedValue : _.toStringOrNull(value);
            this.setTooltip(tooltipValue);
        }
        this.cellRendererParams = this.gridOptionsService.addGridCommonParams({
            value,
            valueFormatted: formattedValue,
            colDef: this.params.colDef,
            column: this.params.column,
        });
    }
    getTooltipParams() {
        const res = super.getTooltipParams();
        res.location = 'setFilterValue';
        res.colDef = this.getComponentHolder();
        if (this.isTree) {
            res.level = this.depth;
        }
        return res;
    }
    getFormattedValue(column, value) {
        return this.valueFormatterService.formatValue(column, null, value, this.valueFormatter, false);
    }
    renderCell() {
        const compDetails = this.userComponentFactory.getSetFilterCellRendererDetails(this.params, this.cellRendererParams);
        const cellRendererPromise = compDetails ? compDetails.newAgStackInstance() : undefined;
        if (cellRendererPromise == null) {
            this.renderCellWithoutCellRenderer();
            return;
        }
        cellRendererPromise.then(component => {
            if (component) {
                this.cellRendererComponent = component;
                this.eCheckbox.setLabel(component.getGui());
                this.destroyCellRendererComponent = () => this.destroyBean(component);
            }
        });
    }
    renderCellWithoutCellRenderer() {
        var _a;
        let valueToRender = (_a = (this.cellRendererParams.valueFormatted == null ? this.cellRendererParams.value : this.cellRendererParams.valueFormatted)) !== null && _a !== void 0 ? _a : this.translate('blanks');
        if (typeof valueToRender !== 'string') {
            _.warnOnce(`Set Filter Value Formatter must return string values. Please ensure the Set Filter Value Formatter returns string values for complex objects, or set convertValuesToStrings=true in the filterParams. See ${this.getFrameworkOverrides().getDocLink('filter-set-filter-list/#filter-value-types')}`);
            valueToRender = '';
        }
        this.eCheckbox.setLabel(valueToRender);
        this.setupFixedAriaLabels(valueToRender);
    }
    getComponentHolder() {
        return this.params.column.getColDef();
    }
}
SetFilterListItem.EVENT_SELECTION_CHANGED = 'selectionChanged';
SetFilterListItem.EVENT_EXPANDED_CHANGED = 'expandedChanged';
SetFilterListItem.GROUP_TEMPLATE = `
        <div class="ag-set-filter-item" aria-hidden="true">
            <span class="ag-set-filter-group-icons">
                <span class="ag-set-filter-group-closed-icon" ref="eGroupClosedIcon"></span>
                <span class="ag-set-filter-group-opened-icon" ref="eGroupOpenedIcon"></span>
                <span class="ag-set-filter-group-indeterminate-icon" ref="eGroupIndeterminateIcon"></span>
            </span>
            <ag-checkbox ref="eCheckbox" class="ag-set-filter-item-checkbox"></ag-checkbox>
        </div>`;
SetFilterListItem.TEMPLATE = `
        <div class="ag-set-filter-item">
            <ag-checkbox ref="eCheckbox" class="ag-set-filter-item-checkbox"></ag-checkbox>
        </div>`;
__decorate$20([
    Autowired('valueFormatterService')
], SetFilterListItem.prototype, "valueFormatterService", void 0);
__decorate$20([
    Autowired('userComponentFactory')
], SetFilterListItem.prototype, "userComponentFactory", void 0);
__decorate$20([
    RefSelector('eCheckbox')
], SetFilterListItem.prototype, "eCheckbox", void 0);
__decorate$20([
    RefSelector('eGroupOpenedIcon')
], SetFilterListItem.prototype, "eGroupOpenedIcon", void 0);
__decorate$20([
    RefSelector('eGroupClosedIcon')
], SetFilterListItem.prototype, "eGroupClosedIcon", void 0);
__decorate$20([
    RefSelector('eGroupIndeterminateIcon')
], SetFilterListItem.prototype, "eGroupIndeterminateIcon", void 0);
__decorate$20([
    PostConstruct
], SetFilterListItem.prototype, "init", null);

const DEFAULT_LOCALE_TEXT = {
    loadingOoo: 'Loading...',
    blanks: '(Blanks)',
    searchOoo: 'Search...',
    selectAll: '(Select All)',
    selectAllSearchResults: '(Select All Search Results)',
    addCurrentSelectionToFilter: 'Add current selection to filter',
    noMatches: 'No matches.'
};

class SetFilterModelFormatter {
    getModelAsString(model, setFilter) {
        const { values } = model || setFilter.getModel() || {};
        const valueModel = setFilter.getValueModel();
        if (values == null || valueModel == null) {
            return '';
        }
        const availableKeys = values.filter(v => valueModel.isKeyAvailable(v));
        const numValues = availableKeys.length;
        const formattedValues = availableKeys.slice(0, 10).map(key => setFilter.getFormattedValue(key));
        return `(${numValues}) ${formattedValues.join(',')}${numValues > 10 ? ',...' : ''}`;
    }
}

var __decorate$21 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/** @param V type of value in the Set Filter */
class SetFilter extends ProvidedFilter {
    constructor() {
        super('setFilter');
        this.valueModel = null;
        this.setFilterParams = null;
        this.virtualList = null;
        this.caseSensitive = false;
        this.convertValuesToStrings = false;
        this.treeDataTreeList = false;
        this.groupingTreeList = false;
        this.hardRefreshVirtualList = false;
        this.noValueFormatterSupplied = false;
        this.filterModelFormatter = new SetFilterModelFormatter();
        this.updateSetFilterOnParamsChange = (newParams) => {
            var _a;
            this.setFilterParams = newParams;
            this.convertValuesToStrings = !!newParams.convertValuesToStrings;
            this.caseSensitive = !!newParams.caseSensitive;
            const keyCreator = (_a = newParams.keyCreator) !== null && _a !== void 0 ? _a : newParams.colDef.keyCreator;
            this.setValueFormatter(newParams.valueFormatter, keyCreator, this.convertValuesToStrings, !!newParams.treeList, !!newParams.colDef.refData);
            const isGroupCol = newParams.column.getId().startsWith(GROUP_AUTO_COLUMN_ID);
            this.treeDataTreeList = this.gridOptionsService.get('treeData') && !!newParams.treeList && isGroupCol;
            this.getDataPath = this.gridOptionsService.get('getDataPath');
            this.groupingTreeList = !!this.columnModel.getRowGroupColumns().length && !!newParams.treeList && isGroupCol;
            this.createKey = this.generateCreateKey(keyCreator, this.convertValuesToStrings, this.treeDataTreeList || this.groupingTreeList);
        };
    }
    postConstruct() {
        super.postConstruct();
    }
    // unlike the simple filters, nothing in the set filter UI shows/hides.
    // maybe this method belongs in abstractSimpleFilter???
    updateUiVisibility() { }
    createBodyTemplate() {
        return /* html */ `
            <div class="ag-set-filter">
                <div ref="eFilterLoading" class="ag-filter-loading ag-hidden">${this.translateForSetFilter('loadingOoo')}</div>
                <ag-input-text-field class="ag-mini-filter" ref="eMiniFilter"></ag-input-text-field>
                <div ref="eFilterNoMatches" class="ag-filter-no-matches ag-hidden">${this.translateForSetFilter('noMatches')}</div>
                <div ref="eSetFilterList" class="ag-set-filter-list" role="presentation"></div>
            </div>`;
    }
    handleKeyDown(e) {
        super.handleKeyDown(e);
        if (e.defaultPrevented) {
            return;
        }
        switch (e.key) {
            case KeyCode.SPACE:
                this.handleKeySpace(e);
                break;
            case KeyCode.ENTER:
                this.handleKeyEnter(e);
                break;
            case KeyCode.LEFT:
                this.handleKeyLeft(e);
                break;
            case KeyCode.RIGHT:
                this.handleKeyRight(e);
                break;
        }
    }
    handleKeySpace(e) {
        var _a;
        (_a = this.getComponentForKeyEvent(e)) === null || _a === void 0 ? void 0 : _a.toggleSelected();
    }
    handleKeyEnter(e) {
        if (!this.setFilterParams) {
            return;
        }
        const { excelMode, readOnly } = this.setFilterParams || {};
        if (!excelMode || !!readOnly) {
            return;
        }
        e.preventDefault();
        // in Excel Mode, hitting Enter is the same as pressing the Apply button
        this.onBtApply(false, false, e);
        if (this.setFilterParams.excelMode === 'mac') {
            // in Mac version, select all the input text
            this.eMiniFilter.getInputElement().select();
        }
    }
    handleKeyLeft(e) {
        var _a;
        (_a = this.getComponentForKeyEvent(e)) === null || _a === void 0 ? void 0 : _a.setExpanded(false);
    }
    handleKeyRight(e) {
        var _a;
        (_a = this.getComponentForKeyEvent(e)) === null || _a === void 0 ? void 0 : _a.setExpanded(true);
    }
    getComponentForKeyEvent(e) {
        var _a;
        const eDocument = this.gridOptionsService.getDocument();
        if (!this.eSetFilterList.contains(eDocument.activeElement) || !this.virtualList) {
            return;
        }
        const currentItem = this.virtualList.getLastFocusedRow();
        if (currentItem == null) {
            return;
        }
        const component = this.virtualList.getComponentAt(currentItem);
        if (component == null) {
            return;
        }
        e.preventDefault();
        const { readOnly } = (_a = this.setFilterParams) !== null && _a !== void 0 ? _a : {};
        if (!!readOnly) {
            return;
        }
        return component;
    }
    getCssIdentifier() {
        return 'set-filter';
    }
    setModel(model) {
        var _a;
        if (model == null && ((_a = this.valueModel) === null || _a === void 0 ? void 0 : _a.getModel()) == null) {
            // refreshing is expensive. if new and old model are both null (e.g. nothing set), skip.
            // mini filter isn't contained within the model, so always reset
            this.setMiniFilter(null);
            return AgPromise.resolve();
        }
        return super.setModel(model);
    }
    refresh(params) {
        var _a, _b, _c;
        if (!super.refresh(params)) {
            return false;
        }
        // Those params have a large impact and should trigger a reload when they change.
        const paramsThatForceReload = [
            'treeList', 'treeListFormatter', 'treeListPathGetter', 'keyCreator', 'convertValuesToStrings',
            'caseSensitive', 'comparator', 'suppressSelectAll', 'excelMode'
        ];
        if (paramsThatForceReload.some(param => { var _a; return params[param] !== ((_a = this.setFilterParams) === null || _a === void 0 ? void 0 : _a[param]); })) {
            return false;
        }
        if (this.haveColDefParamsChanged(params.colDef)) {
            return false;
        }
        super.updateParams(params);
        this.updateSetFilterOnParamsChange(params);
        this.updateMiniFilter();
        if (params.cellRenderer !== ((_a = this.setFilterParams) === null || _a === void 0 ? void 0 : _a.cellRenderer) ||
            params.valueFormatter !== ((_b = this.setFilterParams) === null || _b === void 0 ? void 0 : _b.valueFormatter)) {
            this.checkAndRefreshVirtualList();
        }
        (_c = this.valueModel) === null || _c === void 0 ? void 0 : _c.updateOnParamsChange(params).then(() => {
            var _a;
            if ((_a = this.valueModel) === null || _a === void 0 ? void 0 : _a.hasSelections()) {
                this.refreshFilterValues();
            }
        });
        return true;
    }
    haveColDefParamsChanged(colDef) {
        var _a;
        const paramsThatForceReload = [
            'keyCreator', 'filterValueGetter',
        ];
        const existingColDef = (_a = this.setFilterParams) === null || _a === void 0 ? void 0 : _a.colDef;
        return paramsThatForceReload.some(param => colDef[param] !== (existingColDef === null || existingColDef === void 0 ? void 0 : existingColDef[param]));
    }
    setModelAndRefresh(values) {
        return this.valueModel ? this.valueModel.setModel(values).then(() => this.checkAndRefreshVirtualList()) : AgPromise.resolve();
    }
    resetUiToDefaults() {
        this.setMiniFilter(null);
        return this.setModelAndRefresh(null);
    }
    setModelIntoUi(model) {
        this.setMiniFilter(null);
        const values = model == null ? null : model.values;
        return this.setModelAndRefresh(values);
    }
    getModelFromUi() {
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        const values = this.valueModel.getModel();
        if (!values) {
            return null;
        }
        return { values, filterType: this.getFilterType() };
    }
    getFilterType() {
        return 'set';
    }
    getValueModel() {
        return this.valueModel;
    }
    areModelsEqual(a, b) {
        // both are missing
        if (a == null && b == null) {
            return true;
        }
        return a != null && b != null && _.areEqual(a.values, b.values);
    }
    setParams(params) {
        var _a;
        this.applyExcelModeOptions(params);
        super.setParams(params);
        this.updateSetFilterOnParamsChange(params);
        const keyCreator = (_a = params.keyCreator) !== null && _a !== void 0 ? _a : params.colDef.keyCreator;
        this.valueModel = new SetValueModel({
            filterParams: params,
            setIsLoading: loading => this.setIsLoading(loading),
            valueFormatterService: this.valueFormatterService,
            translate: key => this.translateForSetFilter(key),
            caseFormat: v => this.caseFormat(v),
            createKey: this.createKey,
            valueFormatter: this.valueFormatter,
            usingComplexObjects: !!keyCreator,
            gridOptionsService: this.gridOptionsService,
            columnModel: this.columnModel,
            valueService: this.valueService,
            treeDataTreeList: this.treeDataTreeList,
            groupingTreeList: this.groupingTreeList,
            addManagedListener: (event, listener) => this.addManagedListener(this.eventService, event, listener)
        });
        this.initialiseFilterBodyUi();
        this.addEventListenersForDataChanges();
    }
    onAddCurrentSelectionToFilterChange(newValue) {
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        this.valueModel.setAddCurrentSelectionToFilter(newValue);
    }
    setValueFormatter(providedValueFormatter, keyCreator, convertValuesToStrings, treeList, isRefData) {
        let valueFormatter = providedValueFormatter;
        if (!valueFormatter) {
            if (keyCreator && !convertValuesToStrings && !treeList) {
                throw new Error('AG Grid: Must supply a Value Formatter in Set Filter params when using a Key Creator unless convertValuesToStrings is enabled');
            }
            this.noValueFormatterSupplied = true;
            // ref data is handled by ValueFormatterService
            if (!isRefData) {
                valueFormatter = params => _.toStringOrNull(params.value);
            }
        }
        this.valueFormatter = valueFormatter;
    }
    generateCreateKey(keyCreator, convertValuesToStrings, treeDataOrGrouping) {
        if (treeDataOrGrouping && !keyCreator) {
            throw new Error('AG Grid: Must supply a Key Creator in Set Filter params when `treeList = true` on a group column, and Tree Data or Row Grouping is enabled.');
        }
        if (keyCreator) {
            return (value, node = null) => {
                const params = this.getKeyCreatorParams(value, node);
                return _.makeNull(keyCreator(params));
            };
        }
        if (convertValuesToStrings) {
            // for backwards compatibility - keeping separate as it will eventually be removed
            return value => Array.isArray(value) ? value : _.makeNull(_.toStringOrNull(value));
        }
        else {
            return value => _.makeNull(_.toStringOrNull(value));
        }
    }
    getFormattedValue(key) {
        var _a;
        let value = this.valueModel.getValue(key);
        if (this.noValueFormatterSupplied && (this.treeDataTreeList || this.groupingTreeList) && Array.isArray(value)) {
            // essentially get back the cell value
            value = _.last(value);
        }
        const formattedValue = this.valueFormatterService.formatValue(this.setFilterParams.column, null, value, this.valueFormatter, false);
        return (_a = (formattedValue == null ? _.toStringOrNull(value) : formattedValue)) !== null && _a !== void 0 ? _a : this.translateForSetFilter('blanks');
    }
    applyExcelModeOptions(params) {
        // apply default options to match Excel behaviour, unless they have already been specified
        if (params.excelMode === 'windows') {
            if (!params.buttons) {
                params.buttons = ['apply', 'cancel'];
            }
            if (params.closeOnApply == null) {
                params.closeOnApply = true;
            }
        }
        else if (params.excelMode === 'mac') {
            if (!params.buttons) {
                params.buttons = ['reset'];
            }
            if (params.applyMiniFilterWhileTyping == null) {
                params.applyMiniFilterWhileTyping = true;
            }
            if (params.debounceMs == null) {
                params.debounceMs = 500;
            }
        }
        if (params.excelMode && params.defaultToNothingSelected) {
            params.defaultToNothingSelected = false;
            _.warnOnce('The Set Filter Parameter "defaultToNothingSelected" value was ignored because it does not work when "excelMode" is used.');
        }
    }
    addEventListenersForDataChanges() {
        if (!this.isValuesTakenFromGrid()) {
            return;
        }
        this.addManagedListener(this.eventService, Events.EVENT_CELL_VALUE_CHANGED, (event) => {
            // only interested in changes to do with this column
            if (this.setFilterParams && event.column === this.setFilterParams.column) {
                this.syncAfterDataChange();
            }
        });
        this.addManagedPropertyListeners(['treeData', 'getDataPath', 'groupAllowUnbalanced'], () => {
            this.syncAfterDataChange();
        });
    }
    syncAfterDataChange() {
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        let promise = this.valueModel.refreshValues();
        return promise.then(() => {
            this.checkAndRefreshVirtualList();
            this.onBtApply(false, true);
        });
    }
    setIsLoading(isLoading) {
        _.setDisplayed(this.eFilterLoading, isLoading);
        if (!isLoading) {
            // hard refresh when async data received
            this.hardRefreshVirtualList = true;
        }
    }
    initialiseFilterBodyUi() {
        this.initVirtualList();
        this.initMiniFilter();
    }
    initVirtualList() {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        const translate = this.localeService.getLocaleTextFunc();
        const filterListName = translate('ariaFilterList', 'Filter List');
        const isTree = !!this.setFilterParams.treeList;
        const virtualList = this.virtualList = this.createBean(new VirtualList({
            cssIdentifier: 'filter',
            ariaRole: isTree ? 'tree' : 'listbox',
            listName: filterListName
        }));
        const eSetFilterList = this.getRefElement('eSetFilterList');
        if (isTree) {
            eSetFilterList.classList.add('ag-set-filter-tree-list');
        }
        if (eSetFilterList) {
            eSetFilterList.appendChild(virtualList.getGui());
        }
        const { cellHeight } = this.setFilterParams;
        if (cellHeight != null) {
            virtualList.setRowHeight(cellHeight);
        }
        const componentCreator = (item, listItemElement) => this.createSetListItem(item, isTree, listItemElement);
        virtualList.setComponentCreator(componentCreator);
        const componentUpdater = (item, component) => this.updateSetListItem(item, component);
        virtualList.setComponentUpdater(componentUpdater);
        let model;
        if (this.setFilterParams.suppressSelectAll) {
            model = new ModelWrapper(this.valueModel);
        }
        else {
            model = new ModelWrapperWithSelectAll(this.valueModel, () => this.isSelectAllSelected());
        }
        if (isTree) {
            model = new TreeModelWrapper(model);
        }
        virtualList.setModel(model);
    }
    getSelectAllLabel() {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        const key = this.valueModel.getMiniFilter() == null || !this.setFilterParams.excelMode ?
            'selectAll' : 'selectAllSearchResults';
        return this.translateForSetFilter(key);
    }
    getAddSelectionToFilterLabel() {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        return this.translateForSetFilter('addCurrentSelectionToFilter');
    }
    createSetListItem(item, isTree, focusWrapper) {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        const groupsExist = this.valueModel.hasGroups();
        const { isSelected, isExpanded } = this.isSelectedExpanded(item);
        const { value, depth, isGroup, hasIndeterminateExpandState, selectedListener, expandedListener, } = this.newSetListItemAttributes(item, isTree);
        const itemParams = {
            focusWrapper,
            value,
            params: this.setFilterParams,
            translate: (translateKey) => this.translateForSetFilter(translateKey),
            valueFormatter: this.valueFormatter,
            item,
            isSelected,
            isTree,
            depth,
            groupsExist,
            isGroup,
            isExpanded,
            hasIndeterminateExpandState,
        };
        const listItem = this.createBean(new SetFilterListItem(itemParams));
        listItem.addEventListener(SetFilterListItem.EVENT_SELECTION_CHANGED, selectedListener);
        if (expandedListener) {
            listItem.addEventListener(SetFilterListItem.EVENT_EXPANDED_CHANGED, expandedListener);
        }
        return listItem;
    }
    newSetTreeItemAttributes(item, isTree) {
        var _a, _b, _c, _d, _e, _f;
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        const groupsExist = this.valueModel.hasGroups();
        // Select all option
        if (item.key === SetFilterDisplayValue.SELECT_ALL) {
            return {
                value: () => this.getSelectAllLabel(),
                isGroup: groupsExist,
                depth: item.depth,
                hasIndeterminateExpandState: true,
                selectedListener: (e) => this.onSelectAll(e.isSelected),
                expandedListener: (e) => this.onExpandAll(e.item, e.isExpanded),
            };
        }
        // Add selection to filter option
        if (item.key === SetFilterDisplayValue.ADD_SELECTION_TO_FILTER) {
            return {
                value: () => this.getAddSelectionToFilterLabel(),
                depth: item.depth,
                isGroup: false,
                hasIndeterminateExpandState: false,
                selectedListener: (e) => {
                    this.onAddCurrentSelectionToFilterChange(e.isSelected);
                }
            };
        }
        // Group
        if (item.children) {
            return {
                value: (_c = (_b = (_a = this.setFilterParams).treeListFormatter) === null || _b === void 0 ? void 0 : _b.call(_a, item.treeKey, item.depth, item.parentTreeKeys)) !== null && _c !== void 0 ? _c : item.treeKey,
                depth: item.depth,
                isGroup: true,
                selectedListener: (e) => this.onGroupItemSelected(e.item, e.isSelected),
                expandedListener: (e) => this.onExpandedChanged(e.item, e.isExpanded),
            };
        }
        // Leaf
        return {
            value: (_f = (_e = (_d = this.setFilterParams).treeListFormatter) === null || _e === void 0 ? void 0 : _e.call(_d, item.treeKey, item.depth, item.parentTreeKeys)) !== null && _f !== void 0 ? _f : item.treeKey,
            depth: item.depth,
            selectedListener: (e) => this.onItemSelected(e.item.key, e.isSelected),
        };
    }
    newSetListItemAttributes(item, isTree) {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        // Tree item
        if (this.isSetFilterModelTreeItem(item)) {
            return this.newSetTreeItemAttributes(item, isTree);
        }
        // List item - 'Select All'
        if (item === SetFilterDisplayValue.SELECT_ALL) {
            return {
                value: () => this.getSelectAllLabel(),
                selectedListener: (e) => this.onSelectAll(e.isSelected),
            };
        }
        // List item - 'Add selection to filter'
        if (item === SetFilterDisplayValue.ADD_SELECTION_TO_FILTER) {
            return {
                value: () => this.getAddSelectionToFilterLabel(),
                selectedListener: (e) => {
                    this.onAddCurrentSelectionToFilterChange(e.isSelected);
                },
            };
        }
        // List item
        return {
            value: this.valueModel.getValue(item),
            selectedListener: (e) => this.onItemSelected(e.item, e.isSelected),
        };
    }
    updateSetListItem(item, component) {
        const { isSelected, isExpanded } = this.isSelectedExpanded(item);
        component.refresh(item, isSelected, isExpanded);
    }
    isSelectedExpanded(item) {
        let isSelected;
        let isExpanded;
        if (this.isSetFilterModelTreeItem(item)) {
            isExpanded = item.expanded;
            if (item.key === SetFilterDisplayValue.SELECT_ALL) {
                isSelected = this.isSelectAllSelected();
            }
            else if (item.key === SetFilterDisplayValue.ADD_SELECTION_TO_FILTER) {
                isSelected = this.valueModel.isAddCurrentSelectionToFilterChecked();
            }
            else if (item.children) {
                isSelected = this.areAllChildrenSelected(item);
            }
            else {
                isSelected = this.valueModel.isKeySelected(item.key);
            }
        }
        else {
            if (item === SetFilterDisplayValue.SELECT_ALL) {
                isSelected = this.isSelectAllSelected();
            }
            else if (item === SetFilterDisplayValue.ADD_SELECTION_TO_FILTER) {
                isSelected = this.valueModel.isAddCurrentSelectionToFilterChecked();
            }
            else {
                isSelected = this.valueModel.isKeySelected(item);
            }
        }
        return { isSelected, isExpanded };
    }
    isSetFilterModelTreeItem(item) {
        return (item === null || item === void 0 ? void 0 : item.treeKey) !== undefined;
    }
    initMiniFilter() {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        const { eMiniFilter, localeService } = this;
        const translate = localeService.getLocaleTextFunc();
        eMiniFilter.setDisplayed(!this.setFilterParams.suppressMiniFilter);
        eMiniFilter.setValue(this.valueModel.getMiniFilter());
        eMiniFilter.onValueChange(() => this.onMiniFilterInput());
        eMiniFilter.setInputAriaLabel(translate('ariaSearchFilterValues', 'Search filter values'));
        this.addManagedListener(eMiniFilter.getInputElement(), 'keydown', e => this.onMiniFilterKeyDown(e));
    }
    updateMiniFilter() {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        const { eMiniFilter } = this;
        if (eMiniFilter.isDisplayed() !== !this.setFilterParams.suppressMiniFilter) {
            eMiniFilter.setDisplayed(!this.setFilterParams.suppressMiniFilter);
        }
        const miniFilterValue = this.valueModel.getMiniFilter();
        if (eMiniFilter.getValue() !== miniFilterValue) {
            eMiniFilter.setValue(miniFilterValue);
        }
    }
    // we need to have the GUI attached before we can draw the virtual rows, as the
    // virtual row logic needs info about the GUI state
    afterGuiAttached(params) {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        super.afterGuiAttached(params);
        // collapse all tree list items (if tree list)
        this.resetExpansion();
        this.refreshVirtualList();
        const { eMiniFilter } = this;
        eMiniFilter.setInputPlaceholder(this.translateForSetFilter('searchOoo'));
        if (!params || !params.suppressFocus) {
            eMiniFilter.getFocusableElement().focus();
        }
    }
    afterGuiDetached() {
        var _a, _b;
        super.afterGuiDetached();
        // discard any unapplied UI state (reset to model)
        if ((_a = this.setFilterParams) === null || _a === void 0 ? void 0 : _a.excelMode) {
            this.resetMiniFilter();
        }
        const appliedModel = this.getModel();
        if (((_b = this.setFilterParams) === null || _b === void 0 ? void 0 : _b.excelMode) || !this.areModelsEqual(appliedModel, this.getModelFromUi())) {
            this.resetUiToActiveModel(appliedModel);
            this.showOrHideResults();
        }
    }
    applyModel(source = 'api') {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        if (this.setFilterParams.excelMode && source !== 'rowDataUpdated' && this.valueModel.isEverythingVisibleSelected()) {
            // In Excel, if the filter is applied with all visible values selected, then any active filter on the
            // column is removed. This ensures the filter is removed in this situation.
            this.valueModel.selectAllMatchingMiniFilter();
        }
        // Here we implement AG-9090 TC2
        // When 'Add current selection to filter' is visible and checked, but no filter is applied:
        // Do NOT apply the current selection as filter.
        const shouldKeepCurrentSelection = this.valueModel.showAddCurrentSelectionToFilter() && this.valueModel.isAddCurrentSelectionToFilterChecked();
        if (shouldKeepCurrentSelection && !this.getModel()) {
            return false;
        }
        const result = super.applyModel(source);
        // keep appliedModelKeys in sync with the applied model
        const appliedModel = this.getModel();
        if (appliedModel) {
            if (!shouldKeepCurrentSelection) {
                this.valueModel.setAppliedModelKeys(new Set());
            }
            appliedModel.values.forEach(key => {
                this.valueModel.addToAppliedModelKeys(key);
            });
        }
        else {
            if (!shouldKeepCurrentSelection) {
                this.valueModel.setAppliedModelKeys(null);
            }
        }
        return result;
    }
    isModelValid(model) {
        return this.setFilterParams && this.setFilterParams.excelMode ? model == null || model.values.length > 0 : true;
    }
    doesFilterPass(params) {
        if (!this.setFilterParams || !this.valueModel || !this.valueModel.getCaseFormattedAppliedModelKeys()) {
            return true;
        }
        // if nothing selected, don't need to check value
        if (!this.valueModel.hasAnyAppliedModelKey()) {
            return false;
        }
        const { node, data } = params;
        if (this.treeDataTreeList) {
            return this.doesFilterPassForTreeData(node, data);
        }
        if (this.groupingTreeList) {
            return this.doesFilterPassForGrouping(node);
        }
        let value = this.getValueFromNode(node);
        if (this.convertValuesToStrings) {
            // for backwards compatibility - keeping separate as it will eventually be removed
            return this.doesFilterPassForConvertValuesToString(node, value);
        }
        if (value != null && Array.isArray(value)) {
            if (value.length === 0) {
                return this.valueModel.hasAppliedModelKey(null);
            }
            return value.some(v => this.isInAppliedModel(this.createKey(v, node)));
        }
        return this.isInAppliedModel(this.createKey(value, node));
    }
    doesFilterPassForConvertValuesToString(node, value) {
        const key = this.createKey(value, node);
        if (key != null && Array.isArray(key)) {
            if (key.length === 0) {
                return this.valueModel.hasAppliedModelKey(null);
            }
            return key.some(v => this.isInAppliedModel(v));
        }
        return this.isInAppliedModel(key);
    }
    doesFilterPassForTreeData(node, data) {
        var _a;
        if ((_a = node.childrenAfterGroup) === null || _a === void 0 ? void 0 : _a.length) {
            // only perform checking on leaves. The core filtering logic for tree data won't work properly otherwise
            return false;
        }
        return this.isInAppliedModel(this.createKey(this.checkMakeNullDataPath(this.getDataPath(data))));
    }
    doesFilterPassForGrouping(node) {
        const dataPath = this.columnModel.getRowGroupColumns().map(groupCol => this.valueService.getKeyForNode(groupCol, node));
        dataPath.push(this.getValueFromNode(node));
        return this.isInAppliedModel(this.createKey(this.checkMakeNullDataPath(dataPath)));
    }
    checkMakeNullDataPath(dataPath) {
        if (dataPath) {
            dataPath = dataPath.map(treeKey => _.toStringOrNull(_.makeNull(treeKey)));
        }
        if (dataPath === null || dataPath === void 0 ? void 0 : dataPath.some(treeKey => treeKey == null)) {
            return null;
        }
        return dataPath;
    }
    isInAppliedModel(key) {
        return this.valueModel.hasAppliedModelKey(key);
    }
    getValueFromNode(node) {
        return this.setFilterParams.getValue(node);
    }
    getKeyCreatorParams(value, node = null) {
        return {
            value,
            colDef: this.setFilterParams.colDef,
            column: this.setFilterParams.column,
            node: node,
            data: node === null || node === void 0 ? void 0 : node.data,
            api: this.setFilterParams.api,
            columnApi: this.setFilterParams.columnApi,
            context: this.setFilterParams.context
        };
    }
    onNewRowsLoaded() {
        if (!this.isValuesTakenFromGrid()) {
            return;
        }
        this.syncAfterDataChange();
    }
    isValuesTakenFromGrid() {
        if (!this.valueModel) {
            return false;
        }
        const valuesType = this.valueModel.getValuesType();
        return valuesType === SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES;
    }
    //noinspection JSUnusedGlobalSymbols
    /**
     * Public method provided so the user can change the value of the filter once
     * the filter has been already started
     * @param values The values to use.
     */
    setFilterValues(values) {
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        this.valueModel.overrideValues(values).then(() => {
            this.checkAndRefreshVirtualList();
            this.onUiChanged();
        });
    }
    //noinspection JSUnusedGlobalSymbols
    /**
     * Public method provided so the user can reset the values of the filter once that it has started.
     */
    resetFilterValues() {
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        this.valueModel.setValuesType(SetFilterModelValuesType.TAKEN_FROM_GRID_VALUES);
        this.syncAfterDataChange();
    }
    refreshFilterValues() {
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        // the model is still being initialised
        if (!this.valueModel.isInitialised()) {
            return;
        }
        this.valueModel.refreshValues().then(() => {
            this.checkAndRefreshVirtualList();
            this.onUiChanged();
        });
    }
    onAnyFilterChanged() {
        // don't block the current action when updating the values for this filter
        setTimeout(() => {
            if (!this.isAlive()) {
                return;
            }
            if (!this.valueModel) {
                throw new Error('Value model has not been created.');
            }
            this.valueModel.refreshAfterAnyFilterChanged().then(refresh => {
                if (refresh) {
                    this.checkAndRefreshVirtualList();
                    this.showOrHideResults();
                }
            });
        }, 0);
    }
    onMiniFilterInput() {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        if (!this.valueModel.setMiniFilter(this.eMiniFilter.getValue())) {
            return;
        }
        const { applyMiniFilterWhileTyping, readOnly } = this.setFilterParams || {};
        if (!readOnly && applyMiniFilterWhileTyping) {
            this.filterOnAllVisibleValues(false);
        }
        else {
            this.updateUiAfterMiniFilterChange();
        }
    }
    updateUiAfterMiniFilterChange() {
        if (!this.setFilterParams) {
            throw new Error('Set filter params have not been provided.');
        }
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        const { excelMode, readOnly } = this.setFilterParams || {};
        if (excelMode == null || !!readOnly) {
            this.checkAndRefreshVirtualList();
        }
        else if (this.valueModel.getMiniFilter() == null) {
            this.resetUiToActiveModel(this.getModel());
        }
        else {
            this.valueModel.selectAllMatchingMiniFilter(true);
            this.checkAndRefreshVirtualList();
            this.onUiChanged();
        }
        this.showOrHideResults();
    }
    showOrHideResults() {
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        const hideResults = this.valueModel.getMiniFilter() != null && this.valueModel.getDisplayedValueCount() < 1;
        _.setDisplayed(this.eNoMatches, hideResults);
        _.setDisplayed(this.eSetFilterList, !hideResults);
    }
    resetMiniFilter() {
        var _a;
        this.eMiniFilter.setValue(null, true);
        (_a = this.valueModel) === null || _a === void 0 ? void 0 : _a.setMiniFilter(null);
    }
    resetUiToActiveModel(currentModel, afterUiUpdatedFunc) {
        // override the default behaviour as we don't always want to clear the mini filter
        this.setModelAndRefresh(currentModel == null ? null : currentModel.values).then(() => {
            this.onUiChanged(false, 'prevent');
            afterUiUpdatedFunc === null || afterUiUpdatedFunc === void 0 ? void 0 : afterUiUpdatedFunc();
        });
    }
    handleCancelEnd(e) {
        this.setMiniFilter(null);
        super.handleCancelEnd(e);
    }
    onMiniFilterKeyDown(e) {
        const { excelMode, readOnly } = this.setFilterParams || {};
        if (e.key === KeyCode.ENTER && !excelMode && !readOnly) {
            this.filterOnAllVisibleValues();
        }
    }
    filterOnAllVisibleValues(applyImmediately = true) {
        const { readOnly } = this.setFilterParams || {};
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        if (!!readOnly) {
            throw new Error('Unable to filter in readOnly mode.');
        }
        this.valueModel.selectAllMatchingMiniFilter(true);
        this.checkAndRefreshVirtualList();
        this.onUiChanged(false, applyImmediately ? 'immediately' : 'debounce');
        this.showOrHideResults();
    }
    focusRowIfAlive(rowIndex) {
        if (rowIndex == null) {
            return;
        }
        window.setTimeout(() => {
            if (!this.virtualList) {
                throw new Error('Virtual list has not been created.');
            }
            if (this.isAlive()) {
                this.virtualList.focusRow(rowIndex);
            }
        }, 0);
    }
    onSelectAll(isSelected) {
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        if (!this.virtualList) {
            throw new Error('Virtual list has not been created.');
        }
        if (isSelected) {
            this.valueModel.selectAllMatchingMiniFilter();
        }
        else {
            this.valueModel.deselectAllMatchingMiniFilter();
        }
        this.refreshAfterSelection();
    }
    onGroupItemSelected(item, isSelected) {
        const recursiveGroupSelection = (i) => {
            if (i.children) {
                i.children.forEach(childItem => recursiveGroupSelection(childItem));
            }
            else {
                this.selectItem(i.key, isSelected);
            }
        };
        recursiveGroupSelection(item);
        this.refreshAfterSelection();
    }
    onItemSelected(key, isSelected) {
        if (!this.valueModel) {
            throw new Error('Value model has not been created.');
        }
        if (!this.virtualList) {
            throw new Error('Virtual list has not been created.');
        }
        this.selectItem(key, isSelected);
        this.refreshAfterSelection();
    }
    selectItem(key, isSelected) {
        if (isSelected) {
            this.valueModel.selectKey(key);
        }
        else {
            this.valueModel.deselectKey(key);
        }
    }
    onExpandAll(item, isExpanded) {
        const recursiveExpansion = (i) => {
            if (i.filterPasses && i.available && i.children) {
                i.children.forEach(childItem => recursiveExpansion(childItem));
                i.expanded = isExpanded;
            }
        };
        recursiveExpansion(item);
        this.refreshAfterExpansion();
    }
    onExpandedChanged(item, isExpanded) {
        item.expanded = isExpanded;
        this.refreshAfterExpansion();
    }
    refreshAfterExpansion() {
        const focusedRow = this.virtualList.getLastFocusedRow();
        this.valueModel.updateDisplayedValues('expansion');
        this.checkAndRefreshVirtualList();
        this.focusRowIfAlive(focusedRow);
    }
    refreshAfterSelection() {
        const focusedRow = this.virtualList.getLastFocusedRow();
        this.checkAndRefreshVirtualList();
        this.onUiChanged();
        this.focusRowIfAlive(focusedRow);
    }
    setMiniFilter(newMiniFilter) {
        this.eMiniFilter.setValue(newMiniFilter);
        this.onMiniFilterInput();
    }
    getMiniFilter() {
        return this.valueModel ? this.valueModel.getMiniFilter() : null;
    }
    checkAndRefreshVirtualList() {
        if (!this.virtualList) {
            throw new Error('Virtual list has not been created.');
        }
        this.virtualList.refresh(!this.hardRefreshVirtualList);
        if (this.hardRefreshVirtualList) {
            this.hardRefreshVirtualList = false;
        }
    }
    getFilterKeys() {
        return this.valueModel ? this.valueModel.getKeys() : [];
    }
    getFilterValues() {
        return this.valueModel ? this.valueModel.getValues() : [];
    }
    getValues() {
        return this.getFilterKeys();
    }
    refreshVirtualList() {
        if (this.setFilterParams && this.setFilterParams.refreshValuesOnOpen) {
            this.refreshFilterValues();
        }
        else {
            this.checkAndRefreshVirtualList();
        }
    }
    translateForSetFilter(key) {
        const translate = this.localeService.getLocaleTextFunc();
        return translate(key, DEFAULT_LOCALE_TEXT[key]);
    }
    isSelectAllSelected() {
        if (!this.setFilterParams || !this.valueModel) {
            return false;
        }
        if (!this.setFilterParams.defaultToNothingSelected) {
            // everything selected by default
            if (this.valueModel.hasSelections() && this.valueModel.isNothingVisibleSelected()) {
                return false;
            }
            if (this.valueModel.isEverythingVisibleSelected()) {
                return true;
            }
        }
        else {
            // nothing selected by default
            if (this.valueModel.hasSelections() && this.valueModel.isEverythingVisibleSelected()) {
                return true;
            }
            if (this.valueModel.isNothingVisibleSelected()) {
                return false;
            }
        }
        // returning `undefined` means the checkbox status is indeterminate.
        return undefined;
    }
    areAllChildrenSelected(item) {
        const recursiveChildSelectionCheck = (i) => {
            if (i.children) {
                let someTrue = false;
                let someFalse = false;
                const mixed = i.children.some(child => {
                    if (!child.filterPasses || !child.available) {
                        return false;
                    }
                    const childSelected = recursiveChildSelectionCheck(child);
                    if (childSelected === undefined) {
                        return true;
                    }
                    if (childSelected) {
                        someTrue = true;
                    }
                    else {
                        someFalse = true;
                    }
                    return someTrue && someFalse;
                });
                // returning `undefined` means the checkbox status is indeterminate.
                // if not mixed and some true, all must be true
                return mixed ? undefined : someTrue;
            }
            else {
                return this.valueModel.isKeySelected(i.key);
            }
        };
        if (!this.setFilterParams.defaultToNothingSelected) {
            // everything selected by default
            return recursiveChildSelectionCheck(item);
        }
        else {
            // nothing selected by default
            return this.valueModel.hasSelections() && recursiveChildSelectionCheck(item);
        }
    }
    destroy() {
        if (this.virtualList != null) {
            this.virtualList.destroy();
            this.virtualList = null;
        }
        super.destroy();
    }
    caseFormat(valueToFormat) {
        if (valueToFormat == null || typeof valueToFormat !== 'string') {
            return valueToFormat;
        }
        return this.caseSensitive ? valueToFormat : valueToFormat.toUpperCase();
    }
    resetExpansion() {
        var _a, _b;
        if (!((_a = this.setFilterParams) === null || _a === void 0 ? void 0 : _a.treeList)) {
            return;
        }
        const selectAllItem = (_b = this.valueModel) === null || _b === void 0 ? void 0 : _b.getSelectAllItem();
        if (this.isSetFilterModelTreeItem(selectAllItem)) {
            const recursiveCollapse = (i) => {
                if (i.children) {
                    i.children.forEach(childItem => recursiveCollapse(childItem));
                    i.expanded = false;
                }
            };
            recursiveCollapse(selectAllItem);
            this.valueModel.updateDisplayedValues('expansion');
        }
    }
    getModelAsString(model) {
        return this.filterModelFormatter.getModelAsString(model, this);
    }
    getPositionableElement() {
        return this.eSetFilterList;
    }
}
__decorate$21([
    RefSelector('eMiniFilter')
], SetFilter.prototype, "eMiniFilter", void 0);
__decorate$21([
    RefSelector('eFilterLoading')
], SetFilter.prototype, "eFilterLoading", void 0);
__decorate$21([
    RefSelector('eSetFilterList')
], SetFilter.prototype, "eSetFilterList", void 0);
__decorate$21([
    RefSelector('eFilterNoMatches')
], SetFilter.prototype, "eNoMatches", void 0);
__decorate$21([
    Autowired('valueFormatterService')
], SetFilter.prototype, "valueFormatterService", void 0);
__decorate$21([
    Autowired('columnModel')
], SetFilter.prototype, "columnModel", void 0);
__decorate$21([
    Autowired('valueService')
], SetFilter.prototype, "valueService", void 0);
class ModelWrapper {
    constructor(model) {
        this.model = model;
    }
    getRowCount() {
        return this.model.getDisplayedValueCount();
    }
    getRow(index) {
        return this.model.getDisplayedItem(index);
    }
    areRowsEqual(oldRow, newRow) {
        return oldRow === newRow;
    }
}
class ModelWrapperWithSelectAll {
    constructor(model, isSelectAllSelected) {
        this.model = model;
        this.isSelectAllSelected = isSelectAllSelected;
    }
    getRowCount() {
        const showAddCurrentSelectionToFilter = this.model.showAddCurrentSelectionToFilter();
        const outboundItems = showAddCurrentSelectionToFilter ? 2 : 1;
        return this.model.getDisplayedValueCount() + outboundItems;
    }
    getRow(index) {
        if (index === 0) {
            return this.model.getSelectAllItem();
        }
        const showAddCurrentSelectionToFilter = this.model.showAddCurrentSelectionToFilter();
        const outboundItems = showAddCurrentSelectionToFilter ? 2 : 1;
        if (index === 1 && showAddCurrentSelectionToFilter) {
            return this.model.getAddSelectionToFilterItem();
        }
        return this.model.getDisplayedItem(index - outboundItems);
    }
    areRowsEqual(oldRow, newRow) {
        return oldRow === newRow;
    }
}
// isRowSelected is used by VirtualList to add aria tags for flat lists. We want to suppress this when using trees
class TreeModelWrapper {
    constructor(model) {
        this.model = model;
    }
    getRowCount() {
        return this.model.getRowCount();
    }
    getRow(index) {
        return this.model.getRow(index);
    }
    areRowsEqual(oldRow, newRow) {
        if (oldRow == null && newRow == null) {
            return true;
        }
        return oldRow != null && newRow != null && oldRow.treeKey === newRow.treeKey && oldRow.depth === newRow.depth;
    }
}

var __decorate$22 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SetFloatingFilterComp extends Component {
    constructor() {
        super(/* html */ `
            <div class="ag-floating-filter-input ag-set-floating-filter-input" role="presentation">
                <ag-input-text-field ref="eFloatingFilterText"></ag-input-text-field>
            </div>`);
        this.availableValuesListenerAdded = false;
        this.filterModelFormatter = new SetFilterModelFormatter();
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
    init(params) {
        this.params = params;
        this.eFloatingFilterText
            .setDisabled(true)
            .addGuiEventListener('click', () => this.params.showParentFilter());
        this.setParams(params);
    }
    setParams(params) {
        const displayName = this.columnModel.getDisplayNameForColumn(params.column, 'header', true);
        const translate = this.localeService.getLocaleTextFunc();
        this.eFloatingFilterText.setInputAriaLabel(`${displayName} ${translate('ariaFilterInput', 'Filter Input')}`);
    }
    onParamsUpdated(params) {
        this.refresh(params);
    }
    refresh(params) {
        this.params = params;
        this.setParams(params);
    }
    onParentModelChanged(parentModel) {
        this.updateFloatingFilterText(parentModel);
    }
    parentSetFilterInstance(cb) {
        this.params.parentFilterInstance((filter) => {
            if (!(filter instanceof SetFilter)) {
                throw new Error('AG Grid - SetFloatingFilter expects SetFilter as its parent');
            }
            cb(filter);
        });
    }
    addAvailableValuesListener() {
        this.parentSetFilterInstance((setFilter) => {
            const setValueModel = setFilter.getValueModel();
            if (!setValueModel) {
                return;
            }
            // unlike other filters, what we show in the floating filter can be different, even
            // if another filter changes. this is due to how set filter restricts its values based
            // on selections in other filters, e.g. if you filter Language to English, then the set filter
            // on Country will only show English speaking countries. Thus the list of items to show
            // in the floating filter can change.
            this.addManagedListener(setValueModel, SetValueModel.EVENT_AVAILABLE_VALUES_CHANGED, () => this.updateFloatingFilterText());
        });
        this.availableValuesListenerAdded = true;
    }
    updateFloatingFilterText(parentModel) {
        if (!this.availableValuesListenerAdded) {
            this.addAvailableValuesListener();
        }
        this.parentSetFilterInstance((setFilter) => {
            this.eFloatingFilterText.setValue(this.filterModelFormatter.getModelAsString(parentModel, setFilter));
        });
    }
}
__decorate$22([
    RefSelector('eFloatingFilterText')
], SetFloatingFilterComp.prototype, "eFloatingFilterText", void 0);
__decorate$22([
    Autowired('columnModel')
], SetFloatingFilterComp.prototype, "columnModel", void 0);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$h = '31.1.1';

const SetFilterModule = {
    version: VERSION$h,
    moduleName: ModuleNames.SetFilterModule,
    beans: [],
    userComponents: [
        { componentName: 'agSetColumnFilter', componentClass: SetFilter },
        { componentName: 'agSetColumnFloatingFilter', componentClass: SetFloatingFilterComp },
    ],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

const defaultTooltipCss$1 = `
.ag-sparkline-tooltip-wrapper {
    position: absolute;
    user-select: none;
    pointer-events: none;
}

.ag-sparkline-tooltip {
    position: relative;
    font: 12px arial,sans-serif;
    border-radius: 2px;
    box-shadow: 0 1px 3px rgb(0 0 0 / 20%), 0 1px 1px rgb(0 0 0 / 14%);
    line-height: 1.7em;
    overflow: hidden;
    white-space: nowrap;
    z-index: 99999;
    background-color: rgb(255, 255, 255);
    color: rgba(0,0,0, 0.67);
}

.ag-sparkline-tooltip-content {
    padding: 0 7px;
    opacity: 1;
}

.ag-sparkline-tooltip-title {
    padding-left: 7px;
    opacity: 1;
}

.ag-sparkline-tooltip-wrapper-hidden {
    top: -10000px !important;
}

.ag-sparkline-wrapper {
    box-sizing: border-box;
    overflow: hidden;
}
`;

const { extent: extent$2, isNumber: isNumber$2, isString: isString$2, isStringObject: isStringObject$1, isDate: isDate$2, createId: createId$2, Padding: Padding$2 } = sparklines_util_exports;
const { LinearScale: LinearScale$2, BandScale: BandScale$2, TimeScale: TimeScale$1 } = sparklines_scale_exports;
/**
 * Constants to declare the expected nominal zIndex for nodes in a sparkline rendering.
 */
var ZINDICIES;
(function (ZINDICIES) {
    ZINDICIES[ZINDICIES["SERIES_FILL_ZINDEX"] = 50] = "SERIES_FILL_ZINDEX";
    ZINDICIES[ZINDICIES["AXIS_LINE_ZINDEX"] = 500] = "AXIS_LINE_ZINDEX";
    ZINDICIES[ZINDICIES["SERIES_STROKE_ZINDEX"] = 1000] = "SERIES_STROKE_ZINDEX";
    ZINDICIES[ZINDICIES["SERIES_LABEL_ZINDEX"] = 1500] = "SERIES_LABEL_ZINDEX";
    ZINDICIES[ZINDICIES["CROSSHAIR_ZINDEX"] = 2000] = "CROSSHAIR_ZINDEX";
    ZINDICIES[ZINDICIES["SERIES_MARKERS_ZINDEX"] = 2500] = "SERIES_MARKERS_ZINDEX";
})(ZINDICIES || (ZINDICIES = {}));
class SparklineAxis {
    constructor() {
        this.type = 'category';
        this.stroke = 'rgb(204, 214, 235)';
        this.strokeWidth = 1;
    }
}
class Sparkline {
    constructor() {
        this.id = createId$2(this);
        this.seriesRect = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
        };
        this._context = undefined;
        this._container = undefined;
        this._data = undefined;
        this.padding = new Padding$2(3);
        this.xKey = 'x';
        this.yKey = 'y';
        this.dataType = undefined;
        this.xData = [];
        this.yData = [];
        // Minimum y value in provided data.
        this.min = undefined;
        // Maximum y value in provided data.
        this.max = undefined;
        this.yScale = new LinearScale$2();
        this.axis = new SparklineAxis();
        this.highlightStyle = {
            size: 6,
            fill: 'yellow',
            stroke: 'silver',
            strokeWidth: 1,
        };
        this._width = 100;
        this._height = 100;
        this.smallestInterval = undefined;
        this.layoutId = 0;
        this.defaultDateFormatter = new Intl.DateTimeFormat('en-US', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false,
        });
        this._onMouseMove = this.onMouseMove.bind(this);
        this._onMouseOut = this.onMouseOut.bind(this);
        const root = new integrated_charts_scene_exports.Group();
        this.rootGroup = root;
        const element = document.createElement('div');
        element.setAttribute('class', 'ag-sparkline-wrapper');
        // initialise scene
        const scene = new integrated_charts_scene_exports.Scene({ window, document });
        this.scene = scene;
        this.canvasElement = scene.canvas.element;
        // set scene properties
        scene.root = root;
        scene.container = element;
        this.resizeAndSetDimensions(this.width, this.height);
        // one style element for tooltip styles per document
        if (!Sparkline.tooltipDocuments.includes(document)) {
            this.initialiseTooltipStyles();
        }
        this.setupDomEventListeners(this.canvasElement);
    }
    set context(value) {
        if (this._context !== value) {
            this._context = value;
        }
    }
    get context() {
        return this._context;
    }
    set container(value) {
        if (this._container !== value) {
            const { parentNode } = this.canvasElement;
            if (parentNode != null) {
                parentNode.removeChild(this.canvasElement);
            }
            if (value) {
                value.appendChild(this.canvasElement);
            }
            this._container = value;
        }
    }
    get container() {
        return this._container;
    }
    set data(value) {
        if (this._data !== value) {
            this._data = value;
            this.processData();
            if (this.mouseMoveEvent && this.highlightedDatum) {
                this.updateHitPoint(this.mouseMoveEvent);
            }
        }
    }
    get data() {
        return this._data;
    }
    resizeAndSetDimensions(width, height) {
        this.scene.resize(width, height);
        this.seriesRect.width = width;
        this.seriesRect.height = height;
    }
    initialiseTooltipStyles() {
        const styleElement = document.createElement('style');
        styleElement.innerHTML = defaultTooltipCss$1;
        document.head.insertBefore(styleElement, document.head.querySelector('style'));
        Sparkline.tooltipDocuments.push(document);
    }
    set width(value) {
        if (this._width !== value) {
            this._width = value;
            this.scene.resize(value, this.height);
            this.scheduleLayout();
        }
    }
    get width() {
        return this._width;
    }
    set height(value) {
        if (this._height !== value) {
            this._height = value;
            this.scene.resize(this.width, value);
            this.scheduleLayout();
        }
    }
    get height() {
        return this._height;
    }
    /**
     * Generate node data from processed data.
     * Produce data joins.
     * Update selection's nodes using node data.
     */
    update() { }
    // Update y scale based on processed data.
    updateYScale() {
        this.updateYScaleRange();
        this.updateYScaleDomain();
    }
    // Update y scale domain based on processed data.
    updateYScaleDomain() { }
    // Update y scale range based on height and padding (seriesRect).
    updateYScaleRange() {
        const { yScale, seriesRect } = this;
        yScale.range = [seriesRect.height, 0];
    }
    // Update x scale based on processed data.
    updateXScale() {
        const { type } = this.axis;
        this.xScale = this.getXScale(type);
        this.updateXScaleRange();
        this.updateXScaleDomain();
    }
    // Update x scale range based on width and padding (seriesRect).
    updateXScaleRange() {
        this.xScale.range = [0, this.seriesRect.width];
    }
    // Update x scale domain based on processed data and type of scale.
    updateXScaleDomain() {
        const { xData, xScale } = this;
        let xMinMax;
        if (xScale instanceof LinearScale$2 || xScale instanceof TimeScale$1) {
            xMinMax = extent$2(xData);
        }
        this.xScale.domain = xMinMax ? xMinMax.slice() : xData;
    }
    /**
     * Return xScale instance based on the provided type or return a `BandScale` by default.
     * The default type is `category`.
     * @param type
     */
    getXScale(type = 'category') {
        switch (type) {
            case 'number':
                return new LinearScale$2();
            case 'time':
                return new TimeScale$1();
            case 'category':
            default:
                return new BandScale$2();
        }
    }
    // Update axis line.
    updateAxisLine() { }
    // Update X and Y scales and the axis line.
    updateAxes() {
        this.updateYScale();
        this.updateXScale();
        this.updateAxisLine();
    }
    // Update horizontal and vertical crosshair lines.
    updateCrosshairs() {
        this.updateXCrosshairLine();
        this.updateYCrosshairLine();
    }
    // Using processed data, generate data that backs visible nodes.
    generateNodeData() {
        return [];
    }
    // Returns persisted node data associated with the sparkline's data.
    getNodeData() {
        return [];
    }
    // Update the selection's nodes.
    updateNodes() { }
    // Update the vertical crosshair line.
    updateXCrosshairLine() { }
    // Update the horizontal crosshair line.
    updateYCrosshairLine() { }
    highlightDatum(closestDatum) {
        this.updateNodes();
    }
    dehighlightDatum() {
        this.highlightedDatum = undefined;
        this.updateNodes();
        this.updateCrosshairs();
    }
    /**
     * Highlight closest datum and display tooltip if enabled.
     * Only update if necessary, i.e. only update if the highlighted datum is different from previously highlighted datum,
     * or if there is no previously highlighted datum.
     * @param event
     */
    onMouseMove(event) {
        this.mouseMoveEvent = event;
        this.updateHitPoint(event);
    }
    updateHitPoint(event) {
        var _a, _b, _c;
        const closestDatum = this.pickClosestSeriesNodeDatum(event.offsetX, event.offsetY);
        if (!closestDatum) {
            return;
        }
        const oldHighlightedDatum = this.highlightedDatum;
        this.highlightedDatum = closestDatum;
        if ((this.highlightedDatum && !oldHighlightedDatum) ||
            (this.highlightedDatum && oldHighlightedDatum && this.highlightedDatum !== oldHighlightedDatum)) {
            this.highlightDatum(closestDatum);
            this.updateCrosshairs();
            this.scene.render().catch((e) => console.error(`AG Grid - chart rendering failed`, e));
        }
        const tooltipEnabled = (_c = (_b = (_a = this.processedOptions) === null || _a === void 0 ? void 0 : _a.tooltip) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : true;
        if (tooltipEnabled) {
            this.handleTooltip(event, closestDatum);
        }
    }
    /**
     * Dehighlight all nodes and remove tooltip.
     * @param event
     */
    onMouseOut(event) {
        this.dehighlightDatum();
        this.tooltip.toggle(false);
        this.scene.render().catch((e) => console.error(`AG Grid - chart rendering failed`, e));
    }
    // Fetch required values from the data object and process them.
    processData() {
        const { data, yData, xData } = this;
        if (!data || this.invalidData(this.data)) {
            return;
        }
        yData.length = 0;
        xData.length = 0;
        const n = data.length;
        const dataType = this.getDataType(data);
        this.dataType = dataType;
        const { type: xValueType } = this.axis;
        const xType = xValueType !== 'number' && xValueType !== 'time' ? 'category' : xValueType;
        const isContinuousX = xType === 'number' || xType === 'time';
        const setSmallestXInterval = (curr, prev) => {
            if (this.smallestInterval == undefined) {
                this.smallestInterval = { x: Infinity, y: Infinity };
            }
            const { x } = this.smallestInterval;
            const interval = Math.abs(curr - prev);
            if (interval > 0 && interval < x) {
                this.smallestInterval.x = interval;
            }
        };
        let prevX;
        if (dataType === 'number') {
            for (let i = 0; i < n; i++) {
                const xDatum = i;
                const yDatum = data[i];
                const x = this.getDatum(xDatum, xType);
                const y = this.getDatum(yDatum, 'number');
                if (isContinuousX) {
                    setSmallestXInterval(x, prevX);
                }
                xData.push(x);
                yData.push(y);
                prevX = x;
            }
        }
        else if (dataType === 'array') {
            for (let i = 0; i < n; i++) {
                const datum = data[i];
                if (Array.isArray(datum)) {
                    const xDatum = datum[0];
                    const yDatum = datum[1];
                    const x = this.getDatum(xDatum, xType);
                    const y = this.getDatum(yDatum, 'number');
                    if (x == undefined) {
                        continue;
                    }
                    if (isContinuousX) {
                        setSmallestXInterval(x, prevX);
                    }
                    xData.push(x);
                    yData.push(y);
                    prevX = x;
                }
            }
        }
        else if (dataType === 'object') {
            const { yKey, xKey } = this;
            for (let i = 0; i < n; i++) {
                const datum = data[i];
                if (typeof datum === 'object' && !Array.isArray(datum)) {
                    const xDatum = datum[xKey];
                    const yDatum = datum[yKey];
                    const x = this.getDatum(xDatum, xType);
                    const y = this.getDatum(yDatum, 'number');
                    if (x == undefined) {
                        continue;
                    }
                    if (isContinuousX) {
                        setSmallestXInterval(x, prevX);
                    }
                    xData.push(x);
                    yData.push(y);
                    prevX = x;
                }
            }
        }
        this.updateAxes();
        this.immediateLayout();
    }
    /**
     * Return the type of data provided to the sparkline based on the first truthy value in the data array.
     * If the value is not a number, array or object, return `undefined`.
     * @param data
     */
    getDataType(data) {
        for (const datum of data) {
            if (datum != undefined) {
                if (isNumber$2(datum)) {
                    return 'number';
                }
                else if (Array.isArray(datum)) {
                    return 'array';
                }
                else if (typeof datum === 'object') {
                    return 'object';
                }
            }
        }
    }
    /**
     * Return the given value depending on the type of axis.
     * Return `undefined` if the value is invalid for the given axis type.
     * @param value
     */
    getDatum(value, type) {
        if ((type === 'number' && isNumber$2(value)) || (type === 'time' && (isNumber$2(value) || isDate$2(value)))) {
            return value;
        }
        else if (type === 'category') {
            if (isString$2(value) || isDate$2(value) || isNumber$2(value)) {
                return { toString: () => String(value) };
            }
            else if (isStringObject$1(value)) {
                return value;
            }
        }
    }
    /**
     * Only `true` while we are waiting for the layout to start.
     * This will be `false` if the layout has already started and is ongoing.
     */
    get layoutScheduled() {
        return !!this.layoutId;
    }
    /**
     * Execute update method on the next available screen repaint to make changes to the canvas.
     * If we are waiting for a layout to start and a new layout is requested,
     * cancel the previous layout using the non 0 integer (this.layoutId) returned from requestAnimationFrame.
     */
    scheduleLayout() {
        if (this.layoutId) {
            cancelAnimationFrame(this.layoutId);
        }
        this.layoutId = requestAnimationFrame(() => {
            this.immediateLayout();
            this.layoutId = 0;
        });
    }
    immediateLayout() {
        this.setSparklineDimensions();
        if (this.invalidData(this.data)) {
            return;
        }
        // update axes ranges
        this.updateXScaleRange();
        this.updateYScaleRange();
        // update axis line
        this.updateAxisLine();
        // produce data joins and update selection's nodes
        this.update();
        this.scene.render().catch((e) => console.error(`AG Grid - chart rendering failed`, e));
    }
    setSparklineDimensions() {
        const { width, height, padding, seriesRect, rootGroup } = this;
        const shrunkWidth = width - padding.left - padding.right;
        const shrunkHeight = height - padding.top - padding.bottom;
        seriesRect.width = shrunkWidth;
        seriesRect.height = shrunkHeight;
        seriesRect.x = padding.left;
        seriesRect.y = padding.top;
        rootGroup.translationX = seriesRect.x;
        rootGroup.translationY = seriesRect.y;
    }
    /**
     * Return the closest data point to x/y canvas coordinates.
     * @param x
     * @param y
     */
    pickClosestSeriesNodeDatum(x, y) {
        let minDistance = Infinity;
        let closestDatum;
        const hitPoint = this.rootGroup.transformPoint(x, y);
        const nodeData = this.getNodeData();
        for (let i = 0; i < nodeData.length; i++) {
            const datum = nodeData[i];
            if (!datum.point) {
                return;
            }
            const distance = this.getDistance(hitPoint, datum.point);
            if (distance <= minDistance) {
                minDistance = distance;
                closestDatum = datum;
            }
        }
        return closestDatum;
    }
    /**
     * Return the relevant distance between two points.
     * The distance will be calculated based on the x value of the points for all sparklines except bar sparkline, where the distance is based on the y values.
     * @param x
     * @param y
     */
    getDistance(p1, p2) {
        return Math.abs(p1.x - p2.x);
    }
    /**
     * calculate x/y coordinates for tooltip based on coordinates of highlighted datum, position of canvas and page offset.
     * @param datum
     */
    handleTooltip(event, datum) {
        var _a, _b;
        const { seriesDatum } = datum;
        const { canvasElement } = this;
        const { clientX, clientY } = event;
        const tooltipOptions = (_a = this.processedOptions) === null || _a === void 0 ? void 0 : _a.tooltip;
        const meta = {
            pageX: clientX,
            pageY: clientY,
            position: {
                xOffset: tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.xOffset,
                yOffset: tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.yOffset,
            },
            container: tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.container,
        };
        // confine tooltip to sparkline width if tooltip container not provided.
        if (meta.container == undefined) {
            meta.container = canvasElement;
        }
        const yValue = seriesDatum.y;
        const xValue = seriesDatum.x;
        // check if tooltip is enabled for this specific data point
        let enabled = (_b = tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.enabled) !== null && _b !== void 0 ? _b : true;
        const tooltipRenderer = tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.renderer;
        if (tooltipRenderer) {
            const tooltipRendererResult = tooltipRenderer({
                context: this.context,
                datum: seriesDatum,
                yValue,
                xValue,
            });
            enabled =
                typeof tooltipRendererResult !== 'string' && tooltipRendererResult.enabled !== undefined
                    ? tooltipRendererResult.enabled
                    : enabled;
        }
        const html = enabled && seriesDatum.y !== undefined && this.getTooltipHtml(datum);
        if (html) {
            this.tooltip.show(meta, html);
        }
    }
    formatNumericDatum(datum) {
        return String(Math.round(datum * 10) / 10);
    }
    // locale.format('%m/%d/%y, %H:%M:%S');
    formatDatum(datum) {
        const type = this.axis.type || 'category';
        if (type === 'number' && typeof datum === 'number') {
            return this.formatNumericDatum(datum);
        }
        else if (type === 'time' && (datum instanceof Date || isNumber$2(datum))) {
            return this.defaultDateFormatter.format(datum);
        }
        else {
            return String(datum);
        }
    }
    setupDomEventListeners(chartElement) {
        chartElement.addEventListener('mousemove', this._onMouseMove);
        chartElement.addEventListener('mouseout', this._onMouseOut);
    }
    cleanupDomEventListeners(chartElement) {
        chartElement.removeEventListener('mousemove', this._onMouseMove);
        chartElement.removeEventListener('mouseout', this._onMouseOut);
    }
    invalidData(data) {
        return !data || !Array.isArray(data) || data.length === 0;
    }
    /**
     * Cleanup and remove canvas element from the DOM.
     */
    destroy() {
        this.scene.container = undefined;
        // remove canvas element from the DOM
        this.container = undefined;
        this.cleanupDomEventListeners(this.scene.canvas.element);
    }
}
Sparkline.tooltipDocuments = [];

function toTooltipHtml$1(input, defaults) {
    var _a, _b, _c;
    if (typeof input === 'string') {
        return input;
    }
    defaults = defaults !== null && defaults !== void 0 ? defaults : {};
    const { content = (_a = defaults.content) !== null && _a !== void 0 ? _a : '', title = (_b = defaults.title) !== null && _b !== void 0 ? _b : undefined, color = defaults.color, backgroundColor = defaults.backgroundColor, opacity = (_c = defaults.opacity) !== null && _c !== void 0 ? _c : 1, } = input;
    let titleHtml;
    let contentHtml;
    if (color) {
        titleHtml = title
            ? `<span class="${SparklineTooltip.class}-title"; style="color: ${color}">${title}</span>`
            : '';
        contentHtml = `<span class="${SparklineTooltip.class}-content" style="color: ${color}">${content}</span>`;
    }
    else {
        titleHtml = title ? `<span class="${SparklineTooltip.class}-title">${title}</span>` : '';
        contentHtml = `<span class="${SparklineTooltip.class}-content">${content}</span>`;
    }
    let style = `opacity: ${opacity}`;
    if (backgroundColor) {
        style += `; background-color: ${backgroundColor.toLowerCase()}`;
    }
    return `<div class="${SparklineTooltip.class}" style="${style}">
                ${titleHtml}
                ${contentHtml}
            </div>`;
}
class SparklineTooltip {
    constructor() {
        this.element = document.createElement('div');
        const tooltipRoot = document.body;
        tooltipRoot.appendChild(this.element);
    }
    isVisible() {
        const { element } = this;
        if (element.classList) {
            return !element.classList.contains(`${SparklineTooltip.class}-wrapper-hidden`);
        }
        // IE11
        const classes = element.getAttribute('class');
        if (classes) {
            return classes.split(' ').indexOf(`${SparklineTooltip.class}-wrapper-hidden`) < 0;
        }
        return false;
    }
    updateClass(visible) {
        const classList = [`${SparklineTooltip.class}-wrapper`];
        if (visible !== true) {
            classList.push(`${SparklineTooltip.class}-wrapper-hidden`);
        }
        this.element.setAttribute('class', classList.join(' '));
    }
    show(meta, html) {
        var _a, _b, _c, _d;
        this.toggle(false);
        const { element } = this;
        if (html !== undefined) {
            element.innerHTML = html;
        }
        else if (!element.innerHTML) {
            return;
        }
        const xOffset = (_b = (_a = meta.position) === null || _a === void 0 ? void 0 : _a.xOffset) !== null && _b !== void 0 ? _b : 10;
        const yOffset = (_d = (_c = meta.position) === null || _c === void 0 ? void 0 : _c.yOffset) !== null && _d !== void 0 ? _d : 0;
        let left = meta.pageX + xOffset;
        let top = meta.pageY + yOffset;
        const tooltipRect = element.getBoundingClientRect();
        let maxLeft = window.innerWidth - tooltipRect.width;
        if (meta.container) {
            const containerRect = meta.container.getBoundingClientRect();
            maxLeft = containerRect.left + (containerRect.width - tooltipRect.width);
        }
        if (left > maxLeft) {
            left = meta.pageX - element.clientWidth - xOffset;
        }
        if (typeof scrollX !== 'undefined') {
            left += scrollX;
        }
        if (typeof scrollY !== 'undefined') {
            top += scrollY;
        }
        element.style.left = `${Math.round(left)}px`;
        element.style.top = `${Math.round(top)}px`;
        this.toggle(true);
    }
    toggle(visible) {
        this.updateClass(visible);
    }
    destroy() {
        const { parentNode } = this.element;
        if (parentNode) {
            parentNode.removeChild(this.element);
        }
    }
}
SparklineTooltip.class = 'ag-sparkline-tooltip';

function getMarker$2(shape) {
    switch (shape) {
        case 'circle':
            return integrated_charts_scene_exports.Circle;
        case 'square':
            return integrated_charts_scene_exports.Square;
        case 'diamond':
            return integrated_charts_scene_exports.Diamond;
        default:
            return integrated_charts_scene_exports.Circle;
    }
}

function getLineDash(lineCap, lineDash = 'solid') {
    const buttOrNull = {
        solid: [],
        dash: [4, 3],
        dot: [1, 3],
        dashDot: [4, 3, 1, 3],
        dashDotDot: [4, 3, 1, 3, 1, 3],
        shortDot: [1, 1],
        shortDash: [3, 1],
        shortDashDot: [3, 1, 1, 1],
        shortDashDotDot: [3, 1, 1, 1, 1, 1],
        longDash: [8, 3],
        longDashDot: [8, 3, 1, 3],
        longDashDotDot: [8, 3, 1, 3, 1, 3]
    };
    const roundOrSquare = {
        solid: [],
        dash: [3, 3],
        dot: [0, 3],
        dashDot: [3, 3, 0, 3],
        dashDotDot: [3, 3, 0, 3, 0, 3],
        shortDot: [0, 2],
        shortDash: [2, 2],
        shortDashDot: [2, 2, 0, 2],
        shortDashDotDot: [2, 2, 0, 2, 0, 2],
        longDash: [7, 3],
        longDashDot: [7, 3, 0, 3],
        longDashDotDot: [7, 3, 0, 3, 0, 3]
    };
    if (lineCap === 'round' || lineCap === 'square') {
        if (roundOrSquare[lineDash] == undefined) {
            console.warn(`'${lineDash}' is not a valid 'lineDash' option.`);
            return roundOrSquare.solid;
        }
        return roundOrSquare[lineDash];
    }
    if (buttOrNull[lineDash] == undefined) {
        console.warn(`'${lineDash}' is not a valid 'lineDash' option.`);
        return buttOrNull.solid;
    }
    return buttOrNull[lineDash];
}

const { extent: extent$3 } = sparklines_util_exports;
const { BandScale: BandScale$3 } = sparklines_scale_exports;
class SparklineMarker {
    constructor() {
        this.enabled = true;
        this.shape = 'circle';
        this.size = 0;
        this.fill = 'rgb(124, 181, 236)';
        this.stroke = 'rgb(124, 181, 236)';
        this.strokeWidth = 1;
        this.formatter = undefined;
    }
}
class SparklineLine {
    constructor() {
        this.stroke = 'rgb(124, 181, 236)';
        this.strokeWidth = 1;
    }
}
class SparklineCrosshairs {
    constructor() {
        this.xLine = {
            enabled: true,
            stroke: 'rgba(0,0,0, 0.54)',
            strokeWidth: 1,
            lineDash: 'solid',
            lineCap: undefined,
        };
        this.yLine = {
            enabled: false,
            stroke: 'rgba(0,0,0, 0.54)',
            strokeWidth: 1,
            lineDash: 'solid',
            lineCap: undefined,
        };
    }
}
class AreaSparkline extends Sparkline {
    constructor() {
        super();
        this.fill = 'rgba(124, 181, 236, 0.25)';
        this.strokePath = new integrated_charts_scene_exports.Path();
        this.fillPath = new integrated_charts_scene_exports.Path();
        this.xCrosshairLine = new integrated_charts_scene_exports.Line();
        this.yCrosshairLine = new integrated_charts_scene_exports.Line();
        this.areaSparklineGroup = new integrated_charts_scene_exports.Group();
        this.xAxisLine = new integrated_charts_scene_exports.Line();
        this.markers = new integrated_charts_scene_exports.Group();
        this.markerSelection = integrated_charts_scene_exports.Selection.select(this.markers, () => this.markerFactory());
        this.markerSelectionData = [];
        this.marker = new SparklineMarker();
        this.line = new SparklineLine();
        this.crosshairs = new SparklineCrosshairs();
        this.rootGroup.append(this.areaSparklineGroup);
        this.xAxisLine.zIndex = ZINDICIES.AXIS_LINE_ZINDEX;
        this.fillPath.zIndex = ZINDICIES.SERIES_FILL_ZINDEX;
        this.strokePath.zIndex = ZINDICIES.SERIES_STROKE_ZINDEX;
        this.xCrosshairLine.zIndex = ZINDICIES.CROSSHAIR_ZINDEX;
        this.yCrosshairLine.zIndex = ZINDICIES.CROSSHAIR_ZINDEX;
        this.markers.zIndex = ZINDICIES.SERIES_MARKERS_ZINDEX;
        this.areaSparklineGroup.append([
            this.fillPath,
            this.xAxisLine,
            this.strokePath,
            this.xCrosshairLine,
            this.yCrosshairLine,
            this.markers,
        ]);
    }
    markerFactory() {
        const { shape } = this.marker;
        const MarkerShape = getMarker$2(shape);
        return new MarkerShape();
    }
    getNodeData() {
        return this.markerSelectionData;
    }
    update() {
        const data = this.generateNodeData();
        if (!data) {
            return;
        }
        const { nodeData, fillData, strokeData } = data;
        this.markerSelectionData = nodeData;
        this.updateSelection(nodeData);
        this.updateNodes();
        this.updateStroke(strokeData);
        this.updateFill(fillData);
    }
    updateYScaleDomain() {
        const { yData, yScale } = this;
        const yMinMax = extent$3(yData);
        let yMin = 0;
        let yMax = 1;
        if (yMinMax !== undefined) {
            yMin = this.min = yMinMax[0];
            yMax = this.max = yMinMax[1];
        }
        // if yMin is positive, set yMin to 0
        yMin = yMin < 0 ? yMin : 0;
        // if yMax is negative, set yMax to 0
        yMax = yMax < 0 ? 0 : yMax;
        yScale.domain = [yMin, yMax];
    }
    generateNodeData() {
        const { data, yData, xData, xScale, yScale } = this;
        if (!data) {
            return;
        }
        const continuous = !(xScale instanceof BandScale$3);
        const offsetX = !continuous ? xScale.bandwidth / 2 : 0;
        const n = yData.length;
        const nodeData = [];
        const fillData = [];
        const strokeData = [];
        let firstValidX;
        let lastValidX;
        let previousX;
        let nextX;
        const yZero = yScale.convert(0);
        for (let i = 0; i < n; i++) {
            const yDatum = yData[i];
            const xDatum = xData[i];
            const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;
            const y = yDatum === undefined ? NaN : yScale.convert(yDatum);
            // if this iteration is not the last, set nextX using the next value in the data array
            if (i + 1 < n) {
                nextX = xScale.convert(continuous ? xScale.toDomain(xData[i + 1]) : xData[i + 1]) + offsetX;
            }
            // set stroke data regardless of missing/ undefined values. Undefined values will be handled in the updateStroke() method
            strokeData.push({
                seriesDatum: { x: xDatum, y: yDatum },
                point: { x, y },
            });
            if (yDatum === undefined && previousX !== undefined) {
                // if yDatum is undefined and there is a valid previous data point, add a phantom point at yZero
                // if a next data point exists, add a phantom point at yZero at the next X
                fillData.push({ seriesDatum: undefined, point: { x: previousX, y: yZero } });
                if (nextX !== undefined) {
                    fillData.push({ seriesDatum: undefined, point: { x: nextX, y: yZero } });
                }
            }
            else if (yDatum !== undefined) {
                fillData.push({
                    seriesDatum: { x: xDatum, y: yDatum },
                    point: { x, y },
                });
                // set node data only if yDatum is not undefined. These values are used in the updateSelection() method to update markers
                nodeData.push({
                    seriesDatum: { x: xDatum, y: yDatum },
                    point: { x, y },
                });
                firstValidX = firstValidX !== undefined ? firstValidX : x;
                lastValidX = x;
            }
            previousX = x;
        }
        // phantom points for creating closed area
        fillData.push({ seriesDatum: undefined, point: { x: lastValidX, y: yZero } }, { seriesDatum: undefined, point: { x: firstValidX, y: yZero } });
        return { nodeData, fillData, strokeData };
    }
    updateAxisLine() {
        const { xScale, yScale, axis, xAxisLine } = this;
        xAxisLine.x1 = xScale.range[0];
        xAxisLine.x2 = xScale.range[1];
        xAxisLine.y1 = xAxisLine.y2 = 0;
        xAxisLine.stroke = axis.stroke;
        xAxisLine.strokeWidth = axis.strokeWidth;
        const yZero = yScale.convert(0);
        xAxisLine.translationY = yZero;
    }
    updateSelection(selectionData) {
        this.markerSelection.update(selectionData);
    }
    updateNodes() {
        const { highlightedDatum, highlightStyle, marker } = this;
        const { size: highlightSize, fill: highlightFill, stroke: highlightStroke, strokeWidth: highlightStrokeWidth, } = highlightStyle;
        const markerFormatter = marker.formatter;
        this.markerSelection.each((node, datum, index) => {
            const { point, seriesDatum } = datum;
            if (!point) {
                return;
            }
            const highlighted = datum === highlightedDatum;
            const markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill;
            const markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke;
            const markerStrokeWidth = highlighted && highlightStrokeWidth !== undefined ? highlightStrokeWidth : marker.strokeWidth;
            const markerSize = highlighted && highlightSize !== undefined ? highlightSize : marker.size;
            let markerFormat;
            if (markerFormatter) {
                const first = index === 0;
                const last = index === this.markerSelectionData.length - 1;
                const min = seriesDatum.y === this.min;
                const max = seriesDatum.y === this.max;
                markerFormat = markerFormatter({
                    datum,
                    xValue: seriesDatum.x,
                    yValue: seriesDatum.y,
                    min,
                    max,
                    first,
                    last,
                    fill: markerFill,
                    stroke: markerStroke,
                    strokeWidth: markerStrokeWidth,
                    size: markerSize,
                    highlighted,
                });
            }
            node.size = markerFormat && markerFormat.size != undefined ? markerFormat.size : markerSize;
            node.fill = markerFormat && markerFormat.fill != undefined ? markerFormat.fill : markerFill;
            node.stroke = markerFormat && markerFormat.stroke != undefined ? markerFormat.stroke : markerStroke;
            node.strokeWidth =
                markerFormat && markerFormat.strokeWidth != undefined ? markerFormat.strokeWidth : markerStrokeWidth;
            node.translationX = point.x;
            node.translationY = point.y;
            node.visible =
                markerFormat && markerFormat.enabled != undefined
                    ? markerFormat.enabled
                    : marker.enabled && node.size > 0;
        });
    }
    updateStroke(strokeData) {
        const { strokePath, yData, line } = this;
        if (yData.length < 2) {
            return;
        }
        const path = strokePath.path;
        const n = strokeData.length;
        let moveTo = true;
        path.clear();
        for (let i = 0; i < n; i++) {
            const { point, seriesDatum } = strokeData[i];
            const x = point.x;
            const y = point.y;
            if (seriesDatum.y == undefined) {
                moveTo = true;
            }
            else {
                if (moveTo) {
                    path.moveTo(x, y);
                    moveTo = false;
                }
                else {
                    path.lineTo(x, y);
                }
            }
        }
        strokePath.lineJoin = strokePath.lineCap = 'round';
        strokePath.fill = undefined;
        strokePath.stroke = line.stroke;
        strokePath.strokeWidth = line.strokeWidth;
    }
    updateFill(areaData) {
        const { fillPath, yData, fill } = this;
        const path = fillPath.path;
        const n = areaData.length;
        path.clear();
        if (yData.length < 2) {
            return;
        }
        for (let i = 0; i < n; i++) {
            const { point } = areaData[i];
            const x = point.x;
            const y = point.y;
            if (i > 0) {
                path.lineTo(x, y);
            }
            else {
                path.moveTo(x, y);
            }
        }
        path.closePath();
        fillPath.lineJoin = 'round';
        fillPath.stroke = undefined;
        fillPath.fill = fill;
    }
    updateXCrosshairLine() {
        var _a;
        const { yScale, xCrosshairLine, highlightedDatum, crosshairs: { xLine }, } = this;
        if (!xLine.enabled || highlightedDatum == undefined) {
            xCrosshairLine.strokeWidth = 0;
            return;
        }
        xCrosshairLine.y1 = yScale.range[0];
        xCrosshairLine.y2 = yScale.range[1];
        xCrosshairLine.x1 = xCrosshairLine.x2 = 0;
        xCrosshairLine.stroke = xLine.stroke;
        xCrosshairLine.strokeWidth = (_a = xLine.strokeWidth) !== null && _a !== void 0 ? _a : 1;
        xCrosshairLine.lineCap = xLine.lineCap === 'round' || xLine.lineCap === 'square' ? xLine.lineCap : undefined;
        const { lineDash } = xLine;
        xCrosshairLine.lineDash = Array.isArray(lineDash)
            ? lineDash
            : getLineDash(xCrosshairLine.lineCap, xLine.lineDash);
        xCrosshairLine.translationX = highlightedDatum.point.x;
    }
    updateYCrosshairLine() {
        var _a;
        const { xScale, yCrosshairLine, highlightedDatum, crosshairs: { yLine }, } = this;
        if (!yLine.enabled || highlightedDatum == undefined) {
            yCrosshairLine.strokeWidth = 0;
            return;
        }
        yCrosshairLine.x1 = xScale.range[0];
        yCrosshairLine.x2 = xScale.range[1];
        yCrosshairLine.y1 = yCrosshairLine.y2 = 0;
        yCrosshairLine.stroke = yLine.stroke;
        yCrosshairLine.strokeWidth = (_a = yLine.strokeWidth) !== null && _a !== void 0 ? _a : 1;
        yCrosshairLine.lineCap = yLine.lineCap === 'round' || yLine.lineCap === 'square' ? yLine.lineCap : undefined;
        const { lineDash } = yLine;
        yCrosshairLine.lineDash = Array.isArray(lineDash)
            ? lineDash
            : getLineDash(yCrosshairLine.lineCap, yLine.lineDash);
        yCrosshairLine.translationY = highlightedDatum.point.y;
    }
    getTooltipHtml(datum) {
        var _a, _b;
        const { dataType } = this;
        const { seriesDatum } = datum;
        const yValue = seriesDatum.y;
        const xValue = seriesDatum.x;
        const content = this.formatNumericDatum(yValue);
        const title = dataType === 'array' || dataType === 'object' ? this.formatDatum(xValue) : undefined;
        const defaults = {
            content,
            title,
        };
        const tooltipRenderer = (_b = (_a = this.processedOptions) === null || _a === void 0 ? void 0 : _a.tooltip) === null || _b === void 0 ? void 0 : _b.renderer;
        if (tooltipRenderer) {
            return toTooltipHtml$1(tooltipRenderer({
                context: this.context,
                datum: seriesDatum,
                yValue,
                xValue,
            }), defaults);
        }
        return toTooltipHtml$1(defaults);
    }
}
AreaSparkline.className = 'AreaSparkline';

const { extent: extent$4 } = sparklines_util_exports;
const { BandScale: BandScale$4 } = sparklines_scale_exports;
class SparklineMarker$1 {
    constructor() {
        this.enabled = true;
        this.shape = 'circle';
        this.size = 0;
        this.fill = 'rgb(124, 181, 236)';
        this.stroke = 'rgb(124, 181, 236)';
        this.strokeWidth = 1;
        this.formatter = undefined;
    }
}
class SparklineLine$1 {
    constructor() {
        this.stroke = 'rgb(124, 181, 236)';
        this.strokeWidth = 1;
    }
}
class SparklineCrosshairs$1 {
    constructor() {
        this.xLine = {
            enabled: true,
            stroke: 'rgba(0,0,0, 0.54)',
            strokeWidth: 1,
            lineDash: 'solid',
            lineCap: undefined,
        };
        this.yLine = {
            enabled: false,
            stroke: 'rgba(0,0,0, 0.54)',
            strokeWidth: 1,
            lineDash: 'solid',
            lineCap: undefined,
        };
    }
}
class LineSparkline extends Sparkline {
    constructor() {
        super();
        this.linePath = new integrated_charts_scene_exports.Path();
        this.xCrosshairLine = new integrated_charts_scene_exports.Line();
        this.yCrosshairLine = new integrated_charts_scene_exports.Line();
        this.lineSparklineGroup = new integrated_charts_scene_exports.Group();
        this.markers = new integrated_charts_scene_exports.Group();
        this.markerSelection = integrated_charts_scene_exports.Selection.select(this.markers, () => this.markerFactory());
        this.markerSelectionData = [];
        this.marker = new SparklineMarker$1();
        this.line = new SparklineLine$1();
        this.crosshairs = new SparklineCrosshairs$1();
        this.rootGroup.append(this.lineSparklineGroup);
        this.linePath.zIndex = ZINDICIES.SERIES_STROKE_ZINDEX;
        this.xCrosshairLine.zIndex = ZINDICIES.CROSSHAIR_ZINDEX;
        this.yCrosshairLine.zIndex = ZINDICIES.CROSSHAIR_ZINDEX;
        this.markers.zIndex = ZINDICIES.SERIES_MARKERS_ZINDEX;
        this.lineSparklineGroup.append([this.linePath, this.xCrosshairLine, this.yCrosshairLine, this.markers]);
    }
    getNodeData() {
        return this.markerSelectionData;
    }
    markerFactory() {
        const { shape } = this.marker;
        const MarkerShape = getMarker$2(shape);
        return new MarkerShape();
    }
    /**
     * If marker shape is changed, this method should be called to remove the previous marker nodes selection.
     */
    onMarkerShapeChange() {
        this.markerSelection = this.markerSelection.clear();
        this.scheduleLayout();
    }
    update() {
        const nodeData = this.generateNodeData();
        if (!nodeData) {
            return;
        }
        this.markerSelectionData = nodeData;
        this.updateSelection(nodeData);
        this.updateNodes();
        this.updateLine();
    }
    updateYScaleDomain() {
        const { yData, yScale } = this;
        const yMinMax = extent$4(yData);
        let yMin = 0;
        let yMax = 1;
        if (yMinMax !== undefined) {
            yMin = this.min = yMinMax[0];
            yMax = this.max = yMinMax[1];
        }
        if (yMin === yMax) {
            // if all values in the data are the same, yMin and yMax will be equal, need to adjust the domain with some padding
            const padding = Math.abs(yMin * 0.01);
            yMin -= padding;
            yMax += padding;
        }
        yScale.domain = [yMin, yMax];
    }
    generateNodeData() {
        const { data, yData, xData, xScale, yScale } = this;
        if (!data) {
            return;
        }
        const continuous = !(xScale instanceof BandScale$4);
        const offsetX = !continuous ? xScale.bandwidth / 2 : 0;
        const nodeData = [];
        for (let i = 0; i < yData.length; i++) {
            const yDatum = yData[i];
            const xDatum = xData[i];
            if (yDatum == undefined) {
                continue;
            }
            const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;
            const y = yDatum === undefined ? NaN : yScale.convert(yDatum);
            nodeData.push({
                seriesDatum: { x: xDatum, y: yDatum },
                point: { x, y },
            });
        }
        return nodeData;
    }
    updateSelection(selectionData) {
        this.markerSelection.update(selectionData);
    }
    updateNodes() {
        const { highlightedDatum, highlightStyle, marker } = this;
        const { size: highlightSize, fill: highlightFill, stroke: highlightStroke, strokeWidth: highlightStrokeWidth, } = highlightStyle;
        const markerFormatter = marker.formatter;
        this.markerSelection.each((node, datum, index) => {
            const highlighted = datum === highlightedDatum;
            const markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill;
            const markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke;
            const markerStrokeWidth = highlighted && highlightStrokeWidth !== undefined ? highlightStrokeWidth : marker.strokeWidth;
            const markerSize = highlighted && highlightSize !== undefined ? highlightSize : marker.size;
            let markerFormat;
            const { seriesDatum, point } = datum;
            if (markerFormatter) {
                const first = index === 0;
                const last = index === this.markerSelectionData.length - 1;
                const min = seriesDatum.y === this.min;
                const max = seriesDatum.y === this.max;
                markerFormat = markerFormatter({
                    datum,
                    xValue: seriesDatum.x,
                    yValue: seriesDatum.y,
                    min,
                    max,
                    first,
                    last,
                    fill: markerFill,
                    stroke: markerStroke,
                    strokeWidth: markerStrokeWidth,
                    size: markerSize,
                    highlighted,
                });
            }
            node.size = markerFormat && markerFormat.size != undefined ? markerFormat.size : markerSize;
            node.fill = markerFormat && markerFormat.fill != undefined ? markerFormat.fill : markerFill;
            node.stroke = markerFormat && markerFormat.stroke != undefined ? markerFormat.stroke : markerStroke;
            node.strokeWidth =
                markerFormat && markerFormat.strokeWidth != undefined ? markerFormat.strokeWidth : markerStrokeWidth;
            node.translationX = point.x;
            node.translationY = point.y;
            node.visible =
                markerFormat && markerFormat.enabled != undefined
                    ? markerFormat.enabled
                    : marker.enabled && node.size > 0;
        });
    }
    updateLine() {
        const { linePath, yData, xData, xScale, yScale, line } = this;
        if (yData.length < 2) {
            return;
        }
        const continuous = !(xScale instanceof BandScale$4);
        const path = linePath.path;
        const n = yData.length;
        const offsetX = !continuous ? xScale.bandwidth / 2 : 0;
        let moveTo = true;
        path.clear();
        for (let i = 0; i < n; i++) {
            const xDatum = xData[i];
            const yDatum = yData[i];
            const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum) + offsetX;
            const y = yDatum === undefined ? NaN : yScale.convert(yDatum);
            if (yDatum == undefined) {
                moveTo = true;
            }
            else {
                if (moveTo) {
                    path.moveTo(x, y);
                    moveTo = false;
                }
                else {
                    path.lineTo(x, y);
                }
            }
        }
        linePath.fill = undefined;
        linePath.stroke = line.stroke;
        linePath.strokeWidth = line.strokeWidth;
    }
    updateXCrosshairLine() {
        var _a;
        const { yScale, xCrosshairLine, highlightedDatum, crosshairs: { xLine }, } = this;
        if (!xLine.enabled || highlightedDatum == undefined) {
            xCrosshairLine.strokeWidth = 0;
            return;
        }
        xCrosshairLine.y1 = yScale.range[0];
        xCrosshairLine.y2 = yScale.range[1];
        xCrosshairLine.x1 = xCrosshairLine.x2 = 0;
        xCrosshairLine.stroke = xLine.stroke;
        xCrosshairLine.strokeWidth = (_a = xLine.strokeWidth) !== null && _a !== void 0 ? _a : 1;
        xCrosshairLine.lineCap = xLine.lineCap === 'round' || xLine.lineCap === 'square' ? xLine.lineCap : undefined;
        const { lineDash } = xLine;
        xCrosshairLine.lineDash = Array.isArray(lineDash)
            ? lineDash
            : getLineDash(xCrosshairLine.lineCap, xLine.lineDash);
        xCrosshairLine.translationX = highlightedDatum.point.x;
    }
    updateYCrosshairLine() {
        var _a;
        const { xScale, yCrosshairLine, highlightedDatum, crosshairs: { yLine }, } = this;
        if (!yLine.enabled || highlightedDatum == undefined) {
            yCrosshairLine.strokeWidth = 0;
            return;
        }
        yCrosshairLine.x1 = xScale.range[0];
        yCrosshairLine.x2 = xScale.range[1];
        yCrosshairLine.y1 = yCrosshairLine.y2 = 0;
        yCrosshairLine.stroke = yLine.stroke;
        yCrosshairLine.strokeWidth = (_a = yLine.strokeWidth) !== null && _a !== void 0 ? _a : 1;
        yCrosshairLine.lineCap = yLine.lineCap === 'round' || yLine.lineCap === 'square' ? yLine.lineCap : undefined;
        const { lineDash } = yLine;
        yCrosshairLine.lineDash = Array.isArray(lineDash)
            ? lineDash
            : getLineDash(yCrosshairLine.lineCap, yLine.lineDash);
        yCrosshairLine.translationY = highlightedDatum.point.y;
    }
    getTooltipHtml(datum) {
        var _a, _b;
        const { dataType } = this;
        const { seriesDatum } = datum;
        const yValue = seriesDatum.y;
        const xValue = seriesDatum.x;
        const content = this.formatNumericDatum(yValue);
        const title = dataType === 'array' || dataType === 'object' ? this.formatDatum(xValue) : undefined;
        const defaults = {
            content,
            title,
        };
        const tooltipRenderer = (_b = (_a = this.processedOptions) === null || _a === void 0 ? void 0 : _a.tooltip) === null || _b === void 0 ? void 0 : _b.renderer;
        if (tooltipRenderer) {
            return toTooltipHtml$1(tooltipRenderer({
                context: this.context,
                datum: seriesDatum,
                yValue,
                xValue,
            }), defaults);
        }
        return toTooltipHtml$1(defaults);
    }
}
LineSparkline.className = 'LineSparkline';

class Label$2 {
    constructor() {
        this.enabled = true;
        this.fontSize = 8;
        this.fontFamily = 'Verdana, sans-serif';
        this.fontStyle = undefined;
        this.fontWeight = undefined;
        this.color = 'rgba(70, 70, 70, 1)';
    }
}

const { extent: extent$5 } = sparklines_util_exports;
var BarColumnNodeTag;
(function (BarColumnNodeTag) {
    BarColumnNodeTag[BarColumnNodeTag["Rect"] = 0] = "Rect";
    BarColumnNodeTag[BarColumnNodeTag["Label"] = 1] = "Label";
})(BarColumnNodeTag || (BarColumnNodeTag = {}));
var BarColumnLabelPlacement;
(function (BarColumnLabelPlacement) {
    BarColumnLabelPlacement["InsideBase"] = "insideBase";
    BarColumnLabelPlacement["InsideEnd"] = "insideEnd";
    BarColumnLabelPlacement["Center"] = "center";
    BarColumnLabelPlacement["OutsideEnd"] = "outsideEnd";
})(BarColumnLabelPlacement || (BarColumnLabelPlacement = {}));
class BarColumnLabel extends Label$2 {
    constructor() {
        super(...arguments);
        this.formatter = undefined;
        this.placement = BarColumnLabelPlacement.InsideEnd;
    }
}
class BarColumnSparkline extends Sparkline {
    constructor() {
        super();
        this.fill = 'rgb(124, 181, 236)';
        this.stroke = 'silver';
        this.strokeWidth = 0;
        this.paddingInner = 0.1;
        this.paddingOuter = 0.2;
        this.valueAxisDomain = undefined;
        this.formatter = undefined;
        this.axisLine = new integrated_charts_scene_exports.Line();
        this.bandWidth = 0;
        this.sparklineGroup = new integrated_charts_scene_exports.Group();
        this.rectGroup = new integrated_charts_scene_exports.Group();
        this.labelGroup = new integrated_charts_scene_exports.Group();
        this.rectSelection = integrated_charts_scene_exports.Selection.select(this.rectGroup, integrated_charts_scene_exports.Rect);
        this.labelSelection = integrated_charts_scene_exports.Selection.select(this.labelGroup, integrated_charts_scene_exports.Text);
        this.nodeSelectionData = [];
        this.label = new BarColumnLabel();
        this.rootGroup.append(this.sparklineGroup);
        this.rectGroup.zIndex = ZINDICIES.SERIES_FILL_ZINDEX;
        this.axisLine.zIndex = ZINDICIES.AXIS_LINE_ZINDEX;
        this.labelGroup.zIndex = ZINDICIES.SERIES_LABEL_ZINDEX;
        this.sparklineGroup.append([this.rectGroup, this.axisLine, this.labelGroup]);
        this.axisLine.lineCap = 'round';
        this.label.enabled = false;
    }
    getNodeData() {
        return this.nodeSelectionData;
    }
    update() {
        this.updateSelections();
        this.updateNodes();
    }
    updateSelections() {
        const nodeData = this.generateNodeData();
        if (!nodeData) {
            return;
        }
        this.nodeSelectionData = nodeData;
        this.updateRectSelection(nodeData);
        this.updateLabelSelection(nodeData);
    }
    updateNodes() {
        this.updateRectNodes();
        this.updateLabelNodes();
    }
    calculateStep(range) {
        var _a;
        const { xScale, paddingInner, paddingOuter, smallestInterval } = this;
        // calculate step
        let domainLength = xScale.domain[1] - xScale.domain[0];
        let intervals = domainLength / ((_a = smallestInterval === null || smallestInterval === void 0 ? void 0 : smallestInterval.x) !== null && _a !== void 0 ? _a : 1) + 1;
        // The number of intervals/bands is used to determine the width of individual bands by dividing the available range.
        // Allow a maximum of 50 bands to ensure the step (width of individual bands + padding) does not fall below a certain number of pixels.
        // If the number of intervals exceeds 50, calculate the step for 50 bands within the given range.
        // This means there could be some overlap of the bands in the sparkline.
        const maxBands = 50;
        const bands = Math.min(intervals, maxBands);
        const gaps = bands - 1; // number of gaps (padding between bands)
        const step = range / Math.max(1, 2 * paddingOuter + gaps * paddingInner + bands); // step width is a combination of band width and gap width
        return step;
    }
    updateYScaleDomain() {
        const { yScale, yData, valueAxisDomain } = this;
        const yMinMax = extent$5(yData);
        let yMin = 0;
        let yMax = 1;
        if (yMinMax !== undefined) {
            yMin = this.min = yMinMax[0];
            yMax = this.max = yMinMax[1];
        }
        // if yMin is positive, set yMin to 0
        yMin = yMin < 0 ? yMin : 0;
        // if yMax is negative, set yMax to 0
        yMax = yMax < 0 ? 0 : yMax;
        if (valueAxisDomain) {
            if (valueAxisDomain[1] < yMax) {
                valueAxisDomain[1] = yMax;
            }
            if (valueAxisDomain[0] > yMin) {
                valueAxisDomain[0] = yMin;
            }
        }
        yScale.domain = valueAxisDomain ? valueAxisDomain : [yMin, yMax];
    }
    updateRectSelection(selectionData) {
        this.rectSelection.update(selectionData);
    }
    updateRectNodes() {
        const { highlightedDatum, formatter: nodeFormatter, fill, stroke, strokeWidth } = this;
        const { fill: highlightFill, stroke: highlightStroke, strokeWidth: highlightStrokeWidth } = this.highlightStyle;
        this.rectSelection.each((node, datum, index) => {
            const highlighted = datum === highlightedDatum;
            const nodeFill = highlighted && highlightFill !== undefined ? highlightFill : fill;
            const nodeStroke = highlighted && highlightStroke !== undefined ? highlightStroke : stroke;
            const nodeStrokeWidth = highlighted && highlightStrokeWidth !== undefined ? highlightStrokeWidth : strokeWidth;
            let nodeFormat;
            const { x, y, width, height, seriesDatum } = datum;
            if (nodeFormatter) {
                const first = index === 0;
                const last = index === this.nodeSelectionData.length - 1;
                const min = seriesDatum.y === this.min;
                const max = seriesDatum.y === this.max;
                nodeFormat = nodeFormatter({
                    datum,
                    xValue: seriesDatum.x,
                    yValue: seriesDatum.y,
                    width: width,
                    height: height,
                    min,
                    max,
                    first,
                    last,
                    fill: nodeFill,
                    stroke: nodeStroke,
                    strokeWidth: nodeStrokeWidth,
                    highlighted,
                });
            }
            node.fill = (nodeFormat && nodeFormat.fill) || nodeFill;
            node.stroke = (nodeFormat && nodeFormat.stroke) || nodeStroke;
            node.strokeWidth = (nodeFormat && nodeFormat.strokeWidth) || nodeStrokeWidth;
            node.x = node.y = 0;
            node.width = width;
            node.height = height;
            node.visible = node.height > 0;
            node.translationX = x;
            node.translationY = y;
            // shifts bars upwards?
            // node.crisp = true;
        });
    }
    updateLabelSelection(selectionData) {
        this.labelSelection.update(selectionData, (text) => {
            text.tag = BarColumnNodeTag.Label;
            text.pointerEvents = integrated_charts_scene_exports.PointerEvents.None;
        });
    }
    updateLabelNodes() {
        const { label: { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color }, } = this;
        this.labelSelection.each((text, datum) => {
            const label = datum.label;
            if (label && labelEnabled) {
                text.fontStyle = fontStyle;
                text.fontWeight = fontWeight;
                text.fontSize = fontSize;
                text.fontFamily = fontFamily;
                text.textAlign = label.textAlign;
                text.textBaseline = label.textBaseline;
                text.text = label.text;
                text.x = label.x;
                text.y = label.y;
                text.fill = color;
                text.visible = true;
            }
            else {
                text.visible = false;
            }
        });
    }
    getTooltipHtml(datum) {
        var _a, _b;
        const { dataType } = this;
        const { seriesDatum } = datum;
        const yValue = seriesDatum.y;
        const xValue = seriesDatum.x;
        const content = this.formatNumericDatum(yValue);
        const title = dataType === 'array' || dataType === 'object' ? this.formatDatum(xValue) : undefined;
        const defaults = {
            content,
            title,
        };
        const tooltipRenderer = (_b = (_a = this.processedOptions) === null || _a === void 0 ? void 0 : _a.tooltip) === null || _b === void 0 ? void 0 : _b.renderer;
        if (tooltipRenderer) {
            return toTooltipHtml$1(tooltipRenderer({
                context: this.context,
                datum: seriesDatum,
                yValue,
                xValue,
            }), defaults);
        }
        return toTooltipHtml$1(defaults);
    }
    formatLabelValue(value) {
        return value % 1 !== 0 ? value.toFixed(1) : value.toFixed(0);
    }
}

const { isNumber: isNumber$3 } = sparklines_util_exports;
const { BandScale: BandScale$5 } = sparklines_scale_exports;
class BarSparkline extends BarColumnSparkline {
    updateYScaleRange() {
        const { seriesRect, yScale } = this;
        yScale.range = [0, seriesRect.width];
    }
    updateXScaleRange() {
        const { xScale, seriesRect, paddingOuter, paddingInner } = this;
        if (xScale instanceof BandScale$5) {
            xScale.range = [0, seriesRect.height];
            xScale.paddingInner = paddingInner;
            xScale.paddingOuter = paddingOuter;
        }
        else {
            // last node will be clipped if the scale is not a band scale
            // subtract last band width from the range so that the last band is not clipped
            const step = this.calculateStep(seriesRect.height);
            // PaddingOuter and paddingInner are fractions of the step with values between 0 and 1
            const padding = step * paddingOuter; // left and right outer padding
            this.bandWidth = step * (1 - paddingInner);
            xScale.range = [padding, seriesRect.height - padding - this.bandWidth];
        }
    }
    updateAxisLine() {
        const { yScale, axis, axisLine, seriesRect } = this;
        const { strokeWidth } = axis;
        axisLine.x1 = 0;
        axisLine.x2 = 0;
        axisLine.y1 = 0;
        axisLine.y2 = seriesRect.height;
        axisLine.stroke = axis.stroke;
        axisLine.strokeWidth = strokeWidth + (strokeWidth % 2 === 1 ? 1 : 0);
        const yZero = yScale.convert(0);
        axisLine.translationX = yZero;
    }
    generateNodeData() {
        const { data, yData, xData, xScale, yScale, fill, stroke, strokeWidth, label } = this;
        if (!data) {
            return;
        }
        const { fontStyle: labelFontStyle, fontWeight: labelFontWeight, fontSize: labelFontSize, fontFamily: labelFontFamily, color: labelColor, formatter: labelFormatter, placement: labelPlacement, } = label;
        const nodeData = [];
        const yZero = yScale.convert(0);
        const continuous = !(xScale instanceof BandScale$5);
        for (let i = 0, n = yData.length; i < n; i++) {
            let yDatum = yData[i];
            const xDatum = xData[i];
            const invalidDatum = yDatum === undefined;
            if (invalidDatum) {
                yDatum = 0;
            }
            const y = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum);
            const x = Math.min(yDatum === undefined ? NaN : yScale.convert(yDatum), yZero);
            const bottom = Math.max(yDatum === undefined ? NaN : yScale.convert(yDatum), yZero);
            // if the scale is a band scale, the width of the rects will be the bandwidth, otherwise the width of the rects will be the range / number of items in the data
            const height = !continuous ? xScale.bandwidth : this.bandWidth;
            const width = bottom - x;
            const midPoint = {
                x: yZero,
                y: y,
            };
            let labelText;
            if (labelFormatter) {
                labelText = labelFormatter({ value: yDatum });
            }
            else {
                labelText = yDatum !== undefined && isNumber$3(yDatum) ? this.formatLabelValue(yDatum) : '';
            }
            const labelY = y + height / 2;
            let labelX;
            const labelTextBaseline = 'middle';
            let labelTextAlign;
            const isPositiveY = yDatum !== undefined && yDatum >= 0;
            const labelPadding = 4;
            if (labelPlacement === BarColumnLabelPlacement.Center) {
                labelX = x + width / 2;
                labelTextAlign = 'center';
            }
            else if (labelPlacement === BarColumnLabelPlacement.OutsideEnd) {
                labelX = x + (isPositiveY ? width + labelPadding : -labelPadding);
                labelTextAlign = isPositiveY ? 'start' : 'end';
            }
            else if (labelPlacement === BarColumnLabelPlacement.InsideEnd) {
                labelX = x + (isPositiveY ? width - labelPadding : labelPadding);
                labelTextAlign = isPositiveY ? 'end' : 'start';
                const textSize = integrated_charts_scene_exports.HdpiCanvas.getTextSize(labelText, labelFontFamily);
                const textWidth = textSize.width || 20;
                const positiveBoundary = yZero + textWidth;
                const negativeBoundary = yZero - textWidth;
                const exceedsBoundaries = (isPositiveY && labelX < positiveBoundary) || (!isPositiveY && labelX > negativeBoundary);
                if (exceedsBoundaries) {
                    // if labelX exceeds the boundary, labels should be positioned at `insideBase`.
                    labelX = yZero + labelPadding * (isPositiveY ? 1 : -1);
                    labelTextAlign = isPositiveY ? 'start' : 'end';
                }
            }
            else {
                // if labelPlacement === BarColumnLabelPlacement.InsideBase
                labelX = yZero + labelPadding * (isPositiveY ? 1 : -1);
                labelTextAlign = isPositiveY ? 'start' : 'end';
            }
            nodeData.push({
                x,
                y,
                width,
                height,
                fill,
                stroke,
                strokeWidth,
                seriesDatum: { x: xDatum, y: invalidDatum ? undefined : yDatum },
                point: midPoint,
                label: {
                    x: labelX,
                    y: labelY,
                    text: labelText,
                    fontStyle: labelFontStyle,
                    fontWeight: labelFontWeight,
                    fontSize: labelFontSize,
                    fontFamily: labelFontFamily,
                    textAlign: labelTextAlign,
                    textBaseline: labelTextBaseline,
                    fill: labelColor,
                },
            });
        }
        return nodeData;
    }
    getDistance(p1, p2) {
        return Math.abs(p1.y - p2.y);
    }
}
BarSparkline.className = 'BarSparkline';

const { isNumber: isNumber$4 } = sparklines_util_exports;
const { BandScale: BandScale$6 } = sparklines_scale_exports;
class ColumnSparkline extends BarColumnSparkline {
    updateYScaleRange() {
        const { seriesRect, yScale } = this;
        yScale.range = [seriesRect.height, 0];
    }
    updateXScaleRange() {
        const { xScale, seriesRect, paddingOuter, paddingInner } = this;
        if (xScale instanceof BandScale$6) {
            xScale.range = [0, seriesRect.width];
            xScale.paddingInner = paddingInner;
            xScale.paddingOuter = paddingOuter;
        }
        else {
            // last node will be clipped if the scale is not a band scale
            // subtract last band width from the range so that the last band is not clipped
            const step = this.calculateStep(seriesRect.width);
            // PaddingOuter and paddingInner are fractions of the step with values between 0 and 1
            const padding = step * paddingOuter; // left and right outer padding
            this.bandWidth = step * (1 - paddingInner);
            xScale.range = [padding, seriesRect.width - padding - this.bandWidth];
        }
    }
    updateAxisLine() {
        const { yScale, axis, axisLine, seriesRect } = this;
        const { strokeWidth } = axis;
        axisLine.x1 = 0;
        axisLine.x2 = seriesRect.width;
        axisLine.y1 = 0;
        axisLine.y2 = 0;
        axisLine.stroke = axis.stroke;
        axisLine.strokeWidth = strokeWidth + (strokeWidth % 2 === 1 ? 1 : 0);
        const yZero = yScale.convert(0);
        axisLine.translationY = yZero;
    }
    generateNodeData() {
        const { data, yData, xData, xScale, yScale, fill, stroke, strokeWidth, label } = this;
        if (!data) {
            return;
        }
        const { fontStyle: labelFontStyle, fontWeight: labelFontWeight, fontSize: labelFontSize, fontFamily: labelFontFamily, color: labelColor, formatter: labelFormatter, placement: labelPlacement, } = label;
        const nodeData = [];
        const yZero = yScale.convert(0);
        const continuous = !(xScale instanceof BandScale$6);
        for (let i = 0, n = yData.length; i < n; i++) {
            let yDatum = yData[i];
            const xDatum = xData[i];
            const invalidDatum = yDatum === undefined;
            if (invalidDatum) {
                yDatum = 0;
            }
            const y = Math.min(yDatum === undefined ? NaN : yScale.convert(yDatum), yZero);
            const x = xScale.convert(continuous ? xScale.toDomain(xDatum) : xDatum);
            const bottom = Math.max(yDatum === undefined ? NaN : yScale.convert(yDatum), yZero);
            // if the scale is a band scale, the width of the rects will be the bandwidth, otherwise the width of the rects will be the range / number of items in the data
            const width = !continuous ? xScale.bandwidth : this.bandWidth;
            const height = bottom - y;
            const midPoint = {
                x: x + width / 2,
                y: yZero,
            };
            let labelText;
            if (labelFormatter) {
                labelText = labelFormatter({ value: yDatum });
            }
            else {
                labelText = yDatum !== undefined && isNumber$4(yDatum) ? this.formatLabelValue(yDatum) : '';
            }
            const labelX = x + width / 2;
            let labelY;
            const labelTextAlign = 'center';
            let labelTextBaseline;
            const isPositiveY = yDatum !== undefined && yDatum >= 0;
            const labelPadding = 2;
            if (labelPlacement === BarColumnLabelPlacement.Center) {
                labelY = y + height / 2;
                labelTextBaseline = 'middle';
            }
            else if (labelPlacement === BarColumnLabelPlacement.OutsideEnd) {
                labelY = y + (isPositiveY ? -labelPadding : height + labelPadding);
                labelTextBaseline = isPositiveY ? 'bottom' : 'top';
            }
            else if (labelPlacement === BarColumnLabelPlacement.InsideEnd) {
                labelY = y + (isPositiveY ? labelPadding : height - labelPadding);
                labelTextBaseline = isPositiveY ? 'top' : 'bottom';
                const textSize = integrated_charts_scene_exports.HdpiCanvas.getTextSize(labelText, labelFontFamily);
                const textHeight = textSize.height || 10;
                const positiveBoundary = yZero - textHeight;
                const negativeBoundary = yZero + textHeight;
                const exceedsBoundaries = (isPositiveY && labelY > positiveBoundary) || (!isPositiveY && labelY < negativeBoundary);
                if (exceedsBoundaries) {
                    // if labelY exceeds the y boundary, labels should be positioned at the insideBase
                    labelY = yZero + labelPadding * (isPositiveY ? -1 : 1);
                    labelTextBaseline = isPositiveY ? 'bottom' : 'top';
                }
            }
            else {
                // if labelPlacement === BarColumnLabelPlacement.InsideBase
                labelY = yZero + labelPadding * (isPositiveY ? -1 : 1);
                labelTextBaseline = isPositiveY ? 'bottom' : 'top';
            }
            nodeData.push({
                x,
                y,
                width,
                height,
                fill,
                stroke,
                strokeWidth,
                seriesDatum: { x: xDatum, y: invalidDatum ? undefined : yDatum },
                point: midPoint,
                label: {
                    x: labelX,
                    y: labelY,
                    text: labelText,
                    fontStyle: labelFontStyle,
                    fontWeight: labelFontWeight,
                    fontSize: labelFontSize,
                    fontFamily: labelFontFamily,
                    textAlign: labelTextAlign,
                    textBaseline: labelTextBaseline,
                    fill: labelColor,
                },
            });
        }
        return nodeData;
    }
}
ColumnSparkline.className = 'ColumnSparkline';

const { isNumber: isNumber$5 } = sparklines_util_exports;
class AgSparkline {
    static create(options, tooltip) {
        // avoid mutating user provided options
        options = sparklines_util_exports.deepClone(options);
        const sparkline = getSparklineInstance(options.type);
        if (tooltip) {
            sparkline.tooltip = tooltip;
        }
        initSparkline(sparkline, options);
        initSparklineByType(sparkline, options);
        if (options.data) {
            sparkline.data = options.data;
        }
        sparkline.processedOptions = options;
        return sparkline;
    }
}
function getSparklineInstance(type = 'line') {
    switch (type) {
        case 'column':
            return new ColumnSparkline();
        case 'bar':
            return new BarSparkline();
        case 'area':
            return new AreaSparkline();
        case 'line':
        default:
            return new LineSparkline();
    }
}
function initSparklineByType(sparkline, options) {
    switch (options.type) {
        case 'bar':
            initBarColumnSparkline(sparkline, options);
            break;
        case 'column':
            initBarColumnSparkline(sparkline, options);
            break;
        case 'area':
            initAreaSparkline(sparkline, options);
            break;
        case 'line':
        default:
            initLineSparkline(sparkline, options);
            break;
    }
}
function initSparkline(sparkline, options) {
    setValueIfPropertyExists(sparkline, 'context', options.context, options);
    setValueIfPropertyExists(sparkline, 'width', options.width, options);
    setValueIfPropertyExists(sparkline, 'height', options.height, options);
    setValueIfPropertyExists(sparkline, 'container', options.container, options);
    setValueIfPropertyExists(sparkline, 'xKey', options.xKey, options);
    setValueIfPropertyExists(sparkline, 'yKey', options.yKey, options);
    if (options.padding) {
        initPaddingOptions(sparkline.padding, options.padding);
    }
    if (options.axis) {
        initAxisOptions(sparkline.axis, options.axis);
    }
    if (options.highlightStyle) {
        initHighlightStyleOptions(sparkline.highlightStyle, options.highlightStyle);
    }
}
function initLineSparkline(sparkline, options) {
    if (options.marker) {
        initMarkerOptions(sparkline.marker, options.marker);
    }
    if (options.line) {
        initLineOptions(sparkline.line, options.line);
    }
    if (options.crosshairs) {
        initCrosshairsOptions(sparkline.crosshairs, options.crosshairs);
    }
}
function initAreaSparkline(sparkline, options) {
    setValueIfPropertyExists(sparkline, 'fill', options.fill, options);
    if (options.marker) {
        initMarkerOptions(sparkline.marker, options.marker);
    }
    if (options.line) {
        initLineOptions(sparkline.line, options.line);
    }
    if (options.crosshairs) {
        initCrosshairsOptions(sparkline.crosshairs, options.crosshairs);
    }
}
function initBarColumnSparkline(sparkline, options) {
    setValueIfPropertyExists(sparkline, 'valueAxisDomain', options.valueAxisDomain, options);
    setValueIfPropertyExists(sparkline, 'fill', options.fill, options);
    setValueIfPropertyExists(sparkline, 'stroke', options.stroke, options);
    setValueIfPropertyExists(sparkline, 'strokeWidth', options.strokeWidth, options);
    setValueIfPropertyExists(sparkline, 'paddingInner', options.paddingInner, options);
    setValueIfPropertyExists(sparkline, 'paddingOuter', options.paddingOuter, options);
    setValueIfPropertyExists(sparkline, 'formatter', options.formatter, options);
    if (options.label) {
        initLabelOptions(sparkline.label, options.label);
    }
}
function initPaddingOptions(target, options) {
    setValueIfPropertyExists(target, 'top', options.top, options);
    setValueIfPropertyExists(target, 'right', options.right, options);
    setValueIfPropertyExists(target, 'bottom', options.bottom, options);
    setValueIfPropertyExists(target, 'left', options.left, options);
}
function initMarkerOptions(target, options) {
    setValueIfPropertyExists(target, 'enabled', options.enabled, options);
    setValueIfPropertyExists(target, 'size', options.size, options);
    setValueIfPropertyExists(target, 'shape', options.shape, options);
    setValueIfPropertyExists(target, 'fill', options.fill, options);
    setValueIfPropertyExists(target, 'stroke', options.stroke, options);
    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);
    setValueIfPropertyExists(target, 'formatter', options.formatter, options);
}
function initLabelOptions(target, options) {
    setValueIfPropertyExists(target, 'enabled', options.enabled, options);
    setValueIfPropertyExists(target, 'fontStyle', options.fontStyle, options);
    setValueIfPropertyExists(target, 'fontWeight', options.fontWeight, options);
    setValueIfPropertyExists(target, 'fontSize', options.fontSize, options);
    setValueIfPropertyExists(target, 'fontFamily', options.fontFamily, options);
    setValueIfPropertyExists(target, 'textAlign', options.textAlign, options);
    setValueIfPropertyExists(target, 'textBaseline', options.textBaseline, options);
    setValueIfPropertyExists(target, 'color', options.color, options);
    setValueIfPropertyExists(target, 'formatter', options.formatter, options);
    setValueIfPropertyExists(target, 'placement', options.placement, options);
}
function initLineOptions(target, options) {
    setValueIfPropertyExists(target, 'stroke', options.stroke, options);
    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);
}
function initAxisOptions(target, options) {
    setValueIfPropertyExists(target, 'type', options.type, options);
    setValueIfPropertyExists(target, 'stroke', options.stroke, options);
    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);
}
function initHighlightStyleOptions(target, options) {
    setValueIfPropertyExists(target, 'fill', options.fill, options);
    setValueIfPropertyExists(target, 'size', options.size, options);
    setValueIfPropertyExists(target, 'stroke', options.stroke, options);
    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);
}
function initCrosshairsOptions(target, options) {
    if (target.xLine && options.xLine) {
        initCrosshairLineOptions(target.xLine, options.xLine);
    }
    if (target.yLine && options.yLine) {
        initCrosshairLineOptions(target.yLine, options.yLine);
    }
}
function initCrosshairLineOptions(target, options) {
    setValueIfPropertyExists(target, 'enabled', options.enabled, options);
    setValueIfPropertyExists(target, 'stroke', options.stroke, options);
    setValueIfPropertyExists(target, 'strokeWidth', options.strokeWidth, options);
    setValueIfPropertyExists(target, 'lineDash', options.lineDash, options);
    setValueIfPropertyExists(target, 'lineCap', options.lineCap, options);
}
const doOnceFlags = {};
/**
 * If the key was passed before, then doesn't execute the func
 * @param {Function} func
 * @param {string} key
 */
function doOnce$1(func, key) {
    if (doOnceFlags[key]) {
        return;
    }
    func();
    doOnceFlags[key] = true;
}
const offsetValidator = (property, value, defaultOffset) => {
    if (isNumber$5(value)) {
        return true;
    }
    const message = `AG Charts: ${property} must be a number, the value you provided is not a valid number. Using the default of ${defaultOffset}px.`;
    doOnce$1(() => console.warn(message), `${property} not a number`);
    return false;
};
const validators = {
    xOffset: offsetValidator,
    yOffset: offsetValidator,
};
function setValueIfPropertyExists(target, property, value, options) {
    if (property in options) {
        if (property in target) {
            const validator = validators[property];
            const isValid = validator ? validator(property, value, target[property]) : true;
            if (isValid && target[property] !== value) {
                // only set property if the value is different to new value
                target[property] = value;
            }
        }
        else {
            console.warn(`Property ${property} does not exist on the target object.`);
        }
    }
}

var __decorate$23 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SparklineCellRenderer extends Component {
    constructor() {
        super(SparklineCellRenderer.TEMPLATE);
    }
    init(params) {
        let firstTimeIn = true;
        const updateSparkline = () => {
            const { clientWidth, clientHeight } = this.getGui();
            if (clientWidth === 0 || clientHeight === 0) {
                return;
            }
            if (firstTimeIn) {
                const options = Object.assign({ data: params.value, width: clientWidth, height: clientHeight, context: {
                        data: params.data,
                    } }, params.sparklineOptions);
                // create new instance of sparkline
                this.sparkline = AgSparkline.create(options, this.sparklineTooltipSingleton.getSparklineTooltip());
                // append sparkline canvas to cell renderer element
                this.eSparkline.appendChild(this.sparkline.canvasElement);
                firstTimeIn = false;
            }
            else {
                this.sparkline.width = clientWidth;
                this.sparkline.height = clientHeight;
            }
        };
        const unsubscribeFromResize = this.resizeObserverService.observeResize(this.getGui(), updateSparkline);
        this.addDestroyFunc(() => unsubscribeFromResize());
    }
    refresh(params) {
        if (this.sparkline) {
            this.sparkline.data = params.value;
            return true;
        }
        return false;
    }
    destroy() {
        if (this.sparkline) {
            this.sparkline.destroy();
        }
        super.destroy();
    }
}
SparklineCellRenderer.TEMPLATE /* html */ = `<div class="ag-sparkline-wrapper">
            <span ref="eSparkline"></span>
        </div>`;
__decorate$23([
    RefSelector('eSparkline')
], SparklineCellRenderer.prototype, "eSparkline", void 0);
__decorate$23([
    Autowired('resizeObserverService')
], SparklineCellRenderer.prototype, "resizeObserverService", void 0);
__decorate$23([
    Autowired('sparklineTooltipSingleton')
], SparklineCellRenderer.prototype, "sparklineTooltipSingleton", void 0);

var __decorate$24 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * This 'bean' creates a single sparkline tooltip that is bound to the grid lifecycle.
 */
let SparklineTooltipSingleton = class SparklineTooltipSingleton extends BeanStub {
    postConstruct() {
        this.tooltip = new SparklineTooltip();
    }
    getSparklineTooltip() {
        return this.tooltip;
    }
    destroyTooltip() {
        if (this.tooltip) {
            this.tooltip.destroy();
        }
    }
};
__decorate$24([
    PostConstruct
], SparklineTooltipSingleton.prototype, "postConstruct", null);
__decorate$24([
    PreDestroy
], SparklineTooltipSingleton.prototype, "destroyTooltip", null);
SparklineTooltipSingleton = __decorate$24([
    Bean('sparklineTooltipSingleton')
], SparklineTooltipSingleton);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$i = '31.1.1';

const SparklinesModule = {
    version: VERSION$i,
    moduleName: ModuleNames.SparklinesModule,
    beans: [SparklineTooltipSingleton],
    userComponents: [{ componentName: 'agSparklineCellRenderer', componentClass: SparklineCellRenderer }],
    dependantModules: [EnterpriseCoreModule],
};

var __decorate$25 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let StatusBarService = class StatusBarService extends BeanStub {
    // tslint:disable-next-line
    constructor() {
        super();
        this.allComponents = new Map();
    }
    registerStatusPanel(key, component) {
        this.allComponents.set(key, component);
    }
    unregisterStatusPanel(key) {
        this.allComponents.delete(key);
    }
    unregisterAllComponents() {
        this.allComponents.clear();
    }
    getStatusPanel(key) {
        return this.allComponents.get(key);
    }
    destroy() {
        this.unregisterAllComponents();
        super.destroy();
    }
};
StatusBarService = __decorate$25([
    Bean('statusBarService')
], StatusBarService);

var __decorate$26 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class StatusBar extends Component {
    constructor() {
        super(StatusBar.TEMPLATE);
        this.compDestroyFunctions = {};
    }
    postConstruct() {
        this.processStatusPanels(new Map());
        this.addManagedPropertyListeners(['statusBar'], this.handleStatusBarChanged.bind(this));
    }
    processStatusPanels(existingStatusPanelsToReuse) {
        var _a;
        const statusPanels = (_a = this.gridOptionsService.get('statusBar')) === null || _a === void 0 ? void 0 : _a.statusPanels;
        if (statusPanels) {
            const leftStatusPanelComponents = statusPanels
                .filter((componentConfig) => componentConfig.align === 'left');
            this.createAndRenderComponents(leftStatusPanelComponents, this.eStatusBarLeft, existingStatusPanelsToReuse);
            const centerStatusPanelComponents = statusPanels
                .filter((componentConfig) => componentConfig.align === 'center');
            this.createAndRenderComponents(centerStatusPanelComponents, this.eStatusBarCenter, existingStatusPanelsToReuse);
            const rightStatusPanelComponents = statusPanels
                .filter((componentConfig) => (!componentConfig.align || componentConfig.align === 'right'));
            this.createAndRenderComponents(rightStatusPanelComponents, this.eStatusBarRight, existingStatusPanelsToReuse);
        }
        else {
            this.setDisplayed(false);
        }
    }
    handleStatusBarChanged() {
        var _a;
        const statusPanels = (_a = this.gridOptionsService.get('statusBar')) === null || _a === void 0 ? void 0 : _a.statusPanels;
        const validStatusBarPanelsProvided = Array.isArray(statusPanels) && statusPanels.length > 0;
        this.setDisplayed(validStatusBarPanelsProvided);
        const existingStatusPanelsToReuse = new Map();
        if (validStatusBarPanelsProvided) {
            statusPanels.forEach(statusPanelConfig => {
                var _a, _b;
                const key = (_a = statusPanelConfig.key) !== null && _a !== void 0 ? _a : statusPanelConfig.statusPanel;
                const existingStatusPanel = this.statusBarService.getStatusPanel(key);
                if (existingStatusPanel === null || existingStatusPanel === void 0 ? void 0 : existingStatusPanel.refresh) {
                    const newParams = this.gridOptionsService.addGridCommonParams((_b = statusPanelConfig.statusPanelParams) !== null && _b !== void 0 ? _b : {});
                    const hasRefreshed = existingStatusPanel.refresh(newParams);
                    if (hasRefreshed) {
                        existingStatusPanelsToReuse.set(key, existingStatusPanel);
                        delete this.compDestroyFunctions[key];
                        _.removeFromParent(existingStatusPanel.getGui());
                    }
                }
            });
        }
        this.resetStatusBar();
        if (validStatusBarPanelsProvided) {
            this.processStatusPanels(existingStatusPanelsToReuse);
        }
    }
    resetStatusBar() {
        this.eStatusBarLeft.innerHTML = '';
        this.eStatusBarCenter.innerHTML = '';
        this.eStatusBarRight.innerHTML = '';
        this.destroyComponents();
        this.statusBarService.unregisterAllComponents();
    }
    destroyComponents() {
        Object.values(this.compDestroyFunctions).forEach((func) => func());
        this.compDestroyFunctions = {};
    }
    createAndRenderComponents(statusBarComponents, ePanelComponent, existingStatusPanelsToReuse) {
        const componentDetails = [];
        statusBarComponents.forEach(componentConfig => {
            // default to the component name if no key supplied
            const key = componentConfig.key || componentConfig.statusPanel;
            const existingStatusPanel = existingStatusPanelsToReuse.get(key);
            let promise;
            if (existingStatusPanel) {
                promise = AgPromise.resolve(existingStatusPanel);
            }
            else {
                const params = {};
                const compDetails = this.userComponentFactory.getStatusPanelCompDetails(componentConfig, params);
                promise = compDetails.newAgStackInstance();
                if (!promise) {
                    return;
                }
            }
            componentDetails.push({
                key,
                promise
            });
        });
        AgPromise.all(componentDetails.map((details) => details.promise))
            .then(() => {
            componentDetails.forEach(componentDetail => {
                componentDetail.promise.then((component) => {
                    const destroyFunc = () => {
                        this.getContext().destroyBean(component);
                    };
                    if (this.isAlive()) {
                        this.statusBarService.registerStatusPanel(componentDetail.key, component);
                        ePanelComponent.appendChild(component.getGui());
                        this.compDestroyFunctions[componentDetail.key] = destroyFunc;
                    }
                    else {
                        destroyFunc();
                    }
                });
            });
        });
    }
}
StatusBar.TEMPLATE = `<div class="ag-status-bar">
            <div ref="eStatusBarLeft" class="ag-status-bar-left" role="status"></div>
            <div ref="eStatusBarCenter" class="ag-status-bar-center" role="status"></div>
            <div ref="eStatusBarRight" class="ag-status-bar-right" role="status"></div>
        </div>`;
__decorate$26([
    Autowired('userComponentFactory')
], StatusBar.prototype, "userComponentFactory", void 0);
__decorate$26([
    Autowired('statusBarService')
], StatusBar.prototype, "statusBarService", void 0);
__decorate$26([
    RefSelector('eStatusBarLeft')
], StatusBar.prototype, "eStatusBarLeft", void 0);
__decorate$26([
    RefSelector('eStatusBarCenter')
], StatusBar.prototype, "eStatusBarCenter", void 0);
__decorate$26([
    RefSelector('eStatusBarRight')
], StatusBar.prototype, "eStatusBarRight", void 0);
__decorate$26([
    PostConstruct
], StatusBar.prototype, "postConstruct", null);
__decorate$26([
    PreDestroy
], StatusBar.prototype, "destroyComponents", null);

var __decorate$27 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class NameValueComp extends Component {
    constructor() {
        super(NameValueComp.TEMPLATE);
    }
    setLabel(key, defaultValue) {
        // we want to hide until the first value comes in
        this.setDisplayed(false);
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        this.eLabel.innerHTML = localeTextFunc(key, defaultValue);
    }
    setValue(value) {
        this.eValue.innerHTML = value;
    }
}
NameValueComp.TEMPLATE = `<div class="ag-status-name-value">
            <span ref="eLabel"></span>:&nbsp;
            <span ref="eValue" class="ag-status-name-value-value"></span>
        </div>`;
__decorate$27([
    RefSelector('eLabel')
], NameValueComp.prototype, "eLabel", void 0);
__decorate$27([
    RefSelector('eValue')
], NameValueComp.prototype, "eValue", void 0);

var __decorate$28 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class TotalAndFilteredRowsComp extends NameValueComp {
    postConstruct() {
        // this component is only really useful with client side row model
        if (this.gridApi.__getModel().getType() !== 'clientSide') {
            console.warn(`AG Grid: agTotalAndFilteredRowCountComponent should only be used with the client side row model.`);
            return;
        }
        this.setLabel('totalAndFilteredRows', 'Rows');
        this.addCssClass('ag-status-panel');
        this.addCssClass('ag-status-panel-total-and-filtered-row-count');
        this.setDisplayed(true);
        this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, this.onDataChanged.bind(this));
        this.onDataChanged();
    }
    onDataChanged() {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const thousandSeparator = localeTextFunc('thousandSeparator', ',');
        const decimalSeparator = localeTextFunc('decimalSeparator', '.');
        const rowCount = _.formatNumberCommas(this.getFilteredRowCountValue(), thousandSeparator, decimalSeparator);
        const totalRowCount = _.formatNumberCommas(this.getTotalRowCount(), thousandSeparator, decimalSeparator);
        if (rowCount === totalRowCount) {
            this.setValue(rowCount);
        }
        else {
            const localeTextFunc = this.localeService.getLocaleTextFunc();
            this.setValue(`${rowCount} ${localeTextFunc('of', 'of')} ${totalRowCount}`);
        }
    }
    getFilteredRowCountValue() {
        let filteredRowCount = 0;
        this.gridApi.forEachNodeAfterFilter((node) => {
            if (!node.group) {
                filteredRowCount++;
            }
        });
        return filteredRowCount;
    }
    getTotalRowCount() {
        let totalRowCount = 0;
        this.gridApi.forEachNode(node => {
            if (!node.group) {
                totalRowCount++;
            }
        });
        return totalRowCount;
    }
    init() { }
    refresh() {
        return true;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
}
__decorate$28([
    Autowired('gridApi')
], TotalAndFilteredRowsComp.prototype, "gridApi", void 0);
__decorate$28([
    PostConstruct
], TotalAndFilteredRowsComp.prototype, "postConstruct", null);

var __decorate$29 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class FilteredRowsComp extends NameValueComp {
    postConstruct() {
        this.setLabel('filteredRows', 'Filtered');
        // this component is only really useful with client side row model
        if (this.gridApi.__getModel().getType() !== 'clientSide') {
            console.warn(`AG Grid: agFilteredRowCountComponent should only be used with the client side row model.`);
            return;
        }
        this.addCssClass('ag-status-panel');
        this.addCssClass('ag-status-panel-filtered-row-count');
        this.setDisplayed(true);
        const listener = this.onDataChanged.bind(this);
        this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, listener);
        listener();
    }
    onDataChanged() {
        const totalRowCountValue = this.getTotalRowCountValue();
        const filteredRowCountValue = this.getFilteredRowCountValue();
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const thousandSeparator = localeTextFunc('thousandSeparator', ',');
        const decimalSeparator = localeTextFunc('decimalSeparator', '.');
        this.setValue(_.formatNumberCommas(filteredRowCountValue, thousandSeparator, decimalSeparator));
        this.setDisplayed(totalRowCountValue !== filteredRowCountValue);
    }
    getTotalRowCountValue() {
        let totalRowCount = 0;
        this.gridApi.forEachNode((node) => totalRowCount += 1);
        return totalRowCount;
    }
    getFilteredRowCountValue() {
        let filteredRowCount = 0;
        this.gridApi.forEachNodeAfterFilter((node) => {
            if (!node.group) {
                filteredRowCount += 1;
            }
        });
        return filteredRowCount;
    }
    init() { }
    refresh() {
        return true;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
}
__decorate$29([
    Autowired('gridApi')
], FilteredRowsComp.prototype, "gridApi", void 0);
__decorate$29([
    PostConstruct
], FilteredRowsComp.prototype, "postConstruct", null);

var __decorate$2a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class TotalRowsComp extends NameValueComp {
    postConstruct() {
        this.setLabel('totalRows', 'Total Rows');
        // this component is only really useful with client side row model
        if (this.gridApi.__getModel().getType() !== 'clientSide') {
            console.warn(`AG Grid: agTotalRowCountComponent should only be used with the client side row model.`);
            return;
        }
        this.addCssClass('ag-status-panel');
        this.addCssClass('ag-status-panel-total-row-count');
        this.setDisplayed(true);
        this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, this.onDataChanged.bind(this));
        this.onDataChanged();
    }
    onDataChanged() {
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const thousandSeparator = localeTextFunc('thousandSeparator', ',');
        const decimalSeparator = localeTextFunc('decimalSeparator', '.');
        this.setValue(_.formatNumberCommas(this.getRowCountValue(), thousandSeparator, decimalSeparator));
    }
    getRowCountValue() {
        let totalRowCount = 0;
        this.gridApi.forEachLeafNode((node) => totalRowCount += 1);
        return totalRowCount;
    }
    init() {
    }
    refresh() {
        return true;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
}
__decorate$2a([
    Autowired('gridApi')
], TotalRowsComp.prototype, "gridApi", void 0);
__decorate$2a([
    PostConstruct
], TotalRowsComp.prototype, "postConstruct", null);

var __decorate$2b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class SelectedRowsComp extends NameValueComp {
    postConstruct() {
        if (!this.isValidRowModel()) {
            console.warn(`AG Grid: agSelectedRowCountComponent should only be used with the client and server side row model.`);
            return;
        }
        this.setLabel('selectedRows', 'Selected');
        this.addCssClass('ag-status-panel');
        this.addCssClass('ag-status-panel-selected-row-count');
        this.onRowSelectionChanged();
        const eventListener = this.onRowSelectionChanged.bind(this);
        this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, eventListener);
        this.addManagedListener(this.eventService, Events.EVENT_SELECTION_CHANGED, eventListener);
    }
    isValidRowModel() {
        // this component is only really useful with client or server side rowmodels
        const rowModelType = this.gridApi.__getModel().getType();
        return rowModelType === 'clientSide' || rowModelType === 'serverSide';
    }
    onRowSelectionChanged() {
        const selectedRowCount = this.selectionService.getSelectionCount();
        if (selectedRowCount < 0) {
            this.setValue('?');
            this.setDisplayed(true);
            return;
        }
        const localeTextFunc = this.localeService.getLocaleTextFunc();
        const thousandSeparator = localeTextFunc('thousandSeparator', ',');
        const decimalSeparator = localeTextFunc('decimalSeparator', '.');
        this.setValue(_.formatNumberCommas(selectedRowCount, thousandSeparator, decimalSeparator));
        this.setDisplayed(selectedRowCount > 0);
    }
    init() {
    }
    refresh() {
        return true;
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
}
__decorate$2b([
    Autowired('gridApi')
], SelectedRowsComp.prototype, "gridApi", void 0);
__decorate$2b([
    Autowired('selectionService')
], SelectedRowsComp.prototype, "selectionService", void 0);
__decorate$2b([
    PostConstruct
], SelectedRowsComp.prototype, "postConstruct", null);

var __decorate$2c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class AggregationComp extends Component {
    constructor() {
        super(AggregationComp.TEMPLATE);
    }
    // this is a user component, and IComponent has "public destroy()" as part of the interface.
    // so we need to override destroy() just to make the method public.
    destroy() {
        super.destroy();
    }
    postConstruct() {
        if (!this.isValidRowModel()) {
            console.warn(`AG Grid: agAggregationComponent should only be used with the client and server side row model.`);
            return;
        }
        this.avgAggregationComp.setLabel('avg', 'Average');
        this.countAggregationComp.setLabel('count', 'Count');
        this.minAggregationComp.setLabel('min', 'Min');
        this.maxAggregationComp.setLabel('max', 'Max');
        this.sumAggregationComp.setLabel('sum', 'Sum');
        this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, this.onRangeSelectionChanged.bind(this));
        this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, this.onRangeSelectionChanged.bind(this));
    }
    isValidRowModel() {
        // this component is only really useful with client or server side rowmodels
        const rowModelType = this.gridApi.__getModel().getType();
        return rowModelType === 'clientSide' || rowModelType === 'serverSide';
    }
    init(params) {
        this.params = params;
    }
    refresh(params) {
        this.params = params;
        this.onRangeSelectionChanged();
        return true;
    }
    setAggregationComponentValue(aggFuncName, value, visible) {
        var _a;
        const statusBarValueComponent = this.getAllowedAggregationValueComponent(aggFuncName);
        if (_.exists(statusBarValueComponent) && statusBarValueComponent) {
            const localeTextFunc = this.localeService.getLocaleTextFunc();
            const thousandSeparator = localeTextFunc('thousandSeparator', ',');
            const decimalSeparator = localeTextFunc('decimalSeparator', '.');
            statusBarValueComponent.setValue(_.formatNumberTwoDecimalPlacesAndCommas(value, thousandSeparator, decimalSeparator));
            statusBarValueComponent.setDisplayed(visible);
        }
        else {
            // might have previously been visible, so hide now
            (_a = this.getAggregationValueComponent(aggFuncName)) === null || _a === void 0 ? void 0 : _a.setDisplayed(false);
        }
    }
    getAllowedAggregationValueComponent(aggFuncName) {
        // if the user has specified the agAggregationPanelComp but no aggFuncs we show the all
        // if the user has specified the agAggregationPanelComp and aggFuncs, then we only show the aggFuncs listed
        const { aggFuncs } = this.params;
        if (!aggFuncs || aggFuncs.includes(aggFuncName)) {
            return this.getAggregationValueComponent(aggFuncName);
        }
        // either we can't find it (which would indicate a typo or similar user side), or the user has deliberately
        // not listed the component in aggFuncs
        return null;
    }
    getAggregationValueComponent(aggFuncName) {
        // converts user supplied agg name to our reference - eg: sum => sumAggregationComp
        const refComponentName = `${aggFuncName}AggregationComp`;
        return this[refComponentName];
    }
    onRangeSelectionChanged() {
        const cellRanges = this.rangeService ? this.rangeService.getCellRanges() : undefined;
        let sum = 0;
        let count = 0;
        let numberCount = 0;
        let min = null;
        let max = null;
        const cellsSoFar = {};
        if (cellRanges && !_.missingOrEmpty(cellRanges)) {
            cellRanges.forEach((cellRange) => {
                let currentRow = this.rangeService.getRangeStartRow(cellRange);
                const lastRow = this.rangeService.getRangeEndRow(cellRange);
                while (true) {
                    const finishedAllRows = _.missing(currentRow) || !currentRow || this.rowPositionUtils.before(lastRow, currentRow);
                    if (finishedAllRows || !currentRow || !cellRange.columns) {
                        break;
                    }
                    cellRange.columns.forEach(col => {
                        if (currentRow === null) {
                            return;
                        }
                        // we only want to include each cell once, in case a cell is in multiple ranges
                        const cellId = this.cellPositionUtils.createId({
                            rowPinned: currentRow.rowPinned,
                            column: col,
                            rowIndex: currentRow.rowIndex
                        });
                        if (cellsSoFar[cellId]) {
                            return;
                        }
                        cellsSoFar[cellId] = true;
                        const rowNode = this.rowRenderer.getRowNode(currentRow);
                        if (_.missing(rowNode)) {
                            return;
                        }
                        let value = this.valueService.getValue(col, rowNode);
                        // if empty cell, skip it, doesn't impact count or anything
                        if (_.missing(value) || value === '') {
                            return;
                        }
                        count++;
                        // see if value is wrapped, can happen when doing count() or avg() functions
                        if (typeof value === 'object' && 'value' in value) {
                            value = value.value;
                            // ensure that the new value wouldn't have been skipped by the previous check
                            if (value === '') {
                                return;
                            }
                        }
                        if (typeof value === 'string') {
                            value = Number(value);
                        }
                        if (typeof value === 'number' && !isNaN(value)) {
                            sum += value;
                            if (max === null || value > max) {
                                max = value;
                            }
                            if (min === null || value < min) {
                                min = value;
                            }
                            numberCount++;
                        }
                    });
                    currentRow = this.cellNavigationService.getRowBelow(currentRow);
                }
            });
        }
        const gotResult = count > 1;
        const gotNumberResult = numberCount > 1;
        // we show count even if no numbers
        this.setAggregationComponentValue('count', count, gotResult);
        // show if numbers found
        this.setAggregationComponentValue('sum', sum, gotNumberResult);
        this.setAggregationComponentValue('min', min, gotNumberResult);
        this.setAggregationComponentValue('max', max, gotNumberResult);
        this.setAggregationComponentValue('avg', (sum / numberCount), gotNumberResult);
    }
}
AggregationComp.TEMPLATE = `<div class="ag-status-panel ag-status-panel-aggregations">
            <ag-name-value ref="avgAggregationComp"></ag-name-value>
            <ag-name-value ref="countAggregationComp"></ag-name-value>
            <ag-name-value ref="minAggregationComp"></ag-name-value>
            <ag-name-value ref="maxAggregationComp"></ag-name-value>
            <ag-name-value ref="sumAggregationComp"></ag-name-value>
        </div>`;
__decorate$2c([
    Optional('rangeService')
], AggregationComp.prototype, "rangeService", void 0);
__decorate$2c([
    Autowired('valueService')
], AggregationComp.prototype, "valueService", void 0);
__decorate$2c([
    Autowired('cellNavigationService')
], AggregationComp.prototype, "cellNavigationService", void 0);
__decorate$2c([
    Autowired('rowRenderer')
], AggregationComp.prototype, "rowRenderer", void 0);
__decorate$2c([
    Autowired('gridApi')
], AggregationComp.prototype, "gridApi", void 0);
__decorate$2c([
    Autowired('cellPositionUtils')
], AggregationComp.prototype, "cellPositionUtils", void 0);
__decorate$2c([
    Autowired('rowPositionUtils')
], AggregationComp.prototype, "rowPositionUtils", void 0);
__decorate$2c([
    RefSelector('sumAggregationComp')
], AggregationComp.prototype, "sumAggregationComp", void 0);
__decorate$2c([
    RefSelector('countAggregationComp')
], AggregationComp.prototype, "countAggregationComp", void 0);
__decorate$2c([
    RefSelector('minAggregationComp')
], AggregationComp.prototype, "minAggregationComp", void 0);
__decorate$2c([
    RefSelector('maxAggregationComp')
], AggregationComp.prototype, "maxAggregationComp", void 0);
__decorate$2c([
    RefSelector('avgAggregationComp')
], AggregationComp.prototype, "avgAggregationComp", void 0);
__decorate$2c([
    PostConstruct
], AggregationComp.prototype, "postConstruct", null);

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$j = '31.1.1';

const StatusBarModule = {
    version: VERSION$j,
    moduleName: ModuleNames.StatusBarModule,
    beans: [StatusBarService],
    agStackComponents: [
        { componentName: 'AgStatusBar', componentClass: StatusBar },
        { componentName: 'AgNameValue', componentClass: NameValueComp },
    ],
    userComponents: [
        { componentName: 'agAggregationComponent', componentClass: AggregationComp },
        { componentName: 'agSelectedRowCountComponent', componentClass: SelectedRowsComp },
        { componentName: 'agTotalRowCountComponent', componentClass: TotalRowsComp },
        { componentName: 'agFilteredRowCountComponent', componentClass: FilteredRowsComp },
        { componentName: 'agTotalAndFilteredRowCountComponent', componentClass: TotalAndFilteredRowsComp }
    ],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

// DO NOT UPDATE MANUALLY: Generated from script during build time
const VERSION$k = '31.1.1';

var __decorate$2d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ViewportRowModel = class ViewportRowModel extends BeanStub {
    constructor() {
        super(...arguments);
        // rowRenderer tells us these
        this.firstRow = -1;
        this.lastRow = -1;
        // datasource tells us this
        this.rowCount = -1;
        this.rowNodesByIndex = {};
    }
    // we don't implement as lazy row heights is not supported in this row model
    ensureRowHeightsValid(startPixel, endPixel, startLimitIndex, endLimitIndex) { return false; }
    init() {
        this.rowHeight = this.gridOptionsService.getRowHeightAsNumber();
        this.addManagedListener(this.eventService, Events.EVENT_VIEWPORT_CHANGED, this.onViewportChanged.bind(this));
        this.addManagedPropertyListener('viewportDatasource', () => this.updateDatasource());
        this.addManagedPropertyListener('rowHeight', () => {
            this.rowHeight = this.gridOptionsService.getRowHeightAsNumber();
            this.updateRowHeights();
        });
    }
    start() {
        this.updateDatasource();
    }
    isLastRowIndexKnown() {
        return true;
    }
    destroyDatasource() {
        if (!this.viewportDatasource) {
            return;
        }
        if (this.viewportDatasource.destroy) {
            this.viewportDatasource.destroy();
        }
        this.rowRenderer.datasourceChanged();
        this.firstRow = -1;
        this.lastRow = -1;
    }
    updateDatasource() {
        const datasource = this.gridOptionsService.get('viewportDatasource');
        if (datasource) {
            this.setViewportDatasource(datasource);
        }
    }
    getViewportRowModelPageSize() {
        return this.gridOptionsService.get('viewportRowModelPageSize');
    }
    getViewportRowModelBufferSize() {
        return this.gridOptionsService.get('viewportRowModelBufferSize');
    }
    calculateFirstRow(firstRenderedRow) {
        const bufferSize = this.getViewportRowModelBufferSize();
        const pageSize = this.getViewportRowModelPageSize();
        const afterBuffer = firstRenderedRow - bufferSize;
        if (afterBuffer < 0) {
            return 0;
        }
        return Math.floor(afterBuffer / pageSize) * pageSize;
    }
    calculateLastRow(lastRenderedRow) {
        if (lastRenderedRow === -1) {
            return lastRenderedRow;
        }
        const bufferSize = this.getViewportRowModelBufferSize();
        const pageSize = this.getViewportRowModelPageSize();
        const afterBuffer = lastRenderedRow + bufferSize;
        const result = Math.ceil(afterBuffer / pageSize) * pageSize;
        const lastRowIndex = this.rowCount - 1;
        return Math.min(result, lastRowIndex);
    }
    onViewportChanged(event) {
        const newFirst = this.calculateFirstRow(event.firstRow);
        const newLast = this.calculateLastRow(event.lastRow);
        if (this.firstRow !== newFirst || this.lastRow !== newLast) {
            this.firstRow = newFirst;
            this.lastRow = newLast;
            this.purgeRowsNotInViewport();
            if (this.viewportDatasource) {
                this.viewportDatasource.setViewportRange(this.firstRow, this.lastRow);
            }
        }
    }
    purgeRowsNotInViewport() {
        Object.keys(this.rowNodesByIndex).forEach(indexStr => {
            const index = parseInt(indexStr, 10);
            if (index < this.firstRow || index > this.lastRow) {
                if (this.isRowFocused(index)) {
                    return;
                }
                delete this.rowNodesByIndex[index];
            }
        });
    }
    isRowFocused(rowIndex) {
        const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();
        if (!focusedCell) {
            return false;
        }
        if (focusedCell.rowPinned != null) {
            return false;
        }
        const hasFocus = focusedCell.rowIndex === rowIndex;
        return hasFocus;
    }
    setViewportDatasource(viewportDatasource) {
        this.destroyDatasource();
        this.viewportDatasource = viewportDatasource;
        this.rowCount = -1;
        if (!viewportDatasource.init) {
            console.warn('AG Grid: viewport is missing init method.');
        }
        else {
            viewportDatasource.init({
                setRowCount: this.setRowCount.bind(this),
                setRowData: this.setRowData.bind(this),
                getRow: this.getRow.bind(this)
            });
        }
    }
    getType() {
        return 'viewport';
    }
    getRow(rowIndex) {
        if (!this.rowNodesByIndex[rowIndex]) {
            this.rowNodesByIndex[rowIndex] = this.createBlankRowNode(rowIndex);
        }
        return this.rowNodesByIndex[rowIndex];
    }
    getRowNode(id) {
        let result;
        this.forEachNode(rowNode => {
            if (rowNode.id === id) {
                result = rowNode;
            }
        });
        return result;
    }
    getRowCount() {
        return this.rowCount === -1 ? 0 : this.rowCount;
    }
    getRowIndexAtPixel(pixel) {
        if (this.rowHeight !== 0) { // avoid divide by zero error
            return Math.floor(pixel / this.rowHeight);
        }
        return 0;
    }
    getRowBounds(index) {
        return {
            rowHeight: this.rowHeight,
            rowTop: this.rowHeight * index
        };
    }
    updateRowHeights() {
        this.forEachNode(node => {
            node.setRowHeight(this.rowHeight);
            node.setRowTop(this.rowHeight * node.rowIndex);
        });
        const event = {
            type: Events.EVENT_MODEL_UPDATED,
            newData: false,
            newPage: false,
            keepRenderedRows: true,
            animate: false,
        };
        this.eventService.dispatchEvent(event);
    }
    getTopLevelRowCount() {
        return this.getRowCount();
    }
    getTopLevelRowDisplayedIndex(topLevelIndex) {
        return topLevelIndex;
    }
    isEmpty() {
        return this.rowCount > 0;
    }
    isRowsToRender() {
        return this.rowCount > 0;
    }
    getNodesInRangeForSelection(firstInRange, lastInRange) {
        const firstIndex = _.missing(firstInRange) ? 0 : firstInRange.rowIndex;
        const lastIndex = lastInRange.rowIndex;
        const firstNodeOutOfRange = firstIndex < this.firstRow || firstIndex > this.lastRow;
        const lastNodeOutOfRange = lastIndex < this.firstRow || lastIndex > this.lastRow;
        if (firstNodeOutOfRange || lastNodeOutOfRange) {
            return [];
        }
        const result = [];
        const startIndex = firstIndex <= lastIndex ? firstIndex : lastIndex;
        const endIndex = firstIndex <= lastIndex ? lastIndex : firstIndex;
        for (let i = startIndex; i <= endIndex; i++) {
            result.push(this.rowNodesByIndex[i]);
        }
        return result;
    }
    forEachNode(callback) {
        let callbackCount = 0;
        Object.keys(this.rowNodesByIndex).forEach(indexStr => {
            const index = parseInt(indexStr, 10);
            const rowNode = this.rowNodesByIndex[index];
            callback(rowNode, callbackCount);
            callbackCount++;
        });
    }
    setRowData(rowData) {
        _.iterateObject(rowData, (indexStr, dataItem) => {
            const index = parseInt(indexStr, 10);
            // we should never keep rows that we didn't specifically ask for, this
            // guarantees the contract we have with the server.
            if (index >= this.firstRow && index <= this.lastRow) {
                let rowNode = this.rowNodesByIndex[index];
                // the abnormal case is we requested a row even though the grid didn't need it
                // as a result of the paging and buffer (ie the row is off screen), in which
                // case we need to create a new node now
                if (_.missing(rowNode)) {
                    rowNode = this.createBlankRowNode(index);
                    this.rowNodesByIndex[index] = rowNode;
                }
                // now we deffo have a row node, so set in the details
                // if the grid already asked for this row (the normal case), then we would
                // of put a placeholder node in place.
                rowNode.setDataAndId(dataItem, index.toString());
            }
        });
    }
    createBlankRowNode(rowIndex) {
        const rowNode = new RowNode(this.beans);
        rowNode.setRowHeight(this.rowHeight);
        rowNode.setRowTop(this.rowHeight * rowIndex);
        rowNode.setRowIndex(rowIndex);
        return rowNode;
    }
    setRowCount(rowCount, keepRenderedRows = false) {
        if (rowCount === this.rowCount) {
            return;
        }
        this.rowCount = rowCount;
        this.eventService.dispatchEventOnce({
            type: Events.EVENT_ROW_COUNT_READY
        });
        const event = {
            type: Events.EVENT_MODEL_UPDATED,
            newData: false,
            newPage: false,
            keepRenderedRows: keepRenderedRows,
            animate: false
        };
        this.eventService.dispatchEvent(event);
    }
    isRowPresent(rowNode) {
        const foundRowNode = this.getRowNode(rowNode.id);
        return !!foundRowNode;
    }
};
__decorate$2d([
    Autowired('rowRenderer')
], ViewportRowModel.prototype, "rowRenderer", void 0);
__decorate$2d([
    Autowired('focusService')
], ViewportRowModel.prototype, "focusService", void 0);
__decorate$2d([
    Autowired('beans')
], ViewportRowModel.prototype, "beans", void 0);
__decorate$2d([
    PostConstruct
], ViewportRowModel.prototype, "init", null);
__decorate$2d([
    PreDestroy
], ViewportRowModel.prototype, "destroyDatasource", null);
ViewportRowModel = __decorate$2d([
    Bean('rowModel')
], ViewportRowModel);

const ViewportRowModelModule = {
    version: VERSION$k,
    moduleName: ModuleNames.ViewportRowModelModule,
    rowModel: 'viewport',
    beans: [ViewportRowModel],
    dependantModules: [
        EnterpriseCoreModule
    ]
};

ModuleRegistry.__registerModules([
    AdvancedFilterModule,
    ClipboardModule,
    ColumnsToolPanelModule,
    ExcelExportModule,
    FiltersToolPanelModule,
    GridChartsModule,
    MasterDetailModule,
    MenuModule,
    MultiFilterModule,
    RangeSelectionModule,
    RichSelectModule,
    RowGroupingModule,
    ServerSideRowModelModule,
    SetFilterModule,
    SideBarModule,
    SparklinesModule,
    StatusBarModule,
    ViewportRowModelModule
], false, undefined);
/* COMMUNITY_EXPORTS_END_DO_NOT_DELETE */

export { AgChart, AgCharts, AgErrorBarSupportedSeriesTypes, AgTooltipPositionType, GridChartsModule, GridLicenseManager as LicenseManager, Marker, SetFilter, VERSION$2 as VERSION, module_support_exports as _ModuleSupport, sparklines_scale_exports as _Scale, integrated_charts_scene_exports as _Scene, integrated_charts_theme_exports as _Theme, sparklines_util_exports as _Util, __FORCE_MODULE_DETECTION, __FORCE_MODULE_DETECTION_AG_GRID_CORE_EXT, agCharts, exportMultipleSheetsAsExcel, getMultipleSheetsAsExcel, time_exports as time };
